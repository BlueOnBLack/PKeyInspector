using namespace System
using namespace System.IO
using namespace System.Net
using namespace System.Web
using namespace System.Numerics
using namespace System.Security.Cryptography
using namespace System.Collections.Generic
using namespace System.Drawing
using namespace System.IO.Compression
using namespace System.Management.Automation
using namespace System.Net
using namespace System.Diagnostics
using namespace System.Reflection
using namespace System.Reflection.Emit
using namespace System.Runtime.InteropServices
using namespace System.Security.AccessControl
using namespace System.Security.Principal
using namespace System.ServiceProcess
using namespace System.Text
using namespace System.Text.RegularExpressions
using namespace System.Threading
using namespace System.Windows.Forms

Add-Type -AssemblyName System.Web
Add-Type -AssemblyName System.Drawing
Add-Type -AssemblyName System.Windows.Forms

$ProgressPreference = 'SilentlyContinue'


# ***************************** #
#       Scripts etc etc etc     #
# ***************************** #
 
# Custom `product.ini` extractor

<#
@cls
@echo off
for /f "tokens=1,2 delims==:" %%a in ('type product.ini') do call :parse "%%a" "%%b'
goto :eof

:parse
set "value=%~2"
set "pro=%~1"
keyinfo %value:~0,-1% | more +1 > c:\windows\temp\key.txt
for /f "tokens=*" %%x in ('type c:\windows\temp\key.txt') do set "Ref=%%x" & goto :parse_next
:parse_next
echo     %Ref% = "%value:~0,-1%" # %pro%
rem 3855 = "FV469-WGNG4-YQP66-2B2HY-KD8YX" # enterpriseg
goto :eof
 #>

# Key Parser - For all SKU

<#
$SKU = @{}
$skuList = $keys -split ', ' | Sort
$keys = $skuList | % { Get-ProductKeys -EditionID $_}
$keys.ProductKey | % {  $sku.Add(@(KeyDecode -key0 $_ )[2].Value,$_) }
$SKU.GetEnumerator()|%{Write-Host "    $($_.Key) = ""$($_.Value)"" # "}
#>

# ***************************** #
# Credits & Other Source's list #
# ***************************** #

# Manually Activate Windows
# https://massgrave.dev/manual_hwid_activation
# https://massgrave.dev/manual_kms38_activation
# https://massgrave.dev/manual_ohook_activation

# PS1 version of HWID_Activation.cmd
# Credit WindowsAddict - Mass Project

# ??? / PE Windows 8 Product Key Decoding/Encoding
# https://windowsforum.kr/data/4992763

# Reader on idea from PKeyConfigReader
# https://github.com/VisualSoftware/PKeyConfigReader

# Decode key based on Source's
# https://github.com/IonBazan/pidgenx
# https://github.com/chughes-3/UpdateProductKey/blob/master/UpdateProductKeys/PidChecker.cs
# https://forums.mydigitallife.net/threads/simplepidx-simple-yet-powerful-product-key-checker.80300/ -> KmsTool

# encode keys using API [pkeyhelper]
# https://github.com/laomms -> KmsTool
# Windows Addict, Change windows edition script

# function Get-Strings from 
# https://www.powershellgallery.com/packages/PowerSploit/1.0.0.0/Content/ReverseEngineering%5CGet-Strings.ps1

# PowerSploit Function: Get-Strings
# Author: Matthew Graeber (@mattifestation)
# License: BSD 3-Clause
# Required Dependencies: None
# Optional Dependencies: None

# Kernel-Mode Windows Versions
# https://www.geoffchappell.com/studies/windows/km/versions.htm

# ZwQuerySystemInformation
# https://www.geoffchappell.com/studies/windows/km/ntoskrnl/api/ex/sysinfo/query.htm

# RtlGetNtVersionNumbers Function
# The RtlGetNtVersionNumbers function gets Windows version numbers directly from NTDLL.
# https://www.geoffchappell.com/studies/windows/win32/ntdll/api/ldrinit/getntversionnumbers.htm

# RtlGetVersion function (wdm.h)
# https://learn.microsoft.com/en-us/windows/win32/devnotes/rtlgetversion
# https://learn.microsoft.com/en-us/windows-hardware/drivers/ddi/wdm/nf-wdm-rtlgetversion

# Process Environment Block (PEB)
# https://www.geoffchappell.com/studies/windows/km/ntoskrnl/inc/api/pebteb/peb/index.htm

# KUSER_SHARED_DATA
# https://www.geoffchappell.com/studies/windows/km/ntoskrnl/inc/api/ntexapi_x/kuser_shared_data/index.htm

# KUSER_SHARED_DATA structure (ntddk.h)
# https://learn.microsoft.com/en-us/windows-hardware/drivers/ddi/ntddk/ns-ntddk-kuser_shared_data

# The read-only user-mode address for the shared data is 0x7FFE0000, both in 32-bit and 64-bit Windows.
# The only formal definition among headers in the Windows Driver Kit (WDK) or the Software Development Kit (SDK) is in assembly language headers: KS386.
# INC from the WDK and KSAMD64.
# INC from the SDK both define MM_SHARED_USER_DATA_VA for the user-mode address.

# That they also define USER_SHARED_DATA for the kernel-mode address suggests that they too are intended for kernel-mode programming,
# albeit of a sort that is at least aware of what address works for user-mode access.

# Among relatively large structures,
# the KUSER_SHARED_DATA is highly unusual for having exactly the same layout in 32-bit and 64-bit Windows.
# This is because the one instance must be simultaneously accessible by both 32-bit and 64-bit code on 64-bit Windows,
# and it's desired that 32-bit user-mode code can run unchanged on both 32-bit and 64-bit Windows.

# 2.2.9.6 OSEdition Enumeration
# https://learn.microsoft.com/en-us/openspecs/windows_protocols/ms-mde2/d92ead8f-faf3-47a8-a341-1921dc2c463b

<#
Example's from MAS' AIO

$editionIDPtr = [IntPtr]::Zero
$hresults = $Global:PKHElper::GetEditionNameFromId(126,[ref]$editionIDPtr)
if ($hresults -eq 0) {
    $editionID = [Marshal]::PtrToStringUni($editionIDPtr)
    Write-Host "BrandingInfo: 126 > Edition: $editionID"
}

[int]$brandingInfo = 0
$hresults = $Global:PKHElper::GetEditionIdFromName("enterprisesn", [ref]$brandingInfo)
if ($brandingInfo -ne 0) {
    Write-Host "Edition: enterprisesn > BrandingInfo: $brandingInfo"
}

Full Table, include Name, Sku, etc etc provide by [abbodi1406]
#>
$Global:productTypeTable = @'
ProductID,OSEdition,DWORD
ultimate,PRODUCT_ULTIMATE,0x00000001
homebasic,PRODUCT_HOME_BASIC,0x00000002
homepremium,PRODUCT_HOME_PREMIUM,0x00000003
enterprise,PRODUCT_ENTERPRISE,0x00000004
homebasicn,PRODUCT_HOME_BASIC_N,0x00000005
business,PRODUCT_BUSINESS,0x00000006
serverstandard,PRODUCT_STANDARD_SERVER,0x00000007
serverdatacenter,PRODUCT_DATACENTER_SERVER,0x00000008
serversbsstandard,PRODUCT_SMALLBUSINESS_SERVER,0x00000009
serverenterprise,PRODUCT_ENTERPRISE_SERVER,0x0000000A
starter,PRODUCT_STARTER,0x0000000B
serverdatacentercore,PRODUCT_DATACENTER_SERVER_CORE,0x0000000C
serverstandardcore,PRODUCT_STANDARD_SERVER_CORE,0x0000000D
serverenterprisecore,PRODUCT_ENTERPRISE_SERVER_CORE,0x0000000E
serverenterpriseia64,PRODUCT_ENTERPRISE_SERVER_IA64,0x0000000F
businessn,PRODUCT_BUSINESS_N,0x00000010
serverweb,PRODUCT_WEB_SERVER,0x00000011
serverhpc,PRODUCT_CLUSTER_SERVER,0x00000012
serverhomestandard,PRODUCT_HOME_SERVER,0x00000013
serverstorageexpress,PRODUCT_STORAGE_EXPRESS_SERVER,0x00000014
serverstoragestandard,PRODUCT_STORAGE_STANDARD_SERVER,0x00000015
serverstorageworkgroup,PRODUCT_STORAGE_WORKGROUP_SERVER,0x00000016
serverstorageenterprise,PRODUCT_STORAGE_ENTERPRISE_SERVER,0x00000017
serverwinsb,PRODUCT_SERVER_FOR_SMALLBUSINESS,0x00000018
serversbspremium,PRODUCT_SMALLBUSINESS_SERVER_PREMIUM,0x00000019
homepremiumn,PRODUCT_HOME_PREMIUM_N,0x0000001A
enterprisen,PRODUCT_ENTERPRISE_N,0x0000001B
ultimaten,PRODUCT_ULTIMATE_N,0x0000001C
serverwebcore,PRODUCT_WEB_SERVER_CORE,0x0000001D
servermediumbusinessmanagement,PRODUCT_MEDIUMBUSINESS_SERVER_MANAGEMENT,0x0000001E
servermediumbusinesssecurity,PRODUCT_MEDIUMBUSINESS_SERVER_SECURITY,0x0000001F
servermediumbusinessmessaging,PRODUCT_MEDIUMBUSINESS_SERVER_MESSAGING,0x00000020
serverwinfoundation,PRODUCT_SERVER_FOUNDATION,0x00000021
serverhomepremium,PRODUCT_HOME_PREMIUM_SERVER,0x00000022
serverwinsbv,PRODUCT_SERVER_FOR_SMALLBUSINESS_V,0x00000023
serverstandardv,PRODUCT_STANDARD_SERVER_V,0x00000024
serverdatacenterv,PRODUCT_DATACENTER_SERVER_V,0x00000025
serverenterprisev,PRODUCT_ENTERPRISE_SERVER_V,0x00000026
serverdatacentervcore,PRODUCT_DATACENTER_SERVER_CORE_V,0x00000027
serverstandardvcore,PRODUCT_STANDARD_SERVER_CORE_V,0x00000028
serverenterprisevcore,PRODUCT_ENTERPRISE_SERVER_CORE_V,0x00000029
serverhypercore,PRODUCT_HYPERV,0x0000002A
serverstorageexpresscore,PRODUCT_STORAGE_EXPRESS_SERVER_CORE,0x0000002B
serverstoragestandardcore,PRODUCT_STORAGE_STANDARD_SERVER_CORE,0x0000002C
serverstorageworkgroupcore,PRODUCT_STORAGE_WORKGROUP_SERVER_CORE,0x0000002D
serverstorageenterprisecore,PRODUCT_STORAGE_ENTERPRISE_SERVER_CORE,0x0000002E
startern,PRODUCT_STARTER_N,0x0000002F
professional,PRODUCT_PROFESSIONAL,0x00000030
professionaln,PRODUCT_PROFESSIONAL_N,0x00000031
serversolution,PRODUCT_SB_SOLUTION_SERVER,0x00000032
serverforsbsolutions,PRODUCT_SERVER_FOR_SB_SOLUTIONS,0x00000033
serversolutionspremium,PRODUCT_STANDARD_SERVER_SOLUTIONS,0x00000034
serversolutionspremiumcore,PRODUCT_STANDARD_SERVER_SOLUTIONS_CORE,0x00000035
serversolutionem,PRODUCT_SB_SOLUTION_SERVER_EM,0x00000036
serverforsbsolutionsem,PRODUCT_SERVER_FOR_SB_SOLUTIONS_EM,0x00000037
serverembeddedsolution,PRODUCT_SOLUTION_EMBEDDEDSERVER,0x00000038
serverembeddedsolutioncore,PRODUCT_SOLUTION_EMBEDDEDSERVER_CORE,0x00000039
professionalembedded,PRODUCT_PROFESSIONAL_EMBEDDED,0x0000003A
serveressentialmanagement,PRODUCT_ESSENTIALBUSINESS_SERVER_MGMT,0x0000003B
serveressentialadditional,PRODUCT_ESSENTIALBUSINESS_SERVER_ADDL,0x0000003C
serveressentialmanagementsvc,PRODUCT_ESSENTIALBUSINESS_SERVER_MGMTSVC,0x0000003D
serveressentialadditionalsvc,PRODUCT_ESSENTIALBUSINESS_SERVER_ADDLSVC,0x0000003E
serversbspremiumcore,PRODUCT_SMALLBUSINESS_SERVER_PREMIUM_CORE,0x0000003F
serverhpcv,PRODUCT_CLUSTER_SERVER_V,0x00000040
embedded,PRODUCT_EMBEDDED,0x00000041
startere,PRODUCT_STARTER_E,0x00000042
homebasice,PRODUCT_HOME_BASIC_E,0x00000043
homepremiume,PRODUCT_HOME_PREMIUM_E,0x00000044
professionale,PRODUCT_PROFESSIONAL_E,0x00000045
enterprisee,PRODUCT_ENTERPRISE_E,0x00000046
ultimatee,PRODUCT_ULTIMATE_E,0x00000047
enterpriseeval,PRODUCT_ENTERPRISE_EVALUATION,0x00000048
prerelease,PRODUCT_PRERELEASE,0x0000004A
servermultipointstandard,PRODUCT_MULTIPOINT_STANDARD_SERVER,0x0000004C
servermultipointpremium,PRODUCT_MULTIPOINT_PREMIUM_SERVER,0x0000004D
serverstandardeval,PRODUCT_STANDARD_EVALUATION_SERVER,0x0000004F
serverdatacentereval,PRODUCT_DATACENTER_EVALUATION_SERVER,0x00000050
prereleasearm,PRODUCT_PRODUCT_PRERELEASE_ARM,0x00000051
prereleasen,PRODUCT_PRODUCT_PRERELEASE_N,0x00000052
enterpriseneval,PRODUCT_ENTERPRISE_N_EVALUATION,0x00000054
embeddedautomotive,PRODUCT_EMBEDDED_AUTOMOTIVE,0x00000055
embeddedindustrya,PRODUCT_EMBEDDED_INDUSTRY_A,0x00000056
thinpc,PRODUCT_THINPC,0x00000057
embeddeda,PRODUCT_EMBEDDED_A,0x00000058
embeddedindustry,PRODUCT_EMBEDDED_INDUSTRY,0x00000059
embeddede,PRODUCT_EMBEDDED_E,0x0000005A
embeddedindustrye,PRODUCT_EMBEDDED_INDUSTRY_E,0x0000005B
embeddedindustryae,PRODUCT_EMBEDDED_INDUSTRY_A_E,0x0000005C
professionalplus,PRODUCT_PRODUCT_PROFESSIONAL_PLUS,0x0000005D
serverstorageworkgroupeval,PRODUCT_STORAGE_WORKGROUP_EVALUATION_SERVER,0x0000005F
serverstoragestandardeval,PRODUCT_STORAGE_STANDARD_EVALUATION_SERVER,0x00000060
corearm,PRODUCT_CORE_ARM,0x00000061
coren,PRODUCT_CORE_N,0x00000062
corecountryspecific,PRODUCT_CORE_COUNTRYSPECIFIC,0x00000063
coresinglelanguage,PRODUCT_CORE_SINGLELANGUAGE,0x00000064
core,PRODUCT_CORE,0x00000065
professionalwmc,PRODUCT_PROFESSIONAL_WMC,0x00000067
mobilecore,PRODUCT_MOBILE_CORE,0x00000068
embeddedindustryeval,PRODUCT_EMBEDDED_INDUSTRY_EVAL,0x00000069
embeddedindustryeeval,PRODUCT_EMBEDDED_INDUSTRY_E_EVAL,0x0000006A
embeddedeval,PRODUCT_EMBEDDED_EVAL,0x0000006B
embeddedeeval,PRODUCT_EMBEDDED_E_EVAL,0x0000006C
coresystemserver,PRODUCT_NANO_SERVER,0x0000006D
servercloudstorage,PRODUCT_CLOUD_STORAGE_SERVER,0x0000006E
coreconnected,PRODUCT_CORE_CONNECTED,0x0000006F
professionalstudent,PRODUCT_PROFESSIONAL_STUDENT,0x00000070
coreconnectedn,PRODUCT_CORE_CONNECTED_N,0x00000071
professionalstudentn,PRODUCT_PROFESSIONAL_STUDENT_N,0x00000072
coreconnectedsinglelanguage,PRODUCT_CORE_CONNECTED_SINGLELANGUAGE,0x00000073
coreconnectedcountryspecific,PRODUCT_CORE_CONNECTED_COUNTRYSPECIFIC,0x00000074
connectedcar,PRODUCT_CONNECTED_CAR,0x00000075
industryhandheld,PRODUCT_INDUSTRY_HANDHELD,0x00000076
ppipro,PRODUCT_PPI_PRO,0x00000077
serverarm64,PRODUCT_ARM64_SERVER,0x00000078
education,PRODUCT_EDUCATION,0x00000079
educationn,PRODUCT_EDUCATION_N,0x0000007A
iotuap,PRODUCT_IOTUAP,0x0000007B
serverhi,PRODUCT_CLOUD_HOST_INFRASTRUCTURE_SERVER,0x0000007C
enterprises,PRODUCT_ENTERPRISE_S,0x0000007D
enterprisesn,PRODUCT_ENTERPRISE_S_N,0x0000007E
professionals,PRODUCT_PROFESSIONAL_S,0x0000007F
professionalsn,PRODUCT_PROFESSIONAL_S_N,0x00000080
enterpriseseval,PRODUCT_ENTERPRISE_S_EVALUATION,0x00000081
enterprisesneval,PRODUCT_ENTERPRISE_S_N_EVALUATION,0x00000082
iotuapcommercial,PRODUCT_IOTUAPCOMMERCIAL,0x00000083
mobileenterprise,PRODUCT_MOBILE_ENTERPRISE,0x00000085
analogonecore,PRODUCT_HOLOGRAPHIC,0x00000087
holographic,PRODUCT_HOLOGRAPHIC_BUSINESS,0x00000088
professionalsinglelanguage,PRODUCT_PRO_SINGLE_LANGUAGE,0x0000008A
professionalcountryspecific,PRODUCT_PRO_CHINA,0x0000008B
enterprisesubscription,PRODUCT_ENTERPRISE_SUBSCRIPTION,0x0000008C
enterprisesubscriptionn,PRODUCT_ENTERPRISE_SUBSCRIPTION_N,0x0000008D
serverdatacenternano,PRODUCT_DATACENTER_NANO_SERVER,0x0000008F
serverstandardnano,PRODUCT_STANDARD_NANO_SERVER,0x00000090
serverdatacenteracor,PRODUCT_DATACENTER_A_SERVER_CORE,0x00000091
serverstandardacor,PRODUCT_STANDARD_A_SERVER_CORE,0x00000092
serverdatacentercor,PRODUCT_DATACENTER_WS_SERVER_CORE,0x00000093
serverstandardcor,PRODUCT_STANDARD_WS_SERVER_CORE,0x00000094
utilityvm,PRODUCT_UTILITY_VM,0x00000095
serverdatacenterevalcor,PRODUCT_DATACENTER_EVALUATION_SERVER_CORE,0x0000009F
serverstandardevalcor,PRODUCT_STANDARD_EVALUATION_SERVER_CORE,0x000000A0
professionalworkstation,PRODUCT_PRO_WORKSTATION,0x000000A1
professionalworkstationn,PRODUCT_PRO_WORKSTATION_N,0x000000A2
serverazure,PRODUCT_AZURE_SERVER,0x000000A3
professionaleducation,PRODUCT_PRO_FOR_EDUCATION,0x000000A4
professionaleducationn,PRODUCT_PRO_FOR_EDUCATION_N,0x000000A5
serverazurecor,PRODUCT_AZURE_SERVER_CORE,0x000000A8
serverazurenano,PRODUCT_AZURE_NANO_SERVER,0x000000A9
enterpriseg,PRODUCT_ENTERPRISEG,0x000000AB
enterprisegn,PRODUCT_ENTERPRISEGN,0x000000AC
businesssubscription,PRODUCT_BUSINESS,0x000000AD
businesssubscriptionn,PRODUCT_BUSINESS_N,0x000000AE
serverrdsh,PRODUCT_SERVERRDSH,0x000000AF
cloud,PRODUCT_CLOUD,0x000000B2
cloudn,PRODUCT_CLOUDN,0x000000B3
hubos,PRODUCT_HUBOS,0x000000B4
onecoreupdateos,PRODUCT_ONECOREUPDATEOS,0x000000B6
cloude,PRODUCT_CLOUDE,0x000000B7
andromeda,PRODUCT_ANDROMEDA,0x000000B8
iotos,PRODUCT_IOTOS,0x000000B9
clouden,PRODUCT_CLOUDEN,0x000000BA
iotedgeos,PRODUCT_IOTEDGEOS,0x000000BB
iotenterprise,PRODUCT_IOTENTERPRISE,0x000000BC
modernpc,PRODUCT_LITE,0x000000BD
iotenterprises,PRODUCT_IOTENTERPRISES,0x000000BF
systemos,PRODUCT_XBOX_SYSTEMOS,0x000000C0
nativeos,PRODUCT_XBOX_NATIVEOS,0x000000C1
gamecorexbox,PRODUCT_XBOX_GAMEOS,0x000000C2
gameos,PRODUCT_XBOX_ERAOS,0x000000C3
durangohostos,PRODUCT_XBOX_DURANGOHOSTOS,0x000000C4
scarletthostos,PRODUCT_XBOX_SCARLETTHOSTOS,0x000000C5
keystone,PRODUCT_XBOX_KEYSTONE,0x000000C6
cloudhost,PRODUCT_AZURE_SERVER_CLOUDHOST,0x000000C7
cloudmos,PRODUCT_AZURE_SERVER_CLOUDMOS,0x000000C8
cloudcore,PRODUCT_AZURE_SERVER_CLOUDCORE,0x000000C9
cloudeditionn,PRODUCT_CLOUDEDITIONN,0x000000CA
cloudedition,PRODUCT_CLOUDEDITION,0x000000CB
winvos,PRODUCT_VALIDATION,0x000000CC
iotenterprisesk,PRODUCT_IOTENTERPRISESK,0x000000CD
iotenterprisek,PRODUCT_IOTENTERPRISEK,0x000000CE
iotenterpriseseval,PRODUCT_IOTENTERPRISESEVAL,0x000000CF
agentbridge,PRODUCT_AZURE_SERVER_AGENTBRIDGE,0x000000D0
nanohost,PRODUCT_AZURE_SERVER_NANOHOST,0x000000D1
wnc,PRODUCT_WNC,0x000000D2
serverazurestackhcicor,PRODUCT_AZURESTACKHCI_SERVER_CORE,0x00000196
serverturbine,PRODUCT_DATACENTER_SERVER_AZURE_EDITION,0x00000197
serverturbinecor,PRODUCT_DATACENTER_SERVER_CORE_AZURE_EDITION,0x00000198
'@ | ConvertFrom-Csv

<#
wuerror.h
https://github.com/larsch/wunow/blob/master/wunow/WUError.cs
https://github.com/microsoft/IIS.Setup/blob/main/iisca/lib/wuerror.h
https://learn.microsoft.com/en-us/troubleshoot/windows-client/installing-updates-features-roles/common-windows-update-errors
#>
$Global:WU_ERR_TABLE = @'
ERROR, MESSEGE
0x80D02002, "The operation timed out"
0x8024A10A, "Indicates that the Windows Update Service is shutting down."
0x00240001, "Windows Update Agent was stopped successfully."
0x00240002, "Windows Update Agent updated itself."
0x00240003, "Operation completed successfully but there were errors applying the updates."
0x00240004, "A callback was marked to be disconnected later because the request to disconnect the operation came while a callback was executing."
0x00240005, "The system must be restarted to complete installation of the update."
0x00240006, "The update to be installed is already installed on the system."
0x00240007, "The update to be removed is not installed on the system."
0x00240008, "The update to be downloaded has already been downloaded."
0x00242015, "The installation operation for the update is still in progress."
0x80240001, "Windows Update Agent was unable to provide the service."
0x80240002, "The maximum capacity of the service was exceeded."
0x80240003, "An ID cannot be found."
0x80240004, "The object could not be initialized."
0x80240005, "The update handler requested a byte range overlapping a previously requested range."
0x80240006, "The requested number of byte ranges exceeds the maximum number 2^31 - 1)."
0x80240007, "The index to a collection was invalid."
0x80240008, "The key for the item queried could not be found."
0x80240009, "Another conflicting operation was in progress. Some operations such as installation cannot be performed twice simultaneously."
0x8024000A, "Cancellation of the operation was not allowed."
0x8024000B, "Operation was cancelled."
0x8024000C, "No operation was required."
0x8024000D, "Windows Update Agent could not find required information in the update's XML data."
0x8024000E, "Windows Update Agent found invalid information in the update's XML data."
0x8024000F, "Circular update relationships were detected in the metadata."
0x80240010, "Update relationships too deep to evaluate were evaluated."
0x80240011, "An invalid update relationship was detected."
0x80240012, "An invalid registry value was read."
0x80240013, "Operation tried to add a duplicate item to a list."
0x80240014, "Updates requested for install are not installable by caller."
0x80240016, "Operation tried to install while another installation was in progress or the system was pending a mandatory restart."
0x80240017, "Operation was not performed because there are no applicable updates."
0x80240018, "Operation failed because a required user token is missing."
0x80240019, "An exclusive update cannot be installed with other updates at the same time."
0x8024001A, "A policy value was not set."
0x8024001B, "The operation could not be performed because the Windows Update Agent is self-updating."
0x8024001D, "An update contains invalid metadata."
0x8024001E, "Operation did not complete because the service or system was being shut down."
0x8024001F, "Operation did not complete because the network connection was unavailable."
0x80240020, "Operation did not complete because there is no logged-on interactive user."
0x80240021, "Operation did not complete because it timed out."
0x80240022, "Operation failed for all the updates."
0x80240023, "The license terms for all updates were declined."
0x80240024, "There are no updates."
0x80240025, "Group Policy settings prevented access to Windows Update."
0x80240026, "The type of update is invalid."
0x80240027, "The URL exceeded the maximum length."
0x80240028, "The update could not be uninstalled because the request did not originate from a WSUS server."
0x80240029, "Search may have missed some updates before there is an unlicensed application on the system."
0x8024002A, "A component required to detect applicable updates was missing."
0x8024002B, "An operation did not complete because it requires a newer version of server."
0x8024002C, "A delta-compressed update could not be installed because it required the source."
0x8024002D, "A full-file update could not be installed because it required the source."
0x8024002E, "Access to an unmanaged server is not allowed."
0x8024002F, "Operation did not complete because the DisableWindowsUpdateAccess policy was set."
0x80240030, "The format of the proxy list was invalid."
0x80240031, "The file is in the wrong format."
0x80240032, "The search criteria string was invalid."
0x80240033, "License terms could not be downloaded."
0x80240034, "Update failed to download."
0x80240035, "The update was not processed."
0x80240036, "The object's current state did not allow the operation."
0x80240037, "The functionality for the operation is not supported."
0x80240038, "The downloaded file has an unexpected content type."
0x80240039, "Agent is asked by server to resync too many times."
0x80240040, "WUA API method does not run on Server Core installation."
0x80240041, "Service is not available while sysprep is running."
0x80240042, "The update service is no longer registered with AU."
0x80240043, "There is no support for WUA UI."
0x80240044, "Only administrators can perform this operation on per-machine updates."
0x80240045, "A search was attempted with a scope that is not currently supported for this type of search."
0x80240046, "The URL does not point to a file."
0x80240047, "The operation requested is not supported."
0x80240048, "The featured update notification info returned by the server is invalid."
0x80240FFF, "An operation failed due to reasons not covered by another error code."
0x80241001, "Search may have missed some updates because the Windows Installer is less than version 3.1."
0x80241002, "Search may have missed some updates because the Windows Installer is not configured."
0x80241003, "Search may have missed some updates because policy has disabled Windows Installer patching."
0x80241004, "An update could not be applied because the application is installed per-user."
0x80241FFF, "Search may have missed some updates because there was a failure of the Windows Installer."
0x80244000, "WU_E_PT_SOAPCLIENT_* error codes map to the SOAPCLIENT_ERROR enum of the ATL Server Library."
0x80244001, "Same as SOAPCLIENT_INITIALIZE_ERROR - initialization of the SOAP client failed, possibly because of an MSXML installation failure."
0x80244002, "Same as SOAPCLIENT_OUTOFMEMORY - SOAP client failed because it ran out of memory."
0x80244003, "Same as SOAPCLIENT_GENERATE_ERROR - SOAP client failed to generate the request."
0x80244004, "Same as SOAPCLIENT_CONNECT_ERROR - SOAP client failed to connect to the server."
0x80244005, "Same as SOAPCLIENT_SEND_ERROR - SOAP client failed to send a message for reasons of WU_E_WINHTTP_* error codes."
0x80244006, "Same as SOAPCLIENT_SERVER_ERROR - SOAP client failed because there was a server error."
0x80244007, "Same as SOAPCLIENT_SOAPFAULT - SOAP client failed because there was a SOAP fault for reasons of WU_E_PT_SOAP_* error codes."
0x80244008, "Same as SOAPCLIENT_PARSEFAULT_ERROR - SOAP client failed to parse a SOAP fault."
0x80244009, "Same as SOAPCLIENT_READ_ERROR - SOAP client failed while reading the response from the server."
0x8024400A, "Same as SOAPCLIENT_PARSE_ERROR - SOAP client failed to parse the response from the server."
0x8024400B, "Same as SOAP_E_VERSION_MISMATCH - SOAP client found an unrecognizable namespace for the SOAP envelope."
0x8024400C, "Same as SOAP_E_MUST_UNDERSTAND - SOAP client was unable to understand a header."
0x8024400D, "Same as SOAP_E_CLIENT - SOAP client found the message was malformed; fix before resending."
0x8024400E, "Same as SOAP_E_SERVER - The SOAP message could not be processed due to a server error; resend later."
0x8024400F, "There was an unspecified Windows Management Instrumentation WMI) error."
0x80244010, "The number of round trips to the server exceeded the maximum limit."
0x80244011, "WUServer policy value is missing in the registry."
0x80244012, "Initialization failed because the object was already initialized."
0x80244013, "The computer name could not be determined."
0x80244015, "The reply from the server indicates that the server was changed or the cookie was invalid; refresh the state of the internal cache and retry."
0x80244016, "Same as HTTP status 400 - the server could not process the request due to invalid syntax."
0x80244017, "Same as HTTP status 401 - the requested resource requires user authentication."
0x80244018, "Same as HTTP status 403 - server understood the request, but declined to fulfill it."
0x8024401A, "Same as HTTP status 405 - the HTTP method is not allowed."
0x8024401B, "Same as HTTP status 407 - proxy authentication is required."
0x8024401C, "Same as HTTP status 408 - the server timed out waiting for the request."
0x8024401D, "Same as HTTP status 409 - the request was not completed due to a conflict with the current state of the resource."
0x8024401E, "Same as HTTP status 410 - requested resource is no longer available at the server."
0x8024401F, "Same as HTTP status 500 - an error internal to the server prevented fulfilling the request."
0x80244020, "Same as HTTP status 500 - server does not support the functionality required to fulfill the request."
0x80244021, "Same as HTTP status 502 - the server, while acting as a gateway or proxy, received an invalid response from the upstream server it accessed in attempting to fulfill the request."
0x80244022, "Same as HTTP status 503 - the service is temporarily overloaded."
0x80244023, "Same as HTTP status 503 - the request was timed out waiting for a gateway."
0x80244024, "Same as HTTP status 505 - the server does not support the HTTP protocol version used for the request."
0x80244025, "Operation failed due to a changed file location; refresh internal state and resend."
0x80244026, "Operation failed because Windows Update Agent does not support registration with a non-WSUS server."
0x80244027, "The server returned an empty authentication information list."
0x80244028, "Windows Update Agent was unable to create any valid authentication cookies."
0x80244029, "A configuration property value was wrong."
0x8024402A, "A configuration property value was missing."
0x8024402B, "The HTTP request could not be completed and the reason did not correspond to any of the WU_E_PT_HTTP_* error codes."
0x8024402C, "Same as ERROR_WINHTTP_NAME_NOT_RESOLVED - the proxy server or target server name cannot be resolved."
0x8024502D, "Windows Update Agent failed to download a redirector cabinet file with a new redirectorId value from the server during the recovery."
0x8024502E, "A redirector recovery action did not complete because the server is managed."
0x8024402F, "External cab file processing completed with some errors."
0x80244030, "The external cab processor initialization did not complete."
0x80244031, "The format of a metadata file was invalid."
0x80244032, "External cab processor found invalid metadata."
0x80244033, "The file digest could not be extracted from an external cab file."
0x80244034, "An external cab file could not be decompressed."
0x80244035, "External cab processor was unable to get file locations."
0x80240436, "The server does not support category-specific search; Full catalog search has to be issued instead."
0x80244FFF, "A communication error not covered by another WU_E_PT_* error code."
0x80245001, "The redirector XML document could not be loaded into the DOM class."
0x80245002, "The redirector XML document is missing some required information."
0x80245003, "The redirectorId in the downloaded redirector cab is less than in the cached cab."
0x80245FFF, "The redirector failed for reasons not covered by another WU_E_REDIRECTOR_* error code."
0x8024C001, "A driver was skipped."
0x8024C002, "A property for the driver could not be found. It may not conform with required specifications."
0x8024C003, "The registry type read for the driver does not match the expected type."
0x8024C004, "The driver update is missing metadata."
0x8024C005, "The driver update is missing a required attribute."
0x8024C006, "Driver synchronization failed."
0x8024C007, "Information required for the synchronization of applicable printers is missing."
0x8024CFFF, "A driver error not covered by another WU_E_DRV_* code."
0x80248000, "An operation failed because Windows Update Agent is shutting down."
0x80248001, "An operation failed because the data store was in use."
0x80248002, "The current and expected states of the data store do not match."
0x80248003, "The data store is missing a table."
0x80248004, "The data store contains a table with unexpected columns."
0x80248005, "A table could not be opened because the table is not in the data store."
0x80248006, "The current and expected versions of the data store do not match."
0x80248007, "The information requested is not in the data store."
0x80248008, "The data store is missing required information or has a NULL in a table column that requires a non-null value."
0x80248009, "The data store is missing required information or has a reference to missing license terms, file, localized property or linked row."
0x8024800A, "The update was not processed because its update handler could not be recognized."
0x8024800B, "The update was not deleted because it is still referenced by one or more services."
0x8024800C, "The data store section could not be locked within the allotted time."
0x8024800D, "The category was not added because it contains no parent categories and is not a top-level category itself."
0x8024800E, "The row was not added because an existing row has the same primary key."
0x8024800F, "The data store could not be initialized because it was locked by another process."
0x80248010, "The data store is not allowed to be registered with COM in the current process."
0x80248011, "Could not create a data store object in another process."
0x80248013, "The server sent the same update to the client with two different revision IDs."
0x80248014, "An operation did not complete because the service is not in the data store."
0x80248015, "An operation did not complete because the registration of the service has expired."
0x80248016, "A request to hide an update was declined because it is a mandatory update or because it was deployed with a deadline."
0x80248017, "A table was not closed because it is not associated with the session."
0x80248018, "A table was not closed because it is not associated with the session."
0x80248019, "A request to remove the Windows Update service or to unregister it with Automatic Updates was declined because it is a built-in service and/or Automatic Updates cannot fall back to another service."
0x8024801A, "A request was declined because the operation is not allowed."
0x8024801B, "The schema of the current data store and the schema of a table in a backup XML document do not match."
0x8024801C, "The data store requires a session reset; release the session and retry with a new session."
0x8024801D, "A data store operation did not complete because it was requested with an impersonated identity."
0x80248FFF, "A data store error not covered by another WU_E_DS_* code."
0x80249001, "Parsing of the rule file failed."
0x80249002, "Failed to get the requested inventory type from the server."
0x80249003, "Failed to upload inventory result to the server."
0x80249004, "There was an inventory error not covered by another error code."
0x80249005, "A WMI error occurred when enumerating the instances for a particular class."
0x8024A000, "Automatic Updates was unable to service incoming requests."
0x8024A002, "The old version of the Automatic Updates client has stopped because the WSUS server has been upgraded."
0x8024A003, "The old version of the Automatic Updates client was disabled."
0x8024A004, "Automatic Updates was unable to process incoming requests because it was paused."
0x8024A005, "No unmanaged service is registered with AU."
0x8024A006, "The default service registered with AU changed during the search."
0x8024AFFF, "An Automatic Updates error not covered by another WU_E_AU * code."
0x80242000, "A request for a remote update handler could not be completed because no remote process is available."
0x80242001, "A request for a remote update handler could not be completed because the handler is local only."
0x80242002, "A request for an update handler could not be completed because the handler could not be recognized."
0x80242003, "A remote update handler could not be created because one already exists."
0x80242004, "A request for the handler to install uninstall) an update could not be completed because the update does not support install uninstall)."
0x80242005, "An operation did not complete because the wrong handler was specified."
0x80242006, "A handler operation could not be completed because the update contains invalid metadata."
0x80242007, "An operation could not be completed because the installer exceeded the time limit."
0x80242008, "An operation being done by the update handler was cancelled."
0x80242009, "An operation could not be completed because the handler-specific metadata is invalid."
0x8024200A, "A request to the handler to install an update could not be completed because the update requires user input."
0x8024200B, "The installer failed to install uninstall) one or more updates."
0x8024200C, "The update handler should download self-contained content rather than delta-compressed content for the update."
0x8024200D, "The update handler did not install the update because it needs to be downloaded again."
0x8024200E, "The update handler failed to send notification of the status of the install uninstall) operation."
0x8024200F, "The file names contained in the update metadata and in the update package are inconsistent."
0x80242010, "The update handler failed to fall back to the self-contained content."
0x80242011, "The update handler has exceeded the maximum number of download requests."
0x80242012, "The update handler has received an unexpected response from CBS."
0x80242013, "The update metadata contains an invalid CBS package identifier."
0x80242014, "The post-reboot operation for the update is still in progress."
0x80242015, "The result of the post-reboot operation for the update could not be determined."
0x80242016, "The state of the update after its post-reboot operation has completed is unexpected."
0x80242017, "The OS servicing stack must be updated before this update is downloaded or installed."
0x80242018, "A callback installer called back with an error."
0x80242019, "The custom installer signature did not match the signature required by the update."
0x8024201A, "The installer does not support the installation configuration."
0x8024201B, "The targeted session for isntall is invalid."
0x80242FFF, "An update handler error not covered by another WU_E_UH_* code."
0x80246001, "A download manager operation could not be completed because the requested file does not have a URL."
0x80246002, "A download manager operation could not be completed because the file digest was not recognized."
0x80246003, "A download manager operation could not be completed because the file metadata requested an unrecognized hash algorithm."
0x80246004, "An operation could not be completed because a download request is required from the download handler."
0x80246005, "A download manager operation could not be completed because the network connection was unavailable."
0x80246006, "A download manager operation could not be completed because the version of Background Intelligent Transfer Service BITS) is incompatible."
0x80246007, "The update has not been downloaded."
0x80246008, "A download manager operation failed because the download manager was unable to connect the Background Intelligent Transfer Service BITS)."
0x80246009, "A download manager operation failed because there was an unspecified Background Intelligent Transfer Service BITS) transfer error."
0x8024600A, "A download must be restarted because the location of the source of the download has changed."
0x8024600B, "A download must be restarted because the update content changed in a new revision."
0x80246FFF, "There was a download manager error not covered by another WU_E_DM_* error code."
0x8024D001, "Windows Update Agent could not be updated because an INF file contains invalid information."
0x8024D002, "Windows Update Agent could not be updated because the wuident.cab file contains invalid information."
0x8024D003, "Windows Update Agent could not be updated because of an internal error that caused setup initialization to be performed twice."
0x8024D004, "Windows Update Agent could not be updated because setup initialization never completed successfully."
0x8024D005, "Windows Update Agent could not be updated because the versions specified in the INF do not match the actual source file versions."
0x8024D006, "Windows Update Agent could not be updated because a WUA file on the target system is newer than the corresponding source file."
0x8024D007, "Windows Update Agent could not be updated because regsvr32.exe returned an error."
0x8024D008, "An update to the Windows Update Agent was skipped because previous attempts to update have failed."
0x8024D009, "An update to the Windows Update Agent was skipped due to a directive in the wuident.cab file."
0x8024D00A, "Windows Update Agent could not be updated because the current system configuration is not supported."
0x8024D00B, "Windows Update Agent could not be updated because the system is configured to block the update."
0x8024D00C, "Windows Update Agent could not be updated because a restart of the system is required."
0x8024D00D, "Windows Update Agent setup is already running."
0x8024D00E, "Windows Update Agent setup package requires a reboot to complete installation."
0x8024D00F, "Windows Update Agent could not be updated because the setup handler failed during execution."
0x8024D010, "Windows Update Agent could not be updated because the registry contains invalid information."
0x8024D011, "Windows Update Agent must be updated before search can continue."
0x8024D012, "Windows Update Agent must be updated before search can continue.  An administrator is required to perform the operation."
0x8024D013, "Windows Update Agent could not be updated because the server does not contain update information for this version."
0x8024DFFF, "Windows Update Agent could not be updated because of an error not covered by another WU_E_SETUP_* error code."
0x8024E001, "An expression evaluator operation could not be completed because an expression was unrecognized."
0x8024E002, "An expression evaluator operation could not be completed because an expression was invalid."
0x8024E003, "An expression evaluator operation could not be completed because an expression contains an incorrect number of metadata nodes."
0x8024E004, "An expression evaluator operation could not be completed because the version of the serialized expression data is invalid."
0x8024E005, "The expression evaluator could not be initialized."
0x8024E006, "An expression evaluator operation could not be completed because there was an invalid attribute."
0x8024E007, "An expression evaluator operation could not be completed because the cluster state of the computer could not be determined."
0x8024EFFF, "There was an expression evaluator error not covered by another WU_E_EE_* error code."
0x80243001, "The results of download and installation could not be read from the registry due to an unrecognized data format version."
0x80243002, "The results of download and installation could not be read from the registry due to an invalid data format."
0x80243003, "The results of download and installation are not available; the operation may have failed to start."
0x80243004, "A failure occurred when trying to create an icon in the taskbar notification area."
0x80243FFD, "Unable to show UI when in non-UI mode; WU client UI modules may not be installed."
0x80243FFE, "Unsupported version of WU client UI exported functions."
0x80243FFF, "There was a user interface error not covered by another WU_E_AUCLIENT_* error code."
0x8024F001, "The event cache file was defective."
0x8024F002, "The XML in the event namespace descriptor could not be parsed."
0x8024F003, "The XML in the event namespace descriptor could not be parsed."
0x8024F004, "The server rejected an event because the server was too busy."
0x8024F005, "The specified callback cookie is not found."
0x8024FFFF, "There was a reporter error not covered by another error code."
0x80247001, "An operation could not be completed because the scan package was invalid."
0x80247002, "An operation could not be completed because the scan package requires a greater version of the Windows Update Agent."
0x80247FFF, "Search using the scan package failed."
'@ | ConvertFrom-Csv

<#
WUSA.exe / CbsCore.dll
https://github.com/seven-mile/CallCbsCore/blob/master/CbsUtil.cpp
https://github.com/insystemsco/scripts/blob/master/run-patch-scan.vbs

Ghidra -> CbsCore.dll
char * FUN_180030fb0(int param_1)

{
  if (param_1 < -0x7ff0f7f0) {
    if (param_1 == -0x7ff0f7f1) {
      return "CBS_E_MANIFEST_VALIDATION_DUPLICATE_ELEMENT";
    }
    if (param_1 < -0x7ff0fdd5) {
      if (param_1 == -0x7ff0fdd6) {
        return "SPAPI_E_INVALID_INF_LOGCONFIG";
      }
      if (param_1 < -0x7ff0fdee) {
        if (param_1 == -0x7ff0fdef) {
          return "SPAPI_E_NO_DEVICE_SELECTED";
        }
        if (param_1 < -0x7ff0fdfb) {
          if (param_1 == -0x7ff0fdfc) {
            return "SPAPI_E_KEY_DOES_NOT_EXIST";
          }
          if (param_1 < -0x7ff0fefd) {
            if (param_1 == -0x7ff0fefe) {
              return "SPAPI_E_LINE_NOT_FOUND";
            }
            if (param_1 == -0x7ff10000) {
              return "SPAPI_E_EXPECTED_SECTION_NAME";
            }
            if (param_1 == -0x7ff0ffff) {
              return "SPAPI_E_BAD_SECTION_NAME_LINE";
            }
            if (param_1 == -0x7ff0fffe) {
              return "SPAPI_E_SECTION_NAME_TOO_LONG";
            }
            if (param_1 == -0x7ff0fffd) {
              return "SPAPI_E_GENERAL_SYNTAX";
            }
            if (param_1 == -0x7ff0ff00) {
              return "SPAPI_E_WRONG_INF_STYLE";
            }
            if (param_1 == -0x7ff0feff) {
              return "SPAPI_E_SECTION_NOT_FOUND";
            }
          }
          else {
            if (param_1 == -0x7ff0fefd) {
              return "SPAPI_E_NO_BACKUP";
            }
            if (param_1 == -0x7ff0fe00) {
              return "SPAPI_E_NO_ASSOCIATED_CLASS";
            }
            if (param_1 == -0x7ff0fdff) {
              return "SPAPI_E_CLASS_MISMATCH";
            }
            if (param_1 == -0x7ff0fdfe) {
              return "SPAPI_E_DUPLICATE_FOUND";
            }
            if (param_1 == -0x7ff0fdfd) {
              return "SPAPI_E_NO_DRIVER_SELECTED";
            }
          }
        }
        else {
          switch(param_1) {
          case -0x7ff0fdfb:
            return "SPAPI_E_INVALID_DEVINST_NAME";
          case -0x7ff0fdfa:
            return "SPAPI_E_INVALID_CLASS";
          case -0x7ff0fdf9:
            return "SPAPI_E_DEVINST_ALREADY_EXISTS";
          case -0x7ff0fdf8:
            return "SPAPI_E_DEVINFO_NOT_REGISTERED";
          case -0x7ff0fdf7:
            return "SPAPI_E_INVALID_REG_PROPERTY";
          case -0x7ff0fdf6:
            return "SPAPI_E_NO_INF";
          case -0x7ff0fdf5:
            return "SPAPI_E_NO_SUCH_DEVINST";
          case -0x7ff0fdf4:
            return "SPAPI_E_CANT_LOAD_CLASS_ICON";
          case -0x7ff0fdf3:
            return "SPAPI_E_INVALID_CLASS_INSTALLER";
          case -0x7ff0fdf2:
            return "SPAPI_E_DI_DO_DEFAULT";
          case -0x7ff0fdf1:
            return "SPAPI_E_DI_NOFILECOPY";
          case -0x7ff0fdf0:
            return "SPAPI_E_INVALID_HWPROFILE";
          }
        }
      }
      else {
        switch(param_1) {
        case -0x7ff0fdee:
          return "SPAPI_E_DEVINFO_LIST_LOCKED";
        case -0x7ff0fded:
          return "SPAPI_E_DEVINFO_DATA_LOCKED";
        case -0x7ff0fdec:
          return "SPAPI_E_DI_BAD_PATH";
        case -0x7ff0fdeb:
          return "SPAPI_E_NO_CLASSINSTALL_PARAMS";
        case -0x7ff0fdea:
          return "SPAPI_E_FILEQUEUE_LOCKED";
        case -0x7ff0fde9:
          return "SPAPI_E_BAD_SERVICE_INSTALLSECT";
        case -0x7ff0fde8:
          return "SPAPI_E_NO_CLASS_DRIVER_LIST";
        case -0x7ff0fde7:
          return "SPAPI_E_NO_ASSOCIATED_SERVICE";
        case -0x7ff0fde6:
          return "SPAPI_E_NO_DEFAULT_DEVICE_INTERFACE";
        case -0x7ff0fde5:
          return "SPAPI_E_DEVICE_INTERFACE_ACTIVE";
        case -0x7ff0fde4:
          return "SPAPI_E_DEVICE_INTERFACE_REMOVED";
        case -0x7ff0fde3:
          return "SPAPI_E_BAD_INTERFACE_INSTALLSECT";
        case -0x7ff0fde2:
          return "SPAPI_E_NO_SUCH_INTERFACE_CLASS";
        case -0x7ff0fde1:
          return "SPAPI_E_INVALID_REFERENCE_STRING";
        case -0x7ff0fde0:
          return "SPAPI_E_INVALID_MACHINENAME";
        case -0x7ff0fddf:
          return "SPAPI_E_REMOTE_COMM_FAILURE";
        case -0x7ff0fdde:
          return "SPAPI_E_MACHINE_UNAVAILABLE";
        case -0x7ff0fddd:
          return "SPAPI_E_NO_CONFIGMGR_SERVICES";
        case -0x7ff0fddc:
          return "SPAPI_E_INVALID_PROPPAGE_PROVIDER";
        case -0x7ff0fddb:
          return "SPAPI_E_NO_SUCH_DEVICE_INTERFACE";
        case -0x7ff0fdda:
          return "SPAPI_E_DI_POSTPROCESSING_REQUIRED";
        case -0x7ff0fdd9:
          return "SPAPI_E_INVALID_COINSTALLER";
        case -0x7ff0fdd8:
          return "SPAPI_E_NO_COMPAT_DRIVERS";
        case -0x7ff0fdd7:
          return "SPAPI_E_NO_DEVICE_ICON";
        }
      }
    }
    else if (param_1 < -0x7ff0fcff) {
      if (param_1 == -0x7ff0fd00) {
        return "SPAPI_E_UNRECOVERABLE_STACK_OVERFLOW";
      }
      switch(param_1) {
      case -0x7ff0fdd5:
        return "SPAPI_E_DI_DONT_INSTALL";
      case -0x7ff0fdd4:
        return "SPAPI_E_INVALID_FILTER_DRIVER";
      case -0x7ff0fdd3:
        return "SPAPI_E_NON_WINDOWS_NT_DRIVER";
      case -0x7ff0fdd2:
        return "SPAPI_E_NON_WINDOWS_DRIVER";
      case -0x7ff0fdd1:
        return "SPAPI_E_NO_CATALOG_FOR_OEM_INF";
      case -0x7ff0fdd0:
        return "SPAPI_E_DEVINSTALL_QUEUE_NONNATIVE";
      case -0x7ff0fdcf:
        return "SPAPI_E_NOT_DISABLEABLE";
      case -0x7ff0fdce:
        return "SPAPI_E_CANT_REMOVE_DEVINST";
      case -0x7ff0fdcd:
        return "SPAPI_E_INVALID_TARGET";
      case -0x7ff0fdcc:
        return "SPAPI_E_DRIVER_NONNATIVE";
      case -0x7ff0fdcb:
        return "SPAPI_E_IN_WOW64";
      case -0x7ff0fdca:
        return "SPAPI_E_SET_SYSTEM_RESTORE_POINT";
      case -0x7ff0fdc9:
        return "SPAPI_E_INCORRECTLY_COPIED_INF";
      case -0x7ff0fdc8:
        return "SPAPI_E_SCE_DISABLED";
      case -0x7ff0fdc7:
        return "SPAPI_E_UNKNOWN_EXCEPTION";
      case -0x7ff0fdc6:
        return "SPAPI_E_PNP_REGISTRY_ERROR";
      case -0x7ff0fdc5:
        return "SPAPI_E_REMOTE_REQUEST_UNSUPPORTED";
      case -0x7ff0fdc4:
        return "SPAPI_E_NOT_AN_INSTALLED_OEM_INF";
      case -0x7ff0fdc3:
        return "SPAPI_E_INF_IN_USE_BY_DEVICES";
      case -0x7ff0fdc2:
        return "SPAPI_E_DI_FUNCTION_OBSOLETE";
      case -0x7ff0fdc1:
        return "SPAPI_E_NO_AUTHENTICODE_CATALOG";
      case -0x7ff0fdc0:
        return "SPAPI_E_AUTHENTICODE_DISALLOWED";
      case -0x7ff0fdbf:
        return "SPAPI_E_AUTHENTICODE_TRUSTED_PUBLISHER";
      case -0x7ff0fdbe:
        return "SPAPI_E_AUTHENTICODE_TRUST_NOT_ESTABLISHED";
      case -0x7ff0fdbd:
        return "SPAPI_E_AUTHENTICODE_PUBLISHER_NOT_TRUSTED";
      case -0x7ff0fdbc:
        return "SPAPI_E_SIGNATURE_OSATTRIBUTE_MISMATCH";
      case -0x7ff0fdbb:
        return "SPAPI_E_ONLY_VALIDATE_VIA_AUTHENTICODE";
      case -0x7ff0fdba:
        return "SPAPI_E_DEVICE_INSTALLER_NOT_READY";
      case -0x7ff0fdb9:
        return "SPAPI_E_DRIVER_STORE_ADD_FAILED";
      case -0x7ff0fdb8:
        return "SPAPI_E_DEVICE_INSTALL_BLOCKED";
      case -0x7ff0fdb7:
        return "SPAPI_E_DRIVER_INSTALL_BLOCKED";
      case -0x7ff0fdb6:
        return "SPAPI_E_WRONG_INF_TYPE";
      case -0x7ff0fdb5:
        return "SPAPI_E_FILE_HASH_NOT_IN_CATALOG";
      case -0x7ff0fdb4:
        return "SPAPI_E_DRIVER_STORE_DELETE_FAILED";
      }
    }
    else {
      switch(param_1) {
      case -0x7ff0f800:
        return "CBS_E_INTERNAL_ERROR";
      case -0x7ff0f7ff:
        return "CBS_E_NOT_INITIALIZED";
      case -0x7ff0f7fe:
        return "CBS_E_ALREADY_INITIALIZED";
      case -0x7ff0f7fd:
        return "CBS_E_INVALID_PARAMETER";
      case -0x7ff0f7fc:
        return "CBS_E_OPEN_FAILED";
      case -0x7ff0f7fb:
        return "CBS_E_INVALID_PACKAGE";
      case -0x7ff0f7fa:
        return "CBS_E_PENDING";
      case -0x7ff0f7f9:
        return "CBS_E_NOT_INSTALLABLE";
      case -0x7ff0f7f8:
        return "CBS_E_IMAGE_NOT_ACCESSIBLE";
      case -0x7ff0f7f7:
        return "CBS_E_ARRAY_ELEMENT_MISSING";
      case -0x7ff0f7f6:
        return "CBS_E_REESTABLISH_SESSION";
      case -0x7ff0f7f5:
        return "CBS_E_PROPERTY_NOT_AVAILABLE";
      case -0x7ff0f7f4:
        return "CBS_E_UNKNOWN_UPDATE";
      case -0x7ff0f7f3:
        return "CBS_E_MANIFEST_INVALID_ITEM";
      case -0x7ff0f7f2:
        return "CBS_E_MANIFEST_VALIDATION_DUPLICATE_ATTRIBUTES";
      }
    }
  }
  else if (param_1 < -0x7ff0f7b0) {
    if (param_1 == -0x7ff0f7b1) {
      return "CBS_E_RESOLVE_FAILED";
    }
    switch(param_1) {
    case -0x7ff0f7f0:
      return "CBS_E_MANIFEST_VALIDATION_MISSING_REQUIRED_ATTRIBUTES";
    case -0x7ff0f7ef:
      return "CBS_E_MANIFEST_VALIDATION_MISSING_REQUIRED_ELEMENTS";
    case -0x7ff0f7ee:
      return "CBS_E_MANIFEST_VALIDATION_UPDATES_PARENT_MISSING";
    case -0x7ff0f7ed:
      return "CBS_E_INVALID_INSTALL_STATE";
    case -0x7ff0f7ec:
      return "CBS_E_INVALID_CONFIG_VALUE";
    case -0x7ff0f7eb:
      return "CBS_E_INVALID_CARDINALITY";
    case -0x7ff0f7ea:
      return "CBS_E_DPX_JOB_STATE_SAVED";
    case -0x7ff0f7e9:
      return "CBS_E_PACKAGE_DELETED";
    case -0x7ff0f7e8:
      return "CBS_E_IDENTITY_MISMATCH";
    case -0x7ff0f7e7:
      return "CBS_E_DUPLICATE_UPDATENAME";
    case -0x7ff0f7e6:
      return "CBS_E_INVALID_DRIVER_OPERATION_KEY";
    case -0x7ff0f7e5:
      return "CBS_E_UNEXPECTED_PROCESSOR_ARCHITECTURE";
    case -0x7ff0f7e4:
      return "CBS_E_EXCESSIVE_EVALUATION";
    case -0x7ff0f7e3:
      return "CBS_E_CYCLE_EVALUATION";
    case -0x7ff0f7e2:
      return "CBS_E_NOT_APPLICABLE ";
    case -0x7ff0f7e1:
      return "CBS_E_SOURCE_MISSING";
    case -0x7ff0f7e0:
      return "CBS_E_CANCEL";
    case -0x7ff0f7df:
      return "CBS_E_ABORT";
    case -0x7ff0f7de:
      return "CBS_E_ILLEGAL_COMPONENT_UPDATE";
    case -0x7ff0f7dd:
      return "CBS_E_NEW_SERVICING_STACK_REQUIRED";
    case -0x7ff0f7dc:
      return "CBS_E_SOURCE_NOT_IN_LIST";
    case -0x7ff0f7db:
      return "CBS_E_CANNOT_UNINSTALL";
    case -0x7ff0f7da:
      return "CBS_E_PENDING_VICTIM";
    case -0x7ff0f7d9:
      return "CBS_E_STACK_SHUTDOWN_REQUIRED";
    case -0x7ff0f7d8:
      return "CBS_E_INSUFFICIENT_DISK_SPACE";
    case -0x7ff0f7d7:
      return "CBS_E_AC_POWER_REQUIRED";
    case -0x7ff0f7d6:
      return "CBS_E_STACK_UPDATE_FAILED_REBOOT_REQUIRED";
    case -0x7ff0f7d5:
      return "CBS_E_SQM_REPORT_IGNORED_AI_FAILURES_ON_TRANSACTION_RESOLVE";
    case -0x7ff0f7d4:
      return "CBS_E_DEPENDENT_FAILURE";
    case -0x7ff0f7d3:
      return "CBS_E_PAC_INITIAL_FAILURE";
    case -0x7ff0f7d2:
      return "CBS_E_NOT_ALLOWED_OFFLINE";
    case -0x7ff0f7d1:
      return "CBS_E_EXCLUSIVE_WOULD_MERGE";
    case -0x7ff0f7d0:
      return "CBS_E_IMAGE_UNSERVICEABLE";
    case -0x7ff0f7cf:
      return "CBS_E_STORE_CORRUPTION";
    case -0x7ff0f7ce:
      return "CBS_E_STORE_TOO_MUCH_CORRUPTION";
    case -0x7ff0f7cd:
      return "CBS_S_STACK_RESTART_REQUIRED";
    case -0x7ff0f7c0:
      return "CBS_E_SESSION_CORRUPT";
    case -0x7ff0f7bf:
      return "CBS_E_SESSION_INTERRUPTED";
    case -0x7ff0f7be:
      return "CBS_E_SESSION_FINALIZED";
    case -0x7ff0f7bd:
      return "CBS_E_SESSION_READONLY";
    }
  }
  else if (param_1 < -0x7ff0f66f) {
    if (param_1 == -0x7ff0f670) {
      return "PSFX_E_UNSUPPORTED_COMPRESSION_SWITCH";
    }
    switch(param_1) {
    case -0x7ff0f700:
      return "CBS_E_XML_PARSER_FAILURE";
    case -0x7ff0f6ff:
      return "CBS_E_MANIFEST_VALIDATION_MULTIPLE_UPDATE_COMPONENT_ON_SAME_FAMILY_NOT_ALLOWED";
    case -0x7ff0f6fe:
      return "CBS_E_BUSY";
    case -0x7ff0f6fd:
      return "CBS_E_INVALID_RECALL";
    case -0x7ff0f6fc:
      return "CBS_E_MORE_THAN_ONE_ACTIVE_EDITION";
    case -0x7ff0f6fb:
      return "CBS_E_NO_ACTIVE_EDITION";
    case -0x7ff0f6fa:
      return "CBS_E_DOWNLOAD_FAILURE";
    case -0x7ff0f6f9:
      return "CBS_E_GROUPPOLICY_DISALLOWED";
    case -0x7ff0f6f8:
      return "CBS_E_METERED_NETWORK";
    case -0x7ff0f6f7:
      return "CBS_E_PUBLIC_OBJECT_LEAK";
    case -0x7ff0f6f5:
      return "CBS_E_REPAIR_PACKAGE_CORRUPT";
    case -0x7ff0f6f4:
      return "CBS_E_COMPONENT_NOT_INSTALLED_BY_CBS";
    case -0x7ff0f6f3:
      return "CBS_E_MISSING_PACKAGE_MAPPING_INDEX";
    case -0x7ff0f6f2:
      return "CBS_E_EMPTY_PACKAGE_MAPPING_INDEX";
    case -0x7ff0f6f1:
      return "CBS_E_WINDOWS_UPDATE_SEARCH_FAILURE";
    case -0x7ff0f6f0:
      return "CBS_E_WINDOWS_AUTOMATIC_UPDATE_SETTING_DISALLOWED";
    case -0x7ff0f6e0:
      return "CBS_E_HANG_DETECTED";
    case -0x7ff0f6df:
      return "CBS_E_PRIMITIVES_FAILED";
    case -0x7ff0f6de:
      return "CBS_E_INSTALLERS_FAILED";
    case -0x7ff0f6dd:
      return "CBS_E_SAFEMODE_ENTERED";
    case -0x7ff0f6dc:
      return "CBS_E_SESSIONS_LEAKED";
    case -0x7ff0f6db:
      return "CBS_E_INVALID_EXECUTESTATE";
    case -0x7ff0f6c0:
      return "CBS_E_WUSUS_MAPPING_UNAVAILABLE";
    case -0x7ff0f6bf:
      return "CBS_E_WU_MAPPING_UNAVAILABLE";
    case -0x7ff0f6be:
      return "CBS_E_WUSUS_BYPASS_MAPPING_UNAVAILABLE";
    case -0x7ff0f6bd:
      return "CBS_E_WUSUS_MISSING_PACKAGE_MAPPING_INDEX";
    case -0x7ff0f6bc:
      return "CBS_E_WU_MISSING_PACKAGE_MAPPING_INDEX";
    case -0x7ff0f6bb:
      return "CBS_E_WUSUS_BYPASS_MISSING_PACKAGE_MAPPING_INDEX";
    case -0x7ff0f6ba:
      return "CBS_E_SOURCE_MISSING_FROM_WUSUS_CAB";
    case -0x7ff0f6b9:
      return "CBS_E_SOURCE_MISSING_FROM_WUSUS_EXPRESS";
    case -0x7ff0f6b8:
      return "CBS_E_SOURCE_MISSING_FROM_WU_CAB";
    case -0x7ff0f6b7:
      return "CBS_E_SOURCE_MISSING_FROM_WU_EXPRESS";
    case -0x7ff0f6b6:
      return "CBS_E_SOURCE_MISSING_FROM_WUSUS_BYPASS_CAB";
    case -0x7ff0f6b5:
      return "CBS_E_SOURCE_MISSING_FROM_WUSUS_BYPASS_EXPRESS";
    case -0x7ff0f6b4:
      return "CBS_E_3RD_PARTY_MAPPING_UNAVAILABLE";
    case -0x7ff0f6b3:
      return "CBS_E_3RD_PARTY_MISSING_PACKAGE_MAPPING_INDEX";
    case -0x7ff0f6b2:
      return "CBS_E_SOURCE_MISSING_FROM_3RD_PARTY_CAB";
    case -0x7ff0f6b1:
      return "CBS_E_SOURCE_MISSING_FROM_3RD_PARTY_EXPRESS";
    case -0x7ff0f6b0:
      return "CBS_E_INVALID_WINDOWS_UPDATE_COUNT";
    case -0x7ff0f6af:
      return "CBS_E_INVALID_NO_PRODUCT_REGISTERED";
    case -0x7ff0f6ae:
      return "CBS_E_INVALID_ACTION_LIST_PACKAGE_COUNT";
    case -0x7ff0f6ad:
      return "CBS_E_INVALID_ACTION_LIST_INSTALL_REASON";
    case -0x7ff0f6ac:
      return "CBS_E_INVALID_WINDOWS_UPDATE_COUNT_WSUS";
    case -0x7ff0f6ab:
      return "CBS_E_INVALID_PACKAGE_REQUEST_ON_MULTILINGUAL_FOD";
    case -0x7ff0f680:
      return "PSFX_E_DELTA_NOT_SUPPORTED_FOR_COMPONENT";
    case -0x7ff0f67f:
      return "PSFX_E_REVERSE_AND_FORWARD_DELTAS_MISSING";
    case -0x7ff0f67e:
      return "PSFX_E_MATCHING_COMPONENT_NOT_FOUND";
    case -0x7ff0f67d:
      return "PSFX_E_MATCHING_COMPONENT_DIRECTORY_MISSING";
    case -0x7ff0f67c:
      return "PSFX_E_MATCHING_BINARY_MISSING";
    case -0x7ff0f67b:
      return "PSFX_E_APPLY_REVERSE_DELTA_FAILED";
    case -0x7ff0f67a:
      return "PSFX_E_APPLY_FORWARD_DELTA_FAILED";
    case -0x7ff0f679:
      return "PSFX_E_NULL_DELTA_HYDRATION_FAILED";
    case -0x7ff0f678:
      return "PSFX_E_INVALID_DELTA_COMBINATION";
    case -0x7ff0f677:
      return "PSFX_E_REVERSE_DELTA_MISSING";
    }
  }
  else {
    if (param_1 == -0x7ff0f000) {
      return "SPAPI_E_ERROR_NOT_INSTALLED";
    }
    if (param_1 == 0xf0801) {
      return "CBS_S_BUSY";
    }
    if (param_1 == 0xf0802) {
      return "CBS_S_ALREADY_EXISTS";
    }
    if (param_1 == 0xf0803) {
      return "CBS_S_STACK_SHUTDOWN_REQUIRED";
    }
  }
  return "Unknown Error";
}
#>
$Global:CBS_ERR_TABLE = @'
ERROR, MESSEGE
0xf0801,    The Component-Based Servicing system is currently busy and cannot process the request right now.
0xf0802,    The item or component you are trying to create or add already exists in the system.
0xf0803,    The servicing stack needs to be shut down and restarted to complete the operation.
0xF0804,    The servicing stack restart is required to complete the operation.
0x800F0991, The requested operation could not be completed due to a component store corruption or a missing manifest file.
-0x7ff0f7f1,Manifest validation failed: a duplicate element was found.
-0x7ff0fdd6,Invalid INF log configuration.
-0x7ff0fdef,No device was selected for this operation.
-0x7ff0fdfc,The specified key does not exist.
-0x7ff0fefe,The line requested was not found.
-0x7ff10000,An expected section name is missing or invalid.
-0x7ff0ffff,The section name line is malformed or incorrect.
-0x7ff0fffe,The section name provided is too long.
-0x7ff0fffd,A general syntax error was detected.
-0x7ff0ff00,The INF file has an incorrect style or format.
-0x7ff0feff,The specified section was not found.
-0x7ff0fefd,No backup copy is available.
-0x7ff0fe00,No associated class was found for this operation.
-0x7ff0fdff,There is a mismatch in the specified class.
-0x7ff0fdfe,A duplicate item was found.
-0x7ff0fdfd,No driver was selected.
-0x7ff0fdfb,The device instance name is invalid.
-0x7ff0fdfa,The specified class is invalid.
-0x7ff0fdf9,A device instance with this name already exists.
-0x7ff0fdf8,The device information set is not registered.
-0x7ff0fdf7,The registry property is invalid.
-0x7ff0fdf6,No INF file was found.
-0x7ff0fdf5,The specified device instance does not exist.
-0x7ff0fdf4,Cannot load the class icon.
-0x7ff0fdf3,The class installer is invalid.
-0x7ff0fdf2,Proceed with the default action.
-0x7ff0fdf1,No file copy operation was performed.
-0x7ff0fdf0,The hardware profile is invalid.
-0x7ff0fdee,The device information list is locked.
-0x7ff0fded,The device information data is locked.
-0x7ff0fdec,The specified path is invalid.
-0x7ff0fdeb,No class installation parameters are available.
-0x7ff0fdea,The file queue is locked.
-0x7ff0fde9,The service installation section is malformed.
-0x7ff0fde8,No class driver list is available.
-0x7ff0fde7,No associated service was found.
-0x7ff0fde6,No default device interface exists.
-0x7ff0fde5,The device interface is currently active.
-0x7ff0fde4,The device interface has been removed.
-0x7ff0fde3,The interface installation section is malformed.
-0x7ff0fde2,The specified interface class does not exist.
-0x7ff0fde1,The reference string is invalid.
-0x7ff0fde0,The machine name is invalid.
-0x7ff0fddf,Communication with the remote machine failed.
-0x7ff0fdde,The machine is unavailable for remote operations.
-0x7ff0fddd,Configuration Manager services are not available.
-0x7ff0fddc,The property page provider is invalid.
-0x7ff0fddb,The specified device interface does not exist.
-0x7ff0fdda,Post-processing is required to complete the operation.
-0x7ff0fdd9,The co-installer is invalid.
-0x7ff0fdd8,No compatible drivers were found.
-0x7ff0fdd7,No device icon is available.
-0x7ff0fd00,An unrecoverable stack overflow occurred.
-0x7ff0fdd5,Do not install the device.
-0x7ff0fdd4,The filter driver is invalid.
-0x7ff0fdd3,This is not a Windows NT driver.
-0x7ff0fdd2,This is not a Windows driver.
-0x7ff0fdd1,No catalog file was found for the OEM INF.
-0x7ff0fdd0,The device installation queue contains non-native items.
-0x7ff0fdcf,The component cannot be disabled.
-0x7ff0fdce,Cannot remove the device instance.
-0x7ff0fdcd,The target specified is invalid.
-0x7ff0fdcc,The driver is not native to this system.
-0x7ff0fdcb,Operation is running in WOW64 (32-bit on 64-bit).
-0x7ff0fdca,A system restore point needs to be set.
-0x7ff0fdc9,The INF file was incorrectly copied.
-0x7ff0fdc8,Security Configuration Engine (SCE) is disabled.
-0x7ff0fdc7,An unknown exception occurred.
-0x7ff0fdc6,A Plug and Play (PNP) registry error occurred.
-0x7ff0fdc5,The remote request is not supported.
-0x7ff0fdc4,The specified OEM INF is not installed.
-0x7ff0fdc3,The INF file is currently in use by other devices.
-0x7ff0fdc2,This device installation function is obsolete.
-0x7ff0fdc1,No Authenticode catalog was found.
-0x7ff0fdc0,Authenticode signature is disallowed.
-0x7ff0fdbf,Authenticode signature from a trusted publisher.
-0x7ff0fdbe,Authenticode trust could not be established.
-0x7ff0fdbd,The Authenticode publisher is not trusted.
-0x7ff0fdbc,The signature's OS attribute does not match.
-0x7ff0fdbb,Validation must be performed via Authenticode only.
-0x7ff0fdba,The device installer is not ready.
-0x7ff0fdb9,Failed to add to the driver store.
-0x7ff0fdb8,Device installation is blocked.
-0x7ff0fdb7,Driver installation is blocked.
-0x7ff0fdb6,The INF file type is incorrect.
-0x7ff0fdb5,The file hash is not found in the catalog.
-0x7ff0fdb4,Failed to delete from the driver store.
-0x7ff0f800,An internal Component-Based Servicing (CBS) error occurred.
-0x7ff0f7ff,The Component-Based Servicing (CBS) system is not initialized.
-0x7ff0f7fe,The Component-Based Servicing (CBS) system is already initialized.
-0x7ff0f7fd,An invalid parameter was provided to CBS.
-0x7ff0f7fc,CBS failed to open a required resource.
-0x7ff0f7fb,The package is invalid or corrupt.
-0x7ff0f7fa,The CBS operation is pending.
-0x7ff0f7f9,The component or package cannot be installed.
-0x7ff0f7f8,The image cannot be accessed.
-0x7ff0f7f7,A required element in the array is missing.
-0x7ff0f7f6,The session needs to be reestablished.
-0x7ff0f7f5,The requested property is not available.
-0x7ff0f7f4,An unknown update was encountered.
-0x7ff0f7f3,The manifest contains an invalid item.
-0x7ff0f7f2,Manifest validation failed: duplicate attributes were found.
-0x7ff0f7b1,The Component-Based Servicing system failed to resolve the requested operation or component.
-0x7ff0f7f0,Manifest validation failed: required attributes are missing.
-0x7ff0f7ef,Manifest validation failed: required elements are missing.
-0x7ff0f7ee,Manifest validation failed: the update's parent is missing.
-0x7ff0f7ed,The installation state is invalid.
-0x7ff0f7ec,The configuration value is invalid.
-0x7ff0f7eb,The cardinality value is invalid.
-0x7ff0f7ea,The DPX job state has been saved.
-0x7ff0f7e9,The package has been deleted.
-0x7ff0f7e8,An identity mismatch was detected.
-0x7ff0f7e7,A duplicate update name was found.
-0x7ff0f7e6,The driver operation key is invalid.
-0x7ff0f7e5,An unexpected processor architecture was encountered.
-0x7ff0f7e4,Excessive evaluation was detected.
-0x7ff0f7e3,A cycle was detected during evaluation.
-0x7ff0f7e2,The operation is not applicable.
-0x7ff0f7e1,A required source is missing.
-0x7ff0f7e0,The operation was cancelled.
-0x7ff0f7df,The operation was aborted.
-0x7ff0f7de,An illegal component update was attempted.
-0x7ff0f7dd,A new servicing stack is required.
-0x7ff0f7dc,The source was not found in the list.
-0x7ff0f7db,The component cannot be uninstalled.
-0x7ff0f7da,A pending victim state was detected.
-0x7ff0f7d9,The servicing stack needs to be shut down.
-0x7ff0f7d8,There is insufficient disk space available.
-0x7ff0f7d7,AC power is required for this operation.
-0x7ff0f7d6,The servicing stack update failed; a reboot is required.
-0x7ff0f7d5,SQM report ignored AI failures on transaction resolve.
-0x7ff0f7d4,A dependent failure occurred.
-0x7ff0f7d3,PAC initialization failed.
-0x7ff0f7d2,The operation is not allowed offline.
-0x7ff0f7d1,An exclusive operation would cause a merge conflict.
-0x7ff0f7d0,The image is unserviceable.
-0x7ff0f7cf,Store corruption was detected.
-0x7ff0f7ce,Too much corruption was found in the store.
-0x7ff0f7cd,A servicing stack restart is required (status).
-0x7ff0f7c0,The session is corrupt.
-0x7ff0f7bf,The session was interrupted.
-0x7ff0f7be,The session has been finalized.
-0x7ff0f7bd,The session is read-only.
-0x7ff0f670,Unsupported compression switch in PSFX.
-0x7ff0f700,The XML parser encountered a failure.
-0x7ff0f6ff,Manifest validation failed: multiple update components on the same family are not allowed.
-0x7ff0f6fe,The Component-Based Servicing system is currently busy.
-0x7ff0f6fd,The recall operation attempted is invalid.
-0x7ff0f6fc,More than one active edition exists, which is not allowed.
-0x7ff0f6fb,No active edition is available.
-0x7ff0f6fa,Failure occurred while downloading the package or component.
-0x7ff0f6f9,This operation is disallowed by Group Policy.
-0x7ff0f6f8,Operation failed because the network connection is metered, restricting data usage.
-0x7ff0f6f7,A public object leak was detected, indicating a potential resource management issue.
-0x7ff0f6f5,The repair package is corrupt and cannot be used.
-0x7ff0f6f4,The component was not installed by CBS and cannot be serviced by it.
-0x7ff0f6f3,Missing package mapping index; the system cannot locate the package mapping.
-0x7ff0f6f2,The package mapping index is empty, causing lookup failures.
-0x7ff0f6f1,Windows Update search failed to find the required updates.
-0x7ff0f6f0,The automatic Windows Update setting is disallowed by policy or configuration.
-0x7ff0f6e0,A failure to respond was detected while processing the operation.
-0x7ff0f6df,Primitive operations failed during servicing.
-0x7ff0f6de,Installer operations failed to complete successfully.
-0x7ff0f6dd,The system has entered safe mode, restricting certain operations.
-0x7ff0f6dc,Sessions have leaked, indicating resource management issues.
-0x7ff0f6db,An invalid execution state was encountered.
-0x7ff0f6c0,WSUS (Windows Server Update Services) mapping is unavailable.
-0x7ff0f6bf,Windows Update mapping is unavailable.
-0x7ff0f6be,WSUS bypass mapping is unavailable.
-0x7ff0f6bd,Missing package mapping index in WSUS.
-0x7ff0f6bc,Missing package mapping index in Windows Update.
-0x7ff0f6bb,Missing package mapping index in WSUS bypass.
-0x7ff0f6ba,Source is missing from the WSUS CAB file.
-0x7ff0f6b9,Source is missing from the WSUS Express package.
-0x7ff0f6b8,Source is missing from the Windows Update CAB file.
-0x7ff0f6b7,Source is missing from the Windows Update Express package.
-0x7ff0f6b6,Source is missing from the WSUS bypass CAB file.
-0x7ff0f6b5,Source is missing from the WSUS bypass Express package.
-0x7ff0f6b4,Third-party mapping is unavailable.
-0x7ff0f6b3,Missing package mapping index for third-party components.
-0x7ff0f6b2,Source is missing from the third-party CAB file.
-0x7ff0f6b1,Source is missing from the third-party Express package.
-0x7ff0f6b0,An invalid count of Windows updates was specified.
-0x7ff0f6af,No registered product found; invalid state.
-0x7ff0f6ae,Invalid count in the action list package.
-0x7ff0f6ad,An invalid reason was specified for action list installation.
-0x7ff0f6ac,Invalid Windows Update count for WSUS.
-0x7ff0f6ab,Invalid package request on multilingual Features on Demand (FOD).
-0x7ff0f680,Delta updates are not supported for this component.
-0x7ff0f67f,Reverse and forward delta files are missing.
-0x7ff0f67e,The matching component was not found.
-0x7ff0f67d,The matching component directory is missing.
-0x7ff0f67c,The matching binary file is missing.
-0x7ff0f67b,Failed to apply the reverse delta update.
-0x7ff0f67a,Failed to apply the forward delta update.
-0x7ff0f679,Null delta hydration process failed.
-0x7ff0f678,An invalid combination of delta updates was specified.
-0x7ff0f677,The reverse delta update is missing.
-0x7ff0f000,The error indicates that the component is not installed.
'@ | ConvertFrom-Csv

<#
So technically, error messege, stored in couple location's.

winhttp.dll > Windows Update common errors and mitigation
* https://learn.microsoft.com/en-us/troubleshoot/windows-client/installing-updates-features-roles/common-windows-update-errors

netmsg.dll > Network Management Error Codes
* https://learn.microsoft.com/en-us/windows/win32/netmgmt/network-management-error-codes

Kernel32.dll ,api-ms-win-core-synch-l1-2-0.dll > Win32 Error Codes & HRESULT Values
* https://learn.microsoft.com/en-us/openspecs/windows_protocols/ms-erref/18d8fbe8-a967-4f1c-ae50-99ca8e491d2d
* https://learn.microsoft.com/en-us/openspecs/windows_protocols/ms-erref/705fb797-2175-4a90-b5a3-3918024b10b8

NTDLL.dll > NTSTATUS Values
* https://learn.microsoft.com/en-us/openspecs/windows_protocols/ms-erref/87fba13e-bf06-450e-83b1-9241dc81e781

SLC.dll > Windows Activation Error
* https://howtoedge.com/windows-activation-error-codes-and-solutions/

qmgr.dll > BITS Return Values
* https://learn.microsoft.com/en-us/windows/win32/bits/bits-return-values
* https://gitlab.winehq.org/wine/wine/-/blob/master/include/bitsmsg.h?ref_type=heads

Also, it include in header files too, 
Check Microsoft Error Lookup Tool as example

there is also other place it could save, possibly,
C:\Windows\Logs\CBS\CBS.log, Also include CBS ERROR
could not find DLL Source, or Header file ? .. well

# --------------------------------------------------------------

Microsoft Error Lookup Tool
https://www.microsoft.com/en-us/download/details.aspx?id=100432

SLMGR.vbs, Source code ->
"On a computer running Microsoft Windows non-core edition, run 'slui.exe 0x2a 0x%ERRCODE%' to display the error text."

RtlInitUnicodeStringEx
https://www.geoffchappell.com/studies/windows/km/ntoskrnl/api/rtl/string/initunicodestringex.htm

# --------------------------------------------------------------

slui 0x2a 0xC004F014
using API-SPY -> Debug info
#29122    9:06:51.521 AM    2    KERNELBASE.dll    RtlInitUnicodeStringEx ( 0x00000016fcd7f810, "SLC.dll" )    STATUS_SUCCESS        0.0000001
#29123    9:06:51.521 AM    2    KERNELBASE.dll    RtlDosApplyFileIsolationRedirection_Ustr ( TRUE, 0x00000016fcd7f810, 0x00007ffa653e2138, 0x00000016fcd7f638, 0x00000016fcd7f620, 0x00000016fcd7f5f8, NULL, NULL, NULL )    STATUS_SXS_KEY_NOT_FOUND    0xc0150008 = The requested lookup key was not found in any active activation context.     0.0000008
#29124    9:06:51.521 AM    2    KERNELBASE.dll    RtlFindMessage ( 0x00007ffa639e0000, 11, 1024, 3221549076, 0x00000016fcd7f6f8 )    STATUS_SUCCESS        0.0000484

17-win32 error {api-ms-win-core-synch-l1-2-0}

349	10:57:41.933 PM	1	Kernel32.dll	LoadLibraryEx ( "api-ms-win-core-synch-l1-2-0", NULL, 2048 )	0x00007ffd5dea0000		0.0000012
28480	10:57:45.636 PM	2	KERNELBASE.dll	RtlFindMessage ( 0x00007ffd5dea0000, 11, 1024, 17, 0x00000062b88ff458 )	STATUS_SUCCESS		0.0001046

0x...-SL ERROR ---> ntdll.dll { not from slc.dll, from }

329	10:52:10.339 PM	1	ntdll.dll	DllMain ( 0x00007ffd5c610000, DLL_PROCESS_ATTACH, 0x0000008aba5af380 )	TRUE		0.0000185
28461	10:52:14.324 PM	2	KERNELBASE.dll	RtlFindMessage ( 0x00007ffd5c610000, 11, 1024, 3221549076, 0x0000008aba9ff4d8 )	STATUS_SUCCESS		0.0000233

# --------------------------------------------------------------

2.1.1 HRESULT Values
https://learn.microsoft.com/en-us/openspecs/windows_protocols/ms-erref/705fb797-2175-4a90-b5a3-3918024b10b8

2.2 Win32 Error Codes
https://learn.microsoft.com/en-us/openspecs/windows_protocols/ms-erref/18d8fbe8-a967-4f1c-ae50-99ca8e491d2d

2.3.1 NTSTATUS Values
https://learn.microsoft.com/en-us/openspecs/windows_protocols/ms-erref/596a1078-e883-4972-9bbc-49e60bebca55

Network Management Error Codes
https://learn.microsoft.com/en-us/windows/win32/netmgmt/network-management-error-codes

https://github.com/SystemRage/py-kms/blob/master/py-kms/pykms_Misc.py
http://joshpoley.blogspot.com/2011/09/hresults-user-0x004.html  (slerror.h)

Troubleshoot Windows activation error codes
https://learn.microsoft.com/en-us/troubleshoot/windows-server/licensing-and-activation/troubleshoot-activation-error-codes

https://github.com/SystemRage/py-kms/blob/master/py-kms/pykms_Misc.py
http://joshpoley.blogspot.com/2011/09/hresults-user-0x004.html  (slerror.h)

Windows Activation Error Codes and Solutions on Windows 11/10
https://howtoedge.com/windows-activation-error-codes-and-solutions/

Additional Resources for Windows Server Update Services
https://learn.microsoft.com/de-de/security-updates/windowsupdateservices/18127498

Windows Update error codes by component
https://learn.microsoft.com/en-us/windows/deployment/update/windows-update-error-reference?source=recommendations

Windows Update common errors and mitigation
https://learn.microsoft.com/en-us/troubleshoot/windows-client/installing-updates-features-roles/common-windows-update-errors

BITS Return Values
https://learn.microsoft.com/en-us/windows/win32/bits/bits-return-values

bitsmsg.h
https://gitlab.winehq.org/wine/wine/-/blob/master/include/bitsmsg.h?ref_type=heads

# --------------------------------------------------------------
              Alternative Source
# --------------------------------------------------------------

RCodes.ini
https://forums.mydigitallife.net/threads/multi-oem-retail-project-mrp-mk3.71555/

MicrosoftOfficeAssistant
https://github.com/audricd/MicrosoftOfficeAssistant/blob/master/scripts/roiscan.vbs

--> Alternative CBS / WU, hard codec error database, No dll found, yet! <--

https://github.com/larsch/wunow/blob/master/wunow/WUError.cs
https://github.com/microsoft/IIS.Setup/blob/main/iisca/lib/wuerror.h

#>
<#
Clear-Host
write-host

write-host ------------------------------------------------------------
Write-Host "             NUMBER FORMAT TEST                           " -ForegroundColor Red
write-host ------------------------------------------------------------

Write-Host
Write-Host 'Test win32 error' -ForegroundColor Red
$unsignedNumber = 17
$hexRepresentation = "0x{0:X}" -f $unsignedNumber
$unsignedLong = [long]$unsignedNumber
$overflowedNumber = $unsignedLong - 0x100000000

# Construct the UInt32 HRESULT, And, 
# Format it as a hexadecimal string
$hResultUInt32 = 0x80000000 -bor 0x00070000 -bor $unsignedNumber
$hexNegativeString = "0x{0:X}" -f $hResultUInt32

Write-Host
Write-Warning 'unsignedNumber'
Parse-ErrorMessage -log -MessageId $unsignedNumber
Write-Warning 'overflowedNumber'
Parse-ErrorMessage -log -MessageId $overflowedNumber
Write-Warning 'hexRepresentation'
Parse-ErrorMessage -log -MessageId $hexRepresentation
Write-Warning 'hexNegativeString'
Parse-ErrorMessage -log -MessageId $hexNegativeString

write-host
write-host ------------------------------------------------------------
write-host

Write-Host
Write-Host 'Test SL error' -ForegroundColor Red
$unsignedNumber = 3221549172
$hexRepresentation = "0x{0:X}" -f $unsignedNumber
$unsignedLong = [long]$unsignedNumber
$overflowedNumber = $unsignedLong - 0x100000000

Write-Host
Write-Warning 'unsignedNumber'
Parse-ErrorMessage -log -MessageId $unsignedNumber
Write-Warning 'overflowedNumber'
Parse-ErrorMessage -log -MessageId $overflowedNumber
Write-Warning 'hexRepresentation'
Parse-ErrorMessage -log -MessageId $hexRepresentation

write-host
write-host ------------------------------------------------------------
Write-Host "             DIFFRENT ERROR TEST                          " -ForegroundColor Red
write-host ------------------------------------------------------------
write-host
write-host

Write-Host "Locate -> Activation error" -ForegroundColor Green
Parse-ErrorMessage -log -MessageId 0xC004B007

Write-Host "Locate -> NT STATUS error" -ForegroundColor Green
Parse-ErrorMessage -log -MessageId 0x40000016

Write-Host "Locate -> WIN32 error" -ForegroundColor Green
write-host "0x Positive"
Parse-ErrorMessage -log -MessageId 0x0000215B
write-host "0x Negative"
Parse-ErrorMessage -log -MessageId 0x8007232B
write-host "[Negative] 0x"
Parse-ErrorMessage -log -MessageId -0x7FF8DCD5

Write-Host "Locate -> HRESULT error" -ForegroundColor Green
Parse-ErrorMessage -log -MessageId 0x00030203

Write-Host "Locate -> WU error" -ForegroundColor Green
Parse-ErrorMessage -log -MessageId 0x8024000E

Write-Host "Locate -> network error" -ForegroundColor Green
Parse-ErrorMessage -log -MessageId 0x853 

Write-Host
Write-Host "Locate -> Bits error" -ForegroundColor Green
Parse-ErrorMessage -log -MessageId 0x80200010

Write-Host
Write-Host "Locate -> CBS error" -ForegroundColor Green
Parse-ErrorMessage -log -MessageId 0x800f0831 
Write-Host
write-host "0x Negative"
Parse-ErrorMessage -log -MessageId 0x800f081e 
Write-Host
write-host "[Negative] 0x"
Parse-ErrorMessage -MessageId -0x7ff10000L -Log

write-host
write-host
write-host ------------------------------------------------------------
Write-Host "             OCTA + LEADING TEST                          " -ForegroundColor Red
write-host ------------------------------------------------------------
write-host
write-host

Write-Host "** Octa Test" -ForegroundColor Green
Parse-ErrorMessage -log -MessageId 0225D

Write-Host "** Leading Test" -ForegroundColor Green
Parse-ErrorMessage -log -MessageId 225AASASS

write-host
write-host
write-host ------------------------------------------------------------
Write-Host "             FLAG TEST                                     " -ForegroundColor Red
write-host ------------------------------------------------------------
write-host
write-host

Write-Warning "Testing HRESULT"
Parse-ErrorMessage -log -MessageId 0x00030203 -Flags HRESULT

Write-Host
Write-Warning "Testing WIN32"
Parse-ErrorMessage -log -MessageId '0x80070005' -Flags WIN32

Write-Host
Write-Warning "Testing NTSTATUS"
Parse-ErrorMessage -log -MessageId '0xC0000005' -Flags NTSTATUS

Write-Host
Write-Warning "Testing ACTIVATION"
Parse-ErrorMessage -log -MessageId '0xC004F074' -Flags ACTIVATION

Write-Host
Write-Warning "Testing NETWORK"
Parse-ErrorMessage -log -MessageId '0x853' -Flags NETWORK

Write-Host
Write-Warning "Testing NETWORK -> BITS"
Parse-ErrorMessage -log -MessageId '0x8019019B' -Flags BITS

Write-Host
Write-Warning "Testing NETWORK -> Windows HTTP Services"
Parse-ErrorMessage -log -MessageId '0x80072EE7' -Flags HTTP

Write-Host
Write-Warning "Testing CBS"
Parse-ErrorMessage -log -MessageId '0x800F081F' -Flags CBS

Write-Host
Write-Warning "Testing WINDOWS UPDATE"
Parse-ErrorMessage -log -MessageId '0x00240007' -Flags UPDATE

Write-Host
Write-Host
Write-Host

Write-Host "Testing *** ALL CASE" -ForegroundColor Green
Write-Host "Mode: No flags" -ForegroundColor Green
Parse-ErrorMessage -log -MessageId 0x80072EE7
write-Host "Mode: -Flags ALL" -ForegroundColor Green
Parse-ErrorMessage -log -MessageId 0x80072EE7 -Flags ALL
write-Host "Mode: -Flags ([ErrorMessageType]::ALL)" -ForegroundColor Green
Parse-ErrorMessage -log -MessageId 0x80072EE7 -Flags ([ErrorMessageType]::ALL)

Write-Host "Testing *** BOR CASE" -ForegroundColor Green
Write-Host "WIN32 -bor HRESULT -bor NTSTATUS" -ForegroundColor Green
Parse-ErrorMessage -log -MessageId 0x00030206 -Flags ([ErrorMessageType]::WIN32 -bor [ErrorMessageType]::NTSTATUS -bor [ErrorMessageType]::HRESULT)
#>
Enum ErrorMessageType {
    ALL         = 0
    WIN32       = 1
    NTSTATUS    = 2
    ACTIVATION  = 4
    NETWORK     = 8
    CBS         = 16
    BITS        = 32
    HTTP        = 64
    UPDATE      = 128
    HRESULT     = 256
    WMI         = 512
    OLE         = 1024
}
function Parse-MessageId {
    param (
        [string] $MessageId
    )
    if ($MessageId -match '^(-?0x[0-9a-fA-F]+).*$') { 
        $MessageId = $matches[1]
        $isNegative = $MessageId.StartsWith('-')
        if ($isNegative) {
            $MessageId = $MessageId.TrimStart('-')
        }
    
        try {

            $hexVal = [Convert]::ToUInt32($MessageId, 16)
            if ($isNegative) { 
                $hexVal = Parse-MessageId -MessageId (-1 * $hexVal)
            }
            $isWin32Err = ($hexVal -band 0x80000000) -ne 0 -and (($hexVal -shr 16) -band 0x0FFF) -eq 7
            if ($isWin32Err){
                return ($hexVal -band 0x0000FFFF)
            }
            else {
                return $hexVal
            }
        }
        catch {
            Write-Warning "Invalid hex value: '$MessageId'. Error: $($_.Exception.Message)"
            return $null
        }
    }
    elseif ($MessageId.StartsWith("0")) {

        if ($MessageId -eq "0") {
            return 0
        }

        $numericPart = ""
        $foundOctalDigits = $false

        for ($i = 1; $i -lt $MessageId.Length; $i++) {
            $char = $MessageId[$i]
            if ($char -ge '0' -and $char -le '7') {
                $numericPart += $char
                $foundOctalDigits = $true
            } else {
                break
            }
        }
        if ($foundOctalDigits) {
            try {
                $decimalValue = [Convert]::ToInt32($numericPart, 8)
                return $decimalValue
            } catch {
                return $null
            }
        }
        elseif ($MessageId.Length -gt 1) {
            return 0
        }

    }
    else {
        $MessageId = $MessageId -replace '^(?<decimal>-?\d+).*$', '${decimal}'
       
        try {
            $uintVal = [uint32]::Parse($MessageId)
            $isWin32Err = ($uintVal -band 0x80000000) -ne 0 -and (($uintVal -shr 16) -band 0x0FFF) -eq 7

            if ($isWin32Err){
                return ($uintVal -band 0x0000FFFF)
            }

            return $uintVal
        }
        catch {
            try {
                $longVal = [long]::Parse($MessageId)
                if ($longVal -lt 0) {
                    $wrappedVal = $longVal + 0x100000000L
                    if ($wrappedVal -ge 0 -and $wrappedVal -le [uint32]::MaxValue) {
                        $unsignedVal = [uint32]$wrappedVal
                        return $unsignedVal
                    } else {
                        return $null
                    }
                }
                elseif ($longVal -gt [uint32]::MaxValue) {
                    return $null
                }
                else {
                    return [uint32]$longVal
                }
            }
            catch {
                if ($MessageId -match '^\d+') {
                    return [long]$matches[0]
                }
                return $null
            }
        }
    }
}
function Parse-ErrorMessage {
    param (
        [Parameter(Mandatory=$false)]
        [ValidateNotNullOrEmpty()]
        [string] $MessageId,

        [Parameter(Mandatory = $false)]
        [ErrorMessageType]$Flags = [ErrorMessageType]::ALL,

        [Parameter(Mandatory=$false)]
        [switch]$Log,

        [Parameter(Mandatory=$false)]
        [switch]$LastWin32Error,

        [Parameter(Mandatory=$false)]
        [switch]$LastNTStatus
    )

    if ($MessageId -and ($LastWin32Error -or $LastNTStatus)) {
        throw "Choice MessageId -or Win32Error\LastNTStatus Only.!"
    }
    
    if ($LastWin32Error -or $LastNTStatus) {
        if ($LastWin32Error -and $LastNTStatus) {
            throw "Choice Win32Error -or LastNTStatus Only.!"
        }

        if($LastWin32Error) {
            # Last win32 error
            $MessageId = [marshal]::ReadInt32((NtCurrentTeb), 0x68)
            $Flags = [ErrorMessageType]::WIN32
        } elseif ($LastNTStatus) {
            # Last NTSTATUS error
            $MessageId = [marshal]::ReadInt32((NtCurrentTeb), 0x1250)
            $Flags = [ErrorMessageType]::NTSTATUS
        }

        
    }
    
    if ($MessageId -eq "0" -or $MessageId -eq "0x0") {
        return "Status OK"
    }

    $MessegeValue = Parse-MessageId -MessageId $MessageId
    if ($null -eq $MessegeValue) {
        Write-Warning "Invalid message ID: $MessageId"
        continue
    }

    $apiList = @()
    if (($Flags -eq $null) -or -not ($Flags -is [ErrorMessageType])) {
        $Flags = [ErrorMessageType]::ALL
    }

    # If ALL is set, expand it to all meaningful flags
    if (($Flags -band [ErrorMessageType]::ALL) -eq [ErrorMessageType]::ALL) {
        $Flags = [ErrorMessageType]::WIN32      -bor `
                 [ErrorMessageType]::NTSTATUS   -bor `
                 [ErrorMessageType]::ACTIVATION -bor `
                 [ErrorMessageType]::NETWORK    -bor `
                 [ErrorMessageType]::CBS        -bor `
                 [ErrorMessageType]::BITS       -bor `
                 [ErrorMessageType]::HTTP       -bor `
                 [ErrorMessageType]::UPDATE     -bor `
                 [ErrorMessageType]::HRESULT    -bor `
                 [ErrorMessageType]::WMI        -bor `
                 [ErrorMessageType]::OLE
    }
    foreach ($Flag in [Enum]::GetValues([ErrorMessageType]) | Where-Object { $_ -ne [ErrorMessageType]::ALL }) {
            $isValueExist = ($Flags -band $flag) -eq $flag
            if ($isValueExist) {
                switch ($flag) {
                    ([ErrorMessageType]::HTTP)         { $apiList += "winhttp.dll" }
                    ([ErrorMessageType]::BITS)         { $apiList += "qmgr.dll" }
                    ([ErrorMessageType]::NETWORK)      { $apiList += "netmsg.dll" }
                    ([ErrorMessageType]::WIN32)        { $apiList += "KernelBase.dll","Kernel32.dll"}  #,"api-ms-win-core-synch-l1-2-0.dll" }
                    ([ErrorMessageType]::HRESULT)      { $apiList += "KernelBase.dll","Kernel32.dll"}  #,"api-ms-win-core-synch-l1-2-0.dll" }
                    ([ErrorMessageType]::NTSTATUS)     { $apiList += "ntdll.dll" }
                    ([ErrorMessageType]::ACTIVATION)   { $apiList += "slc.dll", "sppc.dll"}
                    ([ErrorMessageType]::WMI)          { $apiList += "wmiutils.dll", "wbemcore.dll", "wbemcntl.dll" }
                    ([ErrorMessageType]::OLE)          { $apiList += "MSDAERR.dll" }
                }
            }
    }
    $apiList = $apiList | Sort-Object -Unique

    # Define booleans for the flags of interest
    $IsAll    = (($Flags -band [ErrorMessageType]::ALL)    -eq [ErrorMessageType]::ALL)
    $IsCBS    = (($Flags -band [ErrorMessageType]::CBS)    -eq [ErrorMessageType]::CBS)
    $IsUpdate = (($Flags -band [ErrorMessageType]::UPDATE) -eq [ErrorMessageType]::UPDATE)

    if ($IsAll -or $IsUpdate) {
        if ($Log) {
            Write-Warning "Trying Look In WU ERROR_TABLE"
        }
        $messege = $Global:WU_ERR_TABLE | Where-Object { @(Parse-MessageId $_.ERROR) -eq $MessegeValue } | Select-Object -ExpandProperty MESSEGE
        if ($messege) {
            return $messege
        }
        if ($IsUpdate -and ($Flags -eq [ErrorMessageType]::UPDATE)) {
            return
        }
    }

    if ($IsAll -or $IsCBS) {
        if ($Log) {
            Write-Warning "Trying Look In CBS ERROR_TABLE"
        }
        $messege = $Global:CBS_ERR_TABLE | Where-Object { @(Parse-MessageId $_.ERROR) -eq $MessegeValue } | Select-Object -ExpandProperty MESSEGE
        if ($messege) {
            return $messege
        }
        if ($IsCBS -and ($Flags -eq [ErrorMessageType]::CBS)) {
            return
        }
    }
    foreach ($dll in $apiList) {
        
        if (-not $baseMap.ContainsKey($dll)) {
            if ($Log) {
                Write-Warning "$dll failed to load"
            }
            continue
        }

        $hModule = $baseMap[$dll]
        if ($Log) {
            Write-Warning "$dll loaded at base address: $hModule"
        }

        # Find message resource
        $messageEntryPtr = [IntPtr]::Zero
        $result = $Global:ntdll::RtlFindMessage(
            $hModule, 11, 1024, $MessegeValue, [ref]$messageEntryPtr)
        if ($result -ne 0) {
            # Free Handle returned from LoadLibraryExA
            # $null = $Global:kernel32::FreeLibrary($hModule)
            continue
        }

        # Extract MESSAGE_RESOURCE_ENTRY fields
        $length = [Marshal]::ReadInt16($messageEntryPtr, 0)
        $flags  = [Marshal]::ReadInt16($messageEntryPtr, 2)
        $textPtr = [IntPtr]::Add($messageEntryPtr, 4)

        try {
            # Decode string (Unicode or ANSI)
            if (($flags -band 0x0001) -ne 0) {
                $charCount = ($length - 4) / 2
                return [Marshal]::PtrToStringUni($textPtr, $charCount)
            } else {
                $charCount = $length - 4
                return [Marshal]::PtrToStringAnsi($textPtr, $charCount)
            }
        }
        catch {
        }
        finally {
            # Free Handle returned from LoadLibraryExA
            # $null = $Global:kernel32::FreeLibrary($hModule)
        }
    }
}

<#
ntstatus.h
https://www.cnblogs.com/george-cw/p/12613148.html
https://codemachine.com/downloads/win71/ntstatus.h
https://github.com/danmar/clang-headers/blob/master/ntstatus.h
https://home.cs.colorado.edu/~main/cs1300-old/include/ddk/ntstatus.h
https://searchfox.org/mozilla-central/source/third_party/rust/winapi/src/shared/ntstatus.rs
2.3 NTSTATUS
https://learn.microsoft.com/en-us/openspecs/windows_protocols/ms-erref/87fba13e-bf06-450e-83b1-9241dc81e781

//
//  Values are 32 bit values layed out as follows:
//
//   3 3 2 2 2 2 2 2 2 2 2 2 1 1 1 1 1 1 1 1 1 1
//   1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0
//  +---+-+-+-----------------------+-------------------------------+
//  |Sev|C|R|     Facility          |               Code            |
//  +---+-+-+-----------------------+-------------------------------+
//
//  where
//
//      Sev - is the severity code
//
//          00 - Success
//          01 - Informational
//          10 - Warning
//          11 - Error
//
//      C - is the Customer code flag
//
//      R - is a reserved bit
//
//      Facility - is the facility code
//
//      Code - is the facility's status code
//

winerror.h
https://doxygen.reactos.org/d4/ded/winerror_8h_source.html

//
//  HRESULTs are 32 bit values layed out as follows:
//
//   3 3 2 2 2 2 2 2 2 2 2 2 1 1 1 1 1 1 1 1 1 1
//   1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0
//  +-+-+-+-+-+---------------------+-------------------------------+
//  |S|R|C|N|r|    Facility         |               Code            |
//  +-+-+-+-+-+---------------------+-------------------------------+
//
//  where
//
//      S - Severity - indicates success/fail
//
//          0 - Success
//          1 - Fail (COERROR)
//
//      R - reserved portion of the facility code, corresponds to NT's
//              second severity bit.
//
//      C - reserved portion of the facility code, corresponds to NT's
//              C field.
//
//      N - reserved portion of the facility code. Used to indicate a
//              mapped NT status value.
//
//      r - reserved portion of the facility code. Reserved for internal
//              use. Used to indicate HRESULT values that are not status
//              values, but are instead message ids for display strings.
//
//      Facility - is the facility code
//
//      Code - is the facility's status code
//

Facility Codes
5 Appendix A: Product Behavior
https://learn.microsoft.com/en-us/openspecs/windows_protocols/ms-erref/1714a7aa-8e53-4076-8f8d-75073b780a41
2.1 HRESULT
https://learn.microsoft.com/en-us/openspecs/windows_protocols/ms-erref/0642cb2f-2075-4469-918c-4441e69c548a

Error Codes: Win32 vs. HRESULT vs. NTSTATUS
https://jpassing.com/2007/08/20/error-codes-win32-vs-hresult-vs-ntstatus/
HRESULT_FACILITY macro (winerror.h)
https://learn.microsoft.com/en-us/windows/win32/api/winerror/nf-winerror-hresult_facility
HRESULT_FROM_NT macro (winerror.h)
https://learn.microsoft.com/en-us/windows/win32/api/winerror/nf-winerror-hresult_from_nt
HRESULT_FROM_WIN32 macro (winerror.h)
https://learn.microsoft.com/en-us/windows/win32/api/winerror/nf-winerror-hresult_from_win32
2.1.2 HRESULT From WIN32 Error Code Macro
https://learn.microsoft.com/en-us/openspecs/windows_protocols/ms-erref/0c0bcf55-277e-4120-b5dc-f6115fc8dc38

-------------------------------------------------

Clear-Host
Write-Host

Write-Warning "Check ERROR_NOT_SAME_DEVICE WIN32 -> 0x00000011L"
Parse-ErrorFacility -Log $true -HResult 0x00000011L

Write-Warning "Check ERROR_HANDLE_DISK_FULL WIN32 -> 0x00000027L"
Parse-ErrorFacility -Log $true -HResult 0x00000027L

Write-Warning "Check CONVERT10_S_NO_PRESENTATION HRESULTS -> 0x000401C0L"
Parse-ErrorFacility -Log $true -HResult 0x000401C0L

Write-Warning "Check MK_S_ME HRESULTS -> 0x000401E4L"
Parse-ErrorFacility -Log $true -HResult 0x000401E4L

Write-Warning "Check STATUS_SERVICE_NOTIFICATION NTSTATUS -> 0x40000018L"
Parse-ErrorFacility -Log $true -HResult 0x40000018L

Write-Warning "Check STATUS_BAD_STACK NTSTATUS -> 0xC0000028L"
Parse-ErrorFacility -Log $true -HResult 0xC0000028L

Write-Warning "Check STATUS_NDIS_INDICATION_REQUIRED NTSTATUS -> 0x40230001L"
Parse-ErrorFacility -Log $true -HResult 0x40230001L

Write-Warning "Check WU -> 0x00242015"
Parse-ErrorFacility -Log $true -HResult 0x00242015

Write-Warning "Check CBS -> 2148469005 "
Parse-ErrorFacility -Log $true -HResult 2148469005
#>
enum HRESULT_Facility {
    FACILITY_NULL                             = 0x0         # General (no specific source)
    FACILITY_RPC                              = 0x1         # Remote Procedure Call
    FACILITY_DISPATCH                         = 0x2         # COM Dispatch
    FACILITY_STORAGE                          = 0x3         # Storage
    FACILITY_ITF                              = 0x4         # Interface-specific
    FACILITY_WIN32                            = 0x7         # Standard Win32 errors
    FACILITY_WINDOWS                          = 0x8         # Windows system component
    FACILITY_SECURITY                         = 0x9         # Security subsystem
    FACILITY_SSPI                             = 0x9         # Security Support Provider Interface
    FACILITY_CONTROL                          = 0xA         # Control
    FACILITY_CERT                             = 0xB         # Certificate services
    FACILITY_INTERNET                         = 0xC         # Internet-related
    FACILITY_MEDIASERVER                      = 0xD         # Media server
    FACILITY_MSMQ                             = 0xE         # Microsoft Message Queue
    FACILITY_SETUPAPI                         = 0xF         # Setup API
    FACILITY_SCARD                            = 0x10        # Smart card subsystem
    FACILITY_COMPLUS                          = 0x11        # COM+ services
    FACILITY_AAF                              = 0x12        # Advanced Authoring Format
    FACILITY_URT                              = 0x13        # .NET runtime
    FACILITY_ACS                              = 0x14        # Access Control Services
    FACILITY_DPLAY                            = 0x15        # DirectPlay
    FACILITY_UMI                              = 0x16        # UMI (Universal Management Infrastructure)
    FACILITY_SXS                              = 0x17        # Side-by-Side (Assembly)
    FACILITY_WINDOWS_CE                       = 0x18        # Windows CE
    FACILITY_HTTP                             = 0x19        # HTTP services
    FACILITY_USERMODE_COMMONLOG               = 0x1A        # Common Logging
    FACILITY_WER                              = 0x1B        # Windows Error Reporting
    FACILITY_USERMODE_FILTER_MANAGER          = 0x1F        # File system filter manager
    FACILITY_BACKGROUNDCOPY                   = 0x20        # Background Intelligent Transfer Service (BITS)
    FACILITY_CONFIGURATION                    = 0x21        # Configuration
    FACILITY_WIA                              = 0x21        # Windows Image Acquisition
    FACILITY_STATE_MANAGEMENT                 = 0x22        # State management services
    FACILITY_METADIRECTORY                    = 0x23        # Meta-directory services
    FACILITY_WINDOWSUPDATE                    = 0x24        # Windows Update
    FACILITY_DIRECTORYSERVICE                 = 0x25        # Directory services (e.g., Active Directory)
    FACILITY_GRAPHICS                         = 0x26        # Graphics subsystem
    FACILITY_NAP                              = 0x27        # Network Access Protection
    FACILITY_SHELL                            = 0x27        # Windows Shell
    FACILITY_TPM_SERVICES                     = 0x28        # Trusted Platform Module services
    FACILITY_TPM_SOFTWARE                     = 0x29        # TPM software stack
    FACILITY_UI                               = 0x2A        # User Interface
    FACILITY_XAML                             = 0x2B        # XAML parser
    FACILITY_ACTION_QUEUE                     = 0x2C        # Action queue
    FACILITY_PLA                              = 0x30        # Performance Logs and Alerts
    FACILITY_WINDOWS_SETUP                    = 0x30        # Windows Setup
    FACILITY_FVE                              = 0x31        # Full Volume Encryption (BitLocker)
    FACILITY_FWP                              = 0x32        # Windows Filtering Platform
    FACILITY_WINRM                            = 0x33        # Windows Remote Management
    FACILITY_NDIS                             = 0x34        # Network Driver Interface Specification
    FACILITY_USERMODE_HYPERVISOR              = 0x35        # User-mode Hypervisor
    FACILITY_CMI                              = 0x36        # Configuration Management Infrastructure
    FACILITY_USERMODE_VIRTUALIZATION          = 0x37        # User-mode virtualization
    FACILITY_USERMODE_VOLMGR                  = 0x38        # Volume Manager
    FACILITY_BCD                              = 0x39        # Boot Configuration Data
    FACILITY_USERMODE_VHD                     = 0x3A        # Virtual Hard Disk
    FACILITY_SDIAG                            = 0x3C        # System Diagnostics
    FACILITY_WEBSERVICES                      = 0x3D        # Web Services
    FACILITY_WINPE                            = 0x3D        # Windows Preinstallation Environment
    FACILITY_WPN                              = 0x3E        # Windows Push Notification
    FACILITY_WINDOWS_STORE                    = 0x3F        # Windows Store
    FACILITY_INPUT                            = 0x40        # Input subsystem
    FACILITY_EAP                              = 0x42        # Extensible Authentication Protocol
    FACILITY_WINDOWS_DEFENDER                 = 0x50        # Windows Defender
    FACILITY_OPC                              = 0x51        # OPC (Open Packaging Conventions)
    FACILITY_XPS                              = 0x52        # XML Paper Specification
    FACILITY_RAS                              = 0x53        # Remote Access Service
    FACILITY_MBN                              = 0x54        # Mobile Broadband
    FACILITY_POWERSHELL                       = 0x54        # PowerShell
    FACILITY_EAS                              = 0x55        # Exchange ActiveSync
    FACILITY_P2P_INT                          = 0x62        # Peer-to-Peer internal
    FACILITY_P2P                              = 0x63        # Peer-to-Peer
    FACILITY_DAF                              = 0x64        # Device Association Framework
    FACILITY_BLUETOOTH_ATT                    = 0x65        # Bluetooth Attribute Protocol
    FACILITY_AUDIO                            = 0x66        # Audio subsystem
    FACILITY_VISUALCPP                        = 0x6D        # Visual C++ runtime
    FACILITY_SCRIPT                           = 0x70        # Scripting engine
    FACILITY_PARSE                            = 0x71        # Parsing engine
    FACILITY_BLB                              = 0x78        # Backup/Restore infrastructure
    FACILITY_BLB_CLI                          = 0x79        # Backup/Restore client
    FACILITY_WSBAPP                           = 0x7A        # Windows Server Backup Application
    FACILITY_BLBUI                            = 0x80        # Backup UI
    FACILITY_USN                              = 0x81        # Update Sequence Number Journal
    FACILITY_USERMODE_VOLSNAP                 = 0x82        # Volume Snapshot Service
    FACILITY_TIERING                          = 0x83        # Storage Tiering
    FACILITY_WSB_ONLINE                       = 0x85        # Windows Server Backup Online
    FACILITY_ONLINE_ID                        = 0x86        # Windows Live ID
    FACILITY_DLS                              = 0x99        # Downloadable Sound (DLS)
    FACILITY_SOS                              = 0xA0        # SOS debugging
    FACILITY_DEBUGGERS                        = 0xB0        # Debuggers
    FACILITY_USERMODE_SPACES                  = 0xE7        # Storage Spaces (user-mode)
    FACILITY_DMSERVER                         = 0x100       # Digital Media Server
    FACILITY_RESTORE                          = 0x100       # System Restore
    FACILITY_SPP                              = 0x100       # Software Protection Platform
    FACILITY_DEPLOYMENT_SERVICES_SERVER       = 0x101       # Windows Deployment Server
    FACILITY_DEPLOYMENT_SERVICES_IMAGING      = 0x102       # Imaging services
    FACILITY_DEPLOYMENT_SERVICES_MANAGEMENT   = 0x103       # Deployment management
    FACILITY_DEPLOYMENT_SERVICES_UTIL         = 0x104       # Deployment utilities
    FACILITY_DEPLOYMENT_SERVICES_BINLSVC      = 0x105       # BINL service
    FACILITY_DEPLOYMENT_SERVICES_PXE          = 0x107       # PXE boot service
    FACILITY_DEPLOYMENT_SERVICES_TFTP         = 0x108       # Trivial File Transfer Protocol
    FACILITY_DEPLOYMENT_SERVICES_TRANSPORT_MANAGEMENT = 0x110 # Transport management
    FACILITY_DEPLOYMENT_SERVICES_DRIVER_PROVISIONING = 0x116 # Driver provisioning
    FACILITY_DEPLOYMENT_SERVICES_MULTICAST_SERVER = 0x121     # Multicast server
    FACILITY_DEPLOYMENT_SERVICES_MULTICAST_CLIENT = 0x122     # Multicast client
    FACILITY_DEPLOYMENT_SERVICES_CONTENT_PROVIDER = 0x125     # Content provider
    FACILITY_LINGUISTIC_SERVICES              = 0x131       # Linguistic analysis services
    FACILITY_WEB                              = 0x375       # Web Platform
    FACILITY_WEB_SOCKET                       = 0x376       # WebSockets
    FACILITY_AUDIOSTREAMING                   = 0x446       # Audio streaming
    FACILITY_ACCELERATOR                      = 0x600       # Hardware acceleration
    FACILITY_MOBILE                           = 0x701       # Windows Mobile
    FACILITY_WMAAECMA                         = 0x7CC       # Audio echo cancellation
    FACILITY_WEP                              = 0x801       # Windows Enforcement Platform
    FACILITY_SYNCENGINE                       = 0x802       # Sync engine
    FACILITY_DIRECTMUSIC                      = 0x878       # DirectMusic
    FACILITY_DIRECT3D10                       = 0x879       # Direct3D 10
    FACILITY_DXGI                             = 0x87A       # DirectX Graphics Infrastructure
    FACILITY_DXGI_DDI                         = 0x87B       # DXGI Device Driver Interface
    FACILITY_DIRECT3D11                       = 0x87C       # Direct3D 11
    FACILITY_LEAP                             = 0x888       # Leap Motion (or similar input)
    FACILITY_AUDCLNT                          = 0x889       # Audio client
    FACILITY_WINCODEC_DWRITE_DWM              = 0x898       # Imaging, DirectWrite, DWM
    FACILITY_DIRECT2D                         = 0x899       # Direct2D graphics
    FACILITY_DEFRAG                           = 0x900       # Defragmentation
    FACILITY_USERMODE_SDBUS                   = 0x901       # Secure Digital bus (user-mode)
    FACILITY_JSCRIPT                          = 0x902       # JScript engine
    FACILITY_PIDGENX                          = 0xA01       # Product ID Generator (extended)
    FACILITY_UNKNOWN                          = 0xFFF       # Unknown facility
}
enum NTSTATUS_FACILITY {
    FACILITY_DEBUGGER             = 0x1
    FACILITY_RPC_RUNTIME          = 0x2
    FACILITY_RPC_STUBS            = 0x3
    FACILITY_IO_ERROR_CODE        = 0x4
    FACILITY_CODCLASS_ERROR_CODE  = 0x6
    FACILITY_NTWIN32              = 0x7
    FACILITY_NTCERT               = 0x8
    FACILITY_NTSSPI               = 0x9
    FACILITY_TERMINAL_SERVER      = 0xA
    FACILITY_MUI_ERROR_CODE       = 0xB
    FACILITY_USB_ERROR_CODE       = 0x10
    FACILITY_HID_ERROR_CODE       = 0x11
    FACILITY_FIREWIRE_ERROR_CODE  = 0x12
    FACILITY_CLUSTER_ERROR_CODE   = 0x13
    FACILITY_ACPI_ERROR_CODE      = 0x14
    FACILITY_SXS_ERROR_CODE       = 0x15
    FACILITY_TRANSACTION          = 0x19
    FACILITY_COMMONLOG            = 0x1A
    FACILITY_VIDEO                = 0x1B
    FACILITY_FILTER_MANAGER       = 0x1C
    FACILITY_MONITOR              = 0x1D
    FACILITY_GRAPHICS_KERNEL      = 0x1E
    FACILITY_DRIVER_FRAMEWORK     = 0x20
    FACILITY_FVE_ERROR_CODE       = 0x21
    FACILITY_FWP_ERROR_CODE       = 0x22
    FACILITY_NDIS_ERROR_CODE      = 0x23
    FACILITY_TPM                  = 0x29
    FACILITY_RTPM                 = 0x2A
    FACILITY_HYPERVISOR           = 0x35
    FACILITY_IPSEC                = 0x36
    FACILITY_VIRTUALIZATION       = 0x37
    FACILITY_VOLMGR               = 0x38
    FACILITY_BCD_ERROR_CODE       = 0x39
    FACILITY_WIN32K_NTUSER        = 0x3E
    FACILITY_WIN32K_NTGDI         = 0x3F
    FACILITY_RESUME_KEY_FILTER    = 0x40
    FACILITY_RDBSS                = 0x41
    FACILITY_BTH_ATT              = 0x42
    FACILITY_SECUREBOOT           = 0x43
    FACILITY_AUDIO_KERNEL         = 0x44
    FACILITY_VSM                  = 0x45
    FACILITY_VOLSNAP              = 0x50
    FACILITY_SDBUS                = 0x51
    FACILITY_SHARED_VHDX          = 0x5C
    FACILITY_SMB                  = 0x5D
    FACILITY_INTERIX              = 0x99
    FACILITY_SPACES               = 0xE7
    FACILITY_SECURITY_CORE        = 0xE8
    FACILITY_SYSTEM_INTEGRITY     = 0xE9
    FACILITY_LICENSING            = 0xEA
    FACILITY_PLATFORM_MANIFEST    = 0xEB
    FACILITY_APP_EXEC             = 0xEC
    FACILITY_MAXIMUM_VALUE        = 0xED
    FACILITY_UNKNOWN              = 0xFFFF
    FACILITY_NT_BIT               = 0x10000000
}
function Parse-ErrorFacility {
    [CmdletBinding()]
    param (
        [Parameter(Mandatory = $true)]
        [string]$HResult,

        [Parameter(Mandatory = $false)]
        [bool]$Log = $false
    )

    # Define a helper to check if $ntFacility is valid enum member
    function Is-ValidNTFacility {
        param($facility)
        try {
            [NTSTATUS_FACILITY]$facility | Out-Null
            return $true
        } catch {
            return $false
        }
    }
    # Convert input string to integer HRESULT (hex or decimal)
    $HResultDecimal = [uint32](Parse-MessageId $HResult)
    if ($log) {
        Write-Warning "HResultDecimal is $HResultDecimal"
        Write-Warning ("HResultDecimal (hex): 0x{0:X8}" -f $HResultDecimal)
        Write-Warning ("HResultDecimal (type): {0}" -f $HResultDecimal.GetType().Name)            
    }
    if ($null -eq $HResultDecimal -or $HResultDecimal -eq '') {
        if ($Log) { Write-Warning "Failed to parse HResult input." }
        return [HRESULT_Facility]::UNKNOWN_FACILITY
    }

    # 2. If less than 0x10000, treat as Win32 error and convert to HRESULT
    if ($HResultDecimal -lt 0x10000) {
        if ($Log) { Write-Warning "Input is a Win32 error code. Converting to HRESULT." }
        $HResultDecimal = ($HResultDecimal -band 0xFFFF) -bor 0x80070000
        if ($Log) { Write-Warning ("Converted HRESULT: 0x{0:X8}" -f $HResultDecimal) }
    }

    # 3. Extract facility using official HRESULT_FACILITY macro (bits 16-28, 13 bits)
    $facility13 = ($HResultDecimal -shr 16) -band 0x1FFF
    if ($Log) { Write-Warning ("[13-bit mask] FacilityValue = $facility13") }
    try {
        if ($facility13 -ne 0) { return [HRESULT_Facility]$facility13 }
    } catch {}

    # Fallbacks to smaller masks for legacy compatibility
    $facility12 = ($HResultDecimal -shr 16) -band 0xFFF
    if ($Log) { Write-Warning ("[12-bit mask] FacilityValue = $facility12") }
    try {
        if ($facility12 -ne 0) { return [HRESULT_Facility]$facility12 }
    } catch {}

    $facility11 = ($HResultDecimal -shr 16) -band 0x7FF
    if ($Log) { Write-Warning ("[11-bit mask] FacilityValue = $facility11") }
    try {
        if ($facility11 -ne 0) { return [HRESULT_Facility]$facility11 }
    } catch {}

    # N (1 bit): If set, indicates that the error code is an NTSTATUS value
    # R (1 bit): Reserved. If the N bit is set, this bit is defined by the NTSTATUS numbering space
    # #define HRESULT_FROM_NT(x)      ((HRESULT) ((x) | FACILITY_NT_BIT))
    $Is_N_BIT = ($HResultDecimal -band 0x10000000) -ne 0  # bit 28
    $Is_R_BIT = ($HResultDecimal -band 0x40000000) -ne 0  # bit 30

    if ($log) {
        Write-Warning "Is_N_BIT = $Is_N_BIT"
        Write-Warning "Is_R_BIT = $Is_R_BIT"
    }
    if ($Is_N_BIT -or $Is_R_BIT) {
        
        $Severity = ($HResultDecimal -shr 30) -band 0x3
        $ntFacility = ($HResultDecimal -shr 16) -band 0xFFF  # 12-bit mask
        $SeverityLabel = @('SUCCESS', 'INFORMATIONAL', 'WARNING', 'ERROR')[$Severity]
        if ($Log) { Write-Warning "[NTSTATUS detected with $SeverityLabel severity] FacilityValue = $ntFacility" }

        # Special case: NTSTATUS_FROM_WIN32 (0xC007xxxx)
        if (($HResultDecimal -band 0xFFFF0000) -eq 0xC0070000) {
            $win32Code = $HResultDecimal -band 0xFFFF
            if ($Log) {
                Write-Warning "NTSTATUS_FROM_WIN32 detected. Original Win32 error code: 0x{0:X}" -f $win32Code
                Write-Warning "[Facility = NTWIN32 (7)]"
            }
            return [NTSTATUS_FACILITY]::FACILITY_NTWIN32
        }

        $win32ERR = 0
        $win32ERR = $Global:ntdll::RtlNtStatusToDosError($HResultDecimal)
        if ($log) {
            Write-Warning "RtlNtStatusToDosError return $win32ERR"
        }

        if (($win32ERR -notin (0, 317)) -and -not (Is-ValidNTFacility $ntFacility)) {
            # NTSTATUS facility invalid or unknown, try Win32 facility fallback
            try {
                if ($log) {
                    Write-Warning "Redirct error with win32ERR value"
                }
                return Parse-ErrorFacility -HResult $win32ERR
            }
            catch {
                if ($log) {
                    Write-Warning "Return FACILITY_UNKNOWN"
                }
                return [NTSTATUS_FACILITY]::FACILITY_UNKNOWN
            }
        }
        else {
            # Return the NTSTATUS facility (including facility 0)
            try {
                if ($log) {
                    Write-Warning "Parse ntFacility"
                }
                return [NTSTATUS_FACILITY]$ntFacility
            }
            catch {
                if ($log) {
                    Write-Warning "Return FACILITY_UNKNOWN"
                }
                return [NTSTATUS_FACILITY]::FACILITY_UNKNOWN
            }
        }
    }

    if ($facility13 -eq 0 -and $facility12 -eq 0 -and $facility11 -eq 0) {
        return [HRESULT_Facility]::FACILITY_NULL
    }

    return [HRESULT_Facility]::FACILITY_UNKNOWN
}

<#
.SYNOPSIS

* Function Bor
combine multiple Flags, with ease

* Function Get-EnumFlags
An Helper, to Extract Flags, Usage Example:
Get-EnumFlags -EnumType ([CallingConventions]) -Value 33
Get-EnumFlags -EnumType ([MethodAttributes]) -Value 1478
#>
Function Bor {
    param ([int[]] $Array) 
    $ret = $Array[0]
    foreach ($item in $Array) {
        $ret = $ret -bor $item
    }
    return [Int32]$ret
}
function Get-EnumFlags {
    [CmdletBinding()]
    param(
        [Parameter(Mandatory)]
        [Type] $EnumType,

        [Parameter(Mandatory)]
        $Value
    )

    # Convert to numeric
    $numericValue = if ($Value -is $EnumType) {
        [int]$Value
    } else {
        [int]$Value
    }

    # Correctly call static methods on a [Type] object
    $names = [Enum]::GetNames($EnumType)

    foreach ($name in $names) {
        $enumValue = [int]([Enum]::Parse($EnumType, $name))
        if (($numericValue -band $enumValue) -eq $enumValue) {
            [PSCustomObject]@{
                Name  = $name
                Value = $enumValue
            }
        }
    }
}

# WIN32 API Parts
function Dump-MemoryAddress {
    param (
        [Parameter(Mandatory)]
        [IntPtr] $Pointer, 

        [Parameter(Mandatory)]
        [UInt32] $Length,

        [string] $FileName = "memdump.bin"
    )

    $desktop = [Environment]::GetFolderPath('Desktop')
    $outputPath = Join-Path $desktop $FileName

    try {
        # Allocate managed buffer
        $buffer = New-Object byte[] $Length

        # Perform memory copy
        [Marshal]::Copy(
            $Pointer, # Source pointer
            $buffer,                 # Destination array
            0,                       # Start index
            $Length                  # Number of bytes
        )

        # Write to file
        [System.IO.File]::WriteAllBytes($outputPath, $buffer)

        Write-Host "Memory dumped to: $outputPath"
    } catch {
        Write-Error "Failed to dump memory: $_"
    }
}
function New-IntPtr {
    param(
        [Parameter(Mandatory=$false)]
        [int]$Size,

        [Parameter(Mandatory=$false)]
        [int]$InitialValue = 0,

        [Parameter(Mandatory=$false)]
        [IntPtr]$hHandle,

        [Parameter(Mandatory=$false)]
        [byte[]]$Data,

        [Parameter(Mandatory=$false)]
        [switch]$UsePointerSize,

        [switch]$MakeRefType,
        [switch]$WriteSizeAtZero,
        [switch]$Release
    )

    if ($hHandle -or $Release -or $MakeRefType) {
        if ($Size) {
            throw [System.ArgumentException] "Size option can't go with hHandle, Release or MakeRefType"
        }
        if ($MakeRefType -and $Release) {
            throw [System.ArgumentException] "Cannot specify both MakeRefType and Release"
        }
        if (!$hHandle -or (!$Release -and !$MakeRefType)) {
            throw [System.ArgumentException] "hHandle must be provided with either Release or MakeRefType"
        }
    }

    if ($MakeRefType) {
        $handlePtr = [Marshal]::AllocHGlobal([IntPtr]::Size)
        [Marshal]::WriteIntPtr($handlePtr, $hHandle)
        return $handlePtr
    }

    if ($Release) {
        if ($hHandle -and $hHandle -ne [IntPtr]::Zero) {
            [Marshal]::FreeHGlobal($hHandle)
        }
        return
    }

    if ($Data) {
        $Size = $Data.Length
        $ptr = [Marshal]::AllocHGlobal($Size)
        [Marshal]::Copy($Data, 0, $ptr, $Size)
        return $ptr
    }

    if ($Size -le 0) {
        throw [ArgumentException]::new("Size must be a positive non-zero integer.")
    }
    $ptr = [Marshal]::AllocHGlobal($Size)
    $Global:ntdll::RtlZeroMemory($ptr, [UIntPtr]::new($Size))
    if ($WriteSizeAtZero) {
        if ($UsePointerSize) {
            [Marshal]::WriteIntPtr($ptr, 0, [IntPtr]::new($Size))
        }
        else {
            [Marshal]::WriteInt32($ptr, 0, $Size)
        }
    }
    elseif (($Size -ge 4) -and ($InitialValue -ne 0)) {
        if ($UsePointerSize) {
            [Marshal]::WriteIntPtr($ptr, 0, [IntPtr]::new($InitialValue))
        }
        else {
            [Marshal]::WriteInt32($ptr, 0, $InitialValue)
        }
    }

    return $ptr
}
function IsValid-IntPtr {
    param (
        [Parameter(Mandatory = $false)]
        [Object]$handle
    )

    if ($null -eq $handle) {
        return $false
    }

    if ($handle -is [IntPtr]) {
        return ($handle -ne [IntPtr]::Zero)
    }

    if ($handle -is [UIntPtr]) {
        return ($handle -ne [UIntPtr]::Zero)
    }

    if ($handle -is [ValueType]) {
        $tname = $handle.GetType().Name
        if ($tname -in @('SByte','Byte','Int16','UInt16','Int32','UInt32','Int64','UInt64')) {
            if ([IntPtr]::Size -eq 4) {
                # x86: cast to Int32 first
                $val = [int32]$handle
                return ([IntPtr]$val -ne [IntPtr]::Zero)
            }
            else {
                # x64: cast to Int64
                $val = [int64]$handle
                return ([IntPtr]$val -ne [IntPtr]::Zero)
            }
        }
    }

    return $false
}
function Free-IntPtr {
    param (
        [Parameter(Mandatory=$false)]
        [Object]$handle,

        [ValidateSet(
            "HGlobal", "Handle", "NtHandle",
            "ServiceHandle", "Heap", "STRING",
            "UNICODE_STRING", "BSTR", "VARIANT",
            "Local", "Auto", "Desktop", "WindowStation",
            "License", "LSA")]
        [string]$Method = "HGlobal"
    )
    $IsValidPointer = IsValid-IntPtr $handle
    if (!$IsValidPointer) {
        return
    }

    try {
        $Module = [AppDomain]::CurrentDomain.GetAssemblies()| ? { $_.ManifestModule.ScopeName -eq "WIN32U" } | select -Last 1
        $WIN32U = $Module.GetTypes()[0]
    }
    catch {
        $Module = [AppDomain]::CurrentDomain.DefineDynamicAssembly("null", 1).DefineDynamicModule("WIN32U", $False).DefineType("null")
        @(
            @('null', 'null', [int], @()), # place holder
            @('NtUserCloseDesktop',       'win32U.dll', [Int], @([IntPtr])),
            @('NtUserCloseWindowStation', 'win32U.dll', [Int], @([IntPtr])),
            @('LsaClose', 'advapi32.dll', [Int], @([IntPtr]))
        ) | % {
            $Module.DefinePInvokeMethod(($_[0]), ($_[1]), 22, 1, [Type]($_[2]), [Type[]]($_[3]), 1, 3).SetImplementationFlags(128) # Def` 128, fail-safe 0 
        }
        $WIN32U = $Module.CreateType()
    }

    [IntPtr]$ptrToFree = $handle
    #Write-Warning "Free $handle -> $Method"

    switch ($Method) {
        "HGlobal" {
            [Marshal]::FreeHGlobal($ptrToFree)
        }
        "Handle" {
            $null = $Global:kernel32::CloseHandle($ptrToFree)
        }
        "NtHandle" {
            $null = $Global:ntdll::NtClose($ptrToFree)
        }
        "ServiceHandle" {
            $null = $Global:advapi32::CloseServiceHandle($ptrToFree)
        }
        "BSTR" {
            $null = [Marshal]::FreeBSTR($ptrToFree)
        }
        "Heap" {
            $null = $Global:ntdll::RtlFreeHeap(
                ((NtCurrentTeb -ProcessHeap)), 0, $ptrToFree)
        }
        "Local" {
            $null = $Global:kernel32::LocalFree($ptrToFree)
        }
        "STRING" {
            $null = Free-NativeString -StringPtr $ptrToFree
        }
        "UNICODE_STRING" {
            $null = Free-NativeString -StringPtr $ptrToFree
        }
        "VARIANT" {
            $null = Free-Variant -variantPtr $ptrToFree
        }
        "Desktop" {
            $null = $WIN32U::NtUserCloseDesktop($ptrToFree)
        }
        "WindowStation" {
            $null = $WIN32U::NtUserCloseWindowStation($ptrToFree)
        }
        "License" {
            $null = $Global:SLC::SLClose($ptrToFree)
        }
        "LSA" {
            $null = $WIN32U::LsaClose($ptrToFree)
        }

        <#
        ## Disabled, use heap instead
        "Process_Parameter" {
           #$global:ntdll::RtlDestroyEnvironment($ptrToFree)
            $global:ntdll::RtlDestroyProcessParameters($ptrToFree)
        }
        #>

        "Auto" {
            # Best effort guess based on pointer value (basic heuristics)
            # Could be expanded if needed
            try {
                [Marshal]::FreeHGlobal($ptrToFree)
            } catch {
                $null = $Global:kernel32::CloseHandle($ptrToFree)
            }
        }
        default {
                Write-Warning "Unknown freeing method specified: $Method. Attempting HGlobal."
                [Marshal]::FreeHGlobal($ptrToFree)
        }
    }
    if ($handle.Value) {
        $handle.Value = 0
    }
    $handle = $null
    $ptrToFree = 0
}

# DLL Loader
function Register-NativeMethods {
    param (
        [Parameter(Mandatory)]
        [Array]$FunctionList,

        # Global defaults
        $NativeCallConv      = [CallingConvention]::Winapi,
        $NativeCharSet       = [CharSet]::Unicode,
        $ImplAttributes      = [MethodImplAttributes]::PreserveSig,
        $TypeAttributes      = [TypeAttributes]::Public -bor [TypeAttributes]::Abstract -bor [TypeAttributes]::Sealed,
        $Attributes          = [MethodAttributes]::Public -bor [MethodAttributes]::Static -bor [MethodAttributes]::PinvokeImpl,
        $CallingConventions  = [CallingConventions]::Standard
    )

    # Dynamic assembly + module
    $asmName = New-Object System.Reflection.AssemblyName "DynamicDllHelperAssembly"
    $asm     = [AppDomain]::CurrentDomain.DefineDynamicAssembly($asmName, [AssemblyBuilderAccess]::Run)
    $mod     = $asm.DefineDynamicModule("DynamicDllHelperModule")
    $tb      = $mod.DefineType("NativeMethods", $TypeAttributes)

    foreach ($func in $FunctionList) {
        # Per-function overrides
        $funcCharSet = if ($func.ContainsKey("CharSet")) { 
            [System.Runtime.InteropServices.CharSet]::$($func.CharSet) 
        } else { 
            $NativeCharSet 
        }

        $funcCallConv = if ($func.ContainsKey("CallConv")) { 
            $func.CallConv 
        } else { 
            $NativeCallConv 
        }

        $tb.DefinePInvokeMethod(
            $func.Name,
            $func.Dll,
            $Attributes,
            $CallingConventions,
            $func.ReturnType,
            $func.Parameters,
            $funcCallConv,
            $funcCharSet
        ).SetImplementationFlags($ImplAttributes)
    }

    return $tb.CreateType()
}
Function Init-CLIPC {

    $functions = @(
        @{ Name = "ClipGetSubscriptionStatus";  Dll = "clipc.dll"; ReturnType = [uint32]; Parameters = [Type[]]@([IntPtr].MakeByRefType(),[IntPtr],[IntPtr],[IntPtr]) }
    )
    return Register-NativeMethods $functions
}
Function Init-SLC {
    
    <#
    .SYNOPSIS

    Should be called from -> Slc.dll
    but work from sppc.dll, osppc.dll
    maybe Slc.dll call sppc.dll -or osppc.dll

    Windows 10 DLL File Information - sppc.dll
    https://windows10dll.nirsoft.net/sppc_dll.html

    List of files that are statically linked to sppc.dll, 
    slc.dll, etc, etc, 
    This means that when one of the above files is loaded, 
    sppc.dll will be loaded too.
    (The opposite of the previous 'Static Linking' section)

    "OSPPC.dll" is a dynamic link library (DLL) file,
    that is a core component of Microsoft Office's Software Protection Platform.
    Essentially, it's involved in the licensing and activation of your Microsoft Office products.
    can be found under windows 7 ~ Vista, For older MSI version

    SLIsGenuineLocal, SLGetLicensingStatusInformation, SLGetWindowsInformation, SLGetWindowsInformationDWORD -> 
    is likely --> ZwQueryLicenseValue with: (Security-SPP-Action-StateData, Security-SPP-LastWindowsActivationHResult, etc)
    So, instead, use Get-ProductPolicy instead, to enum all value's

    >>> SLIsGenuineLocal function (slpublic.h)
    This function checks the **Tampered flag** of the license associated with the specified application. If the license is not valid, 
    or if the Tampered flag of the license is set, the installation is not considered valid. 

    >>> https://www.geoffchappell.com/studies/windows/km/ntoskrnl/api/ex/slmem/queryvalue.htm
    If the license has been **tampered with**, the function fails (returning STATUS_INTERNAL_ERROR). 
    If the licensing cache is corrupt, the function fails (returning STATUS_DATA_ERROR). 
    If there are no licensing descriptors but the kernel thinks it has the licensing descriptors sorted, 
    the function fails (returning STATUS_OJBECT_NAME_NOT_FOUND). 
    If the licensing descriptors are not sorted, they have to be.

    #>
    $functions = @(
        @{ Name = "SLOpen";                       Dll = "sppc.dll"; ReturnType = [int]; Parameters = [Type[]]@([IntPtr].MakeByRefType()) },
        @{ Name = "SLGetLicense";                 Dll = "sppc.dll"; ReturnType = [int]; Parameters = [Type[]]@(
            [IntPtr],                        # hSLC
            [Guid].MakeByRefType(),          # pSkuId
            [UInt32].MakeByRefType(),        # pBufferSize (pointer to UInt32)
            [IntPtr].MakeByRefType()         # pBuffer (pointer to BYTE*)
        )},
        @{ name = 'SLGetProductSkuInformation'; Dll = "sppc.dll"; returnType = [Int32]; parameters = @([IntPtr], [Guid].MakeByRefType(), [String], [UInt32].MakeByRefType(), [UInt32].MakeByRefType(), [IntPtr].MakeByRefType()) },
        @{ name = 'SLGetServiceInformation';    Dll = "sppc.dll"; returnType = [Int32]; parameters = @([IntPtr], [String], [UInt32].MakeByRefType(), [UInt32].MakeByRefType(), [IntPtr].MakeByRefType()) },
        
        @{ Name = "SLClose";                      Dll = "sppc.dll"; ReturnType = [int]; Parameters = [Type[]]@([IntPtr]) },
        @{ Name = "SLGetLicenseInformation";      Dll = "sppc.dll"; ReturnType = [int]; Parameters = [Type[]]@( 
           [IntPtr],                 # hSLC
           [Guid].MakeByRefType(),   # pSLLicenseId
           [string],                 # pwszValueName
           [IntPtr].MakeByRefType(), # peDataType (optional)
           [UInt32].MakeByRefType(), # pcbValue
           [IntPtr].MakeByRefType()  # ppbValue
           )},
        @{ Name = "SLGetPKeyInformation"; Dll = "sppc.dll"; ReturnType = [int]; Parameters = [Type[]]@(
            [IntPtr],                         # hSLC
            [Guid].MakeByRefType(),           # pPKeyId
            [string],                         # pwszValueName
            [IntPtr].MakeByRefType(),         # peDataType
            [UInt32].MakeByRefType(),         # pcbValue
            [IntPtr].MakeByRefType()          # ppbValue
        )},
        @{  Name       = 'SLGetInstalledProductKeyIds'
            Dll        = "sppc.dll"
            ReturnType = [UInt32]
            Parameters = @(
                [IntPtr],                         # HSLC
                [Guid].MakeByRefType(),           # pProductSkuId (nullable)
                [UInt32].MakeByRefType(),         # *pnProductKeyIds
                [IntPtr].MakeByRefType()          # **ppProductKeyIds
            )
        },
        @{  Name       = 'SLGetApplicationInformation'
            Dll        = "sppc.dll"
            ReturnType = [Int32]
            Parameters = @(
                [IntPtr],                  # HSLC hSLC
		        [Guid].MakeByRefType(),    # const SLID* pApplicationId
		        [string],                  # PCWSTR pwszValueName
		        [IntPtr],                  # SLDATATYPE* peDataType (optional)
		        [IntPtr],                  # UINT* pcbValue (output)
		        [IntPtr]                   # PBYTE* ppbValue (output pointer-to-pointer)
            )
        },
        @{
            Name       = 'SLGetGenuineInformation'
            Dll        = "sppc.dll"
            ReturnType = [Int32]  # HRESULT (return type of the function)
            Parameters = @(
                [Guid].MakeByRefType(),         # const SLID* pQueryId
                [string],                       # PCWSTR pwszValueName
                [int].MakeByRefType(),          # SLDATATYPE* peDataType (optional)
                [int].MakeByRefType(),          # UINT* pcbValue (out)
                [IntPtr].MakeByRefType()        # BYTE** ppbValue (out)
            )
            },
            @{
                Name       = 'SLGetSLIDList'
                Dll        = "sppc.dll"
                ReturnType = [Int32]  # HRESULT (return type of the function)
                Parameters = @(
                    [IntPtr],             # hSLC (HSLC handle)
                    [Int32],              # eQueryIdType (SLIDTYPE)
                    [IntPtr],             # null (no query ID passed)
                    [Int32],              # eReturnIdType (SLIDTYPE)
                    [int].MakeByRefType(), 
                    [IntPtr].MakeByRefType()
                )
            },
            @{
                Name       = 'SLUninstallLicense'
                Dll        = "sppc.dll"
                ReturnType = [Int32]  # HRESULT
                Parameters = @(
                    [IntPtr],              # hSLC
                    [Guid].MakeByRefType() # const SLID* pLicenseFileId
                )
            },
            @{
                Name       = 'SLInstallLicense'
                Dll        = "sppc.dll"
                ReturnType = [Int32]  # HRESULT
                Parameters = @(
                    [IntPtr],                # HSLC hSLC
                    [UInt32],                # UINT cbLicenseBlob
                    [IntPtr],                # const BYTE* pbLicenseBlob
                    [Guid].MakeByRefType()   # SLID* pLicenseFileId (output GUID)
                )
            },
            @{
                Name       = 'SLInstallProofOfPurchase'
                Dll        = "sppc.dll"
                ReturnType = [Int32]  # HRESULT
                Parameters = @(
                    [IntPtr],                         # HSLC hSLC
                    [string],                         # pwszPKeyAlgorithm (e.g., "msft:rm/algorithm/pkey/2005")
                    [string],                         # pwszPKeyString (the product key)
                    [IntPtr],                         # cbPKeySpecificData (size of specific data, could be 0)
                    [IntPtr],                         # pbPKeySpecificData (optional additional data, can be NULL)
                    [Guid].MakeByRefType()            # SLID* pPkeyId (output GUID)
                )
            },
            @{
                Name       = 'SLUninstallProofOfPurchase'
                Dll        = "sppc.dll"
                ReturnType = [Int32]  # HRESULT
                Parameters = @(
                    [IntPtr],                         # HSLC hSLC
                    [Guid]                            # pPKeyId (the GUID returned from SLInstallProofOfPurchase)
                )
            },
            @{
                Name       = 'SLFireEvent'
                Dll        = "sppc.dll"
                ReturnType = [Int32]  # HRESULT (return type of the function)
                Parameters = @(
                    [IntPtr],              # hSLC
                    [String],              # pwszEventId (PCWSTR)
                    [Guid].MakeByRefType() # pApplicationId (SLID*)
                )
            },
            @{
                Name       = 'SLReArm'
                Dll        = 'sppc.dll'
                ReturnType = [Int32] # HRESULT
                Parameters = @(
                    [IntPtr],               # hSLC (HSLC handle)
                    [Guid].MakeByRefType(), # pApplicationId (const SLID* - pointer to GUID)
                    [Guid].MakeByRefType(), # pProductSkuId (const SLID* - pointer to GUID, optional)
                    [UInt32]                # dwFlags (DWORD)
                )
            },
            @{
                Name       = 'SLReArmWindows'
                Dll        = 'slc.dll'
                ReturnType = [Int32] # HRESULT
                Parameters = @()
            },
            @{
                Name       = 'SLActivateProduct'
                Dll        = 'sppcext.dll'
                ReturnType = [Int32] # HRESULT
                Parameters = @(
                    [IntPtr],           # hSLC (HSLC handle)
                    [Guid].MakeByRefType(), # pProductSkuId (const SLID* - pointer to GUID)
                    [UInt32],           # cbAppSpecificData (UINT)
                    [IntPtr],           # pvAppSpecificData (const PVOID - pointer to arbitrary data, typically IntPtr.Zero if not used)
                    [IntPtr],           # pActivationInfo (const SL_ACTIVATION_INFO_HEADER* - pointer to structure, typically IntPtr.Zero if not used)
                    [string],           # pwszProxyServer (PCWSTR - string for proxy server, can be $null)
                    [UInt16]            # wProxyPort (WORD - unsigned 16-bit integer for proxy port)
                )
            },
            @{
                # Probably internet activation API
                Name       = 'SLpIAActivateProduct'
                Dll        = 'sppc.dll'
                ReturnType = [uint32] # HRESULT
                Parameters = @(
                    [IntPtr],           # hSLC (HSLC handle)
                    [Guid].MakeByRefType() # pProductSkuId (const SLID* - pointer to GUID)
                )
            },
            @{
                # Probably Volume activation API
                Name       = 'SLpVLActivateProduct'
                Dll        = 'sppc.dll'
                ReturnType = [uint32] # HRESULT
                Parameters = @(
                    [IntPtr],           # hSLC (HSLC handle)
                    [Guid].MakeByRefType() # pProductSkuId (const SLID* - pointer to GUID)
                )
            },
            @{
                Name       = 'SLGetLicensingStatusInformation'
                Dll        = 'sppc.dll'
                ReturnType = [Int32] # HRESULT
                Parameters = @(
                    [IntPtr],                     # hSLC (HSLC handle)
                    [GUID].MakeByRefType(),       # pAppID (const SLID * - pass [IntPtr]::Zero or allocated GUID)
                    [IntPtr],                     # pProductSkuId (const SLID * - pass [IntPtr]::Zero or allocated GUID)
                    [IntPtr],                     # pwszRightName (PCWSTR - pass [IntPtr]::Zero for NULL)
                    [uint32].MakeByRefType(),     # pnStatusCount (UINT *)
                    [IntPtr].MakeByRefType()      # ppLicensingStatus (SL_LICENSING_STATUS **)
            )
        },
        @{
                Name       = 'SLConsumeWindowsRight'
                Dll        = 'slc.dll'
                ReturnType = [Int32] # HRESULT
                Parameters = @(
                    [IntPtr]                     # hSLC (HSLC handle)
            )
        },
        @{
                Name       = 'SLConsumeRight'
                Dll        = 'sppc.dll'
                ReturnType = [Int32] # HRESULT
                Parameters = @(
                    [IntPtr],                     # hSLC (HSLC handle)
                    [GUID].MakeByRefType(),       # pAppID (const SLID * - pass [IntPtr]::Zero or allocated GUID)
                    [IntPtr],                     # pProductSkuId (const SLID * - pass [IntPtr]::Zero or allocated GUID)
                    [IntPtr],                     # pwszRightName (PCWSTR - pass [IntPtr]::Zero for NULL)
                    [IntPtr]                      # pvReserved    -> Null
            )
        },
        @{
                Name       = 'SLGetPKeyId'
                Dll        = 'sppc.dll'
                ReturnType = [Int32] # HRESULT
                Parameters = @(
                    [IntPtr],                     # hSLC (HSLC handle)
                    [string],                     # pwszPKeyAlgorithm
                    [string],                     # pwszPKeyString
                    [IntPtr],                     # cbPKeySpecificData -> NULL
                    [IntPtr],                     # pbPKeySpecificData -> Null
                    [GUID].MakeByRefType()        # pPKeyId (const SLID * - pass [IntPtr]::Zero or allocated GUID)
            )
        },
        @{
                Name       = 'SLGenerateOfflineInstallationIdEx'
                Dll        = 'sppc.dll'
                ReturnType = [Int32] # HRESULT
                Parameters = @(
                    [IntPtr],                     # hSLC (HSLC handle)
                    [GUID].MakeByRefType(),       # pProductSkuId (const SLID * - pass [IntPtr]::Zero or allocated GUID)
                    [IntPtr],                     # const SL_ACTIVATION_INFO_HEADER *pActivationInfo // Zero
                    [IntPtr].MakeByRefType()      # [out] ppwszInstallationId
            )
        },
        @{
                Name       = 'SLGetActiveLicenseInfo'
                Dll        = 'sppc.dll'
                ReturnType = [Int32] # HRESULT
                Parameters = @(
                    [IntPtr],     # hSLC (HSLC handle)
                    [IntPtr],     # Reserved
                    [uint32].MakeByRefType(),
                    [IntPtr].MakeByRefType()
            )
        },
        @{
                Name       = 'SLGetTokenActivationGrants'
                Dll        = 'sppcext.dll'
                ReturnType = [Int32] # HRESULT
                Parameters = @(
                    [IntPtr],
                    [Guid].MakeByRefType(),
                    [IntPtr].MakeByRefType()
            )
        },
        @{
                Name       = 'SLFreeTokenActivationGrants'
                Dll        = 'sppcext.dll'
                ReturnType = [Int32] # HRESULT
                Parameters = @(
                    [IntPtr]
            )
        }
    )
    return Register-NativeMethods $functions
}
Function Init-NTDLL {
$functions = @(
    @{ Name = "NtDuplicateToken";          Dll = "ntdll.dll"; ReturnType = [Int32];  Parameters = @([IntPtr], [Int], [IntPtr], [Int], [Int], [IntPtr].MakeByRefType())},
    @{ Name = "NtQuerySystemInformation";  Dll = "ntdll.dll"; ReturnType = [Int32];  Parameters = @([Int32],[IntPtr],[Int32],[Int32].MakeByRefType())},
    @{ Name = "CsrClientCallServer";       Dll = "ntdll.dll"; ReturnType = [Int32];  Parameters = @([IntPtr],[IntPtr],[Int32],[Int32])},
    @{ Name = "NtResumeThread";            Dll = "ntdll.dll"; ReturnType = [Int32];  Parameters = @([IntPtr],[Int32])},
    @{ Name = "RtlMoveMemory";             Dll = "ntdll.dll"; ReturnType = [Void];   Parameters = @([IntPtr],[IntPtr],[UintPtr])},
    @{ Name = "RtlGetVersion";             Dll = "ntdll.dll"; ReturnType = [Int32];  Parameters = [Type[]]@([IntPtr]) },
    @{ Name = "RtlGetCurrentPeb";          Dll = "ntdll.dll"; ReturnType = [IntPtr]; Parameters = [Type[]]@() },
    @{ Name = "RtlGetProductInfo";         Dll = "ntdll.dll"; ReturnType = [Boolean];  Parameters = [Type[]]@([UInt32], [UInt32], [UInt32], [UInt32], [Uint32].MakeByRefType()) },
    @{ Name = "RtlGetNtVersionNumbers";    Dll = "ntdll.dll"; ReturnType = [Int32];  Parameters = [Type[]]@([Uint32].MakeByRefType(), [Uint32].MakeByRefType(), [Uint32].MakeByRefType()) },
    @{ Name = "RtlZeroMemory";             Dll = "ntdll.dll"; ReturnType = [Void];   Parameters = [Type[]]@([IntPtr], [UIntPtr]) },
    @{ Name = "RtlFreeHeap";               Dll = "ntdll.dll"; ReturnType = [Int32];  Parameters = [Type[]]@([IntPtr], [uint32], [IntPtr]) },
    @{ Name = "RtlGetProcessHeaps";        Dll = "ntdll.dll"; ReturnType = [Int32];  Parameters = [Type[]]@([Int32], [IntPtr]) },
    @{ Name = "NtGetNextProcess";          Dll = "ntdll.dll"; ReturnType = [Int32];  Parameters = [Type[]]@([IntPtr], [UInt32], [UInt32], [UInt32], [IntPtr].MakeByRefType()) },
    @{ Name = "NtQueryInformationProcess"; Dll = "ntdll.dll"; ReturnType = [Int32];  Parameters = [Type[]]@([IntPtr], [UInt32], [IntPtr], [UInt32], [UInt32].MakeByRefType()) },
    @{ Name = "ZwQueryLicenseValue";       Dll = "ntdll.dll"; ReturnType = [Int32];  Parameters = [Type[]]@([IntPtr], [UInt32].MakeByRefType(), [IntPtr], [UInt32], [UInt32].MakeByRefType()) },
    @{ Name = "RtlCreateUnicodeString";    Dll = "ntdll.dll"; ReturnType = [Int32];  Parameters = [Type[]]@([IntPtr], [string]) },
    @{ Name = "RtlFreeUnicodeString";      Dll = "ntdll.dll"; ReturnType = [Int32];  Parameters = [Type[]]@([IntPtr]) },
    @{ Name = "LdrGetDllHandleEx";         Dll = "ntdll.dll"; ReturnType = [Int32];  Parameters = [Type[]]@([Int32], [IntPtr], [IntPtr], [IntPtr], [IntPtr].MakeByRefType()) },
    @{ Name = "ZwQuerySystemInformation";  Dll = "ntdll.dll"; ReturnType = [Int32];  Parameters = [Type[]]@([int32], [IntPtr], [uint32], [uint32].MakeByRefType() ) },
    @{ Name = "RtlFindMessage";            Dll = "ntdll.dll"; ReturnType = [Int32];  Parameters = [Type[]]@(
        [IntPtr],                 # DllHandle
        [Uint32],                 # MessageTableId
        [Uint32],                 # MessageLanguageId
        [Uint32],                 # MessageId // ULONG
        [IntPtr].MakeByRefType()  # ref IntPtr for output MESSAGE_RESOURCE_ENTRY*
    ) },
    @{ Name = "RtlNtStatusToDosError"; Dll = "ntdll.dll"; ReturnType = [Int32]; Parameters = [Type[]]@([Int32]) },
        
    <#
        [In]String\Flags, [In][REF]Flags, [In][REF]UNICODE_STRING, [Out]Handle
        void LdrLoadDll(ulonglong param_1,uint *param_2,uint *param_3,undefined8 *param_4)

        https://rextester.com/KCUV42565
        RtlInitUnicodeStringStruct (&unicodestring, L"USER32.dll");
        LdrLoadDllStruct (NULL, 0, &unicodestring, &hModule);

        https://doxygen.reactos.org/d7/d55/ldrapi_8c_source.html
        NTSTATUS
        NTAPI
        DECLSPEC_HOTPATCH
        LdrLoadDll(
            _In_opt_ PWSTR SearchPath,
            _In_opt_ PULONG DllCharacteristics,
            _In_ PUNICODE_STRING DllName,
            _Out_ PVOID *BaseAddress)
        {
    #>
    @{ Name = "LdrLoadDll";    Dll = "ntdll.dll";     ReturnType = [Int32];      Parameters = [Type[]]@(
            
        # [IntPtr]::Zero // [STRING] -> NULL -> C Behavior
        [IntPtr],
            
        # [IntPtr]::Zero // Uint.makeByRef[]
        # Legit, no flags, can be 0x0 -> if (param_2 == (uint *)0x0) {uVar4 = 0;}
        [IntPtr],
            
        [IntPtr],                      # ModuleFileName Pointer (from RtlCreateUnicodeString)
        [IntPtr].MakeByRefType()       # out ModuleHandle
    ) },
    @{ Name = "LdrUnLoadDll";  Dll = "ntdll.dll";     ReturnType = [Int32];      Parameters = [Type[]]@(
        [IntPtr]                       # ModuleHandle (PVOID*)
    )},
    @{
        Name       = "LdrGetProcedureAddressForCaller"
        Dll        = "ntdll.dll"
        ReturnType = [Int32]
        Parameters = [Type[]]@(
            [IntPtr],                  # [HMODULE] Module handle pointer
            [IntPtr],                  # [PSTRING] Pointer to STRING struct (pass IntPtr directly, NOT [ref])
            [Int32],                   # [ULONG]   Ordinal / Flags (usually 0)
            [IntPtr].MakeByRefType(),  # [PVOID*]  Out pointer to procedure address (pass [ref])
            [byte],                    # [Flags]   0 or 1 (usually 0)
            [IntPtr]                   # [Caller]  Nullable caller address, pass [IntPtr]::Zero if none
        )
    },
    @{ Name = "NtOpenProcess";             Dll = "ntdll.dll"; ReturnType = [Int32];  Parameters = [Type[]]@([IntPtr].MakeByRefType(),[Int32], [IntPtr], [IntPtr]) },
    @{ Name = "NtClose";                   Dll = "ntdll.dll"; ReturnType = [Int32];  Parameters = [Type[]]@([IntPtr]) },
    @{ Name = "NtOpenProcessToken";        Dll = "ntdll.dll"; ReturnType = [Int32];  Parameters = [Type[]]@([IntPtr], [UInt32], [IntPtr].MakeByRefType()) },
    @{ Name = "NtAdjustPrivilegesToken";   Dll = "ntdll.dll"; ReturnType = [Int32];  Parameters = [Type[]]@([IntPtr], [bool] , [IntPtr], [UInt32], [IntPtr], [IntPtr]) },
    @{
        Name       = "NtCreateUserProcess";
        Dll        = "ntdll.dll";
        ReturnType = [Int32];
        Parameters = [Type[]]@(
            [IntPtr].MakeByRefType(),  # out PHANDLE ProcessHandle
            [IntPtr].MakeByRefType(),  # out PHANDLE ThreadHandle
            [Int32],                   # ACCESS_MASK ProcessDesiredAccess
            [Int32],                   # ACCESS_MASK ThreadDesiredAccess
            [IntPtr],                  # POBJECT_ATTRIBUTES ProcessObjectAttributes (nullable)
            [IntPtr],                  # POBJECT_ATTRIBUTES ThreadObjectAttributes (nullable)
            [UInt32],                  # ULONG ProcessFlags
            [UInt32],                  # ULONG ThreadFlags
            [IntPtr],                  # PRTL_USER_PROCESS_PARAMETERS (nullable)
            [IntPtr],                  # PPS_CREATE_INFO
            [IntPtr]                   # PPS_ATTRIBUTE_LIST (nullable)
        )
    },
    @{
        Name       = "RtlCreateProcessParametersEx";
        Dll        = "ntdll.dll";
        ReturnType = [Int32];
        Parameters = [Type[]]@(
            [IntPtr].MakeByRefType(),  # OUT PRTL_USER_PROCESS_PARAMETERS*
            [IntPtr],                  # PUNICODE_STRING ImagePathName
            [IntPtr],                  # PUNICODE_STRING DllPath
            [IntPtr],                  # PUNICODE_STRING CurrentDirectory
            [IntPtr],                  # PUNICODE_STRING CommandLine
            [IntPtr],                  # PVOID Environment
            [IntPtr],                  # PUNICODE_STRING WindowTitle
            [IntPtr],                  # PUNICODE_STRING DesktopInfo
            [IntPtr],                  # PUNICODE_STRING ShellInfo
            [IntPtr],                  # PUNICODE_STRING RuntimeData
            [Int32]                    # ULONG Flags
        )
    }
    @{ Name = "CsrCaptureMessageMultiUnicodeStringsInPlace";  Dll = "ntdll.dll"; ReturnType = [Int32];  Parameters = @(
        [IntPtr].MakeByRefType(),
        [Int32],[IntPtr])
    }
)
return Register-NativeMethods $functions
}
function Init-DismApi {

    <#
        Managed DismApi Wrapper
        https://github.com/jeffkl/ManagedDism/tree/main

        Windows 10 DLL File Information - DismApi.dll
        https://windows10dll.nirsoft.net/dismapi_dll.html

        DISMSDK
        https://github.com/Chuyu-Team/DISMSDK/blob/main/dismapi.h

        DISM API Functions
        https://learn.microsoft.com/en-us/windows-hardware/manufacture/desktop/dism/dism-api-functions
    #>
    $functions = @(
        @{ 
            Name = "DismInitialize"; 
            Dll  = "DismApi.dll";
            ReturnType = [Int32]; 
            # logLevel, logFilePath, scratchDirectory
            Parameters = [Type[]]@([Int32], [IntPtr], [IntPtr])
        },
        @{ 
            Name = "DismOpenSession"; 
            Dll  = "DismApi.dll";
            ReturnType = [Int32]; 
            # imagePath, windowsDirectory, systemDrive, out session
            Parameters = [Type[]]@([string], [IntPtr], [IntPtr], [IntPtr].MakeByRefType()) 
        },
        @{ 
            Name = "DismCloseSession"; 
            Dll  = "DismApi.dll";
            ReturnType = [Int32]; 
            # session handle
            Parameters = [Type[]]@([IntPtr])
        },
        @{ 
            Name = "_DismGetTargetEditions"; 
            Dll  = "DismApi.dll";
            ReturnType = [Int32]; 
            # session, out editionIds, out count
            Parameters = [Type[]]@([IntPtr], [IntPtr].MakeByRefType(), [UInt32].MakeByRefType())
        },
        @{ 
            Name = "DismShutdown"; 
            Dll  = "DismApi.dll";
            ReturnType = [Int32]; 
            # no parameters
            Parameters = [Type[]]@()
        },
        @{
            Name = "DismDelete";
            Dll  = "DismApi.dll";
            ReturnType = [Int32];
            # parameter is a void* pointer to the structure to free
            Parameters = [Type[]]@([IntPtr])
        }
    )
    return Register-NativeMethods $functions
}
Function Init-advapi32 {

    $functions = @(
        @{ Name = "OpenProcessToken";        Dll = "advapi32.dll"; ReturnType = [UInt32]; Parameters = [Type[]]@([IntPtr], [UInt32], [IntPtr].MakeByRefType()) },
        @{ Name = "LookupPrivilegeValue";    Dll = "advapi32.dll"; ReturnType = [UInt32]; Parameters = [Type[]]@([IntPtr], [string], [Int64].MakeByRefType()) },
        @{ Name = "AdjustTokenPrivileges";   Dll = "advapi32.dll"; ReturnType = [UInt32]; Parameters = [Type[]]@([IntPtr], [bool] , [IntPtr], [Int32], [IntPtr], [IntPtr]) },
        @{ Name = "GetTokenInformation";     Dll = "advapi32.dll"; ReturnType = [UInt32]; Parameters = [Type[]]@([IntPtr], [Int32] , [IntPtr], [Int32], [Int32].MakeByRefType()) },
        @{ Name = "LookupPrivilegeNameW";    Dll = "advapi32.dll"; ReturnType = [UInt32]; Parameters = [Type[]]@([IntPtr], [Int32].MakeByRefType() , [IntPtr], [Int32].MakeByRefType()) },
        @{ Name = "LsaNtStatusToWinError";   Dll = "advapi32.dll"; ReturnType = [UInt32]; Parameters = [Type[]]@([UInt32]) },
        @{ Name = "LsaOpenPolicy";           Dll = "advapi32.dll"; ReturnType = [UInt32]; Parameters = [Type[]]@([IntPtr], [IntPtr], [UInt32], [IntPtr].MakeByRefType()) },
        @{ Name = "LsaLookupPrivilegeValue"; Dll = "advapi32.dll"; ReturnType = [UInt32]; Parameters = [Type[]]@([IntPtr], [IntPtr], [Int64].MakeByRefType()) },
        @{ Name = "LsaClose";                Dll = "advapi32.dll"; ReturnType = [UInt32]; Parameters = [Type[]]@([IntPtr]) },
        @{ Name = "OpenServiceW";            Dll = "advapi32.dll"; ReturnType = [IntPtr]; Parameters = [Type[]]@([IntPtr],[IntPtr],[Int32]) },
        @{ Name = "OpenSCManagerW";          Dll = "advapi32.dll"; ReturnType = [IntPtr]; Parameters = [Type[]]@([Int32],[IntPtr],[Int32]) },
        @{ Name = "CloseServiceHandle";      Dll = "advapi32.dll"; ReturnType = [BOOL];   Parameters = [Type[]]@([IntPtr]) },
        @{ Name = "StartServiceW";           Dll = "advapi32.dll"; ReturnType = [BOOL];   Parameters = [Type[]]@([IntPtr],[Int32],[IntPtr]) },
        @{ Name = "QueryServiceStatusEx";    Dll = "advapi32.dll"; ReturnType = [BOOL];   Parameters = [Type[]]@([IntPtr],[Int32],[IntPtr],[Int32],[UInt32].MakeByRefType()) },
        @{ Name = "CreateProcessWithTokenW"; Dll = "advapi32.dll"; ReturnType = [BOOL];   Parameters = [Type[]]@([IntPtr], [Int32], [IntPtr], [IntPtr], [Int32], [IntPtr],[IntPtr],[IntPtr],[IntPtr]) },
        @{ Name = "LsaRemoveAccountRights";  Dll = "advapi32.dll"; ReturnType = [UInt32]; Parameters = [Type[]]@([IntPtr], [IntPtr], [Int32], [IntPtr], [Int32]) },
        @{ Name = "LsaAddAccountRights";     Dll = "advapi32.dll"; ReturnType = [UInt32]; Parameters = [Type[]]@([IntPtr], [IntPtr], [IntPtr], [Int32]) },
        @{ Name = "LookupAccountNameW";      Dll = "advapi32.dll"; ReturnType = [UInt32]; Parameters = [Type[]]@([IntPtr], [string], [IntPtr], [Int32].MakeByRefType(),[IntPtr], [Int32].MakeByRefType(), [Boolean].MakeByRefType()) },
        @{ Name = "ConvertSidToStringSidW";  Dll = "advapi32.dll"; ReturnType = [UInt32]; Parameters = [Type[]]@([IntPtr], [IntPtr]) }
    )
    return Register-NativeMethods $functions
}
Function Init-KERNEL32 {

    $functions = @(
        @{ Name = "RevertToSelf";            Dll = "KernelBase.dll"; ReturnType = [bool]; Parameters = [Type[]]@() },
        @{ Name = "ImpersonateLoggedOnUser"; Dll = "KernelBase.dll"; ReturnType = [bool]; Parameters = [Type[]]@([IntPtr]) },
        @{ Name = "FindFirstFileW"; Dll = "KernelBase.dll"; ReturnType = [IntPtr]; Parameters = [Type[]]@([string], [IntPtr]) },
        @{ Name = "FindNextFileW";  Dll = "KernelBase.dll"; ReturnType = [bool];   Parameters = [Type[]]@([IntPtr], [IntPtr]) },
        @{ Name = "FindClose";      Dll = "KernelBase.dll"; ReturnType = [bool];   Parameters = [Type[]]@([IntPtr]) },
        @{ Name = "LocalFree" ;     Dll = "KernelBase.dll"; ReturnType = [IntPtr]; Parameters = [Type[]]@([IntPtr]) },
        @{ Name = "LoadLibraryExW"; Dll = "KernelBase.dll"; ReturnType = [IntPtr]; Parameters = [Type[]]@([string], [IntPtr], [UInt32]) },
        @{ Name = "FreeLibrary";    Dll = "KernelBase.dll"; ReturnType = [BOOL];   Parameters = [Type[]]@([IntPtr]) },
        @{ Name = "HeapFree";       Dll = "KernelBase.dll"; ReturnType = [bool]  ; Parameters = [Type[]]@([IntPtr], [uint32], [IntPtr]) },
        @{ Name = "ResumeThread";   Dll = "KernelBase.dll"; ReturnType = [int32];  Parameters = [Type[]]@([IntPtr]) },
        @{ Name = "GetProcAddress"; Dll = "KernelBase.dll"; ReturnType = [IntPtr]; Parameters = [Type[]]@([IntPtr], [string]) },
        @{ Name = "CloseHandle";    Dll = "KernelBase.dll"; ReturnType = [bool];   Parameters = [Type[]]@([IntPtr]) },
        @{ Name = "LocalFree";      Dll = "KernelBase.dll"; ReturnType = [bool];   Parameters = [Type[]]@([IntPtr]) },
        @{ Name = "CreateProcessW"; Dll = "KernelBase.dll"; ReturnType = [bool];   Parameters = [Type[]]@([IntPtr],[IntPtr],[IntPtr],[IntPtr],[bool],[Int32],[IntPtr],[IntPtr],[IntPtr],[IntPtr]) },
        @{ Name = "WaitForSingleObject";   Dll = "KernelBase.dll"; ReturnType = [int32];  Parameters = [Type[]]@([IntPtr],[int32]) },
        @{ Name = "EnumSystemFirmwareTables"; Dll = "KernelBase.dll"; ReturnType = [UInt32]; Parameters = [Type[]]@([UInt32], [IntPtr], [UInt32]) },
        @{ Name = "GetSystemFirmwareTable";   Dll = "KernelBase.dll"; ReturnType = [UInt32]; Parameters = [Type[]]@([UInt32], [UInt32], [IntPtr], [UInt32]) },
        @{ Name = "UpdateProcThreadAttribute";  Dll = "KernelBase.dll"; ReturnType = [bool];   Parameters = [Type[]]@([IntPtr],[uint32],[uint32],[IntPtr],[Int32],[IntPtr],[IntPtr]) },
        @{ Name = "InitializeProcThreadAttributeList";    Dll = "KernelBase.dll"; ReturnType = [bool];   Parameters = [Type[]]@([IntPtr],[uint32],[uint32],[IntPtr]) },
        @{ Name = "DeleteProcThreadAttributeList";    Dll = "KernelBase.dll"; ReturnType = [void];   Parameters = [Type[]]@([IntPtr]) }
    )
    return Register-NativeMethods $functions
}
Function Init-PKHELPER {

    $functions = @(
        @{
            Name = "GetEditionIdFromName"
            Dll = "pkeyhelper.dll"
            ReturnType = [int]
            Parameters = [Type[]]@(
                [string],                     # edition Name
                [int].MakeByRefType()         # out Branding Value
            )
        },
        @{
            Name = "GetEditionNameFromId"
            Dll = "pkeyhelper.dll"
            ReturnType = [int]
            Parameters = [Type[]]@(
                [int],                     # Branding Value
                [intptr].MakeByRefType()   # out edition Name
            )
        },
        @{
            Name = "SkuGetProductKeyForEdition"
            Dll = "pkeyhelper.dll"
            ReturnType = [int]
            Parameters = [Type[]]@(
                [int],                    # editionId
                [IntPtr],                 # sku
                [IntPtr].MakeByRefType()  # ref productKey
                [IntPtr].MakeByRefType()  # ref keyType
            )
        },
        @{
            Name = "IsDefaultPKey"
            Dll = "pkeyhelper.dll"
            ReturnType = [uint32]
            Parameters = [Type[]]@(
                [string],               # 29 digits cd-key
                [bool].MakeByRefType()  # Default bool Propertie = 0, [ref]$Propertie
            )

        <#
            [bool]$results = 0
            $hr = $Global:PKHElper::IsDefaultPKey(
                "89DNY-M3VP8-CB7JK-3QGBC-Q3WV6", [ref]$results)
            if ($hr -eq 0) {
	            $results
            }            
        #>
        },
        @{
            Name = "GetDefaultProductKeyForPfn"
            Dll = "pkeyhelper.dll"
            ReturnType = [uint32]
            Parameters = [Type[]]@(
                [string],                  # "Microsoft.Windows.100.res-v3274_8wekyb3d8bbwe"
                [IntPtr].MakeByRefType(),  # Handle to result
                [uint32]                   # Flags
            )

        <#
            $output = [IntPtr]::Zero
            $hr = $Global:PKHElper::GetDefaultProductKeyForPfn(
                "Microsoft.Windows.100.res-v3274_8wekyb3d8bbwe", [ref]$output, 0)
            if ($hr -eq 0) {
	            [marshal]::PtrToStringUni($outPut)
                # free pointer later
            }            
        #>
        }
    )
    return Register-NativeMethods $functions
}
Function Init-PIDGENX {
     
    <#
    https://github.com/chughes-3
    https://github.com/chughes-3/UpdateProductKey/blob/master/UpdateProductKeys/PidChecker.cs

    [DllImport("pidgenx.dll", EntryPoint = "PidGenX", CharSet = CharSet.Auto)]
    static extern int PidGenX(string ProductKey, string PkeyPath, string MSPID, int UnknownUsage, IntPtr ProductID, IntPtr DigitalProductID, IntPtr DigitalProductID4);

    * sppcomapi.dll
    * __int64 __fastcall GetWindowsPKeyInfo(_WORD *a1, __int64 a2, __int64 a3, __int64 a4)
    __int128 v46[3]; // __m128 v46[3], 48 bytes total
    int v47[44];
    int v48[320];
    memset(v46, 0, sizeof(v46)); // size of structure 2
    memset_0(v47, 0, 0xA4ui64);
    memset_0(v48, 0, 0x4F8ui64);
    v47[0] = 164;   // size of structure 3
    v48[0] = 1272;  // size of structure 4

    $PIDPtr   = New-IntPtr -Size 0x30  -WriteSizeAtZero
    $DPIDPtr  = New-IntPtr -Size 0xB0  -InitialValue 0xA4
    $DPID4Ptr = New-IntPtr -Size 0x500 -InitialValue 0x4F8

    $result = $Global:PIDGENX::PidGenX(
        # Most important Roles
        $key, $configPath,
        # Default value for MSPID, 03612 ?? 00000 ?
        # PIDGENX2 -> v26 = L"00000" // SPPCOMAPI, GetWindowsPKeyInfo -> L"03612"
        "00000",
        # Unknown1
        0,
        # Structs
        $PIDPtr, $DPIDPtr, $DPID4Ptr
    )

    $result = $Global:PIDGENX::PidGenX2(
        # Most important Roles
        $key, $configPath,
        # Default value for MSPID, 03612 ?? 00000 ?
        # PIDGENX2 -> v26 = L"00000" // SPPCOMAPI, GetWindowsPKeyInfo -> L"03612"
        "00000",
        # Unknown1 / [Unknown2, Added in PidGenX2!]
        0,0,
        # Structs
        $PIDPtr, $DPIDPtr, $DPID4Ptr
    )
    #>

    $functions = @(
        @{
            Name       = "PidGenX"
            Dll        = "pidgenx.dll"
            ReturnType = [int]
            Parameters = [Type[]]@([string], [string], [string], [int], [IntPtr], [IntPtr], [IntPtr])
        },
        @{
            Name       = "PidGenX2"
            Dll        = "pidgenx.dll"
            ReturnType = [int]
            Parameters = [Type[]]@([string], [string], [string], [int], [int], [IntPtr], [IntPtr], [IntPtr])
        }
    )
    return Register-NativeMethods $functions -ImplAttributes ([MethodImplAttributes]::IL)
}

<#

     *********************

      !Managed Api & 
             Com Warper.!
        -  Helper's -

     *********************

    Get-SysCallData <> based on PowerSploit 3.0.0.0
    https://www.powershellgallery.com/packages/PowerSploit/3.0.0.0
    https://www.powershellgallery.com/packages/PowerSploit/1.0.0.0/Content/PETools%5CGet-PEHeader.ps1

#>
function Get-Base26Name {
    param (
        [int]$idx
    )

    $result = [System.Text.StringBuilder]::new()
    while ($idx -ge 0) {
        $remainder = $idx % 26
        [void]$result.Insert(0, [char](65 + $remainder))
        $idx = [math]::Floor($idx / 26) - 1
    }

    return $result.ToString()
}
function Process-Parameters {
    param (
        [Parameter(Mandatory=$true)]
        [PSCustomObject]$InterfaceSpec,

        [switch]$Ignore
    )

    # Initialize the parameters list with the base parameter (thisPtr)
    $allParams = New-Object System.Collections.Generic.List[string]

    if (-not $Ignore) {
       $BaseParams = "IntPtr thisPtr"
       $allParams.Add($BaseParams) # Add the base parameter (thisPtr) first
    }

    # Process user-provided parameters if they exist
    if (-not [STRING]::IsNullOrEmpty($InterfaceSpec.Params)) {
        # Split the user-provided parameters by comma and trim whitespace
        $userParams = $InterfaceSpec.Params.Split(',') | ForEach-Object { $_.Trim() }
        
        foreach ($param in $userParams) {
            $modifier = ""
            $typeAndName = $param

            # Check for 'ref' or 'out' keywords, optionally wrapped in brackets, and separate them
            if ($param -match "^\s*\[?(ref|out)\]?\s+(.+)$") {
                $modifier = $Matches[1]                 # This will capture "ref" or "out" (e.g., if input was "[REF]", $Matches[1] will be "REF")
                $modifier = $modifier.ToLowerInvariant() # Convert modifier to lowercase ("REF" -> "ref")
                $typeAndName = $Matches[2]             # Extract the actual type and name
            }

            # Split the type and name (e.g., "uint Flags" -> "uint", "Flags")
            $parts = $typeAndName.Split(' ', 2) 
            if ($parts.Length -eq 2) {
                $type = $parts[0]
                $name = $parts[1]
                $fixedType = $type # Default to original type if no match

                switch ($type.ToLowerInvariant()) {
                    # Fully qualified .NET types
                    "system.boolean" { $fixedType = "bool" }
                    "system.byte"    { $fixedType = "byte" }
                    "system.char"    { $fixedType = "char" }
                    "system.decimal" { $fixedType = "decimal" }
                    "system.double"  { $fixedType = "double" }
                    "system.int16"   { $fixedType = "short" }
                    "system.int32"   { $fixedType = "int" }
                    "system.int64"   { $fixedType = "long" }
                    "system.intptr"  { $fixedType = "IntPtr" }
                    "system.object"  { $fixedType = "object" }
                    "system.sbyte"   { $fixedType = "sbyte" }
                    "system.single"  { $fixedType = "float" }
                    "system.string"  { $fixedType = "string" }
                    "system.uint16"  { $fixedType = "ushort" }
                    "system.uint32"  { $fixedType = "uint" }
                    "system.uint64"  { $fixedType = "ulong" }
                    "system.uintptr" { $fixedType = "UIntPtr" }

                    # Alternate type spellings and aliases
                    "boolean"        { $fixedType = "bool" }
                    "dword32"        { $fixedType = "uint" }
                    "dword64"        { $fixedType = "ulong" }
                    "int16"          { $fixedType = "short" }
                    "int32"          { $fixedType = "int" }
                    "int64"          { $fixedType = "long" }
                    "single"         { $fixedType = "float" }
                    "uint16"         { $fixedType = "ushort" }
                    "uint32"         { $fixedType = "uint" }
                    "uint64"         { $fixedType = "ulong" }

                    # --- Additional C/C++ & WinAPI aliases ---
                    "double"         { $fixedType = "double" }
                    "float"          { $fixedType = "float" }
                    "long"           { $fixedType = "long" }
                    "longlong"       { $fixedType = "long" }
                    "tchar"          { $fixedType = "char" }
                    "uchar"          { $fixedType = "byte" }
                    "ulong"          { $fixedType = "ulong" }
                    "ulonglong"      { $fixedType = "ulong" }
                    "short"          { $fixedType = "short" }
                    "ushort"         { $fixedType = "ushort" }

                    # --- Additional typedefs ---
                    "atom"           { $fixedType = "ushort" }
                    "dword_ptr"      { $fixedType = "UIntPtr" }
                    "dwordlong"      { $fixedType = "ulong" }
                    "farproc"        { $fixedType = "IntPtr" }
                    "hhook"          { $fixedType = "IntPtr" }
                    "hresult"        { $fixedType = "int" }
                    "NTSTATUS"       { $fixedType = "Int32" }
                    "int_ptr"        { $fixedType = "IntPtr" }
                    "intptr_t"       { $fixedType = "IntPtr" }
                    "long_ptr"       { $fixedType = "IntPtr" }
                    "lpbyte"         { $fixedType = "IntPtr" }
                    "lpdword"        { $fixedType = "IntPtr" }
                    "lparam"         { $fixedType = "IntPtr" }
                    "pcstr"          { $fixedType = "IntPtr" }
                    "pcwstr"         { $fixedType = "IntPtr" }
                    "pstr"           { $fixedType = "IntPtr" }
                    "pwstr"          { $fixedType = "IntPtr" }
                    "uint_ptr"       { $fixedType = "UIntPtr" }
                    "uintptr_t"      { $fixedType = "UIntPtr" }
                    "wparam"         { $fixedType = "UIntPtr" }

                    # C# built-in types
                    "bool"           { $fixedType = "bool" }
                    "byte"           { $fixedType = "byte" }
                    "char"           { $fixedType = "char" }
                    "decimal"        { $fixedType = "decimal" }
                    "int"            { $fixedType = "int" }
                    "intptr"         { $fixedType = "IntPtr" }
                    "nint"           { $fixedType = "nint" }
                    "nuint"          { $fixedType = "nuint" }
                    "object"         { $fixedType = "object" }
                    "sbyte"          { $fixedType = "sbyte" }
                    "string"         { $fixedType = "string" }
                    "uint"           { $fixedType = "uint" }
                    "uintptr"        { $fixedType = "UIntPtr" }

                    # Common WinAPI handle types
                    "hbitmap"        { $fixedType = "IntPtr" }
                    "hbrush"         { $fixedType = "IntPtr" }
                    "hcurs"          { $fixedType = "IntPtr" }
                    "hdc"            { $fixedType = "IntPtr" }
                    "hfont"          { $fixedType = "IntPtr" }
                    "hicon"          { $fixedType = "IntPtr" }
                    "hmenu"          { $fixedType = "IntPtr" }
                    "hpen"           { $fixedType = "IntPtr" }
                    "hrgn"           { $fixedType = "IntPtr" }

                    # Pointer-based aliases
                    "pbyte"          { $fixedType = "IntPtr" }
                    "pchar"          { $fixedType = "IntPtr" }
                    "pdword"         { $fixedType = "IntPtr" }
                    "pint"           { $fixedType = "IntPtr" }
                    "plong"          { $fixedType = "IntPtr" }
                    "puint"          { $fixedType = "IntPtr" }
                    "pulong"         { $fixedType = "IntPtr" }
                    "pvoid"          { $fixedType = "IntPtr" }
                    "lpvoid"         { $fixedType = "IntPtr" }

                    # Special types
                    "guid"           { $fixedType = "Guid" }

                    # Windows/WinAPI types (common aliases)
                    "dword"          { $fixedType = "uint" }
                    "handle"         { $fixedType = "IntPtr" }
                    "hinstance"      { $fixedType = "IntPtr" }
                    "hmodule"        { $fixedType = "IntPtr" }
                    "hwnd"           { $fixedType = "IntPtr" }
                    "ptr"            { $fixedType = "IntPtr" }
                    "size_t"         { $fixedType = "UIntPtr" }
                    "ssize_t"        { $fixedType = "IntPtr" }
                    "void*"          { $fixedType = "IntPtr" }
                    "word"           { $fixedType = "ushort" }
                    "phandle"        { $fixedType = "IntPtr" }
                    "lresult"        { $fixedType = "IntPtr" }

                    # STRSAFE typedefs
                    "strsafe_lpstr"       { $fixedType = "string" }       # ANSI
                    "strsafe_lpcstr"      { $fixedType = "string" }       # ANSI
                    "strsafe_lpwstr"      { $fixedType = "string" }       # Unicode
                    "strsafe_lpcwstr"     { $fixedType = "string" }       # Unicode
                    "strsafe_lpcuwstr"    { $fixedType = "string" }       # Unicode
                    "strsafe_pcnzch"      { $fixedType = "string" }       # ANSI char
                    "strsafe_pcnzwch"     { $fixedType = "string" }       # Unicode wchar
                    "strsafe_pcunzwch"    { $fixedType = "string" }       # Unicode wchar

                    # Wide-character (Unicode) types
                    "lpcstr"        { $fixedType = "string" }             # ANSI string
                    "lpcwstr"       { $fixedType = "string" }             # Unicode string
                    "lpstr"         { $fixedType = "string" }             # ANSI string
                    "lpwstr"        { $fixedType = "string" }             # Unicode string
                    "pstring"       { $fixedType = "string" }             # ANSI string (likely)
                    "pwchar"        { $fixedType = "string" }             # Unicode char*
                    "lpwchar"       { $fixedType = "string" }             # Unicode char*
                    "pczpwstr"      { $fixedType = "string" }             # Unicode string
                    "pzpwstr"       { $fixedType = "string" }
                    "pzwstr"        { $fixedType = "string" }
                    "pzzwstr"       { $fixedType = "string" }
                    "pczzwstr"      { $fixedType = "string" }
                    "puczzwstr"     { $fixedType = "string" }
                    "pcuczzwstr"    { $fixedType = "string" }
                    "pnzwch"        { $fixedType = "string" }
                    "pcnzwch"       { $fixedType = "string" }
                    "punzwch"       { $fixedType = "string" }
                    "pcunzwch"      { $fixedType = "string" }

                    # ANSI string types
                    "npstr"         { $fixedType = "string" }             # ANSI string
                    "pzpcstr"       { $fixedType = "string" }
                    "pczpcstr"      { $fixedType = "string" }
                    "pzzstr"        { $fixedType = "string" }
                    "pczzstr"       { $fixedType = "string" }
                    "pnzch"         { $fixedType = "string" }
                    "pcnzch"        { $fixedType = "string" }

                    # UCS types
                    "ucschar"       { $fixedType = "uint" }               # leave as uint
                    "pucschar"      { $fixedType = "IntPtr" }
                    "pcucschar"     { $fixedType = "IntPtr" }
                    "puucschar"     { $fixedType = "IntPtr" }
                    "pcuucschar"    { $fixedType = "IntPtr" }
                    "pucsstr"       { $fixedType = "IntPtr" }
                    "pcucsstr"      { $fixedType = "IntPtr" }
                    "puucsstr"      { $fixedType = "IntPtr" }
                    "pcuucsstr"     { $fixedType = "IntPtr" }

                    # Neutral ANSI/Unicode (TCHAR-based) Types
                    "ptchar"        { $fixedType = "IntPtr" }              # keep IntPtr due to TCHAR ambiguity
                    "tbyte"         { $fixedType = "byte" }
                    "ptbyte"        { $fixedType = "IntPtr" }
                    "ptstr"         { $fixedType = "IntPtr" }
                    "lptstr"        { $fixedType = "IntPtr" }
                    "pctstr"        { $fixedType = "IntPtr" }
                    "lpctstr"       { $fixedType = "IntPtr" }
                    "putstr"        { $fixedType = "IntPtr" }
                    "lputstr"       { $fixedType = "IntPtr" }
                    "pcutstr"       { $fixedType = "IntPtr" }
                    "lpcutstr"      { $fixedType = "IntPtr" }
                    "pzptstr"       { $fixedType = "IntPtr" }
                    "pzzstr"        { $fixedType = "IntPtr" }
                    "pczztstr"      { $fixedType = "IntPtr" }
                    "pzzwstr"       { $fixedType = "string" }             # Unicode string
                    "pczzwstr"      { $fixedType = "string" }
                }
                # Reconstruct the parameter string with the fixed type and optional modifier
                $formattedParam = "$fixedType $name"
                if (-not [STRING]::IsNullOrEmpty($modifier)) {
                    $formattedParam = "$modifier $formattedParam"
                }
                $allParams.Add($formattedParam)
            } else {
                # If the parameter couldn't be parsed, add it as is
                $allParams.Add($param)
            }
        }
    }
    
    # Join all processed parameters with a comma and add indentation for readability
    $Params = $allParams -join ("," + "`n" + " " * 10)

    return $Params
}
function Process-ReturnType {
    param (
        [Parameter(Mandatory=$true)]
        [ValidateNotNullOrEmpty()]
        [string]$ReturnType
    )

    $fixedReturnType = $ReturnType

    switch ($ReturnType.ToLowerInvariant()) {
        
        # Void
        "void"           { $fixedReturnType = "void" }

        # Fully qualified .NET types
        "system.boolean" { $fixedReturnType = "bool" }
        "system.byte"    { $fixedReturnType = "byte" }
        "system.char"    { $fixedReturnType = "char" }
        "system.decimal" { $fixedReturnType = "decimal" }
        "system.double"  { $fixedReturnType = "double" }
        "system.int16"   { $fixedReturnType = "short" }
        "system.int32"   { $fixedReturnType = "int" }
        "system.int64"   { $fixedReturnType = "long" }
        "system.intptr"  { $fixedReturnType = "IntPtr" }
        "system.object"  { $fixedReturnType = "object" }
        "system.sbyte"   { $fixedReturnType = "sbyte" }
        "system.single"  { $fixedReturnType = "float" }
        "system.string"  { $fixedReturnType = "string" }
        "system.uint16"  { $fixedReturnType = "ushort" }
        "system.uint32"  { $fixedReturnType = "uint" }
        "system.uint64"  { $fixedReturnType = "ulong" }
        "system.uintptr" { $fixedReturnType = "UIntPtr" }

        # Alternate type spellings and aliases
        "boolean"        { $fixedReturnType = "bool" }
        "dword32"        { $fixedReturnType = "uint" }
        "dword64"        { $fixedReturnType = "ulong" }
        "int16"          { $fixedReturnType = "short" }
        "int32"          { $fixedReturnType = "int" }
        "int64"          { $fixedReturnType = "long" }
        "single"         { $fixedReturnType = "float" }
        "uint16"         { $fixedReturnType = "ushort" }
        "uint32"         { $fixedReturnType = "uint" }
        "uint64"         { $fixedReturnType = "ulong" }

        # --- Additional C/C++ & WinAPI aliases ---
        "double"         { $fixedReturnType = "double" }
        "float"          { $fixedReturnType = "float" }
        "long"           { $fixedReturnType = "long" }
        "longlong"       { $fixedReturnType = "long" }
        "tchar"          { $fixedReturnType = "char" }
        "uchar"          { $fixedReturnType = "byte" }
        "ulong"          { $fixedReturnType = "ulong" }
        "ulonglong"      { $fixedReturnType = "ulong" }
        "short"          { $fixedReturnType = "short" }
        "ushort"         { $fixedReturnType = "ushort" }

        # --- Additional typedefs ---
        "atom"           { $fixedReturnType = "ushort" }
        "dword_ptr"      { $fixedReturnType = "UIntPtr" }
        "dwordlong"      { $fixedReturnType = "ulong" }
        "farproc"        { $fixedReturnType = "IntPtr" }
        "hhook"          { $fixedReturnType = "IntPtr" }
        "hresult"        { $fixedReturnType = "int" }
        "NTSTATUS"       { $fixedReturnType = "Int32" }
        "int_ptr"        { $fixedReturnType = "IntPtr" }
        "intptr_t"       { $fixedReturnType = "IntPtr" }
        "long_ptr"       { $fixedReturnType = "IntPtr" }
        "lpbyte"         { $fixedReturnType = "IntPtr" }
        "lpdword"        { $fixedReturnType = "IntPtr" }
        "lparam"         { $fixedReturnType = "IntPtr" }
        "pcstr"          { $fixedReturnType = "IntPtr" }
        "pcwstr"         { $fixedReturnType = "IntPtr" }
        "pstr"           { $fixedReturnType = "IntPtr" }
        "pwstr"          { $fixedReturnType = "IntPtr" }
        "uint_ptr"       { $fixedReturnType = "UIntPtr" }
        "uintptr_t"      { $fixedReturnType = "UIntPtr" }
        "wparam"         { $fixedReturnType = "UIntPtr" }

        # C# built-in types
        "bool"           { $fixedReturnType = "bool" }
        "byte"           { $fixedReturnType = "byte" }
        "char"           { $fixedReturnType = "char" }
        "decimal"        { $fixedReturnType = "decimal" }
        "int"            { $fixedReturnType = "int" }
        "intptr"         { $fixedReturnType = "IntPtr" }
        "nint"           { $fixedReturnType = "nint" }
        "nuint"          { $fixedReturnType = "nuint" }
        "object"         { $fixedReturnType = "object" }
        "sbyte"          { $fixedReturnType = "sbyte" }
        "string"         { $fixedReturnType = "string" }
        "uint"           { $fixedReturnType = "uint" }
        "uintptr"        { $fixedReturnType = "UIntPtr" }

        # Common WinAPI handle types
        "hbitmap"        { $fixedReturnType = "IntPtr" }
        "hbrush"         { $fixedReturnType = "IntPtr" }
        "hcurs"          { $fixedReturnType = "IntPtr" }
        "hdc"            { $fixedReturnType = "IntPtr" }
        "hfont"          { $fixedReturnType = "IntPtr" }
        "hicon"          { $fixedReturnType = "IntPtr" }
        "hmenu"          { $fixedReturnType = "IntPtr" }
        "hpen"           { $fixedReturnType = "IntPtr" }
        "hrgn"           { $fixedReturnType = "IntPtr" }

        # Pointer-based aliases
        "pbyte"          { $fixedReturnType = "IntPtr" }
        "pchar"          { $fixedReturnType = "IntPtr" }
        "pdword"         { $fixedReturnType = "IntPtr" }
        "pint"           { $fixedReturnType = "IntPtr" }
        "plong"          { $fixedReturnType = "IntPtr" }
        "puint"          { $fixedReturnType = "IntPtr" }
        "pulong"         { $fixedReturnType = "IntPtr" }
        "pvoid"          { $fixedReturnType = "IntPtr" }
        "lpvoid"         { $fixedReturnType = "IntPtr" }

        # Special types
        "guid"           { $fixedReturnType = "Guid" }

        # Windows/WinAPI types (common aliases)
        "dword"          { $fixedReturnType = "uint" }
        "handle"         { $fixedReturnType = "IntPtr" }
        "hinstance"      { $fixedReturnType = "IntPtr" }
        "hmodule"        { $fixedReturnType = "IntPtr" }
        "hwnd"           { $fixedReturnType = "IntPtr" }
        "ptr"            { $fixedReturnType = "IntPtr" }
        "size_t"         { $fixedReturnType = "UIntPtr" }
        "ssize_t"        { $fixedReturnType = "IntPtr" }
        "void*"          { $fixedReturnType = "IntPtr" }
        "word"           { $fixedReturnType = "ushort" }
        "phandle"        { $fixedReturnType = "IntPtr" }
        "lresult"        { $fixedReturnType = "IntPtr" }                  

        # STRSAFE typedefs
        "strsafe_lpstr"       { $fixedReturnType = "string" }       # ANSI
        "strsafe_lpcstr"      { $fixedReturnType = "string" }       # ANSI
        "strsafe_lpwstr"      { $fixedReturnType = "string" }       # Unicode
        "strsafe_lpcwstr"     { $fixedReturnType = "string" }       # Unicode
        "strsafe_lpcuwstr"    { $fixedReturnType = "string" }       # Unicode
        "strsafe_pcnzch"      { $fixedReturnType = "string" }       # ANSI char
        "strsafe_pcnzwch"     { $fixedReturnType = "string" }       # Unicode wchar
        "strsafe_pcunzwch"    { $fixedReturnType = "string" }       # Unicode wchar

        # Wide-character (Unicode) types
        "lpcstr"        { $fixedReturnType = "string" }             # ANSI string
        "lpcwstr"       { $fixedReturnType = "string" }             # Unicode string
        "lpstr"         { $fixedReturnType = "string" }             # ANSI string
        "lpwstr"        { $fixedReturnType = "string" }             # Unicode string
        "pstring"       { $fixedReturnType = "string" }             # ANSI string (likely)
        "pwchar"        { $fixedReturnType = "string" }             # Unicode char*
        "lpwchar"       { $fixedReturnType = "string" }             # Unicode char*
        "pczpwstr"      { $fixedReturnType = "string" }             # Unicode string
        "pzpwstr"       { $fixedReturnType = "string" }
        "pzwstr"        { $fixedReturnType = "string" }
        "pzzwstr"       { $fixedReturnType = "string" }
        "pczzwstr"      { $fixedReturnType = "string" }
        "puczzwstr"     { $fixedReturnType = "string" }
        "pcuczzwstr"    { $fixedReturnType = "string" }
        "pnzwch"        { $fixedReturnType = "string" }
        "pcnzwch"       { $fixedReturnType = "string" }
        "punzwch"       { $fixedReturnType = "string" }
        "pcunzwch"      { $fixedReturnType = "string" }

        # ANSI string types
        "npstr"         { $fixedReturnType = "string" }             # ANSI string
        "pzpcstr"       { $fixedReturnType = "string" }
        "pczpcstr"      { $fixedReturnType = "string" }
        "pzzstr"        { $fixedReturnType = "string" }
        "pczzstr"       { $fixedReturnType = "string" }
        "pnzch"         { $fixedReturnType = "string" }
        "pcnzch"        { $fixedReturnType = "string" }

        # UCS types
        "ucschar"       { $fixedReturnType = "uint" }               # leave as uint
        "pucschar"      { $fixedReturnType = "IntPtr" }
        "pcucschar"     { $fixedReturnType = "IntPtr" }
        "puucschar"     { $fixedReturnType = "IntPtr" }
        "pcuucschar"    { $fixedReturnType = "IntPtr" }
        "pucsstr"       { $fixedReturnType = "IntPtr" }
        "pcucsstr"      { $fixedReturnType = "IntPtr" }
        "puucsstr"      { $fixedReturnType = "IntPtr" }
        "pcuucsstr"     { $fixedReturnType = "IntPtr" }

        # Neutral ANSI/Unicode (TCHAR-based) Types
        "ptchar"        { $fixedReturnType = "IntPtr" }              # keep IntPtr due to TCHAR ambiguity
        "tbyte"         { $fixedReturnType = "byte" }
        "ptbyte"        { $fixedReturnType = "IntPtr" }
        "ptstr"         { $fixedReturnType = "IntPtr" }
        "lptstr"        { $fixedReturnType = "IntPtr" }
        "pctstr"        { $fixedReturnType = "IntPtr" }
        "lpctstr"       { $fixedReturnType = "IntPtr" }
        "putstr"        { $fixedReturnType = "IntPtr" }
        "lputstr"       { $fixedReturnType = "IntPtr" }
        "pcutstr"       { $fixedReturnType = "IntPtr" }
        "lpcutstr"      { $fixedReturnType = "IntPtr" }
        "pzptstr"       { $fixedReturnType = "IntPtr" }
        "pzzstr"        { $fixedReturnType = "IntPtr" }
        "pczztstr"      { $fixedReturnType = "IntPtr" }
        "pzzwstr"       { $fixedReturnType = "string" }             # Unicode string
        "pczzwstr"      { $fixedReturnType = "string" }
    }

    return $fixedReturnType
}
function Invoke-Object {
    [CmdletBinding()]
    param (
        [Parameter(Mandatory, ValueFromPipeline)]
        $Interface,

        [Parameter(ValueFromRemainingArguments = $true)]
        [object[]]$Params,

        [Parameter(Mandatory)]
        [ValidateSet("API", "COM")]
        [string]$type
    )
    [int]$count = 0
    [void][Int]::TryParse($Params.Count, [ref]$count)
    
    $sb = New-Object System.Text.StringBuilder
    if ($type -eq 'COM') {
        if ($count -gt 0) {
            [void]$sb.Append('$Interface.IUnknownPtr,')
        } else {
            [void]$sb.Append('$Interface.IUnknownPtr')
        }
    }
    if ($count -gt 0) {
        for ($i = 0; $i -lt $count; $i++) {
            if ($i -gt 0) {
                [void]$sb.Append(',')
            }
            [void]$sb.Append("`$Params[$i]")
        }
    }

    $argsString = $sb.ToString()
    return & (
        [scriptblock]::Create("`$Interface.DelegateInstance.Invoke($argsString)")
    )
}
function Get-SysCallData {
    [CmdletBinding()]
    param (
        [Parameter(Mandatory = $true)]
        [string]$DllName,

        [Parameter(Mandatory = $true)]
        [string]$FunctionName,

        [Parameter(Mandatory = $true)]
        [int]$BytesToRead
    )

if (!([PSTypeName]'PE').Type) {
$code = @"
using System;
using System.Runtime.InteropServices;

public class PE
{
    [Flags]
    public enum IMAGE_DOS_SIGNATURE : ushort
    {
        DOS_SIGNATURE = 0x5A4D, // MZ
        OS2_SIGNATURE = 0x454E, // NE
        OS2_SIGNATURE_LE = 0x454C, // LE
        VXD_SIGNATURE = 0x454C, // LE
    }
        
    [Flags]
    public enum IMAGE_NT_SIGNATURE : uint
    {
        VALID_PE_SIGNATURE = 0x00004550 // PE00
    }
        
    [Flags]
    public enum IMAGE_FILE_MACHINE : ushort
    {
        UNKNOWN = 0,
        I386 = 0x014c, // Intel 386.
        R3000 = 0x0162, // MIPS little-endian =0x160 big-endian
        R4000 = 0x0166, // MIPS little-endian
        R10000 = 0x0168, // MIPS little-endian
        WCEMIPSV2 = 0x0169, // MIPS little-endian WCE v2
        ALPHA = 0x0184, // Alpha_AXP
        SH3 = 0x01a2, // SH3 little-endian
        SH3DSP = 0x01a3,
        SH3E = 0x01a4, // SH3E little-endian
        SH4 = 0x01a6, // SH4 little-endian
        SH5 = 0x01a8, // SH5
        ARM = 0x01c0, // ARM Little-Endian
        THUMB = 0x01c2,
        ARMNT = 0x01c4, // ARM Thumb-2 Little-Endian
        AM33 = 0x01d3,
        POWERPC = 0x01F0, // IBM PowerPC Little-Endian
        POWERPCFP = 0x01f1,
        IA64 = 0x0200, // Intel 64
        MIPS16 = 0x0266, // MIPS
        ALPHA64 = 0x0284, // ALPHA64
        MIPSFPU = 0x0366, // MIPS
        MIPSFPU16 = 0x0466, // MIPS
        AXP64 = ALPHA64,
        TRICORE = 0x0520, // Infineon
        CEF = 0x0CEF,
        EBC = 0x0EBC, // EFI public byte Code
        AMD64 = 0x8664, // AMD64 (K8)
        M32R = 0x9041, // M32R little-endian
        CEE = 0xC0EE
    }
        
    [Flags]
    public enum IMAGE_FILE_CHARACTERISTICS : ushort
    {
        IMAGE_RELOCS_STRIPPED = 0x0001, // Relocation info stripped from file.
        IMAGE_EXECUTABLE_IMAGE = 0x0002, // File is executable (i.e. no unresolved external references).
        IMAGE_LINE_NUMS_STRIPPED = 0x0004, // Line nunbers stripped from file.
        IMAGE_LOCAL_SYMS_STRIPPED = 0x0008, // Local symbols stripped from file.
        IMAGE_AGGRESIVE_WS_TRIM = 0x0010, // Agressively trim working set
        IMAGE_LARGE_ADDRESS_AWARE = 0x0020, // App can handle >2gb addresses
        IMAGE_REVERSED_LO = 0x0080, // public bytes of machine public ushort are reversed.
        IMAGE_32BIT_MACHINE = 0x0100, // 32 bit public ushort machine.
        IMAGE_DEBUG_STRIPPED = 0x0200, // Debugging info stripped from file in .DBG file
        IMAGE_REMOVABLE_RUN_FROM_SWAP = 0x0400, // If Image is on removable media =copy and run from the swap file.
        IMAGE_NET_RUN_FROM_SWAP = 0x0800, // If Image is on Net =copy and run from the swap file.
        IMAGE_SYSTEM = 0x1000, // System File.
        IMAGE_DLL = 0x2000, // File is a DLL.
        IMAGE_UP_SYSTEM_ONLY = 0x4000, // File should only be run on a UP machine
        IMAGE_REVERSED_HI = 0x8000 // public bytes of machine public ushort are reversed.
    }
        
    [Flags]
    public enum IMAGE_NT_OPTIONAL_HDR_MAGIC : ushort
    {
        PE32 = 0x10b,
        PE64 = 0x20b
    }
        
    [Flags]
    public enum IMAGE_SUBSYSTEM : ushort
    {
        UNKNOWN = 0, // Unknown subsystem.
        NATIVE = 1, // Image doesn't require a subsystem.
        WINDOWS_GUI = 2, // Image runs in the Windows GUI subsystem.
        WINDOWS_CUI = 3, // Image runs in the Windows character subsystem.
        OS2_CUI = 5, // image runs in the OS/2 character subsystem.
        POSIX_CUI = 7, // image runs in the Posix character subsystem.
        NATIVE_WINDOWS = 8, // image is a native Win9x driver.
        WINDOWS_CE_GUI = 9, // Image runs in the Windows CE subsystem.
        EFI_APPLICATION = 10,
        EFI_BOOT_SERVICE_DRIVER = 11,
        EFI_RUNTIME_DRIVER = 12,
        EFI_ROM = 13,
        XBOX = 14,
        WINDOWS_BOOT_APPLICATION = 16
    }
        
    [Flags]
    public enum IMAGE_DLLCHARACTERISTICS : ushort
    {
        DYNAMIC_BASE = 0x0040, // DLL can move.
        FORCE_INTEGRITY = 0x0080, // Code Integrity Image
        NX_COMPAT = 0x0100, // Image is NX compatible
        NO_ISOLATION = 0x0200, // Image understands isolation and doesn't want it
        NO_SEH = 0x0400, // Image does not use SEH. No SE handler may reside in this image
        NO_BIND = 0x0800, // Do not bind this image.
        WDM_DRIVER = 0x2000, // Driver uses WDM model
        TERMINAL_SERVER_AWARE = 0x8000
    }
        
    [Flags]
    public enum IMAGE_SCN : uint
    {
        TYPE_NO_PAD = 0x00000008, // Reserved.
        CNT_CODE = 0x00000020, // Section contains code.
        CNT_INITIALIZED_DATA = 0x00000040, // Section contains initialized data.
        CNT_UNINITIALIZED_DATA = 0x00000080, // Section contains uninitialized data.
        LNK_INFO = 0x00000200, // Section contains comments or some other type of information.
        LNK_REMOVE = 0x00000800, // Section contents will not become part of image.
        LNK_COMDAT = 0x00001000, // Section contents comdat.
        NO_DEFER_SPEC_EXC = 0x00004000, // Reset speculative exceptions handling bits in the TLB entries for this section.
        GPREL = 0x00008000, // Section content can be accessed relative to GP
        MEM_FARDATA = 0x00008000,
        MEM_PURGEABLE = 0x00020000,
        MEM_16BIT = 0x00020000,
        MEM_LOCKED = 0x00040000,
        MEM_PRELOAD = 0x00080000,
        ALIGN_1BYTES = 0x00100000,
        ALIGN_2BYTES = 0x00200000,
        ALIGN_4BYTES = 0x00300000,
        ALIGN_8BYTES = 0x00400000,
        ALIGN_16BYTES = 0x00500000, // Default alignment if no others are specified.
        ALIGN_32BYTES = 0x00600000,
        ALIGN_64BYTES = 0x00700000,
        ALIGN_128BYTES = 0x00800000,
        ALIGN_256BYTES = 0x00900000,
        ALIGN_512BYTES = 0x00A00000,
        ALIGN_1024BYTES = 0x00B00000,
        ALIGN_2048BYTES = 0x00C00000,
        ALIGN_4096BYTES = 0x00D00000,
        ALIGN_8192BYTES = 0x00E00000,
        ALIGN_MASK = 0x00F00000,
        LNK_NRELOC_OVFL = 0x01000000, // Section contains extended relocations.
        MEM_DISCARDABLE = 0x02000000, // Section can be discarded.
        MEM_NOT_CACHED = 0x04000000, // Section is not cachable.
        MEM_NOT_PAGED = 0x08000000, // Section is not pageable.
        MEM_SHARED = 0x10000000, // Section is shareable.
        MEM_EXECUTE = 0x20000000, // Section is executable.
        MEM_READ = 0x40000000, // Section is readable.
        MEM_WRITE = 0x80000000 // Section is writeable.
    }
    
    [StructLayout(LayoutKind.Sequential, Pack=1)]
    public struct _IMAGE_DOS_HEADER
    {
        public IMAGE_DOS_SIGNATURE e_magic; // Magic number
        public ushort e_cblp; // public bytes on last page of file
        public ushort e_cp; // Pages in file
        public ushort e_crlc; // Relocations
        public ushort e_cparhdr; // Size of header in paragraphs
        public ushort e_minalloc; // Minimum extra paragraphs needed
        public ushort e_maxalloc; // Maximum extra paragraphs needed
        public ushort e_ss; // Initial (relative) SS value
        public ushort e_sp; // Initial SP value
        public ushort e_csum; // Checksum
        public ushort e_ip; // Initial IP value
        public ushort e_cs; // Initial (relative) CS value
        public ushort e_lfarlc; // File address of relocation table
        public ushort e_ovno; // Overlay number
        [MarshalAs(UnmanagedType.ByValTStr, SizeConst = 8)]
        public string e_res; // This will contain 'Detours!' if patched in memory
        public ushort e_oemid; // OEM identifier (for e_oeminfo)
        public ushort e_oeminfo; // OEM information; e_oemid specific
        [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst=10)] // , ArraySubType=UnmanagedType.U4
        public ushort[] e_res2; // Reserved public ushorts
        public int e_lfanew; // File address of new exe header
    }
        
    [StructLayout(LayoutKind.Sequential, Pack=1)]
    public struct _IMAGE_FILE_HEADER
    {
        public IMAGE_FILE_MACHINE Machine;
        public ushort NumberOfSections;
        public uint TimeDateStamp;
        public uint PointerToSymbolTable;
        public uint NumberOfSymbols;
        public ushort SizeOfOptionalHeader;
        public IMAGE_FILE_CHARACTERISTICS Characteristics;
    }
        
    [StructLayout(LayoutKind.Sequential, Pack=1)]
    public struct _IMAGE_NT_HEADERS32
    {
        public IMAGE_NT_SIGNATURE Signature;
        public _IMAGE_FILE_HEADER FileHeader;
        public _IMAGE_OPTIONAL_HEADER32 OptionalHeader;
    }
        
    [StructLayout(LayoutKind.Sequential, Pack=1)]
    public struct _IMAGE_NT_HEADERS64
    {
        public IMAGE_NT_SIGNATURE Signature;
        public _IMAGE_FILE_HEADER FileHeader;
        public _IMAGE_OPTIONAL_HEADER64 OptionalHeader;
    }
        
    [StructLayout(LayoutKind.Sequential, Pack=1)]
    public struct _IMAGE_OPTIONAL_HEADER32
    {
        public IMAGE_NT_OPTIONAL_HDR_MAGIC Magic;
        public byte MajorLinkerVersion;
        public byte MinorLinkerVersion;
        public uint SizeOfCode;
        public uint SizeOfInitializedData;
        public uint SizeOfUninitializedData;
        public uint AddressOfEntryPoint;
        public uint BaseOfCode;
        public uint BaseOfData;
        public uint ImageBase;
        public uint SectionAlignment;
        public uint FileAlignment;
        public ushort MajorOperatingSystemVersion;
        public ushort MinorOperatingSystemVersion;
        public ushort MajorImageVersion;
        public ushort MinorImageVersion;
        public ushort MajorSubsystemVersion;
        public ushort MinorSubsystemVersion;
        public uint Win32VersionValue;
        public uint SizeOfImage;
        public uint SizeOfHeaders;
        public uint CheckSum;
        public IMAGE_SUBSYSTEM Subsystem;
        public IMAGE_DLLCHARACTERISTICS DllCharacteristics;
        public uint SizeOfStackReserve;
        public uint SizeOfStackCommit;
        public uint SizeOfHeapReserve;
        public uint SizeOfHeapCommit;
        public uint LoaderFlags;
        public uint NumberOfRvaAndSizes;
        [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst=16)]
        public _IMAGE_DATA_DIRECTORY[] DataDirectory;
    }
        
    [StructLayout(LayoutKind.Sequential, Pack=1)]
    public struct _IMAGE_OPTIONAL_HEADER64
    {
        public IMAGE_NT_OPTIONAL_HDR_MAGIC Magic;
        public byte MajorLinkerVersion;
        public byte MinorLinkerVersion;
        public uint SizeOfCode;
        public uint SizeOfInitializedData;
        public uint SizeOfUninitializedData;
        public uint AddressOfEntryPoint;
        public uint BaseOfCode;
        public ulong ImageBase;
        public uint SectionAlignment;
        public uint FileAlignment;
        public ushort MajorOperatingSystemVersion;
        public ushort MinorOperatingSystemVersion;
        public ushort MajorImageVersion;
        public ushort MinorImageVersion;
        public ushort MajorSubsystemVersion;
        public ushort MinorSubsystemVersion;
        public uint Win32VersionValue;
        public uint SizeOfImage;
        public uint SizeOfHeaders;
        public uint CheckSum;
        public IMAGE_SUBSYSTEM Subsystem;
        public IMAGE_DLLCHARACTERISTICS DllCharacteristics;
        public ulong SizeOfStackReserve;
        public ulong SizeOfStackCommit;
        public ulong SizeOfHeapReserve;
        public ulong SizeOfHeapCommit;
        public uint LoaderFlags;
        public uint NumberOfRvaAndSizes;
        [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst=16)]
        public _IMAGE_DATA_DIRECTORY[] DataDirectory;
    }
        
    [StructLayout(LayoutKind.Sequential, Pack=1)]
    public struct _IMAGE_DATA_DIRECTORY
    {
        public uint VirtualAddress;
        public uint Size;
    }
        
    [StructLayout(LayoutKind.Sequential, Pack=1)]
    public struct _IMAGE_EXPORT_DIRECTORY
    {
        public uint Characteristics;
        public uint TimeDateStamp;
        public ushort MajorVersion;
        public ushort MinorVersion;
        public uint Name;
        public uint Base;
        public uint NumberOfFunctions;
        public uint NumberOfNames;
        public uint AddressOfFunctions; // RVA from base of image
        public uint AddressOfNames; // RVA from base of image
        public uint AddressOfNameOrdinals; // RVA from base of image
    }
       
    [StructLayout(LayoutKind.Sequential, Pack=1)]
    public struct _IMAGE_SECTION_HEADER
    {
        [MarshalAs(UnmanagedType.ByValTStr, SizeConst = 8)]
        public string Name;
        public uint VirtualSize;
        public uint VirtualAddress;
        public uint SizeOfRawData;
        public uint PointerToRawData;
        public uint PointerToRelocations;
        public uint PointerToLinenumbers;
        public ushort NumberOfRelocations;
        public ushort NumberOfLinenumbers;
        public IMAGE_SCN Characteristics;
    }
        
    [StructLayout(LayoutKind.Sequential, Pack=1)]
    public struct _IMAGE_IMPORT_DESCRIPTOR
    {
        public uint OriginalFirstThunk; // RVA to original unbound IAT (PIMAGE_THUNK_DATA)
        public uint TimeDateStamp; // 0 if not bound,
                                            // -1 if bound, and real date/time stamp
                                            // in IMAGE_DIRECTORY_ENTRY_BOUND_IMPORT (new BIND)
                                            // O.W. date/time stamp of DLL bound to (Old BIND)
        public uint ForwarderChain; // -1 if no forwarders
        public uint Name;
        public uint FirstThunk; // RVA to IAT (if bound this IAT has actual addresses)
    }

    [StructLayout(LayoutKind.Sequential, Pack=1)]
    public struct _IMAGE_THUNK_DATA32
    {
        public Int32 AddressOfData; // PIMAGE_IMPORT_BY_NAME
    }

    [StructLayout(LayoutKind.Sequential, Pack=1)]
    public struct _IMAGE_THUNK_DATA64
    {
        public Int64 AddressOfData; // PIMAGE_IMPORT_BY_NAME
    }
        
    [StructLayout(LayoutKind.Sequential, Pack=1)]
    public struct _IMAGE_IMPORT_BY_NAME
    {
        public ushort Hint;
        public char Name;
    }
}
"@

$compileParams = New-Object System.CodeDom.Compiler.CompilerParameters
$compileParams.ReferencedAssemblies.AddRange(@('System.dll', 'mscorlib.dll'))
$compileParams.GenerateInMemory = $True
Add-Type -TypeDefinition $code -CompilerParameters $compileParams -PassThru -WarningAction SilentlyContinue | Out-Null
}
function Convert-RVAToFileOffset([int]$Rva, [PSObject[]]$SectionHeaders) {
    foreach ($Section in $SectionHeaders) {
        if ($Rva -ge $Section.VirtualAddress -and $Rva -lt ($Section.VirtualAddress + $Section.VirtualSize)) {
            return $Rva - $Section.VirtualAddress + $Section.PointerToRawData
        }
    }
    return $Rva
}

    $DllPath = Join-Path -Path $env:windir -ChildPath "System32\$DllName"

    if (-not (Test-Path $DllPath)) {
        Write-Error "DLL file not found at: $DllPath"
        return $null
    }

    $FileByteArray = [System.IO.File]::ReadAllBytes($DllPath)
    $Handle = [GCHandle]::Alloc($FileByteArray, 'Pinned')
    $PEBaseAddr = $Handle.AddrOfPinnedObject()

    try {
        # Parse DOS header
        $DosHeader = [Marshal]::PtrToStructure($PEBaseAddr, [Type] [PE+_IMAGE_DOS_HEADER])
        $PointerNtHeader = [IntPtr]($PEBaseAddr.ToInt64() + $DosHeader.e_lfanew)

        # Detect architecture
        $NtHeader32 = [Marshal]::PtrToStructure($PointerNtHeader, [Type] [PE+_IMAGE_NT_HEADERS32])
        $Architecture = $NtHeader32.FileHeader.Machine.ToString()
        $PEStruct = @{}

        if ($Architecture -eq 'AMD64') {
            $PEStruct['NT_HEADER'] = [PE+_IMAGE_NT_HEADERS64]
        } elseif ($Architecture -eq 'I386') {
            $PEStruct['NT_HEADER'] = [PE+_IMAGE_NT_HEADERS32]
        } else {
            Write-Error "Unsupported architecture: $Architecture"
            return $null
        }

        # Parse correct NT header
        $NtHeader = [Marshal]::PtrToStructure($PointerNtHeader, [Type] $PEStruct['NT_HEADER'])
        $NumSections = $NtHeader.FileHeader.NumberOfSections

        # Parse section headers
        $PointerSectionHeader = [IntPtr] ($PointerNtHeader.ToInt64() + [Marshal]::SizeOf([Type] $PEStruct['NT_HEADER']))
        $SectionHeaders = New-Object PSObject[]($NumSections)
        for ($i = 0; $i -lt $NumSections; $i++) {
            $SectionHeaders[$i] = [Marshal]::PtrToStructure(
                [IntPtr]($PointerSectionHeader.ToInt64() + ($i * [Marshal]::SizeOf([Type] [PE+_IMAGE_SECTION_HEADER]))),
                [Type] [PE+_IMAGE_SECTION_HEADER]
            )
        }

        # Check for exports
        if ($NtHeader.OptionalHeader.DataDirectory[0].VirtualAddress -eq 0) {
            Write-Error "Module does not contain any exports."
            return $null
        }

        # Get Export Directory
        $ExportDirRVA = $NtHeader.OptionalHeader.DataDirectory[0].VirtualAddress
        $ExportDirOffset = Convert-RVAToFileOffset -Rva $ExportDirRVA -SectionHeaders $SectionHeaders
        $ExportDirectory = [Marshal]::PtrToStructure(
            [IntPtr]($PEBaseAddr.ToInt64() + $ExportDirOffset),
            [Type] [PE+_IMAGE_EXPORT_DIRECTORY]
        )

        # Export table pointers
        $AddressOfNamesOffset        = Convert-RVAToFileOffset -Rva $ExportDirectory.AddressOfNames        -SectionHeaders $SectionHeaders
        $AddressOfNameOrdinalsOffset = Convert-RVAToFileOffset -Rva $ExportDirectory.AddressOfNameOrdinals -SectionHeaders $SectionHeaders
        $AddressOfFunctionsOffset    = Convert-RVAToFileOffset -Rva $ExportDirectory.AddressOfFunctions    -SectionHeaders $SectionHeaders

        # Loop through exported names to find the function
        for ($i = 0; $i -lt $ExportDirectory.NumberOfNames; $i++) {
            $nameRVA = [Marshal]::ReadInt32([IntPtr]($PEBaseAddr.ToInt64() + $AddressOfNamesOffset + ($i * 4)))
            $funcNameOffset = Convert-RVAToFileOffset -Rva $nameRVA -SectionHeaders $SectionHeaders
            $funcName = [Marshal]::PtrToStringAnsi([IntPtr]($PEBaseAddr.ToInt64() + $funcNameOffset))

            if ($funcName -eq $FunctionName) {
                $ordinal = [Marshal]::ReadInt16([IntPtr]($PEBaseAddr.ToInt64() + $AddressOfNameOrdinalsOffset + ($i * 2)))
                $funcRVA = [Marshal]::ReadInt32([IntPtr]($PEBaseAddr.ToInt64() + $AddressOfFunctionsOffset + ($ordinal * 4)))

                # Skip forwarded exports
                if ($funcRVA -ge $ExportDirRVA -and $funcRVA -lt ($ExportDirRVA + $NtHeader.OptionalHeader.DataDirectory[0].Size)) {
                    Write-Error "Function '$FunctionName' is a forwarded export and cannot be read."
                    return $null
                }

                # Get file offset and extract bytes
                $funcFileOffset = Convert-RVAToFileOffset -Rva $funcRVA -SectionHeaders $SectionHeaders
                if ($funcFileOffset -ge $FileByteArray.Length) {
                    Write-Error "Function RVA points outside the file. Cannot read bytes."
                    return $null
                }

                $bytesAvailable = $FileByteArray.Length - $funcFileOffset
                if ($BytesToRead -gt $bytesAvailable) {
                    $BytesToRead = $bytesAvailable
                    Write-Warning "Read would go beyond file size. Reading to end of file ($BytesToRead bytes)."
                }

                $funcBytes = $FileByteArray[$funcFileOffset..($funcFileOffset + $BytesToRead - 1)]
                return $funcBytes
            }
        }

        Write-Error "Function '$FunctionName' not found in DLL."
        return $null
    } finally {
        $Handle.Free()
    }
}

<#

     *********************

     !Managed Com Warper.!
      -  Example code. -

     *********************

# netlistmgr.h
# https://raw.githubusercontent.com/nihon-tc/Rtest/refs/heads/master/header/Microsoft%20SDKs/Windows/v7.0A/Include/netlistmgr.h

# get_IsConnectedToInternet 
# https://learn.microsoft.com/en-us/windows/win32/api/netlistmgr/nf-netlistmgr-inetworklistmanager-get_isconnectedtointernet

-------------------------------

Clear-host
write-host "`n`nCLSID & Propertie's [Test]`nDCB00C01-570F-4A9B-8D69-199FDBA5723B->Default->IsConnected,IsConnectedToInternet`n"
$NetObj = "DCB00C01-570F-4A9B-8D69-199FDBA5723B" | Initialize-ComObject
write-host "IsConnected: $($NetObj.IsConnected)"
write-host "IsConnectedToInternet: $($NetObj.IsConnectedToInternet)"
$NetObj | Release-ComObject

-------------------------------

Clear-host
write-host "`n`nIEnumerator & Params\values [Test]`nDCB00C01-570F-4A9B-8D69-199FDBA5723B->DCB00000-570F-4A9B-8D69-199FDBA5723B->GetNetwork`n"
[intPtr]$ppEnumNetwork = [intPtr]::Zero
Use-ComInterface `
    -CLSID "DCB00C01-570F-4A9B-8D69-199FDBA5723B" `
    -IID "DCB00000-570F-4A9B-8D69-199FDBA5723B" `
    -Index 1 `
    -Name "GetNetwork" `
    -Return "uint" `
    -Params 'system.UINT32 Flags, out INTPTR ppEnumNetwork' `
    -Values @(1, [ref]$ppEnumNetwork)

if ($ppEnumNetwork -ne [IntPtr]::Zero) {
    $networkList = $ppEnumNetwork | Receive-ComObject
    foreach ($network in $networkList) {
        "Name: $($network.GetName()), IsConnected: $($network.IsConnected())"
    }
    $networkList | Release-ComObject
}

-------------------------------

Clear-host
write-host "`n`nVoid & No Return [Test]`n17CCA47D-DAE5-4E4A-AC42-CC54E28F334A->f2dcb80d-0670-44bc-9002-cd18688730af->ShowProductKeyUI`n"
Use-ComInterface `
    -CLSID "17CCA47D-DAE5-4E4A-AC42-CC54E28F334A" `
    -IID "f2dcb80d-0670-44bc-9002-cd18688730af" `
    -Index 3 `
    -Name "ShowProductKeyUI" `
    -Return "void"

-------------------------------

Clear-host
"ApiMajorVersion", "ApiMinorVersion", "ProductVersionString" | ForEach-Object {
    $name = $_
    $outVarPtr = New-Variant -Type VT_EMPTY
    $inVarPtr  = New-Variant -Type VT_BSTR -Value $name
    try {
        $ret = Use-ComInterface `
            -CLSID "C2E88C2F-6F5B-4AAA-894B-55C847AD3A2D" `
            -IID "85713fa1-7796-4fa2-be3b-e2d6124dd373" `
            -Index 1 -Name "GetInfo" `
            -Values @($inVarPtr, $outVarPtr) `
            -Type IDispatch

        if ($ret -eq 0) {
            $value = Parse-Variant -variantPtr $outVarPtr
            Write-Host "$name -> $value"
        }

    } finally {
        Free-IntPtr -handle $inVarPtr  -Method VARIANT
        Free-IntPtr -handle $outVarPtr -Method VARIANT
    }
}

#>
function Build-ComInterfaceSpec {
    param (
        [Parameter(Mandatory = $true, Position = 1)]
        [ValidateNotNullOrEmpty()]
        [ValidatePattern('^[A-F0-9]{8}-([A-F0-9]{4}-){3}[A-F0-9]{12}$')]
        [string]$CLSID,

        [Parameter(Position = 2)]
        [string]$IID,

        [Parameter(Mandatory = $true, Position = 3)]
        [ValidateRange(1, [int]::MaxValue)]
        [int]$Index,

        [Parameter(Mandatory = $true, Position = 4)]
        [ValidateNotNullOrEmpty()]
        [string]$Name,

        [Parameter(Mandatory = $true, Position = 5)]
        [ValidateSet(
            # Void
            "void",

            # Fully qualified .NET types
            "system.boolean", "system.byte", "system.char", "system.decimal", "system.double",
            "system.int16", "system.int32", "system.int64", "system.intptr", "system.object",
            "system.sbyte", "system.single", "system.string", "system.uint16", "system.uint32",
            "system.uint64", "system.uintptr",

            # Alternate type spellings and aliases
            "boolean", "dword32", "dword64", "int16", "int32", "int64", "single", "uint16",
            "uint32", "uint64",

            # Additional C/C++ & WinAPI aliases
            "double", "float", "long", "longlong", "tchar", "uchar", "ulong", "ulonglong",
            "short", "ushort",

            # Additional typedefs
            "atom", "dword_ptr", "dwordlong", "farproc", "hhook", "hresult", "NTSTATUS",
            "int_ptr", "intptr_t", "long_ptr", "lpbyte", "lpdword", "lparam", "pcstr",
            "pcwstr", "pstr", "pwstr", "uint_ptr", "uintptr_t", "wparam",

            # C# built-in types
            "bool", "byte", "char", "decimal", "int", "intptr", "nint", "nuint", "object",
            "sbyte", "string", "uint", "uintptr",

            # Common WinAPI handle types
            "hbitmap", "hbrush", "hcurs", "hdc", "hfont", "hicon", "hmenu", "hpen", "hrgn",

            # Pointer-based aliases
            "pbyte", "pchar", "pdword", "pint", "plong", "puint", "pulong", "pvoid", "lpvoid",

            # Special types
            "guid",

            # Windows/WinAPI types (common aliases)
            "dword", "handle", "hinstance", "hmodule", "hwnd", "lpcstr", "lpcwstr", "lpstr",
            "lpwstr", "ptr", "size_t", "ssize_t", "void*", "word", "phandle", "lresult",

            # STRSAFE typedefs
            "strsafe_lpstr", "strsafe_lpcstr", "strsafe_lpwstr", "strsafe_lpcwstr",
            "strsafe_lpcuwstr", "strsafe_pcnzch", "strsafe_pcnzwch", "strsafe_pcunzwch",

            # Wide-character (Unicode) types
            "pstring", "pwchar", "lpwchar", "pczpwstr", "pzpwstr", "pzwstr", "pzzwstr",
            "pczzwstr", "puczzwstr", "pcuczzwstr", "pnzwch", "pcnzwch", "punzwch", "pcunzwch",

            # ANSI string types
            "npstr", "pzpcstr", "pczpcstr", "pzzstr", "pczzstr", "pnzch", "pcnzch",

            # UCS types
            "ucschar", "pucschar", "pcucschar", "puucschar", "pcuucschar", "pucsstr",
            "pcucsstr", "puucsstr", "pcuucsstr",

            # Neutral ANSI/Unicode (TCHAR-based) Types
            "ptchar", "tbyte", "ptbyte", "ptstr", "lptstr", "pctstr", "lpctstr", "putstr",
            "lputstr", "pcutstr", "lpcutstr", "pzptstr", "pzzstr", "pczztstr", "pzzwstr", "pczzwstr"
        )]
        [string]$Return,
        
        [Parameter(Position = 6)]
        [string]$Params,

        [Parameter(Position = 7)]
        [string]$InterFaceType,

        [Parameter(Position = 8)]
        [string]$CharSet
    )

    if (-not [string]::IsNullOrEmpty($IID)) {
        if (-not [regex]::Match($IID,'^[A-F0-9]{8}-([A-F0-9]{4}-){3}[A-F0-9]{12}$')){
            throw "ERROR: $IID not match ^[A-F0-9]{8}-([A-F0-9]{4}-){3}[A-F0-9]{12}$"
        }
    }

    # Create and return the interface specification object
    $interfaceSpec = [PSCustomObject]@{
        Index   = $Index
        Return  = $Return
        Name    = $Name
        Params  = if ($Params) { $Params } else { "" }
        CLSID   = $CLSID
        IID     = if ($IID) { $IID } else { "" }
        Type    = if ($InterFaceType) { $InterFaceType } else { "" }
        CharSet = $CharSet
    }

    return $interfaceSpec
}
function Build-ComDelegate {
    param (
        [Parameter(Mandatory=$true, ValueFromPipeline)]
        [PSCustomObject]$InterfaceSpec,

        [Parameter(Mandatory=$true)]
        [string]$UNIQUE_ID
    )

    # External function calls for Params and ReturnType
    $Params = Process-Parameters -InterfaceSpec $InterfaceSpec
    $fixedReturnType = Process-ReturnType -ReturnType $InterfaceSpec.Return
    $charSet = if ($InterfaceSpec.CharSet) { "CharSet = CharSet.$($InterfaceSpec.CharSet)" } else { "CharSet = CharSet.Unicode" }

    # Construct the delegate code template
    $Return = @"
    [UnmanagedFunctionPointer(CallingConvention.StdCall, $charSet)]
    public delegate $($fixedReturnType) $($UNIQUE_ID)(
        $($Params)
    );
"@

    # Define the C# namespace and using statements
    $namespace = "namespace DynamicDelegates"
    $using = "`nusing System;`nusing System.Runtime.InteropServices;`n"
    
    # Combine all parts to form the final C# code
    return "$using`n$namespace`n{`n$Return`n}`n"
}
function Initialize-ComObject {
    param (
        [Parameter(ValueFromPipeline, Position = 0)]
        [PSCustomObject]$InterfaceSpec,

        [Parameter(ValueFromPipeline, Position = 1)]
        [ValidatePattern('^[A-F0-9]{8}-([A-F0-9]{4}-){3}[A-F0-9]{12}$')]
        [GUID]$CLSID,

        [switch]
        $CreateInstance
    )

    if ($CLSID -and $InterfaceSpec -and $CLSID.ToString() -eq $InterfaceSpec) {
        $InterfaceSpec = $null
    }

    # Oppsite XOR Case, Validate it Not both
    if (-not ([bool]$InterfaceSpec -xor [bool]$CLSID)) {
        throw "Select CLSID OR $InterfaceSpec"
    }

    # ------ BASIC SETUP -------

    if ($InterfaceSpec) {
        $CLSID = [guid]$InterfaceSpec.CLSID
    }

    $comObj = [Activator]::CreateInstance([type]::GetTypeFromCLSID($clsid))
    if (-not $comObj) {
        throw "Failed to create COM object for CLSID $clsid"
    }

    if (-not $InterfaceSpec -or $CreateInstance)  {
       return $comObj
    }

    $iid = if ($InterfaceSpec.IID) {
        [guid]$InterfaceSpec.IID
    } else {
        [guid]"00000000-0000-0000-C000-000000000046"
    }

    # ------ QueryInterface Delegate -------
    
    try {
     [QueryInterfaceDelegate] | Out-Null
    }
    catch {
        Add-Type -TypeDefinition @"
using System;
using System.Runtime.InteropServices;

[UnmanagedFunctionPointer(CallingConvention.StdCall)]
public delegate int QueryInterfaceDelegate(IntPtr thisPtr, ref Guid riid, out IntPtr ppvObject);
"@ -Language CSharp -ErrorAction Stop
    }

    $iUnknownPtr = [Marshal]::GetIUnknownForObject($comObj)
    $queryInterfacePtr = [Marshal]::ReadIntPtr(
        [Marshal]::ReadIntPtr($iUnknownPtr))

    $queryInterface = [Marshal]::GetDelegateForFunctionPointer(
        $queryInterfacePtr, [QueryInterfaceDelegate])

    # ------ Continue with IID Setup -------

    $interfacePtr = [IntPtr]::Zero
    $hresult = $queryInterface.Invoke($iUnknownPtr, [ref]$iid, [ref]$interfacePtr)
    if ($hresult -ne 0 -or $interfacePtr -eq [IntPtr]::Zero) {
        throw "QueryInterface failed with HRESULT 0x{0:X8}" -f $hresult
    }
    $requestedVTablePtr = [Marshal]::ReadIntPtr($interfacePtr)

    # ------ Check if inherit *** [can fail, or misled, be aware!] -------

    $interfaces = @(
        @("00020400-0000-0000-C000-000000000046", 7,  "IDispatch"),                # 1
        @("00000003-0000-0000-C000-000000000046", 9,  "IMarshal"),                 # 2
        @("00000118-0000-0000-C000-000000000046", 8,  "IOleClientSite"),           # 3
        @("00000112-0000-0000-C000-000000000046", 24, "IOleObject"),               # 4
        @("0000010B-0000-0000-C000-000000000046", 8,  "IPersistFile"),             # 5
        @("0000010C-0000-0000-C000-000000000046", 4,  "IPersist"),                 # 6
        @("00000109-0000-0000-C000-000000000046", 7,  "IPersistStream"),           # 7
        @("0000010E-0000-0000-C000-000000000046", 12, "IDataObject"),              # 8
        @("0000000C-0000-0000-C000-000000000046", 13, "IStream"),                  # 9
        @("0000000B-0000-0000-C000-000000000046", 15, "IStorage"),                 # 10
        @("0000010A-0000-0000-C000-000000000046", 11, "IPersistStorage"),          # 11
        @("00000139-0000-0000-C000-000000000046", 7,  "IEnumSTATPROPSTG"),         # 12
        @("0000013A-0000-0000-C000-000000000046", 7,  "IEnumSTATPROPSETSTG"),      # 13
        @("0000000D-0000-0000-C000-000000000046", 7,  "IEnumSTATSTG"),             # 14
        @("00020404-0000-0000-C000-000000000046", 7,  "IEnumVARIANT"),             # 15
        @("00000102-0000-0000-C000-000000000046", 7,  "IEnumMoniker"),             # 16
        @("00000101-0000-0000-C000-000000000046", 7,  "IEnumString"),              # 17
        @("B196B286-BAB4-101A-B69C-00AA00341D07", 7,  "IConnectionPoint"),         # 18
        @("55272A00-42CB-11CE-8135-00AA004BB851", 5,  "IPropertyBag"),             # 19
        @("00000114-0000-0000-C000-000000000046", 5,  "IOleWindow"),               # 20
        @("B196B283-BAB4-101A-B69C-00AA00341D07", 4,  "IProvideClassInfo"),        # 21
        @("A6BC3AC0-DBAA-11CE-9DE3-00AA004BB851", 4,  "IProvideClassInfo2"),       # 22
        @("B196B28B-BAB4-101A-B69C-00AA00341D07", 4,  "ISpecifyPropertyPages"),    # 23
        @("EB5E0020-8F75-11D1-ACDD-00C04FC2B085", 4,  "IPersistPropertyBag"),      # 24
        @("B196B284-BAB4-101A-B69C-00AA00341D07", 4,  "IConnectionPointContainer") # 25
    )

    $baseMethodOffset = 0
    if ($InterfaceSpec.Type -and (-not [string]::IsNullOrEmpty($InterfaceSpec.Type))) {
        $interface = $interfaces | ? { $_[2] -eq $InterfaceSpec.Type }
        if ($interface) {
            $baseMethodOffset = $interface[1]
    }}

    if ($baseMethodOffset -eq 0) {
        $baseMethodOffset = 3

        foreach ($iface in $interfaces) {
            $iid = $iface[0]
            $totalMethods = $iface[1]
            $ptr = [IntPtr]::Zero

            $hr = $queryInterface.Invoke($interfacePtr, [ref]$iid, [ref]$ptr)
            if ($hr -eq 0 -and $ptr -ne [IntPtr]::Zero) {
                $baseMethodOffset = $totalMethods
                [Marshal]::Release($ptr) | Out-Null
                break
    }}}

    # ------ Continue with IID Setup -------

    $timestampSuffix = (Get-Date -Format "yyyyMMddHHmmssfff")
    $simpleUniqueDelegateName = "$($InterfaceSpec.Name)$timestampSuffix"
    $delegateCode = Build-ComDelegate -InterfaceSpec $InterfaceSpec -UNIQUE_ID $simpleUniqueDelegateName
    Add-Type -TypeDefinition $delegateCode -Language CSharp -ErrorAction Stop

    $delegateType = $null
    $fullDelegateTypeName = "DynamicDelegates.$simpleUniqueDelegateName"
    $delegateType = [AppDomain]::CurrentDomain.GetAssemblies() |
        ForEach-Object { $_.GetType($fullDelegateTypeName, $false, $true) } |
        Where-Object { $_ } |
        Select-Object -First 1

    if (-not $delegateType) {
        throw "Delegate type '$simpleUniqueDelegateName' not found."
    }

    $methodIndex = $baseMethodOffset + ([int]$InterfaceSpec.Index - 1)
    $funcPtr = [Marshal]::ReadIntPtr($requestedVTablePtr, $methodIndex * [IntPtr]::Size)
    $delegateInstance = [Marshal]::GetDelegateForFunctionPointer($funcPtr, $delegateType)

    return [PSCustomObject]@{
        ComObject        = $comObj
        IUnknownPtr      = $iUnknownPtr
        InterfacePtr     = $interfacePtr
        VTablePtr        = $requestedVTablePtr
        FunctionPtr      = $funcPtr
        DelegateType     = $delegateType
        DelegateInstance = $delegateInstance
        InterfaceSpec    = $InterfaceSpec
        MethodIndex      = $methodIndex
        DelegateCode     = $delegateCode
    }
}
function Receive-ComObject {
    param (
        [Parameter(Mandatory=$true, ValueFromPipeline)]
        [object]$punk
    )

    try {
        return [Marshal]::GetObjectForIUnknown([intPtr]$punk)
    }
    catch {
        return $punk
    }
}
function Release-ComObject {
    param (
        [Parameter(Mandatory=$true, ValueFromPipeline)]
        $comInterface
    )

    $ISComObject = $comInterface.GetType().Name -match '__ComObject'
    $IsPSCustomObject = $comInterface.GetType().Name -match 'PSCustomObject'

    if ($ISComObject) {
        [Marshal]::ReleaseComObject($comInterface) | Out-Null
    }
    if ($IsPSCustomObject) {
        try {
            if ($comInterface.ComObject) {
                [Marshal]::ReleaseComObject($comInterface.ComObject) | Out-Null
            }
        } catch {}

        try {
            if ($comInterface.IUnknownPtr -and $comInterface.IUnknownPtr -ne [IntPtr]::Zero) {
                [Marshal]::Release($comInterface.IUnknownPtr) | Out-Null
            }
        } catch {}

        try {
            if ($comInterface.InterfacePtr -and $comInterface.InterfacePtr -ne [IntPtr]::Zero) {
                [Marshal]::Release($comInterface.InterfacePtr) | Out-Null
            }
        } catch {}

        # Cleanup
        $comInterface.ComObject        = $null
        $comInterface.DelegateInstance = $null
        $comInterface.VTablePtr        = $null
        $comInterface.FunctionPtr      = $null
        $comInterface.DelegateType     = $null
        $comInterface.InterfaceSpec    = $null
        $comInterface.IUnknownPtr      = [IntPtr]::Zero
        [GC]::Collect()
        [GC]::WaitForPendingFinalizers()
    }
}
function Use-ComInterface {
    param (
        [Parameter(Mandatory = $true, Position = 1)]
        [ValidateNotNullOrEmpty()]
        [ValidatePattern('^[A-F0-9]{8}-([A-F0-9]{4}-){3}[A-F0-9]{12}$')]
        [string]$CLSID,

        [Parameter(Position = 2)]
        [ValidatePattern('^[A-F0-9]{8}-([A-F0-9]{4}-){3}[A-F0-9]{12}$')]
        [string]$IID,

        [Parameter(Mandatory = $true, Position = 3)]
        [ValidateRange(1, [int]::MaxValue)]
        [int]$Index,

        [Parameter(Mandatory = $true, Position = 4)]
        [ValidateNotNullOrEmpty()]
        [string]$Name,

        [Parameter(Mandatory = $false, Position = 5)]
        [ValidateSet(
            # Void
            "void",

            # Fully qualified .NET types
            "system.boolean", "system.byte", "system.char", "system.decimal", "system.double",
            "system.int16", "system.int32", "system.int64", "system.intptr", "system.object",
            "system.sbyte", "system.single", "system.string", "system.uint16", "system.uint32",
            "system.uint64", "system.uintptr",

            # Alternate type spellings and aliases
            "boolean", "dword32", "dword64", "int16", "int32", "int64", "single", "uint16",
            "uint32", "uint64",

            # Additional C/C++ & WinAPI aliases
            "double", "float", "long", "longlong", "tchar", "uchar", "ulong", "ulonglong",
            "short", "ushort",

            # Additional typedefs
            "atom", "dword_ptr", "dwordlong", "farproc", "hhook", "hresult", "NTSTATUS",
            "int_ptr", "intptr_t", "long_ptr", "lpbyte", "lpdword", "lparam", "pcstr",
            "pcwstr", "pstr", "pwstr", "uint_ptr", "uintptr_t", "wparam",

            # C# built-in types
            "bool", "byte", "char", "decimal", "int", "intptr", "nint", "nuint", "object",
            "sbyte", "string", "uint", "uintptr",

            # Common WinAPI handle types
            "hbitmap", "hbrush", "hcurs", "hdc", "hfont", "hicon", "hmenu", "hpen", "hrgn",

            # Pointer-based aliases
            "pbyte", "pchar", "pdword", "pint", "plong", "puint", "pulong", "pvoid", "lpvoid",

            # Special types
            "guid",

            # Windows/WinAPI types (common aliases)
            "dword", "handle", "hinstance", "hmodule", "hwnd", "lpcstr", "lpcwstr", "lpstr",
            "lpwstr", "ptr", "size_t", "ssize_t", "void*", "word", "phandle", "lresult",

            # STRSAFE typedefs
            "strsafe_lpstr", "strsafe_lpcstr", "strsafe_lpwstr", "strsafe_lpcwstr",
            "strsafe_lpcuwstr", "strsafe_pcnzch", "strsafe_pcnzwch", "strsafe_pcunzwch",

            # Wide-character (Unicode) types
            "pstring", "pwchar", "lpwchar", "pczpwstr", "pzpwstr", "pzwstr", "pzzwstr",
            "pczzwstr", "puczzwstr", "pcuczzwstr", "pnzwch", "pcnzwch", "punzwch", "pcunzwch",

            # ANSI string types
            "npstr", "pzpcstr", "pczpcstr", "pzzstr", "pczzstr", "pnzch", "pcnzch",

            # UCS types
            "ucschar", "pucschar", "pcucschar", "puucschar", "pcuucschar", "pucsstr",
            "pcucsstr", "puucsstr", "pcuucsstr",

            # Neutral ANSI/Unicode (TCHAR-based) Types
            "ptchar", "tbyte", "ptbyte", "ptstr", "lptstr", "pctstr", "lpctstr", "putstr",
            "lputstr", "pcutstr", "lpcutstr", "pzptstr", "pzzstr", "pczztstr", "pzzwstr", "pczzwstr"
        )]
        [string]$Return,
        
        [Parameter(Position = 6)]
        [string]$Params,

        [Parameter(Position = 7)]
        [object[]]$Values,

        [Parameter(Position = 8)]
        [ValidateSet(
            "IOleObject", "IDataObject", "IStream", "IPersistStorage", 
            "IStorage", "IMarshal", "IPersistFile", "IOleClientSite", 
            "IDispatch", "IEnumSTATPROPSTG", "IEnumSTATPROPSETSTG", 
            "IEnumSTATSTG", "IPersistStream", "IEnumVARIANT", "IEnumMoniker",
            "IConnectionPoint", "IEnumString", "IOleWindow", "IPropertyBag",
            "IPersist", "IProvideClassInfo", "IProvideClassInfo2", "ISpecifyPropertyPages",
            "IPersistPropertyBag", "IConnectionPointContainer"
        )]
        [string]$Type,

        [Parameter(Mandatory = $false, Position = 9)]
        [ValidateSet("Unicode", "Ansi")]
        [string]$CharSet = "Unicode"
    )

    # Detect platform
    if (-not $CallingConvention) {
        if ([IntPtr]::Size -eq 8) {
            $CallingConvention = "StdCall" 
        }
        else {
            $CallingConvention = "StdCall"
        }
    }

    # Lazy Mode Detection
    $Count = 0
    [void][int]::TryParse($Values.Count,[ref]$count)
    $lazyMode = (-not $Params) -and ($Count -gt 0)
    $IsArrayObj = $Count -eq 1 -and $Values[0] -is [System.Array]

     if (-not $Return) {
        $Return = "Int32"
    }

    if ($IsArrayObj) {
        Write-error "Cast all Params with '-Values @()' Please"
        return
    }

    if ($lazyMode) {
        
        try {
            $idx = 0
            $Params = (
                $Values | % {
                    ++$idx
                    if ($_.Value -or ($_ -is [ref])) {
                        $byRef = 'ref '
                        $Name  = $_.Value.GetType().Name
                    }
                    else {
                        $byRef = ''
                        $Name  = $_.GetType().Name
                    }
                    "{0}{1} {2}" -f $byRef, $Name, (Get-Base26Name -idx $idx)
                }
            ) -join ", "
        }
        catch {
            throw "auto parse params fail"
        }

        $CharSet = if ($Function -like "*A") { "Ansi" } else { "Unicode" }
    }

    $interfaceSpec = Build-ComInterfaceSpec `
        -CLSID $CLSID  `
        -IID $IID  `
        -Index $Index  `
        -Name $Name  `
        -Return $Return  `
        -Params $Params `
        -InterFaceType $Type `
        -CharSet $CharSet

    $comObj = $interfaceSpec | Initialize-ComObject

    try {
        return $comObj | Invoke-Object -Params $Values -type COM
    }
    finally {
        $comObj | Release-ComObject
    }
}

<#
.SYNOPSIS

Creates an in-memory Interface for use in your PowerShell session.

Based On example from Consumer_ESU_Enrollment.ps1
https://github.com/abbodi1406/ConsumerESU/blob/master/Consumer_ESU_Enrollment.ps1

.EXAMPLE

Clear-Host
Write-Host

$ComObj = New-ComInterface `
    -InterfaceName 'IEditionUpgradeManager' `
    -Clsid '17CCA47D-DAE5-4E4A-AC42-CC54E28F334A' `
    -IID 'F2DCB80D-0670-44BC-9002-CD18688730AF' `
    -Fields @(
        @{ name = 'Place_Holder' },
        @{ name = 'Place_Holder' },
        @{
            Name = 'ShowProductKeyUI'
            attributes = (Bor @(2,4,6,64,128,256,1024))
            callingConvention = (Bor @(1,32))
        },
        @{
            name = 'UpdateOperatingSystemWithParams'
            attributes = (Bor @(2,4,6,64,128,256,1024))
            callingConvention = (Bor @(1,32))
            returnType = [Int32]
            parameterTypes = @([string], [Int32], [Int32], [Int32])
        }
    )

Invoke-ComInterface `
    -ComObject $ComObj `
    -Method ShowProductKeyUI `
    -Params @()

Invoke-ComInterface `
    -ComObject $ComObj `
    -Method UpdateOperatingSystemWithParams `
    -Params @('QPM6N-7J2WJ-P88HH-P3YRH-YY74H', 0, 1, 0)

[Marshal]::ReleaseComObject($ComObj.Instance) | Out-Null

# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ #
# Alternative Way. [Call to A Specific Function] #
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ #

Use-ComInterface `
    -Clsid '17CCA47D-DAE5-4E4A-AC42-CC54E28F334A' `
    -IID 'F2DCB80D-0670-44BC-9002-CD18688730AF' `
    -Index 3 `
    -Name ShowProductKeyUI

Use-ComInterface `
    -Clsid '17CCA47D-DAE5-4E4A-AC42-CC54E28F334A' `
    -IID 'F2DCB80D-0670-44BC-9002-CD18688730AF' `
    -Index 4 `
    -Name UpdateOperatingSystemWithParams `
    -Values @('QPM6N-7J2WJ-P88HH-P3YRH-YY74H', 0, 1, 0)
#>
function New-ComInterface {
    param(
        [string]$InterfaceName,
        [string]$Clsid,
        [string]$IID,
        [array]$Fields
    )

    $CAB = [System.Reflection.Emit.CustomAttributeBuilder]
    $Module = ([AppDomain]::CurrentDomain.DefineDynamicAssembly(
        (New-Object System.Reflection.AssemblyName "DynamicCOMAssembly"),
        [System.Reflection.Emit.AssemblyBuilderAccess]::Run
    )).DefineDynamicModule($InterfaceName, $false)

    $ICom = $Module.DefineType($InterfaceName, 'Public, Interface, Abstract, Import')
    $ICom.SetCustomAttribute($CAB::new([System.Runtime.InteropServices.ComImportAttribute].GetConstructor(@()), @()))
    $ICom.SetCustomAttribute($CAB::new([System.Runtime.InteropServices.GuidAttribute].GetConstructor(@([String])), @($IID)))
    $ICom.SetCustomAttribute($CAB::new([System.Runtime.InteropServices.InterfaceTypeAttribute].GetConstructor(@([Int16])), @([Int16]1)))
    foreach ($Field in $Fields) {
        if (!($Field.ContainsKey('Name'))) {
            Write-error "Fields contain bad parameters .!"
            return
        }

        $name              = $Field.Name
        $attributes        = if ($Field.ContainsKey('attributes')) { $Field.attributes } else { Bor @(64,1024) }
        $callingConvention = if ($Field.ContainsKey('callingConvention')) { $Field.callingConvention } else { 1 }
        $returnType        = if ($Field.ContainsKey('returnType')) { $Field.returnType } else { [Void] }
        $parameterTypes    = if ($Field.ContainsKey('parameterTypes')) { $Field.parameterTypes } else { $null }
        [void]$ICom.DefineMethod( $name, $attributes, $callingConvention, $returnType, $parameterTypes )
    }

    $InterfaceType = $ICom.CreateType()
    $ComObj = [Activator]::CreateInstance([Type]::GetTypeFromCLSID($Clsid))
    return [PsObject]@{
        InterfaceType = $InterfaceType
        Instance      = $ComObj
    }
}
function Invoke-ComInterface {
    param(
        [Parameter(Mandatory)]
        $ComObject,
        [Parameter(Mandatory)]
        [string]$Method,
        [Parameter()]
        [object[]]$Params = $null,
        [switch]$Release
    )

    try {
        if (-not $ComObject.InterfaceType -or -not $ComObject.Instance) {
            throw "Invalid COM interface object. Expected output from New-ComInterface."
        }

        $methodInfo = $ComObject.InterfaceType.GetMethod($Method)
        if (-not $methodInfo) {
            throw "Method '$Method' not found on interface '$($ComObject.InterfaceType.FullName)'."
        }

        $result = $methodInfo.Invoke($ComObject.Instance, $Params)
        return $result
    }
    catch {
        Write-Error $_
    }
    finally {
        if ($Release) {
            [System.Runtime.InteropServices.Marshal]::ReleaseComObject($ComObject.Instance) | Out-Null
        }
    }
}

<#
.SYNOPSIS

Creates an in-memory struct for use in your PowerShell session.

Author: Matthew Graeber (@mattifestation)
License: BSD 3-Clause
Required Dependencies: None
Optional Dependencies: field

.EXAMPLE

Clear-Host
Write-Host

# Example struct, IMAGE_DOS_HEADER
New-Struct `
    -Module (New-InMemoryModule -ModuleName Win32) `
    -FullName IMAGE_DOS_HEADER `
    -StructFields @{
        e_magic =    New-field 0 UInt16
        e_cblp =     New-field 1 UInt16
        e_cp =       New-field 2 UInt16
        e_crlc =     New-field 3 UInt16
        e_cparhdr =  New-field 4 UInt16
        e_minalloc = New-field 5 UInt16
        e_maxalloc = New-field 6 UInt16
        e_ss =       New-field 7 UInt16
        e_sp =       New-field 8 UInt16
        e_csum =     New-field 9 UInt16
        e_ip =       New-field 10 UInt16
        e_cs =       New-field 11 UInt16
        e_lfarlc =   New-field 12 UInt16
        e_ovno =     New-field 13 UInt16
        e_res =      New-field 14 UInt16[] -MarshalAs @('ByValArray', 4)
        e_oemid =    New-field 15 UInt16
        e_oeminfo =  New-field 16 UInt16
        e_res2 =     New-field 17 UInt16[] -MarshalAs @('ByValArray', 10)
        e_lfanew =   New-field 18 Int32
    } | Out-Null

# Example of using an explicit layout in order to create a union.
New-struct `
    -Module (New-InMemoryModule -ModuleName Win32) `
    -FullName TestUnion  `
    -StructFields @{
        field1 = New-field 0 UInt32 0
        field2 = New-field 1 IntPtr 0
    } -ExplicitLayout | Out-Null

# Example struct, UNICODE_STRING
New-Struct `
    -Module (New-InMemoryModule -ModuleName UCICODE_HELPER) `
    -FullName UNICODE_STRING `
    -StructFields @{
        Length        = New-field 0 UInt16
        MaximumLength = New-field 1 UInt16
        Buffer        = New-field 2 IntPtr
    } | Out-Null

## Using GetSize & Casting
$header = New-Object([IMAGE_DOS_HEADER]); $header.e_cs = 2;
$headerPtr = New-IntPtr -Data (New-Object byte[] ([IMAGE_DOS_HEADER]::GetSize()))
[marshal]::StructureToPtr($header, $headerPtr, $false)
$header = [IMAGE_DOS_HEADER]$headerPtr
Write-Host ("Is Same ? {0}" -f ($header.e_cs -eq 2))

## Using SizeOf & PtrToStructure
$stringPtr = New-IntPtr ([Marshal]::SizeOf([Type][UNICODE_STRING]))
[marshal]::WriteInt16($stringPtr, 0x00, 0x08)
[marshal]::WriteInt16($stringPtr, 0x02, 0x0a)
[marshal]::WriteIntPtr($stringPtr, [IntPtr]::Size, ([Marshal]::StringToHGlobalUni('Test')))
$stringInfo = Parse-NativeString -StringPtr $stringPtr -Encoding Unicode
write-host "Parse-NativeString : $($stringInfo | select -ExpandProperty StringData)" -ForegroundColor Green
$string = [marshal]::PtrToStructure($stringPtr, [Type][UNICODE_STRING])
write-host "PtrToStructure     : $([Marshal]::PtrToStringUni($string.Buffer))" -ForegroundColor Green
Free-NativeString -StringPtr $stringPtr
#>
function New-InMemoryModule {
    [Diagnostics.CodeAnalysis.SuppressMessageAttribute('PSUseShouldProcessForStateChangingFunctions', '')]
    [CmdletBinding()]
    Param (
        [Parameter(Position = 0)]
        [ValidateNotNullOrEmpty()]
        [String]
        $ModuleName = [Guid]::NewGuid().ToString()
    )

    $AppDomain = [Reflection.Assembly].Assembly.GetType('System.AppDomain').GetProperty('CurrentDomain').GetValue($null, @())
    $LoadedAssemblies = $AppDomain.GetAssemblies()

    foreach ($Assembly in $LoadedAssemblies) {
        if ($Assembly.FullName -and ($Assembly.FullName.Split(',')[0] -eq $ModuleName)) {
            return $Assembly
        }
    }

    $DynAssembly = New-Object Reflection.AssemblyName($ModuleName)
    $Domain = $AppDomain
    $AssemblyBuilder = $Domain.DefineDynamicAssembly($DynAssembly, 'Run')
    $ModuleBuilder = $AssemblyBuilder.DefineDynamicModule($ModuleName, $False)

    return $ModuleBuilder
}
function New-field {
    Param (
        [Parameter(Position = 0, Mandatory=$True)]
        [UInt16]
        $Position,

        [Parameter(Position = 1, Mandatory=$True)]
        [Type]
        $Type,

        [Parameter(Position = 2)]
        [UInt16]
        $Offset,

        [Object[]]
        $MarshalAs
    )

    @{
        Position = $Position
        Type = $Type -as [Type]
        Offset = $Offset
        MarshalAs = $MarshalAs
    }
}
function New-Struct {
    [OutputType([Type])]
    Param (
        [Parameter(Position = 1, Mandatory=$True)]
        [ValidateScript({($_ -is [Reflection.Emit.ModuleBuilder]) -or ($_ -is [Reflection.Assembly])})]
        $Module,

        [Parameter(Position = 2, Mandatory=$True)]
        [ValidateNotNullOrEmpty()]
        [String]
        $FullName,

        [Parameter(Position = 3, Mandatory=$True)]
        [ValidateNotNullOrEmpty()]
        [Hashtable]
        $StructFields,

        [Reflection.Emit.PackingSize]
        $PackingSize = [Reflection.Emit.PackingSize]::Unspecified,

        [Switch]
        $ExplicitLayout
    )

    if ($Module -is [Reflection.Assembly])
    {
        return ($Module.GetType($FullName))
    }

    [Reflection.TypeAttributes] $StructAttributes = bor @(0,1,256,1048576)
    if ($ExplicitLayout)
    {
        $StructAttributes = $StructAttributes -bor [Reflection.TypeAttributes]::ExplicitLayout
    }
    else
    {
        $StructAttributes = $StructAttributes -bor [Reflection.TypeAttributes]::SequentialLayout
    }

    $StructBuilder = $Module.DefineType($FullName, $StructAttributes, [ValueType], $PackingSize)
    $ConstructorInfo = [Runtime.InteropServices.MarshalAsAttribute].GetConstructors()[0]
    $SizeConst = @([Runtime.InteropServices.MarshalAsAttribute].GetField('SizeConst'))

    $Fields = New-Object Hashtable[]($StructFields.Count)

    # Sort each field according to the orders specified
    # Unfortunately, PSv2 doesn't have the luxury of the
    # hashtable [Ordered] accelerator.
    foreach ($Field in $StructFields.Keys)
    {
        $Index = $StructFields[$Field]['Position']
        $Fields[$Index] = @{FieldName = $Field; Properties = $StructFields[$Field]}
    }

    foreach ($Field in $Fields)
    {
        $FieldName = $Field['FieldName']
        $FieldProp = $Field['Properties']

        $Offset = $FieldProp['Offset']
        $Type = $FieldProp['Type']
        $MarshalAs = $FieldProp['MarshalAs']

        $NewField = $StructBuilder.DefineField($FieldName, $Type, 'Public')

        if ($MarshalAs)
        {
            $UnmanagedType = $MarshalAs[0] -as ([Runtime.InteropServices.UnmanagedType])
            if ($MarshalAs[1])
            {
                $Size = $MarshalAs[1]
                $AttribBuilder = New-Object Reflection.Emit.CustomAttributeBuilder($ConstructorInfo,
                    $UnmanagedType, $SizeConst, @($Size))
            }
            else
            {
                $AttribBuilder = New-Object Reflection.Emit.CustomAttributeBuilder($ConstructorInfo, [Object[]] @($UnmanagedType))
            }

            $NewField.SetCustomAttribute($AttribBuilder)
        }

        if ($ExplicitLayout) { $NewField.SetOffset($Offset) }
    }

    # Make the struct aware of its own size.
    # No more having to call [Runtime.InteropServices.Marshal]::SizeOf!
    $SizeMethod = $StructBuilder.DefineMethod('GetSize',
        'Public, Static',
        [Int],
        [Type[]] @())
    $ILGenerator = $SizeMethod.GetILGenerator()
    # Thanks for the help, Jason Shirk!
    $ILGenerator.Emit([Reflection.Emit.OpCodes]::Ldtoken, $StructBuilder)
    $ILGenerator.Emit([Reflection.Emit.OpCodes]::Call,
        [Type].GetMethod('GetTypeFromHandle'))
    $ILGenerator.Emit([Reflection.Emit.OpCodes]::Call,
        [Runtime.InteropServices.Marshal].GetMethod('SizeOf', [Type[]] @([Type])))
    $ILGenerator.Emit([Reflection.Emit.OpCodes]::Ret)

    # Allow for explicit casting from an IntPtr
    # No more having to call [Runtime.InteropServices.Marshal]::PtrToStructure!
    $ImplicitConverter = $StructBuilder.DefineMethod('op_Implicit',
        'PrivateScope, Public, Static, HideBySig, SpecialName',
        $StructBuilder,
        [Type[]] @([IntPtr]))
    $ILGenerator2 = $ImplicitConverter.GetILGenerator()
    $ILGenerator2.Emit([Reflection.Emit.OpCodes]::Nop)
    $ILGenerator2.Emit([Reflection.Emit.OpCodes]::Ldarg_0)
    $ILGenerator2.Emit([Reflection.Emit.OpCodes]::Ldtoken, $StructBuilder)
    $ILGenerator2.Emit([Reflection.Emit.OpCodes]::Call,
        [Type].GetMethod('GetTypeFromHandle'))
    $ILGenerator2.Emit([Reflection.Emit.OpCodes]::Call,
        [Runtime.InteropServices.Marshal].GetMethod('PtrToStructure', [Type[]] @([IntPtr], [Type])))
    $ILGenerator2.Emit([Reflection.Emit.OpCodes]::Unbox_Any, $StructBuilder)
    $ILGenerator2.Emit([Reflection.Emit.OpCodes]::Ret)

    $StructBuilder.CreateType()
}

<#

     *********************

     !Managed Api Warper.!
      -  Example code. -

     *********************

Clear-Host
Write-Host

Invoke-UnmanagedMethod `
    -Dll "kernel32.dll" `
    -Function "Beep" `
    -Return "bool" `
    -Params "uint dwFreq, uint dwDuration" `
    -Values @(750, 300)  # 750 Hz beep for 300 ms

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Invoke-UnmanagedMethod `
    -Dll "User32.dll" `
    -Function "MessageBoxA" `
    -Values @(
        [IntPtr]0,
        "Text Block",
        "Text title",
        20,
        [UIntPtr]::new(9),
        1,2,"Alpha",
        ([REF]1),
        ([REF]"1"),
        [Int16]1,
        ([REF][uInt16]2)
    )

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

# Test Charset <> Ansi
$Func = Register-NativeMethods @(
    @{ 
        Name       = "MessageBoxA"
        Dll        = "user32.dll"
        ReturnType = [int]
        CharSet    = 'Ansi'
        Parameters = [Type[]]@(
            [IntPtr],    # hWnd
            [string],    # lpText
            [string],    # lpCaption
            [uint32]     # uType
        )
    })
$Func::MessageBoxA(
    [IntPtr]::Zero, "Hello from ANSI!", "MessageBoxA", 0)

# Test Charset <> Ansi
Invoke-UnmanagedMethod `
    -Dll "user32.dll" `
    -Function "MessageBoxA" `
    -Return "int32" `
    -Params "HWND hWnd, LPCSTR lpText, LPCSTR lpCaption, UINT uType" `
    -Values @(0, "Hello from ANSI!", "MessageBoxA", 0) `
    -CharSet Ansi

# Test Charset <> Ansi
Invoke-UnmanagedMethod `
    -Dll "User32.dll" `
    -Function "MessageBoxA" `
    -Values @(
        [IntPtr]0,
        "Text Block",
        "Text title",
        20,
        ([ref]1),
        [UintPtr]::new(1),
        ([ref][IntPtr]2),
        ([ref][guid]::Empty)
    )

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Clear-Host
Write-Host
$buffer = New-IntPtr -Size 256
$result = Invoke-UnmanagedMethod `
  -Dll "kernel32.dll" `
  -Function "GetComputerNameA" `
  -Return "bool" `
  -Params "IntPtr lpBuffer, ref uint lpnSize" `
  -Values @($buffer, [ref]256)

if ($result) {
    $computerName = [Marshal]::PtrToStringAnsi($buffer)
    Write-Host "Computer Name: $computerName"
} else {
    Write-Host "Failed to get computer name"
}
New-IntPtr -hHandle $buffer -Release

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

# --- For GetComputerNameA (ANSI Version) ---
$computerNameA = New-Object byte[] 250
$handle = [gchandle]::Alloc($computerNameA, 'Pinned')
Invoke-UnmanagedMethod "kernel32.dll" "GetComputerNameA" void -Values @($handle.AddrOfPinnedObject(), [ref]250)
Write-Host ("Computer Name (A): {0}" -f ([Encoding]::ASCII.GetString($computerNameA).Trim([char]0)))
$handle.Free()

# --- For GetComputerNameW (Unicode Version) ---
$computerNameW = New-Object byte[] (250*2)
$handle = [gchandle]::Alloc($computerNameW, 'Pinned')
Invoke-UnmanagedMethod "kernel32.dll" "GetComputerNameW" void -Values @($handle.AddrOfPinnedObject(), [ref]250)
Write-Host ("Computer Name (W): {0}" -f ([Encoding]::Unicode.GetString($computerNameW).Trim([char]0)))
$handle.Free()

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Clear-Host
Write-Host

# ZwQuerySystemInformation
# https://www.geoffchappell.com/studies/windows/km/ntoskrnl/api/ex/sysinfo/query.htm?tx=61&ts=0,1677

# SYSTEM_PROCESS_INFORMATION structure
# https://www.geoffchappell.com/studies/windows/km/ntoskrnl/api/ex/sysinfo/process.htm

# ZwQuerySystemInformation
# https://www.geoffchappell.com/studies/windows/km/ntoskrnl/api/ex/sysinfo/query.htm?tx=61&ts=0,1677

# SYSTEM_BASIC_INFORMATION structure
# https://www.geoffchappell.com/studies/windows/km/ntoskrnl/inc/api/ntexapi/system_basic_information.htm

# Step 1: Get required buffer size
$ReturnLength = 0
$dllResult = Invoke-UnmanagedMethod `
  -Dll "ntdll.dll" `
  -Function "ZwQuerySystemInformation" `
  -Return "uint32" `
  -Params "int SystemInformationClass, IntPtr SystemInformation, uint SystemInformationLength, ref uint ReturnLength" `
  -Values @(0, [IntPtr]::Zero, 0, [ref]$ReturnLength)

# Allocate buffer (add some extra room just in case)
$infoBuffer = New-IntPtr -Size $ReturnLength

# Step 2: Actual call with allocated buffer
$result = Invoke-UnmanagedMethod `
  -Dll "ntdll.dll" `
  -Function "ZwQuerySystemInformation" `
  -Return "uint32" `
  -Params "int SystemInformationClass, IntPtr SystemInformation, uint SystemInformationLength, ref uint ReturnLength" `
  -Values @(0, $infoBuffer, $ReturnLength, [ref]$ReturnLength)

if ($result -ne 0) {
    Write-Host "NtQuerySystemInformation failed: 0x$("{0:X}" -f $result)"
    Parse-ErrorMessage -MessageId $result
    New-IntPtr -hHandle $infoBuffer -Release
    return
}

# Parse values from the structure
$sysBasicInfo = [PSCustomObject]@{
    PageSize                     = [Marshal]::ReadInt32($infoBuffer,  0x08)
    NumberOfPhysicalPages        = [Marshal]::ReadInt32($infoBuffer,  0x0C)
    LowestPhysicalPageNumber     = [Marshal]::ReadInt32($infoBuffer,  0x10)
    HighestPhysicalPageNumber    = [Marshal]::ReadInt32($infoBuffer,  0x14)
    AllocationGranularity        = [Marshal]::ReadInt32($infoBuffer,  0x18)
    MinimumUserModeAddress       = [Marshal]::ReadIntPtr($infoBuffer, 0x20)
    MaximumUserModeAddress       = [Marshal]::ReadIntPtr($infoBuffer, 0x28)
    ActiveProcessorsAffinityMask = [Marshal]::ReadIntPtr($infoBuffer, 0x30)
    NumberOfProcessors           = [Marshal]::ReadByte($infoBuffer,   0x38)
}

# Step 1: Get required buffer size
$ReturnLength = 0
$dllResult = Invoke-UnmanagedMethod `
  -Dll "ntdll.dll" `
  -Function "ZwQuerySystemInformation" `
  -Return "uint32" `
  -Params "int SystemInformationClass, IntPtr SystemInformation, uint SystemInformationLength, ref uint ReturnLength" `
  -Values @(5, [IntPtr]::Zero, 0, [ref]$ReturnLength)

# Allocate buffer (add some extra room just in case)
$ReturnLength += 200
$procBuffer = New-IntPtr -Size $ReturnLength

# Step 2: Actual call with allocated buffer
$result = Invoke-UnmanagedMethod `
  -Dll "ntdll.dll" `
  -Function "ZwQuerySystemInformation" `
  -Return "uint32" `
  -Params "int SystemInformationClass, IntPtr SystemInformation, uint SystemInformationLength, ref uint ReturnLength" `
  -Values @(5, $procBuffer, $ReturnLength, [ref]$ReturnLength)

if ($result -ne 0) {
    Write-Host "NtQuerySystemInformation failed: 0x$("{0:X}" -f $result)"
    Parse-ErrorMessage -MessageId $result
    New-IntPtr -hHandle $procBuffer -Release
    return
}

$offset = 0
$processList = @()

while ($true) {
    try {
        $entryPtr = [IntPtr]::Add($procBuffer, $offset)
        $nextOffset = [Marshal]::ReadInt32($entryPtr, 0x00)

        $namePtr = [Marshal]::ReadIntPtr($entryPtr, 0x38 + [IntPtr]::Size)
        $processName = if ($namePtr -ne [IntPtr]::Zero) {
            [Marshal]::PtrToStringUni($namePtr)
        } else {
            "[System]"
        }

        $procObj = [PSCustomObject]@{
            ProcessId       = [Marshal]::ReadIntPtr($entryPtr, 0x50)
            ProcessName     = $processName
            NumberOfThreads = [Marshal]::ReadInt32($entryPtr, 0x04)
        }

        $processList += $procObj

        if ($nextOffset -eq 0) { break }
        $offset += $nextOffset
    } catch {
        Write-Host "Parsing error at offset $offset. Stopping."
        break
    }
}

New-IntPtr -hHandle $infoBuffer -Release
New-IntPtr -hHandle $procBuffer -Release

$sysBasicInfo | Format-List
$processList | Sort-Object ProcessName | Format-Table ProcessId, ProcessName, NumberOfThreads -AutoSize

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

GitHub - jhalon/SharpCall: Simple PoC demonstrating syscall execution in C#
https://github.com/jhalon/SharpCall

Red Team Tactics: Utilizing Syscalls in C# - Writing The Code - Jack Hacks
https://jhalon.github.io/utilizing-syscalls-in-csharp-2/

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Clear-Host

Write-Host
$hProc = [IntPtr]::Zero
$hProcNext = [IntPtr]::Zero
$ret = Invoke-UnmanagedMethod `
    -Dll NTDLL `
    -Function ZwGetNextProcess `
    -Values @($hProc, [UInt32]0x02000000, [UInt32]0x00, [UInt32]0x00, ([ref]$hProcNext)) `
    -Mode Allocate -SysCall
write-host "NtGetNextProcess Test: $ret"
write-host "hProcNext Value :$hProcNext"

Write-Host
$hThread = [IntPtr]::Zero
$hThreadNext = [IntPtr]::Zero
$ret = Invoke-UnmanagedMethod `
    -Dll NTDLL `
    -Function ZwGetNextThread `
    -Values @([IntPtr]::new(-1), $hThread, 0x0040, 0x00, 0x00, ([ref]$hThreadNext)) `
    -Mode AllocateEx -SysCall
write-host "NtGetNextThread Test: $ret"
write-host "hThreadNext Value :$hThreadNext"

Write-Host
$ret = Invoke-UnmanagedMethod `
    -Dll NTDLL `
    -Function NtClose `
    -Values @([IntPtr]$hProcNext) `
    -Mode Allocate -SysCall
write-host "NtClose Test: $ret"

Write-Host
$FileHandle = [IntPtr]::Zero
$IoStatusBlock    = New-IntPtr -Size 16
$ObjectAttributes = New-IntPtr -Size 48 -WriteSizeAtZero
$filePath = ("\??\{0}\test.txt" -f [Environment]::GetFolderPath('Desktop'))
$ObjectName = Init-NativeString -Encoding Unicode -Value $filePath
[Marshal]::WriteIntPtr($ObjectAttributes, 0x10, $ObjectName)
[Marshal]::WriteInt32($ObjectAttributes,  0x18, 0x40)
$ret = Invoke-UnmanagedMethod `
    -Dll NTDLL `
    -Function NtCreateFile `
    -Values @(
        ([ref]$FileHandle),   # OUT HANDLE
        0x40100080,           # DesiredAccess (GENERIC_WRITE | SYNCHRONIZE | FILE_WRITE_DATA)
        $ObjectAttributes,    # POBJECT_ATTRIBUTES
        $IoStatusBlock,       # PIO_STATUS_BLOCK
        [IntPtr]::Zero,       # AllocationSize
        0x80,                 # FileAttributes (FILE_ATTRIBUTE_NORMAL)
        0x07,                 # ShareAccess (read|write|delete)
        0x5,                  # CreateDisposition (FILE_OVERWRITE_IF)
        0x20,                 # CreateOptions (FILE_NON_DIRECTORY_FILE)
        [IntPtr]::Zero,       # EaBuffer
        0x00                  # EaLength
    ) `
    -Mode Protect -SysCall
Free-NativeString -StringPtr $ObjectName
write-host "NtCreateFile Test: $ret"
#>
function Build-ApiDelegate {
    param (
        [Parameter(Mandatory=$true, ValueFromPipeline)]
        [PSCustomObject]$InterfaceSpec,

        [Parameter(Mandatory=$true)]
        [string]$UNIQUE_ID
    )

    $namespace = "namespace DynamicDelegates"
    $using = "`nusing System;`nusing System.Runtime.InteropServices;`n"
    $Params = Process-Parameters -InterfaceSpec $InterfaceSpec -Ignore
    $fixedReturnType = Process-ReturnType -ReturnType $InterfaceSpec.Return
    $charSet = if ($InterfaceSpec.CharSet) { "CharSet = CharSet.$($InterfaceSpec.CharSet)" } else { "CharSet = CharSet.Unicode" }
    $Return = @"
    [UnmanagedFunctionPointer(CallingConvention.$($InterfaceSpec.CallingType), $charSet)]
    public delegate $($fixedReturnType) $($UNIQUE_ID)(
        $($Params)
    );
"@

    return "$using`n$namespace`n{`n$Return`n}`n"
}
function Build-ApiInterfaceSpec {
    param (
        [Parameter(Mandatory = $true, Position = 1)]
        [ValidateNotNullOrEmpty()]
        [string]$Dll,

        [Parameter(Mandatory = $true, Position = 2)]
        [ValidateNotNullOrEmpty()]
        [string]$Function,

        [Parameter(Mandatory = $true, Position = 3)]
        [ValidateSet("StdCall", "Cdecl")]
        [string]$CallingConvention = "StdCall",

        [Parameter(Mandatory = $true, Position = 4)]
        [ValidateNotNullOrEmpty()]
        [ValidateSet(
            # Void
            "void",

            # Fully qualified .NET types
            "system.boolean", "system.byte", "system.char", "system.decimal", "system.double",
            "system.int16", "system.int32", "system.int64", "system.intptr", "system.object",
            "system.sbyte", "system.single", "system.string", "system.uint16", "system.uint32",
            "system.uint64", "system.uintptr",

            # Alternate type spellings and aliases
            "boolean", "dword32", "dword64", "int16", "int32", "int64", "single", "uint16",
            "uint32", "uint64",

            # Additional C/C++ & WinAPI aliases
            "double", "float", "long", "longlong", "tchar", "uchar", "ulong", "ulonglong",
            "short", "ushort",

            # Additional typedefs
            "atom", "dword_ptr", "dwordlong", "farproc", "hhook", "hresult", "NTSTATUS",
            "int_ptr", "intptr_t", "long_ptr", "lpbyte", "lpdword", "lparam", "pcstr",
            "pcwstr", "pstr", "pwstr", "uint_ptr", "uintptr_t", "wparam",

            # C# built-in types
            "bool", "byte", "char", "decimal", "int", "intptr", "nint", "nuint", "object",
            "sbyte", "string", "uint", "uintptr",

            # Common WinAPI handle types
            "hbitmap", "hbrush", "hcurs", "hdc", "hfont", "hicon", "hmenu", "hpen", "hrgn",

            # Pointer-based aliases
            "pbyte", "pchar", "pdword", "pint", "plong", "puint", "pulong", "pvoid", "lpvoid",

            # Special types
            "guid",

            # Windows/WinAPI types (common aliases)
            "dword", "handle", "hinstance", "hmodule", "hwnd", "lpcstr", "lpcwstr", "lpstr",
            "lpwstr", "ptr", "size_t", "ssize_t", "void*", "word", "phandle", "lresult",

            # STRSAFE typedefs
            "strsafe_lpstr", "strsafe_lpcstr", "strsafe_lpwstr", "strsafe_lpcwstr",
            "strsafe_lpcuwstr", "strsafe_pcnzch", "strsafe_pcnzwch", "strsafe_pcunzwch",

            # Wide-character (Unicode) types
            "pstring", "pwchar", "lpwchar", "pczpwstr", "pzpwstr", "pzwstr", "pzzwstr",
            "pczzwstr", "puczzwstr", "pcuczzwstr", "pnzwch", "pcnzwch", "punzwch", "pcunzwch",

            # ANSI string types
            "npstr", "pzpcstr", "pczpcstr", "pzzstr", "pczzstr", "pnzch", "pcnzch",

            # UCS types
            "ucschar", "pucschar", "pcucschar", "puucschar", "pcuucschar", "pucsstr",
            "pcucsstr", "puucsstr", "pcuucsstr",

            # Neutral ANSI/Unicode (TCHAR-based) Types
            "ptchar", "tbyte", "ptbyte", "ptstr", "lptstr", "pctstr", "lpctstr", "putstr",
            "lputstr", "pcutstr", "lpcutstr", "pzptstr", "pzzstr", "pczztstr", "pzzwstr", "pczzwstr"
        )]
        [string]$Return,

        [Parameter(Mandatory = $false, Position = 5)]
        [string]$Params,

        [Parameter(Mandatory = $false, Position = 6)]
        [ValidateSet("Unicode", "Ansi")]
        [string]$CharSet = "Unicode"
    )

    return [PSCustomObject]@{
        Dll     = $Dll
        Function= $Function
        Return  = $Return
        Params  = $Params
        CallingType = $CallingConvention
        CharSet     = $CharSet
    }
}
function Initialize-ApiObject {
    param (
        [Parameter(Mandatory=$true, ValueFromPipeline)]
        [PSCustomObject]$ApiSpec,

        [Parameter(Mandatory = $false)]
        [string]$Mode = '',

        [Parameter(Mandatory=$false, ValueFromPipeline)]
        [switch]$SysCall
    )
    
    $hModule = [IntPtr]::Zero
    $BaseAddress = Ldr-LoadDll -dwFlags SEARCH_SYS32 -dll $ApiSpec.Dll
    if ($BaseAddress -ne $null -and $BaseAddress -ne [IntPtr]::Zero) {
        $hModule = [IntPtr]$BaseAddress
    }

    if ($hModule -eq [IntPtr]::Zero) {
        throw "Failed to load DLL: $($ApiSpec.Dll)"
    }

    $funcAddress = [IntPtr]::Zero
    $AnsiPtr = Init-NativeString -Value $ApiSpec.Function -Encoding Ansi
    $hresult = $Global:ntdll::LdrGetProcedureAddressForCaller(
        $hModule, $AnsiPtr, 0, [ref]$funcAddress, 0, 0)
    Free-NativeString -StringPtr $AnsiPtr
    if ($funcAddress -eq [IntPtr]::Zero -or $hresult -ne 0) {
        throw "Failed to find function: $($ApiSpec.Function)"
    }

    # Build delegate
    $baseAddress = [IntPtr]::Zero;
    $uniqueName = "$($ApiSpec.Function)Api$(Get-Random)"
    $delegateCode = Build-ApiDelegate -InterfaceSpec $ApiSpec -UNIQUE_ID $uniqueName

    Add-Type -TypeDefinition $delegateCode -Language CSharp -ErrorAction Stop
    $delegateType = [AppDomain]::CurrentDomain.GetAssemblies() |
        ForEach-Object { $_.GetType("DynamicDelegates.$uniqueName", $false, $true) } |
        Where-Object { $_ } |
        Select-Object -First 1

    if (-not $delegateType) {
        throw "Failed to get delegate type for $uniqueName"
    }

    if ($SysCall) {
        $SysCallPtr = [IntPtr]::Zero
        if ([IntPtr]::Size -gt 4) {
            if (![TEB]::IsRobustValidx64Stub($funcAddress)) {
                $dllName = if (($ApiSpec.Dll).EndsWith('.dll')) { $dllName } else { "$($ApiSpec.Dll).dll" }
                $SysCallPtr = New-IntPtr -Data (
                    Get-SysCallData -DllName $dllName -FunctionName $ApiSpec.Function -BytesToRead 25
                )
                if (![TEB]::IsRobustValidx64Stub($SysCallPtr)) {
                    Free-IntPtr $SysCallPtr
                    throw 'x64 stub not valid'
                }
            }
        }
        $sysCallID = if ($SysCallPtr -ne [IntPtr]::zero) {
            [Marshal]::ReadInt32(
                $SysCallPtr, 0x04)
        } elseif ([IntPtr]::Size -gt 4) {
            [Marshal]::ReadInt32(
                $funcAddress, 0x04)
        } else {
            0 # Place Holder
        }
        Free-IntPtr $SysCallPtr
        
        [byte[]]$shellcode = if ([IntPtr]::Size -gt 4) { 
            [byte[]]([TEB]::GenerateSyscallx64(
                ([BitConverter]::GetBytes($sysCallID))))
        } else {
            [byte[]]([TEB]::GenerateSyscallx86($funcAddress))
        }

        $lpflOldProtect = [Uint32]0;
        $baseAddress = [IntPtr]::Zero;
        $baseAddressPtr = [IntPtr]::Zero;
        $regionSize = [UIntPtr]::new($shellcode.Length);

        if ($Mode -eq 'Protect') {
            $baseAddressPtr = [gchandle]::Alloc($shellcode, 'pinned')
            $baseAddress = $baseAddressPtr.AddrOfPinnedObject()
            [IntPtr]$tempBase = $baseAddress

            if ([TEB]::NtProtectVirtualMemory(
                    [IntPtr]::new(-1),
                    [ref]$tempBase,
                    ([ref]$regionSize),
                    0x00000040,
                    [ref]$lpflOldProtect) -ne 0) {
                throw "Fail to Protect Memory for SysCall"
            }
        }
        elseif ($Mode -match "Allocate|AllocateEx") {
            $ret = if ($Mode -eq 'Allocate') {
                [TEB]::ZwAllocateVirtualMemory(
                    [IntPtr]::new(-1),
                    [ref] $baseAddress,
                    [UIntPtr]::new(0x00),
                    [ref] $regionSize,
                    0x3000, 
                    0x40 
                )
            } elseif ($Mode -eq 'AllocateEx') {
                [TEB]::ZwAllocateVirtualMemoryEx(
                   [IntPtr]::new(-1),
                   [ref]$baseAddress,
                   [ref]$regionSize,
                   0x3000, 0x40,
                   [IntPtr]0,0)
            }

            if ($ret -ne 0) {
                throw "Fail to allocate Memory for SysCall"
            }

            [Marshal]::Copy(
                $shellcode, 0, $baseAddress, $shellcode.Length)
        }

        $delegate = [Marshal]::GetDelegateForFunctionPointer(
            $baseAddress, $delegateType)
    }
    else {
        $delegate = [Marshal]::GetDelegateForFunctionPointer(
            $funcAddress, $delegateType)
    }

    return [PSCustomObject]@{
        Dll              = $ApiSpec.Dll
        Function         = $ApiSpec.Function
        FunctionPtr      = $funcAddress
        DelegateInstance = $delegate
        DelegateType     = $delegateType
        DelegateCode     = $delegateCode
        baseAddress      = $baseAddress
        baseAddressPtr   = $baseAddressPtr
        RegionSize       = $regionSize
    }
}
function Release-ApiObject {
    [CmdletBinding()]
    param (
        [Parameter(Mandatory = $true, ValueFromPipeline)]
        [PSCustomObject]$ApiObject
    )

    process {
        try {
            if ($ApiObject.baseAddressPtr -and $ApiObject.baseAddressPtr -ne [IntPtr]::Zero) {
                $null = $ApiObject.baseAddressPtr.Free()
            }
            elseif ($ApiObject.BaseAddress -and $ApiObject.BaseAddress -ne [IntPtr]::Zero) {
                [IntPtr]$baseAddrLocal = $ApiObject.BaseAddress
                [UIntPtr]$regionSizeLocal = $ApiObject.RegionSize

                $null = [TEB]::ZwFreeVirtualMemory(
                    [IntPtr]::new(-1),
                    [ref]$baseAddrLocal, 
                    [ref]$regionSizeLocal,
                    0x8000
                );
            }
            $ApiObject.Dll = $null
            $ApiObject.Function = $null
            $ApiObject.BaseAddress = $null
            $ApiObject.baseAddressPtr = $null
            $ApiObject.DelegateType = $null
            $ApiObject.DelegateCode = $null
            $ApiObject.DelegateInstance = $null
            $ApiObject.FunctionPtr = 0x0
            [GC]::Collect()
            [GC]::WaitForPendingFinalizers()

        } catch {
            Write-Warning "Failed to release ApiObject: $_"
        }
    }
}
function Invoke-UnmanagedMethod {
    param (
        [Parameter(Mandatory = $true, Position = 1)]
        [ValidateNotNullOrEmpty()]
        [string]$Dll,

        [Parameter(Mandatory = $true, Position = 2)]
        [ValidateNotNullOrEmpty()]
        [string]$Function,

        [Parameter(Mandatory = $false, Position = 3)]
        [ValidateSet(
            # Void
            "void",

            # Fully qualified .NET types
            "system.boolean", "system.byte", "system.char", "system.decimal", "system.double",
            "system.int16", "system.int32", "system.int64", "system.intptr", "system.object",
            "system.sbyte", "system.single", "system.string", "system.uint16", "system.uint32",
            "system.uint64", "system.uintptr",

            # Alternate type spellings and aliases
            "boolean", "dword32", "dword64", "int16", "int32", "int64", "single", "uint16",
            "uint32", "uint64",

            # Additional C/C++ & WinAPI aliases
            "double", "float", "long", "longlong", "tchar", "uchar", "ulong", "ulonglong",
            "short", "ushort",

            # Additional typedefs
            "atom", "dword_ptr", "dwordlong", "farproc", "hhook", "hresult", "NTSTATUS",
            "int_ptr", "intptr_t", "long_ptr", "lpbyte", "lpdword", "lparam", "pcstr",
            "pcwstr", "pstr", "pwstr", "uint_ptr", "uintptr_t", "wparam",

            # C# built-in types
            "bool", "byte", "char", "decimal", "int", "intptr", "nint", "nuint", "object",
            "sbyte", "string", "uint", "uintptr",

            # Common WinAPI handle types
            "hbitmap", "hbrush", "hcurs", "hdc", "hfont", "hicon", "hmenu", "hpen", "hrgn",

            # Pointer-based aliases
            "pbyte", "pchar", "pdword", "pint", "plong", "puint", "pulong", "pvoid", "lpvoid",

            # Special types
            "guid",

            # Windows/WinAPI types (common aliases)
            "dword", "handle", "hinstance", "hmodule", "hwnd", "lpcstr", "lpcwstr", "lpstr",
            "lpwstr", "ptr", "size_t", "ssize_t", "void*", "word", "phandle", "lresult",

            # STRSAFE typedefs
            "strsafe_lpstr", "strsafe_lpcstr", "strsafe_lpwstr", "strsafe_lpcwstr",
            "strsafe_lpcuwstr", "strsafe_pcnzch", "strsafe_pcnzwch", "strsafe_pcunzwch",

            # Wide-character (Unicode) types
            "pstring", "pwchar", "lpwchar", "pczpwstr", "pzpwstr", "pzwstr", "pzzwstr",
            "pczzwstr", "puczzwstr", "pcuczzwstr", "pnzwch", "pcnzwch", "punzwch", "pcunzwch",

            # ANSI string types
            "npstr", "pzpcstr", "pczpcstr", "pzzstr", "pczzstr", "pnzch", "pcnzch",

            # UCS types
            "ucschar", "pucschar", "pcucschar", "puucschar", "pcuucschar", "pucsstr",
            "pcucsstr", "puucsstr", "pcuucsstr",

            # Neutral ANSI/Unicode (TCHAR-based) Types
            "ptchar", "tbyte", "ptbyte", "ptstr", "lptstr", "pctstr", "lpctstr", "putstr",
            "lputstr", "pcutstr", "lpcutstr", "pzptstr", "pzzstr", "pczztstr", "pzzwstr", "pczzwstr"
        )]
        [string]$Return,

        [Parameter(Mandatory = $false, Position = 4)]
        [string]$Params,

        [Parameter(Mandatory = $false, Position = 5)]
        [ValidateSet("StdCall", "Cdecl")]
        [string]$CallingConvention,

        [Parameter(Mandatory = $false, Position = 6)]
        [object[]]$Values,

        [Parameter(Mandatory = $false, Position = 7)]
        [ValidateSet("Unicode", "Ansi")]
        [string]$CharSet = "Unicode",

        [Parameter(Mandatory = $false, Position = 8)]
        [ValidateNotNullOrEmpty()]
        [ValidateSet('Allocate', 'AllocateEx', 'Protect')]
        [string]$Mode = 'Allocate',

        [Parameter(Mandatory = $false, Position = 9)]
        [switch]$SysCall
    )

    # Detect platform
    if (-not $CallingConvention) {
        if ([IntPtr]::Size -eq 8) {
            $CallingConvention = "StdCall" 
        }
        else {
            $CallingConvention = "StdCall"
        }
    }

    # Lazy Mode Detection
    $Count = 0
    [void][int]::TryParse($Values.Count,[ref]$count)
    $lazyMode = (-not $Params) -and ($Count -gt 0)
    $IsArrayObj = $Count -eq 1 -and $Values[0] -is [System.Array]

    if (-not $Return) {
        $Return = "Int32"
    }

    if ($IsArrayObj) {
        Write-error "Cast all Params with '-Values @()' Please"
        return
    }

    if ($lazyMode) {
        
        try {
            $idx = 0
            $Params = (
                $Values | % {
                    ++$idx
                    if ($_.Value -or ($_ -is [ref])) {
                        $byRef = 'ref '
                        $Name  = $_.Value.GetType().Name
                    }
                    else {
                        $byRef = ''
                        $Name  = $_.GetType().Name
                    }
                    "{0}{1} {2}" -f $byRef, $Name, (Get-Base26Name -idx $idx)
                }
            ) -join ", "
        }
        catch {
            throw "auto parse params fail"
        }

        $CharSet = if ($Function -like "*A") { "Ansi" } else { "Unicode" }
    }

    $apiSpec = Build-ApiInterfaceSpec -Dll $Dll  `
        -Function $Function  `
        -Return $Return  `
        -CallingConvention $CallingConvention `
        -Params $Params `
        -CharSet $CharSet

    $apiObj = if ($SysCall) {
        Initialize-ApiObject -ApiSpec $apiSpec -Mode $Mode -SysCall
    }
    else {
        $apiSpec | Initialize-ApiObject
    }

    try {
        return $apiObj | Invoke-Object -Params $Values -type API
    }
    finally {
        $apiObj | Release-ApiObject
    }
}

<#
.HELPERS 

UnicodeString function helper, 
just for testing purpose

+++ Struct Info +++

typedef struct _UNICODE_STRING {
  USHORT Length; [ushort = 2]
  USHORT MaximumLength; [ushort = 2]
  ** in x64 enviroment Add 4 byte's padding **
  PWSTR  Buffer; [IntPtr].Size
} UNICODE_STRING, *PUNICODE_STRING;

Buffer Offset == [IntPtr].Size { x86=4, x64=8 }

+++ Test Code +++

Clear-Host
Write-Host

$unicodeStringPtr = Init-NativeString -Value 99 -Encoding Unicode
Parse-NativeString -StringPtr $unicodeStringPtr -Encoding Unicode
Free-NativeString -StringPtr $unicodeStringPtr

$ansiStringPtr = Init-NativeString -Value 99 -Encoding Ansi
Parse-NativeString -StringPtr $ansiStringPtr -Encoding Ansi
Free-NativeString -StringPtr $ansiStringPtr

$unicodeStringPtr = [IntPtr]::Zero
$unicodeStringPtr = Manage-UnicodeString -Value 'data123'
Parse-UnicodeString -unicodeStringPtr $unicodeStringPtr
Manage-UnicodeString -UnicodeStringPtr $unicodeStringPtr -Release
#>
function Init-NativeString {
    param (
        [string]$Value = "",

        [Parameter(Mandatory = $true)]
        [ValidateSet('Ansi', 'Unicode')]
        [string]$Encoding,

        [Int32]$Length = 0,
        [Int32]$MaxLength = 0,
        [Int32]$BufferSize = 0
    )
    if ([string]::IsNullOrEmpty($Value)) {
        $blockSize = if ([IntPtr]::Size -gt 4) { 0x10 } else { 0x08 }
        $stringPtr = New-IntPtr -Size $blockSize
        $stringVal = New-IntPtr -Size 0x02
        [marshal]::WriteInt16($stringPtr,  0x02, 0x02)
        [marshal]::WriteIntPtr($stringPtr, [IntPtr]::Size, $stringVal)
        return $stringPtr
    }

     # Determine required byte length of the string in the specified encoding
    if ($Encoding -eq 'Ansi') {
        $requiredSize = [System.Text.Encoding]::ASCII.GetByteCount($Value)
    } else {
        $requiredSize = [System.Text.Encoding]::Unicode.GetByteCount($Value)
    }

    if ($BufferSize -gt 0 -and $BufferSize -lt $requiredSize) {
        throw "BufferSize ($BufferSize) is smaller than the encoded string size ($requiredSize)."
    }

    $blockSize = if ([IntPtr]::Size -gt 4) { 0x10 } else { 0x08 }
    $stringPtr = New-IntPtr -Size $blockSize

    if ($Encoding -eq 'Ansi') {
        if ($Length -le 0) {
            $Length = [System.Text.Encoding]::ASCII.GetByteCount($Value)
            if ($Length -ge 0xFFFE) {
                $Length = 0xFFFC
            }
        }

        if ($BufferSize -gt 0) {
            $bufferPtr = New-IntPtr -Size $BufferSize
            $bytes = [System.Text.Encoding]::ASCII.GetBytes($Value)
            [Marshal]::Copy($bytes, 0, $bufferPtr, $bytes.Length)
        }
        else {
            $bufferPtr = [Marshal]::StringToHGlobalAnsi($Value)
        }
        if ($MaxLength -le 0) {
            $maxLength = $Length + 1
        }
    }
    else {
        if ($Length -le 0) {
            $Length = $Value.Length * 2
            if ($Length -ge 0xFFFE) {
                $Length = 0xFFFC
            }
        }
        if ($BufferSize -gt 0) {
            $bufferPtr = New-IntPtr -Size $BufferSize
            $bytes = [System.Text.Encoding]::Unicode.GetBytes($Value)
            [Marshal]::Copy($bytes, 0, $bufferPtr, $bytes.Length)
        }
        else {
            $bufferPtr = [Marshal]::StringToHGlobalUni($Value)
        }
        if ($MaxLength -le 0) {
            $maxLength = $Length + 2
        }
    }

    [Marshal]::WriteInt16($stringPtr, 0, $Length)
    [Marshal]::WriteInt16($stringPtr, 2, $maxLength)
    [Marshal]::WriteIntPtr($stringPtr, [IntPtr]::Size, $bufferPtr)

    return $stringPtr
}
function Parse-NativeString {
    param (
        [Parameter(Mandatory = $true)]
        [IntPtr]$StringPtr,

        [Parameter(Mandatory = $false)]
        [ValidateSet('Ansi', 'Unicode')]
        [string]$Encoding = 'Ansi'
    )

    if ($StringPtr -eq [IntPtr]::Zero) {
        return
    }

    $Length = [Marshal]::ReadInt16($StringPtr, 0)
    $Size   = [Marshal]::ReadInt16($StringPtr, 2)
    $BufferPtr = [Marshal]::ReadIntPtr($StringPtr, [IntPtr]::Size)
    if ($Length -le 0) {
        return $null
    }

    if ($Encoding -eq 'Ansi') {
        # Length is number of bytes
        $Data = [Marshal]::PtrToStringAnsi($BufferPtr, $Length)
    } else {
        # Unicode, length is bytes, divide by 2 for chars
        $Data = [Marshal]::PtrToStringUni($BufferPtr, $Length / 2)
    }

    return [PSCustomObject]@{
        Length        = $Length
        MaximumLength = $Size
        StringData    = $Data
    }
}
function Free-NativeString {
    param (
        [Parameter(Mandatory = $true)]
        [IntPtr]$StringPtr
    )
    
    if ($StringPtr -eq [IntPtr]::Zero) {
        Write-Warning 'Failed to free pointer: The pointer is null'
        return
    }

    $ptr = [IntPtr]::Zero
    try {
        $bufferPtr = [Marshal]::ReadIntPtr($StringPtr, [IntPtr]::Size)
        if ($bufferPtr -ne [IntPtr]::Zero) {
            [Marshal]::FreeHGlobal($bufferPtr)
        }
        else {
            Write-Warning 'Failed to free buffer: The buffer pointer is null.'
        }
        [Marshal]::FreeHGlobal($StringPtr)
    }
    catch {
        Write-Warning 'An error occurred while attempting to free memory'
        return
    }
}

<#
.SYNOPSIS
Manages native UNICODE_STRING memory and content for P/Invoke.

.DESCRIPTION
This function allows for the creation of new UNICODE_STRING structures,
in-place updating of existing ones, and safe release of all associated
unmanaged memory (both the structure and its internal string buffer)
using low-level NTDLL APIs.

.USE
Manage-UnicodeString -Value '?'
Manage-UnicodeString -Value '?' -UnicodeStringPtr ?
Manage-UnicodeString -UnicodeStringPtr ? -Release
#>
function Manage-UnicodeString {
    param (
        [Parameter(Mandatory = $false)]
        [ValidateNotNullOrEmpty()]
        [string] $Value,

        [Parameter(Mandatory = $false)]
        [IntPtr] $UnicodeStringPtr = [IntPtr]::Zero,

        [switch] $Release
    )

    # Check if the pointer is valid (non-zero)
    $isValidPtr = $UnicodeStringPtr -ne [IntPtr]::Zero

    # Case 1: Value only - allocate and create a new string (if pointer is zero)
    if ($Value -and -not $isValidPtr -and -not $Release) {
        $unicodeStringPtr = New-IntPtr -Size 16
        $returnValue = $Global:ntdll::RtlCreateUnicodeString($unicodeStringPtr, $Value)

        # Check if the lowest byte is 1 (indicating success as per the C code's CONCAT71)
        if (($returnValue -band 0xFF) -ne 1) {
                throw "Failed to create Unicode string for '$Value'. NTSTATUS return value: 0x$hexReturnValue"
        }

        return $unicodeStringPtr
    }

    # Case 2: Value + existing pointer - reuse the pointer (if pointer is valid)
    elseif ($Value -and $isValidPtr -and -not $Release) {
        $null = $Global:ntdll::RtlFreeUnicodeString($unicodeStringPtr)
        $Global:ntdll::RtlZeroMemory($unicodeStringPtr, [UIntPtr]::new(16))
        $returnValue = $Global:ntdll::RtlCreateUnicodeString($unicodeStringPtr, $Value)
        
        # Check if the lowest byte is 1 (indicating success as per the C code's CONCAT71)
        if (($returnValue -band 0xFF) -ne 1) {
                throw "Failed to create Unicode string for '$Value'. NTSTATUS return value: 0x$hexReturnValue"
        }
        return
    }

    # Case 3: Pointer + Release - cleanup the string (if pointer is valid)
    elseif (-not $Value -and $isValidPtr -and $Release) {
        $null = $Global:ntdll::RtlFreeUnicodeString($unicodeStringPtr)
        New-IntPtr -hHandle $unicodeStringPtr -Release
        return
    }

    # Invalid combinations (no valid operation matched)
    else {
        throw "Invalid parameter combination. You must provide one of the following:
        1) -Value to create a new string,
        2) -Value and -unicodeStringPtr to reuse the pointer,
        3) -unicodeStringPtr and -Release to free the string."
    }
}

<#
.HELPERS 

* VARIANT structure (oaidl.h)
* https://learn.microsoft.com/en-us/windows/win32/api/oaidl/ns-oaidl-variant

struct {
    VARTYPE vt;           0x0
    WORD    wReserved1;   0x2
    WORD    wReserved2;
    WORD    wReserved3;
    union 
    {
        LONGLONG llVal;
        LONG lVal;
        BYTE bVal;
        SHORT iVal;
        FLOAT fltVal;
        DOUBLE dblVal;
        VARIANT_BOOL boolVal;
        VARIANT_BOOL __OBSOLETE__VARIANT_BOOL;
        SCODE scode;
        CY cyVal;
        DATE date;
        BSTR bstrVal;
        IUnknown *punkVal;
        IDispatch *pdispVal;
        SAFEARRAY *parray;
        BYTE *pbVal;
        SHORT *piVal;
        LONG *plVal;
        LONGLONG *pllVal;
        FLOAT *pfltVal;
        DOUBLE *pdblVal;
        VARIANT_BOOL *pboolVal;
        VARIANT_BOOL *__OBSOLETE__VARIANT_PBOOL;
        SCODE *pscode;
        CY *pcyVal;
        DATE *pdate;
        BSTR *pbstrVal;
        IUnknown **ppunkVal;
        IDispatch **ppdispVal;
        SAFEARRAY **pparray;
        VARIANT *pvarVal;
        PVOID byref;
        CHAR cVal;
        USHORT uiVal;
        ULONG ulVal;
        ULONGLONG ullVal;
        INT intVal;
        UINT uintVal;
        DECIMAL *pdecVal;
        CHAR *pcVal;
        USHORT *puiVal;
        ULONG *pulVal;
        ULONGLONG *pullVal;
        INT *pintVal;
        UINT *puintVal;
    }
} VARIANT *LPVARIANT;

enum VARENUM
{
    VT_EMPTY  = 0,
    VT_NULL	= 1,
    VT_I2	= 2,
    VT_I4	= 3,
    VT_R4	= 4,
    VT_R8	= 5,
    VT_CY	= 6,
    VT_DATE	= 7,
    VT_BSTR	= 8,
    VT_DISPATCH	= 9,
    VT_ERROR	= 10,
    VT_BOOL	= 11,
    VT_VARIANT	= 12,
    VT_UNKNOWN	= 13,
    VT_DECIMAL	= 14,
    VT_I1	= 16,
    VT_UI1	= 17,
    VT_UI2	= 18,
    VT_UI4	= 19,
    VT_I8	= 20,
    VT_UI8	= 21,
    VT_INT	= 22,
    VT_UINT	= 23,
    VT_VOID	= 24,
    VT_HRESULT	= 25,
    VT_PTR	= 26,
    VT_SAFEARRAY	= 27,
    VT_CARRAY	= 28,
    VT_USERDEFINED	= 29,
    VT_LPSTR	= 30,
    VT_LPWSTR	= 31,
    VT_RECORD	= 36,
    VT_INT_PTR	= 37,
    VT_UINT_PTR	= 38,
    VT_FILETIME	= 64,
    VT_BLOB	= 65,
    VT_STREAM	= 66,
    VT_STORAGE	= 67,
    VT_STREAMED_OBJECT	= 68,
    VT_STORED_OBJECT	= 69,
    VT_BLOB_OBJECT	= 70,
    VT_CF	= 71,
    VT_CLSID	= 72,
    VT_VERSIONED_STREAM	= 73,
    VT_BSTR_BLOB	= 0xfff,
    VT_VECTOR	= 0x1000,
    VT_ARRAY	= 0x2000,
    VT_BYREF	= 0x4000,
    VT_RESERVED	= 0x8000,
    VT_ILLEGAL	= 0xffff,
    VT_ILLEGALMASKED	= 0xfff,
    VT_TYPEMASK	= 0xfff
} ;

~~~~~~~~~~~~~~~

"ApiMajorVersion", "ApiMinorVersion", "ProductVersionString" | ForEach-Object {
    $name = $_
    $outVarPtr = New-Variant -Type VT_EMPTY
    $inVarPtr  = New-Variant -Type VT_BSTR -Value $name
    try {
        $ret = Use-ComInterface `
            -CLSID "C2E88C2F-6F5B-4AAA-894B-55C847AD3A2D" `
            -IID "85713fa1-7796-4fa2-be3b-e2d6124dd373" `
            -Index 1 -Name "GetInfo" `
            -Values @($inVarPtr, $outVarPtr) `
            -Type IDispatch

        if ($ret -eq 0) {
            $value = Parse-Variant -variantPtr $outVarPtr
            Write-Host "$name -> $value"
        }

    } finally {
        Free-Variant $inVarPtr
        Free-Variant $outVarPtr
    }
}
#>
function New-Variant {
    param(
        [Parameter(Mandatory)]
        [ValidateSet(
            "VT_EMPTY","VT_NULL","VT_I2",
            "VT_I4","VT_R4","VT_R8",
            "VT_BOOL","VT_BSTR","VT_DATE"
        )] 
        [string]$Type,

        [object]$Value
    )

    # Allocate VARIANT struct (24 bytes)
    $variantPtr = New-IntPtr -Size 24

    # Map type string to VARENUM
    $vt = switch ($Type) {
        "VT_EMPTY" {0}
        "VT_NULL"  {1}
        "VT_I2"    {2}
        "VT_I4"    {3}
        "VT_R4"    {4}
        "VT_R8"    {5}
        "VT_DATE"  {7}
        "VT_BSTR"  {8}
        "VT_BOOL"  {11}
        default    { throw "Unsupported VARIANT type $Type" }
    }

    [Marshal]::WriteInt16($variantPtr, 0, $vt)

    # Write value
    switch ($vt) {
        0  { } # VT_EMPTY, do nothing
        2  { [Marshal]::WriteInt16($variantPtr, 8, [int16]$Value) }  # VT_I2
        3  { [Marshal]::WriteInt32($variantPtr, 8, [int32]$Value) }  # VT_I4
        4  { [Marshal]::WriteInt32($variantPtr, 8, [BitConverter]::ToInt32([BitConverter]::GetBytes([float]$Value),0)) } # VT_R4
        5  { [Marshal]::WriteInt64($variantPtr, 8, [BitConverter]::ToInt64([BitConverter]::GetBytes([double]$Value),0)) } # VT_R8
        7  { # VT_DATE = OLE Automation DATE
            $dateVal = [double]([datetime]$Value).ToOADate()
            [Marshal]::WriteInt64($variantPtr, 8, [BitConverter]::ToInt64([BitConverter]::GetBytes($dateVal),0))
        }
        8  { # VT_BSTR
            $bstr = [Marshal]::StringToBSTR($Value)
            [Marshal]::WriteIntPtr($variantPtr, 8, $bstr)
        }
        11 { # VT_BOOL
            $boolVal = if ($Value) { -1 } else { 0 } # VARIANT_TRUE/-FALSE
            [Marshal]::WriteInt16($variantPtr, 8, $boolVal)
        }
    }

    return $variantPtr
}
function Parse-Variant {
    param([IntPtr]$variantPtr)

    if ($variantPtr -eq [IntPtr]::Zero) { return $null }

    $vt = [Marshal]::ReadInt16($variantPtr, 0)

    switch ($vt) {
        0  { return $null } # VT_EMPTY
        1  { return $null } # VT_NULL
        2  { return [Marshal]::ReadInt16($variantPtr, 8) } # VT_I2
        3  { return [Marshal]::ReadInt32($variantPtr, 8) } # VT_I4
        4  { return [BitConverter]::ToSingle([BitConverter]::GetBytes([Marshal]::ReadInt32($variantPtr, 8)),0) } # VT_R4
        5  { return [BitConverter]::ToDouble([BitConverter]::GetBytes([Marshal]::ReadInt64($variantPtr, 8)),0) } # VT_R8
        7  { return [datetime]::FromOADate([BitConverter]::ToDouble([BitConverter]::GetBytes([Marshal]::ReadInt64($variantPtr, 8)),0)) } # VT_DATE
        8  { # VT_BSTR
            $bstrPtr = [Marshal]::ReadIntPtr($variantPtr, 8)
            if ($bstrPtr -ne [IntPtr]::Zero) {
                return [Marshal]::PtrToStringBSTR($bstrPtr)
            }
            return $null
        }
        11 { return ([Marshal]::ReadInt16($variantPtr, 8) -ne 0) } # VT_BOOL
        default { return "[Unsupported VARIANT type $vt]" }
    }
}
function Free-Variant {
    param([IntPtr]$variantPtr)
    if ($variantPtr -eq [IntPtr]::Zero) { return }

    $vt = [Marshal]::ReadInt16($variantPtr, 0)
    if ($vt -eq 8) { # VT_BSTR
        $bstrPtr = [Marshal]::ReadIntPtr($variantPtr, 8)
        if ($bstrPtr -ne [IntPtr]::Zero) { [Marshal]::FreeBSTR($bstrPtr) }
    }
    [Marshal]::FreeHGlobal($variantPtr)
}

<#
  A utility function for generating, converting, and comparing GUIDs.
  Supports conversions between GUID, ByteArray, and Pointer formats.
  Can also compare GUIDs for equality with different representations.
  Example use.

  Clear-Host
  Write-Host
  $Guid = Guid-Handler -Generate
  $GuidPtr = Guid-Handler $Guid -OutputType Pointer
  $GuidBytes = Guid-Handler $GuidPtr -OutputType ByteArray
  $GuidNew = Guid-Handler $GuidBytes -OutputType Guid
  Guid-Handler -InputData $GuidPtr -ReferenceData $GuidBytes -Compare
  Write-Host
  return
#>
function Guid-Handler {
    [CmdletBinding()]
    param(
        [Parameter(Position = 0, ValueFromPipeline = $true)]
        [object]$InputData,

        [Parameter(Position = 1)]
        [object]$ReferenceData,

        [Parameter(Position = 2)]
        [ValidateSet("Guid", "ByteArray", "Pointer")]
        [string]$OutputType,

        [Parameter(Position = 3)]
        [switch]$Generate,
        [Parameter(Position = 4)]
        [switch]$Compare
    )

    begin {
        $GuidValue, $GuidBytes, $GuidPtr = `
            $null, $null, $null
        
        $GuidValueNew, $GuidBytesNew, $GuidPtrNew = `
            $null, $null, $null

        Add-Type `
            -AssemblyName System.Runtime.InteropServices
    }

    Process {
        # Case New Guid
        if ($Generate) {
            if ($Compare -or $ReferenceData) {
                Write-Error "can't combine -Compare and [-Generate or -ReferenceData]"
                return
            }
           return [guid]::NewGuid()
        }

        if ($ReferenceData -and !$Compare) {
            Write-Error "-ReferenceData must be used with -Compare"
            return
        }
       
        # Case Guid Value [Struct]
        try {
          if (!$GuidValue -or !$GuidBytes) {
            [Guid]$GuidValue = $InputData
            $GuidBytes = $GuidValue.ToByteArray()
          }
        } catch {}
        
        # Case Guid Bytes Array
        try {
          if (!$GuidValue -or !$GuidBytes) {
            [byte[]]$GuidBytes = $InputData
            try {
              $GuidValue = [Guid]::new($GuidBytes)
            } catch {
              $GuidValue = [Activator]::CreateInstance([type]'System.Guid', $GuidBytes)
            }
          }
        } catch {}
        
        # Case Guid Pointer
        try {
          if (!$GuidValue -or !$GuidBytes) {
            [IntPtr]$GuidPtr = $InputData

            if (!(IsValid-IntPtr $GuidPtr)) {
                Write-Error "Pointer not valid"
                return
            }

            # Alt` [Byte[]]::new(16) -or @(0) * 16
            [byte[]]$GuidBytes = New-Object byte[] 16
            [Marshal]::Copy($GuidPtr, $GuidBytes, 0, 16)

            # Directly Case from Pointer, Work just fine.
            # Avoid use [Guid]::new / [Activator]::CreateInstance
            $GuidValue = [Marshal]::PtrToStructure(
                $GuidPtr, [type][Guid]) # Or [type]'Guid'
          }
        } catch {}

        # Case Equal
        if ($Compare) {
            if (!$ReferenceData) {
                Write-Error "Must Provide ReferenceData Object"
                return
            }
            try {
              if (!$GuidValueNew -or !$GuidBytesNew) {
                [Guid]$GuidValueNew = $ReferenceData
                $GuidBytesNew = $GuidValueNew.ToByteArray()
              }
            } catch {}
            try {
              if (!$GuidValueNew -or !$GuidBytesNew) {
                [byte[]]$GuidBytesNew = $ReferenceData
                try {
                  $GuidValueNew = [Guid]::new($GuidBytesNew)
                } catch {
                  $GuidValueNew = [Activator]::CreateInstance([type]'System.Guid', $GuidBytesNew)
                }
              }
            } catch {}
            try {
              if (!$GuidValueNew -or !$GuidBytesNew) {
                [IntPtr]$GuidPtrNew = $ReferenceData
                if (!(IsValid-IntPtr $GuidPtrNew)) {
                    Write-Error "Pointer not valid"
                    return
                }

                # Alt` [Byte[]]::new(16) -or @(0) * 16
                [byte[]]$GuidBytesNew = New-Object byte[] 16
                [Marshal]::Copy($GuidPtrNew, $GuidBytesNew, 0, 16)

                # Directly Case from Pointer, Work just fine.
                # Avoid use [Guid]::new / [Activator]::CreateInstance
                $GuidValueNew = [Marshal]::PtrToStructure(
                    $GuidPtrNew, [type][Guid]) # Or [type]'Guid'
              }
            } catch {}
            try {
                $IsEqal = [Guid]::Equals($GuidValue, $GuidValueNew)
                return $IsEqal
            }
            catch{}
            return $false
        }

        # Return results
        if ($OutputType -eq "Guid") {
            return $GuidValue
          }
          elseif ($OutputType -eq "ByteArray") {
            return $GuidBytes
          }
          elseif ($OutputType -eq "Pointer") {
            $GuidPtr = if (IsValid-IntPtr $GuidPtr) {
                $GuidPtr 
            } else {
                New-IntPtr -Data $GuidBytes 
            }
            return $GuidPtr
          } else {
            return $null
        }
    }
}

<#
.SYNOPSIS
* keyhelper API
* Source, change edition` script by windows addict

* KMS Local Activation Tool
* https://github.com/laomms/KmsTool/blob/main/Form1.cs

* 'Retail', 'OEM', 'Volume', 'Volume:GVLK', 'Volume:MAK'
  Any other case, it use default key

_wcsnicmp(input, "Retail", 6)           ? _CHANNEL_ENUM = 1
_wcsnicmp(input, "OEM", 3)              ? _CHANNEL_ENUM = 2
_wcsnicmp(input, "Volume:MAK", 10)      ? _CHANNEL_ENUM = 4
_wcsnicmp(input, "Volume:GVLK", 11)     ? _CHANNEL_ENUM = 3
_wcsnicmp(input, "Volume", 6)           ? _CHANNEL_ENUM = 3
)
#>
function Get-ProductKeys {
    param (
        [Parameter(Mandatory = $true)]
        [string]$EditionID,

        [Parameter(Mandatory = $false)]
        [ValidateSet('Default', 'Retail', 'OEM', 'Volume:GVLK', 'Volume:MAK')]
        [string]$ProductKeyType
    )

    $id = 0
    $result = @()
    $defaultKey = ''

    if ([int]::TryParse($EditionID, [ref]$null)) {
        $id = [int]$EditionID
    }
    else {
        $id = $Global:productTypeTable | Where-Object ProductID -eq $EditionID | Select-Object -ExpandProperty DWORD
        if ($id -eq 0) {
            $null = $Global:PKHElper::GetEditionIdFromName($EditionID, [ref]$id)
        }
    }

    if ($id -eq 0) {
        throw "Could not resolve edition ID from input '$EditionID'."
    }

    # Step 1 - Retrieve the 'Default' key for the edition upfront
    $keyOutPtr = $typeOutPtr = $ProductKeyTypePtr = [IntPtr]::Zero
    try {
        $hResults = $Global:PKHElper::SkuGetProductKeyForEdition($id, [IntPtr]::zero, [ref]$keyOutPtr, [ref]$typeOutPtr)
        if ($hResults -eq 0) {
            $defaultKey = [Marshal]::PtrToStringUni($keyOutPtr)
        }
    }
    catch { }
    finally {
        ($keyOutPtr, $typeOutPtr) | % { Free-IntPtr -handle $_ -Method Heap}
        ($ProductKeyTypePtr, $ProductKeyTypePtr) | % { Free-IntPtr -handle $_ -Method Auto}
    }

    # Step 2 - Case of specic group Key
    if ($ProductKeyType) {
        # Handle specific ProductKeyType request
        try {
            $keyOutPtr = $typeOutPtr = $ProductKeyTypePtr = [IntPtr]::Zero
            if ($ProductKeyType -eq 'Default') {
                $keyOut = $defaultKey
            }
            else {
                $ProductKeyTypePtr = [Marshal]::StringToHGlobalUni($ProductKeyType)
                $hResults = $Global:PKHElper::SkuGetProductKeyForEdition($id, $ProductKeyTypePtr, [ref]$keyOutPtr, [ref]$typeOutPtr)
                if ($hResults -eq 0) {
                    $keyOut = [Marshal]::PtrToStringUni($keyOutPtr)
                }
            }

            $isDefault = !($keyOut -eq $defaultKey)
            $IsValue   = !([String]::IsNullOrWhiteSpace($keyOut))

            if ($IsValue -and (($ProductKeyType -eq 'Default') -or ($ProductKeyType -ne 'Default' -and $isDefault))) {
                $result += [PSCustomObject]@{
                    ProductKeyType = $ProductKeyType
                    ProductKey     = $keyOut
                }
            }
        }
        catch {}
        finally {
            ($keyOutPtr, $typeOutPtr) | % { Free-IntPtr -handle $_ -Method Heap }
            ($ProductKeyTypePtr, $ProductKeyTypePtr) | % { Free-IntPtr -handle $_ -Method Auto }
        }
    }

    # Step 3 - Case of Whole option's
    if (-not $ProductKeyType) {
        # Loop through other key types (excluding 'Default' as it's handled above)
        foreach ($group in @('Retail', 'OEM', 'Volume:GVLK', 'Volume:MAK' )) {
            try {
                $keyOutPtr = $typeOutPtr = $ProductKeyTypePtr = [IntPtr]::Zero
                $ProductKeyTypePtr = [Marshal]::StringToHGlobalUni($group)
                $hResults = $Global:PKHElper::SkuGetProductKeyForEdition($id, $ProductKeyTypePtr, [ref]$keyOutPtr, [ref]$typeOutPtr)
                if ($hResults -eq 0) {
                    $keyOut = [Marshal]::PtrToStringUni($keyOutPtr)
                    if (-not [string]::IsNullOrWhiteSpace($keyOut)) {
                        $result += [PSCustomObject]@{
                            ProductKeyType = $group
                            ProductKey     = $keyOut
                        }
                    }
                }
            }
            catch {}
            finally {
                Free-IntPtr -handle $ProductKeyTypePtr -Method Auto
                ($keyOutPtr, $typeOutPtr) | % { Free-IntPtr -handle $_ -Method Heap }
            }
        }
            
        # Now, filter the collected results based on your specific rules
        $seenKeys = @{}
        $filterResults = @()

        # Add the 'Default' key to results if it's valid
        if (-not [string]::IsNullOrWhiteSpace($defaultKey)) {
            $seenKeys[$defaultKey] = $true
            $filterResults += [PSCustomObject]@{
                ProductKeyType = "Default"
                ProductKey     = $defaultKey
            }
        }

        # Add other entries only if their ProductKey hasn't been seen yet
        foreach ($item in $result) {
            if (-not [string]::IsNullOrWhiteSpace($item.ProductKey) -and -not $seenKeys.ContainsKey($item.ProductKey)) {
                $filterResults += $item
                $seenKeys[$item.ProductKey] = $true
            }
        }
        $result = $filterResults
    }

    return $result
}

<#
.SYNOPSIS
Read PkeyConfig data from System,
Include Windows & Office pKeyConfig license's
#>
function Init-XMLInfo {
    $paths = @(
        "C:\Windows\System32\spp\tokens\pkeyconfig\pkeyconfig.xrm-ms",
        "C:\Windows\System32\spp\tokens\pkeyconfig\pkeyconfig-csvlk.xrm-ms",
        "C:\Windows\System32\spp\tokens\pkeyconfig\pkeyconfig-downlevel.xrm-ms",
        "C:\Program Files\Microsoft Office\root\Licenses16\pkeyconfig-office.xrm-ms"
    )

    $entries = @()
    foreach ($path in $paths) {
        if (Test-Path -Path $path) {
            $extracted = Extract-Base64Xml -FilePath $path
            if ($extracted) {
                $entries += $extracted
            }
        }
    }

    return $entries
}
function Extract-Base64Xml {
    param (
        [string]$FilePath
    )

    # Check if the file exists
    if (-Not (Test-Path $FilePath)) {
        Write-Warning "File not found: $FilePath"
        return $null
    }

    # Read the content of the file
    $content = Get-Content -Path $FilePath -Raw

    # Use regex to find all Base64 encoded strings between <tm:infoBin> tags
    $matches = [regex]::Matches($content, '<tm:infoBin name="pkeyConfigData">(.*?)<\/tm:infoBin>', [RegexOptions]::Singleline)

    $configurationsList = @()

    foreach ($match in $matches) {
        # Extract the Base64 encoded string
        $base64String = $match.Groups[1].Value.Trim()

        # Decode the Base64 string
        try {
            $decodedBytes = [Convert]::FromBase64String($base64String)
            $decodedString = [Encoding]::UTF8.GetString($decodedBytes)
            [xml]$xmlData = $decodedString

            # Process ProductKeyConfiguration
            #$xmlData.OuterXml | Out-File 'C:\Users\Administrator\Desktop\License.txt'
            if ($xmlData.ProductKeyConfiguration.Configurations) {
                foreach ($config in $xmlData.ProductKeyConfiguration.Configurations.ChildNodes) {
                    # Create a PSCustomObject for each configuration
                    $configObj = [PSCustomObject]@{
                        ActConfigId       = $config.ActConfigId
                        RefGroupId        = $config.RefGroupId
                        EditionId         = $config.EditionId
                        ProductDescription = $config.ProductDescription
                        ProductKeyType    = $config.ProductKeyType
                        IsRandomized      = $config.IsRandomized
                    }
                    $configurationsList += $configObj
                }
            }
        } catch {
            Write-Warning "Failed to decode Base64 string: $_"
        }
    }

    # Return the list of configurations
    return $configurationsList
}

<#
.SYNOPSIS
Get System Build numbers using low level methods

#>
Function Init-osVersion {
    
    <#
        First try read from KUSER_SHARED_DATA 
        And, if fail, Read from PEB.!

        RtlGetNtVersionNumbers Read from PEB. [X64 offset]
        * v3 = NtCurrentPeb();
        * OSMajorVersion -> 0x118 (v3->OSMajorVersion)
        * OSMinorVersion -> 0x11C (v3->OSMinorVersion)
        * OSBuildNumber  -> 0x120 (v3->OSBuildNumber | 0xF0000000)

        RtlGetVersion, do the same, just read extra info from PEB
        * v2 = NtCurrentPeb();
        * a1[1] = v2->OSMajorVersion;
        * a1[2] = v2->OSMinorVersion;
        * a1[3] = v2->OSBuildNumber;
        * a1[4] = v2->OSPlatformId;
        * Buffer = v2->CSDVersion.Buffer;
    #>

    if (-not $Global:PebPtr -or $Global:PebPtr -eq [IntPtr]::Zero) {
        $Global:PebPtr = NtCurrentTeb -Peb
        #$Global:PebPtr = $Global:ntdll::RtlGetCurrentPeb()
    }

    try {
        # 0x026C, ULONG NtMajorVersion; NT 4.0 and higher
        $NtMajorVersion = [Marshal]::ReadInt32([IntPtr](0x7FFE0000 + 0x26C))

        # 0x0270, ULONG NtMinorVersion; NT 4.0 and higher
        $NtMinorVersion = [Marshal]::ReadInt32([IntPtr](0x7FFE0000 + 0x270))

        # 0x0260, ULONG NtBuildNumber; NT 10.0 & higher
        $NtBuildNumber  = [Marshal]::ReadInt32([IntPtr](0x7FFE0000 + 0x0260))

        if (($NtMajorVersion -lt 10) -or (
            $NtBuildNumber -lt 10240)) {
      
          # this offset for nt 10.0 & Up
          # NT 6.3 end in 9600,
          # nt 10.0 start with 10240 (RTM)

          # Before, we stop throw, 
          # Try read from PEB memory.

          $offset = if ([IntPtr]::Size -eq 8) { 0x120 } else { 0x0AC }
          $NtBuildNumber = [int][Marshal]::ReadInt16($Global:PebPtr, $offset)

          # 0xAC, 0x0120, USHORT OSBuildNumber; 4.0 and higher
          if ($NtBuildNumber -lt 1381) {
            throw }
        }

        # Extract Service Pack Major (high byte) and Minor (low byte)
        # *((_WORD *)a1 + 138) = HIBYTE(v2->OSCSDVersion);
        # *((_WORD *)a1 + 139) = (unsigned __int8)v2->OSCSDVersion;
        $offset = if ([IntPtr]::Size -eq 8) { 0x122 } else { 0xAE }
        $oscVersion = [Marshal]::ReadInt16($Global:PebPtr, $offset)
        $wServicePackMajor = ($oscVersion -shr 8) -band 0xFF
        $wServicePackMinor = $oscVersion -band 0xFF

        # Retrieve the OS version details
        return [PSCustomObject]@{
            Major   = $NtMajorVersion
            Minor   = $NtMinorVersion
            Build   = $NtBuildNumber
            UBR     = $Global:ubr
            Version = ($NtMajorVersion,$NtMinorVersion,$NtBuildNumber)
            ServicePackMajor = $wServicePackMajor
            ServicePackMinor = $wServicePackMinor
        }
    }
    catch {}
        
    # Fallback: REGISTRY
    try {
        $major = (Get-ItemProperty -Path $Global:CurrentVersion -Name CurrentMajorVersionNumber -ea 0).CurrentMajorVersionNumber
        $minor = (Get-ItemProperty -Path $Global:CurrentVersion -Name CurrentMinorVersionNumber -ea 0).CurrentMinorVersionNumber
        $build = (Get-ItemProperty -Path $Global:CurrentVersion -Name CurrentBuildNumber -ea 0).CurrentBuildNumber
        $osVersion = [PSCustomObject]@{
            Major   = [int]$major
            Minor   = [int]$minor
            Build   = [int]$build
            UBR     = $Global:ubr
            Version = @([int]$major, [int]$minor, [int]$build)
            ServicePackMajor = 0
            ServicePackMinor = 0
        }
        return $osVersion
    }
    catch {
    }

    Clear-host
    Write-Host
    write-host "Failed to retrieve OS version from all methods."
    Write-Host
    read-host
    exit 1
}

<#
.SYNOPSIS
Get Edition Name using low level methods

#>
function Get-ProductID {
    
    <# 
        Experiment way,
        who work only on online active system,
        that why i don't use it !

        $LicensingProducts = (
            Get-SLIDList -eQueryIdType SL_ID_APPLICATION -eReturnIdType SL_ID_PRODUCT_SKU -pQueryId $windowsAppID | ? { Retrieve-SKUInfo -SkuId $_ -eReturnIdType SL_ID_PKEY }
            ) | % {
            [PSCustomObject]@{
                ID            = $_
                Description   = Get-LicenseDetails -ActConfigId $_ -pwszValueName 'Description'
                Name          = Get-LicenseDetails -ActConfigId $_ -pwszValueName 'productName'
                LicenseFamily = Get-LicenseDetails -ActConfigId $_ -pwszValueName 'Family'
            }
        }
        $ID_PKEY = $LicensingProducts | ? Name -NotMatch 'ESU' | ? Description -NotMatch 'ESU' | select -First 1
        [XML]$licenseData = Get-LicenseDetails $ID_PKEY.ID -ReturnRawData
        $Branding = $licenseData.licenseGroup.license[1].otherInfo.infoTables.infoList.infoStr | ? Name -EQ win:branding

        $ID_PKEY.LicenseFamily
        $Branding.'#text'
    #>

    # ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ ! ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

    <#
        Retrieves Windows Product Policy values from the registry
        HKLM:\SYSTEM\CurrentControlSet\Control\ProductOptions -> ProductPolicy
    #>

    $KernelEdition = Get-ProductPolicy -Filter Kernel-EditionName -UseApi | select -ExpandProperty Value
    #$KernelEdition = Get-ProductPolicy -Filter Kernel-EditionName | ? Name -Match 'Kernel-EditionName' | select -ExpandProperty Value
    if ($KernelEdition -and (-not [string]::IsNullOrWhiteSpace($KernelEdition))) {
        return $KernelEdition
    }

    <#
        Extract Edition Info from Registry -> 
            DigitalProductId4
    #>

    # DigitalProductId4, WCHAR szEditionType[260];
    $DigitalProductId4 = Parse-DigitalProductId4
    if ($DigitalProductId4 -and $DigitalProductId4.EditionType -and 
        (-not [String]::IsNullOrWhiteSpace($DigitalProductId4.EditionType))) {
        return $DigitalProductId4.EditionType
    }

    <#
        Use RtlGetProductInfo to get brand info, And convert the value

        Alternative, 
        * HKLM:\SYSTEM\CurrentControlSet\Control\ProductOptions, ProductPolicy
        * Get-ProductPolicy -> Read 'Kernel-BrandingInfo' -or 'Kernel-ProductInfo' -> Value
          Get-ProductPolicy | ? name -Match "Kernel-BrandingInfo|Kernel-ProductInfo" | select -First 1 -ExpandProperty Value
          which i believe, the source data of the function
        * Win32_OperatingSystem Class -> OperatingSystemSKU
          which i believe, call -> RtlGetProductInfo
        * Also, this registry value --> 
          HKLM\SYSTEM\CurrentControlSet\Control\ProductOptions->OSProductPfn
    #>
    try {
        <#
        -- It call ZwQueryLicenseValue -> Kernel-BrandingInfo \ Kernel-ProductInfo
        -- Replace with direct call ...

        [UInt32]$BrandingInfo = 0
        $status = $Global:ntdll::RtlGetProductInfo(
            $OperatingSystemInfo.dwOSMajorVersion,
            $OperatingSystemInfo.dwOSMinorVersion,
            $OperatingSystemInfo.dwSpMajorVersion,
            $OperatingSystemInfo.dwSpMinorVersion,
            [Ref]$BrandingInfo)

        if (!$status) {
            throw }

        # Get Branding info Number of current Build
        [INT]$BrandingInfo
        #>

        [INT]$BrandingInfo = Get-ProductPolicy |
            ? name -Match "Kernel-BrandingInfo|Kernel-ProductInfo" |
                ? Value | Select -First 1 -ExpandProperty Value

        # Get editionID Name using hard coded table,
        # provide by abbodi1406 :)
        $match = $Global:productTypeTable | Where-Object {
            [Convert]::ToInt32($_.DWORD, 16) -eq $BrandingInfo
        }
        if ($match) {
            return $match.ProductID
        }

        # using API to convert from BradingInfo to EditionName
        $editionIDPtr = [IntPtr]::Zero
        $hresults = $Global:PKHElper::GetEditionNameFromId(
            $BrandingInfo, [ref]$editionIDPtr)
        if ($hresults -eq 0) {
            $editionID = [Marshal]::PtrToStringUni($editionIDPtr)
            return $editionID
        }
    }
    catch { }
    Finally {
        New-IntPtr -hHandle $productTypePtr -Release
    }

    # Key: HKLM\SOFTWARE\Microsoft\Windows NT\CurrentVersion Propery: EditionID
    $EditionID = (Get-ItemProperty -Path "HKLM:\SOFTWARE\Microsoft\Windows NT\CurrentVersion" -Name EditionID -ea 0).EditionID
    if ($EditionID) {
        return $EditionID }

    Clear-host
    Write-Host
    write-host "Failed to Edition ID version from all methods."
    Write-Host
    read-host
    exit 1
}

<#
.SYNOPSIS
Retrieves Windows edition upgrade paths and facilitates interactive upgrades.
[Bool] USeApi Option, Only available for > *Current* edition

.EXAMPLE
# Target edition for current system:
Get-EditionTargetsFromMatrix
Get-EditionTargetsFromMatrix -UseApi

.EXAMPLE
# Target edition for a specific ID (e.g., 'EnterpriseSN'):
Get-EditionTargetsFromMatrix -EditionID 'EnterpriseSN'
Get-EditionTargetsFromMatrix -EditionID 'EnterpriseSN' -RawData

.EXAMPLE
# Upgrade from the current version (interactive selection):
Get-EditionTargetsFromMatrix -UpgradeFrom

.EXAMPLE
# Upgrade from a specific base version (e.g., 'EnterpriseSN' or 'CoreCountrySpecific'):
Get-EditionTargetsFromMatrix -UpgradeFrom -EditionID 'EnterpriseSN'
Get-EditionTargetsFromMatrix -UpgradeFrom -EditionID 'CoreCountrySpecific'

.EXAMPLE
# Upgrade to any chosen version (interactive product key selection):
Get-EditionTargetsFromMatrix -UpgradeTo

.EXAMPLE
# Upgrade to a specific edition (e.g., 'EnterpriseSEval' with product key selection):
Get-EditionTargetsFromMatrix -EditionID EnterpriseSEval -UpgradeTo

.EXAMPLE
# List all available editions:
Get-EditionTargetsFromMatrix -ReturnEditionList

--------------------------------------------------

PowerShell, Also support this function apparently
--> Get-WindowsEdition -Online -Target .!

#>
function Get-EditionTargetsFromMatrix {
    param (
        [Parameter(Mandatory = $false)]
        [ValidateSet(
            "ultimate","homebasic","homepremium","enterprise","homebasicn","business","serverstandard","serverdatacenter","serversbsstandard","serverenterprise","starter",
            "serverdatacentercore","serverstandardcore","serverenterprisecore","serverenterpriseia64","businessn","serverweb","serverhpc","serverhomestandard","serverstorageexpress",
            "serverstoragestandard","serverstorageworkgroup","serverstorageenterprise","serverwinsb","serversbspremium","homepremiumn","enterprisen","ultimaten","serverwebcore",
            "servermediumbusinessmanagement","servermediumbusinesssecurity","servermediumbusinessmessaging","serverwinfoundation","serverhomepremium","serverwinsbv","serverstandardv",
            "serverdatacenterv","serverenterprisev","serverdatacentervcore","serverstandardvcore","serverenterprisevcore","serverhypercore","serverstorageexpresscore","serverstoragestandardcore",
            "serverstorageworkgroupcore","serverstorageenterprisecore","startern","professional","professionaln","serversolution","serverforsbsolutions","serversolutionspremium",
            "serversolutionspremiumcore","serversolutionem","serverforsbsolutionsem","serverembeddedsolution","serverembeddedsolutioncore","professionalembedded","serveressentialmanagement",
            "serveressentialadditional","serveressentialmanagementsvc","serveressentialadditionalsvc","serversbspremiumcore","serverhpcv","embedded","startere","homebasice",
            "homepremiume","professionale","enterprisee","ultimatee","enterpriseeval","prerelease","servermultipointstandard","servermultipointpremium","serverstandardeval",
            "serverdatacentereval","prereleasearm","prereleasen","enterpriseneval","embeddedautomotive","embeddedindustrya","thinpc","embeddeda","embeddedindustry","embeddede",
            "embeddedindustrye","embeddedindustryae","professionalplus","serverstorageworkgroupeval","serverstoragestandardeval","corearm","coren","corecountryspecific","coresinglelanguage",
            "core","professionalwmc","mobilecore","embeddedindustryeval","embeddedindustryeeval","embeddedeval","embeddedeeval","coresystemserver","servercloudstorage","coreconnected",
            "professionalstudent","coreconnectedn","professionalstudentn","coreconnectedsinglelanguage","coreconnectedcountryspecific","connectedcar","industryhandheld",
            "ppipro","serverarm64","education","educationn","iotuap","serverhi","enterprises","enterprisesn","professionals","professionalsn","enterpriseseval",
            "enterprisesneval","iotuapcommercial","mobileenterprise","analogonecore","holographic","professionalsinglelanguage","professionalcountryspecific","enterprisesubscription",
            "enterprisesubscriptionn","serverdatacenternano","serverstandardnano","serverdatacenteracor","serverstandardacor","serverdatacentercor","serverstandardcor","utilityvm",
            "serverdatacenterevalcor","serverstandardevalcor","professionalworkstation","professionalworkstationn","serverazure","professionaleducation","professionaleducationn",
            "serverazurecor","serverazurenano","enterpriseg","enterprisegn","businesssubscription","businesssubscriptionn","serverrdsh","cloud","cloudn","hubos","onecoreupdateos",
            "cloude","andromeda","iotos","clouden","iotedgeos","iotenterprise","modernpc","iotenterprises","systemos","nativeos","gamecorexbox","gameos","durangohostos",
            "scarletthostos","keystone","cloudhost","cloudmos","cloudcore","cloudeditionn","cloudedition","winvos","iotenterprisesk","iotenterprisek","iotenterpriseseval",
            "agentbridge","nanohost","wnc","serverazurestackhcicor","serverturbine","serverturbinecor"
        )]
        [string]$EditionID = $null,

        [Parameter(Mandatory = $false)]
        [switch]$ReturnEditionList,

        [Parameter(Mandatory = $false)]
        [switch]$UpgradeFrom,

        [Parameter(Mandatory = $false)]
        [switch]$UpgradeTo,

        [Parameter(Mandatory = $false)]
        [switch]$UseApi,

        [Parameter(Mandatory = $false)]
        [switch]$RawData
    )

    $targets = @();

    [string]$xmlPath = "C:\Windows\servicing\Editions\EditionMappings.xml"
    [string]$MatrixPath = "C:\Windows\servicing\Editions\EditionMatrix.xml"
    if (-not $xmlPath -or -not $MatrixPath) {
        Write-Host
         Write-Warning "Required files not found: `n$xmlPath`n$MatrixPath"
        return
    }
    $CurrentEdition = Get-ProductID
    if ($UseApi -and (
            $EditionID -and ($EditionID -ne $CurrentEdition))) {
        Write-Warning "UseApi Only for Current edition."
        return @()
    }

    function Find-Upgrades {
        param (
            [Parameter(Mandatory = $true)]
            [ValidateNotNullOrEmpty()]
            [string]$EditionID
        )

        if ($EditionID -and ($Global:productTypeTable.ProductID -notcontains $EditionID)) {
            Write-Warning "EditionID '$EditionID' is not found in the product type table."
            return
        }
    
        $parentEdition = $null
        $relatedEditions = @()

        [xml]$xml = Get-Content -Path $xmlPath
        $WindowsEditions = $xml.WindowsEditions.Edition

        $isVirtual = $WindowsEditions.Name -contains $EditionID
        $isParent = $WindowsEditions.ParentEdition -contains $EditionID

        # If the selected edition is a Virtual Edition, get the Parent Edition
        if ($isVirtual) {
            $selectedEditionNode = $WindowsEditions | Where-Object { $_.Name -eq $EditionID }
            $parentEdition = $selectedEditionNode.ParentEdition
        }

        # If the edition is a Parent Edition, find all related Virtual Editions
        if ($isParent) {
            try {
                $relatedEditions = $WindowsEditions | Where-Object { $_.ParentEdition -eq $EditionID -and $_.virtual -eq "true" }
            }
            catch {
            }
        }

        # If the edition is a Virtual Edition, find all other Virtual Editions linked to the same Parent Edition
        if ($isVirtual) {
            try {
                $relatedEditions += $WindowsEditions | Where-Object { $_.ParentEdition -eq $parentEdition -and $_.virtual -eq "true" }
            }
            catch {
            }
        }

        return [PSCustomObject]@{
            Editions = $relatedEditions | Select-Object -ExpandProperty Name
            Parent   = $parentEdition
        }
    }
    Function Dism-GetTargetEditions {
        try {
            $hr = $Global:DismAPI::DismInitialize(
                0, [IntPtr]::Zero, [IntPtr]::Zero)
            if ($hr -ne 0) {
                Write-Warning "DismInitialize failed: $hr"
                return @()
            }

            $session = [IntPtr]::Zero
            $hr = $Global:DismAPI::DismOpenSession(
                "DISM_{53BFAE52-B167-4E2F-A258-0A37B57FF845}", [IntPtr]::Zero, [IntPtr]::Zero, [ref]$session)
            if ($hr -ne 0) { 
                Write-Warning "DismOpenSession failed: $hr"
                return
            }

            $count = 0
            $editionIds = [IntPtr]::Zero
            $hr = $Global:DismAPI::_DismGetTargetEditions($session, [ref]$editionIds, [ref]$count)
            if ($hr -ne 0) { 
                Write-Warning "_DismGetTargetEditions failed: $hr"
            }

            if ($hr -eq 0 -and $count -gt 0) {
                try {
                    return Convert-PointerArrayToStrings -PointerToArray $editionIds -Count $count
                }
                catch {
                    Write-Warning "Failed to convert editions: $_"
                    return @()
                }
            }
        }
        catch {
        }
        finally {
            if ($editionIds -and (
                $editionIds -ne [IntPtr]::Zero)) {
                    $null = $Global:DismAPI::DismDelete($editionIds)
            }
            if ($session -and (
                $session -ne [IntPtr]::Zero)) {
                    $null = $Global:DismAPI::DismCloseSession($session)
            }
            $null = $Global:DismAPI::DismShutdown()
        }
    }
    function Convert-PointerArrayToStrings {
        param (
            [Parameter(Mandatory = $true)]
            [IntPtr] $PointerToArray,

            [Parameter(Mandatory = $true)]
            [UInt32] $Count
        )

        if ($PointerToArray -eq [IntPtr]::Zero -or $Count -eq 0) {
            return @()
        }

        $strings = @()
        for ($i = 0; $i -lt $Count; $i++) {
            # Calculate pointer to pointer at index $i
            $ptrToStringPtr = [IntPtr]::Add($PointerToArray, $i * [IntPtr]::Size)

            # Read the string pointer
            $stringPtr = [Marshal]::ReadIntPtr($ptrToStringPtr)
            if ($stringPtr -ne [IntPtr]::Zero) {
                # Read the Unicode string from the pointer
                $edition = [Marshal]::PtrToStringUni($stringPtr)
                $strings += $edition
            }
        }
        return $strings
    }

    if (-Not (Test-Path $MatrixPath)) {
        Write-Warning "EditionMatrix.xml not found at $MatrixPath"
        return
    }
    if ($EditionID -and ($Global:productTypeTable.ProductID -notcontains $EditionID)) {
        Write-Warning "EditionID '$EditionID' is not found in the product type table."
        return
    }
    [xml]$xml = Get-Content $MatrixPath
    $LicensingProducts = Get-SLIDList -eQueryIdType SL_ID_PRODUCT_SKU -eReturnIdType SL_ID_PRODUCT_SKU | % {
        [PSCustomObject]@{
            ID            = $_
            Description   = Get-LicenseDetails -ActConfigId $_ -pwszValueName 'Description'
            Name          = Get-LicenseDetails -ActConfigId $_ -pwszValueName 'productName'
            LicenseFamily = Get-LicenseDetails -ActConfigId $_ -pwszValueName 'Family'
        }
    }
    $uniqueFamilies = $LicensingProducts.LicenseFamily | Select-Object -Unique
    
    if ($UpgradeFrom) {
        if (-not $EditionID) {
            $EditionID = $CurrentEdition
        }
        if (-not $EditionID) {
            Write-Host
            Write-Warning "EditionID is missing. Upgrade may not proceed correctly."
            return
        }

        # Find edition node in XML
        # Editions where this ID is the source (normal lookup)
        $sourceNode = $xml.TmiMatrix.Edition | Where-Object { $_.ID -eq $EditionID }

        # Editions where this ID is a target (reverse lookup)
        $targetNodes = $xml.TmiMatrix.Edition | Where-Object {
            $_.Target.ID -contains $EditionID
        }

        # Combine all
        $editionNode = @()
        if ($sourceNode) { $editionNode += $sourceNode }
        if ($targetNodes) { $editionNode += $targetNodes }
        $Upgrades = Find-Upgrades -EditionID $EditionID

        if ($UseApi -and (
            $EditionID -eq $CurrentEdition)) {
                $targetEditions = Dism-GetTargetEditions
        }
        else {
            if ($editionNode.Target.ID) {
                $targetEditions += $editionNode.Target.ID
            }

            if ($Upgrades.Editions) {
                $targetEditions += $Upgrades.Editions
            }

            if ($Upgrades.Parent) {
                $targetEditions += $Upgrades.Parent
            }

            $targetEditions = $targetEditions | ? { $_ -ne $CurrentEdition} | select -Unique
            if (-not $targetEditions) {
                Write-Host
                Write-Warning "No upgrade targets found for EditionID '$EditionID'."
                return
            }
            $targetEditions = $targetEditions | Where-Object { $uniqueFamilies  -contains $_ } | select -Unique
        }

        if ($targetEditions.Count -eq 0) {
            Write-Host
            Write-Warning "No targets license's found in Current system for '$EditionID' Edition."
            return
        }
        elseif ($targetEditions.Count -eq 1) {
            $chosenTarget = $targetEditions
            Write-Host
            Write-Warning "Only one upgrade target found: $chosenTarget. Selecting automatically."
        } else {
            # Multiple targets: let user choose
            $chosenTarget = $null
            while (-not $chosenTarget) {
                Clear-Host
                Write-Host
                Write-Host "[Available upgrade targets]"
                Write-Host
                for ($i = 0; $i -lt $targetEditions.Count; $i++) {
                    Write-Host "[$($i+1)] $($targetEditions[$i])"
                }
                $selection = Read-Host "Select upgrade target edition by number (or 'q' to quit)"
                if ($selection -eq 'q') { break }

                $parsedSelection = 0
                if ([int]::TryParse($selection, [ref]$parsedSelection) -and
                    $parsedSelection -ge 1 -and
                    $parsedSelection -le $targetEditions.Count) {
                    $chosenTarget = $targetEditions[$parsedSelection - 1]
                } else {
                    Write-Host "Invalid selection, please try again."
                }
            }
        }

        if (-not $chosenTarget) {
            Write-Host
            Write-Warning "No target edition selected. Cancelling."
            return
        }

        $UpgradeTo = $true
        $EditionID = $chosenTarget
    }
    if ($UpgradeTo) {
        $filteredKeys = $Global:PKeyDatabase | ? { $LicensingProducts.ID -contains $_.ActConfigId}
        if ($EditionID) {
            if ($EditionID -eq $CurrentEdition) {
                Write-Host
                Write-Warning "Attempting to upgrade to the same edition ($EditionID) already installed. No upgrade needed."
                return
            }
            $matchingKeys = @($filteredKeys | Where-Object { $_.EditionId -eq $EditionID })
            if (-not $matchingKeys -or $matchingKeys.Count -eq 0) {
                Write-Host
                Write-Warning "No matching keys found for EditionID '$EditionID'"
                return
            }
        } else {
            # No EditionID specified, use all keys
            $matchingKeys = @($filteredKeys)
        }

        if (-not $matchingKeys -or $matchingKeys.Count -eq 0) {
            Write-Host
            Write-Warning "No product keys available."
            return
        }

        if ($matchingKeys.Count -gt 1) {
            # Multiple keys: show Out-GridView for selection
            $selectedKey = $null
            while (-not $selectedKey) {
                Clear-Host
                Write-Host
                Write-Host "[Available product keys]"
                Write-Host

                for ($i = 0; $i -lt $matchingKeys.Count; $i++) {
                    $item = $matchingKeys[$i]
                    Write-Host ("{0,-4} {1,-30} | {2,-50} | {3,-15} | {4}" -f ("[$($i+1)]"), $item.EditionId, $item.ProductDescription, $item.ProductKeyType, $item.RefGroupId)
                }

                Write-Host
                $input = Read-Host "Select a product key by number (or 'q' to quit)"
                if ($input -eq 'q') { break }

                $parsed = 0
                if ([int]::TryParse($input, [ref]$parsed) -and $parsed -ge 1 -and $parsed -le $matchingKeys.Count) {
                    $selectedKey = $matchingKeys[$parsed - 1]
                } else {
                    Write-Host "Invalid selection. Please try again."
                }
            }            if (-not $selectedKey) {
                Write-Host
                Write-Warning "No selection made. Operation cancelled."
                return
            }
        }
        elseif ($matchingKeys.Count -eq 1) {
            # Only one key: select automatically
            $selectedKey = $matchingKeys
        }
        else {
            Write-Host
            Write-Warning "No product keys available."
            return
        }
        if (-not $selectedKey) {
            Write-Host
            Write-Warning "No selection made. Operation cancelled."
            return
        }

        # Simulated Key Installation
        Write-Host
        SL-InstallProductKey -Keys @(
            (Encode-Key $($selectedKey.RefGroupId) 0 0))

        return
    }
    if (-not $EditionID) {
        $EditionID = Get-ProductID
    }
    if ($ReturnEditionList) {
        return $xml.TmiMatrix.Edition | Select-Object -ExpandProperty ID
    }

    if ($UseApi -and (
        $EditionID -eq $CurrentEdition)) {
            $targets = Dism-GetTargetEditions
    }
    else {
        $Upgrades = Find-Upgrades -EditionID $EditionID
        $editionNode = $xml.TmiMatrix.Edition | Where-Object { $_.ID -eq $EditionID }
        
        if ($editionNode.Target.ID) {
            $targets += $editionNode.Target.ID
        }

        if ($Upgrades.Editions) {
            $targets += $Upgrades.Editions
        }

        if ($Upgrades.Parent) {
            $targets += $Upgrades.Parent
        }
        $FilterList = @($CurrentEdition, $EditionID)
        $targets = $targets | ? {$_ -notin $FilterList} | Sort-Object -Unique
    }
    if ($targets) {
        if ($RawData) {
            return $targets
        }
        Write-Host
        Write-Host "Edition '$EditionID' can be upgraded/downgraded to:" -ForegroundColor Green
        $targets | ForEach-Object { Write-Host "  - $_" }
    } else {
        if ($RawData) {
            return @()
        }
        Write-Host
        Write-Warning "Edition '$EditionID' has no defined upgrade targets."
    }
}

<#
Retrieves Windows Product Policy values from the registry.
Supports filtering by policy names or returns all by default.

Adapted from Windows Product Policy Editor by kost:
https://forums.mydigitallife.net/threads/windows-product-policy-editor.39411/

Software Licensing
https://www.geoffchappell.com/studies/windows/km/ntoskrnl/api/ex/slmem/index.htm?tx=57,58

Windows Vista introduces a formal scheme of named license values,
with API functions to manage them. The license values are stored together -
as binary data for a single registry value. The data format is presented separately.
Like registry values, each license value has its own data.

Windows Internals Book 7th Edition Tools
https://github.com/zodiacon/WindowsInternals/blob/master/SlPolicy/SlPolicy.cpp

windows Sdk
https://github.com/mic101/windows/blob/master/WRK-v1.2/public/internal/base/inc/zwapi.h

[StructLayout(LayoutKind.Sequential, CharSet = CharSet.Unicode)]
public struct UNICODE_STRING {
    public ushort Length;
    public ushort MaximumLength;
    public IntPtr Buffer;
}

public static class Ntdll {
    [DllImport("ntdll.dll", CharSet = CharSet.Unicode)]
    public static extern int ZwQueryLicenseValue(
        ref UNICODE_STRING ValueName,
        out uint Type,
        IntPtr Data,
        uint DataSize,
        out uint ResultDataSize
    );
}
#>
function Get-ProductPolicy {
    param (
        [Parameter(Mandatory=$false)]
        [string[]]$Filter = @(),
        
        [Parameter(Mandatory=$false)]
        [switch]$OutList,

        [Parameter(Mandatory=$false)]
        [switch]$UseApi
    )

    if ($OutList -eq $true) {
        # Oppsite XOR Case, Validate it Not both
        if (-not ([bool]$filter -xor [bool]$OutList)) {
            Write-Warning "Can't use both -OutList and -Filter"
            return
        }

        # Oppsite XOR Case, Validate it Not both
        if (-not ($UseApi -xor $OutList)) {
            Write-Warning "Can't use both -OutList and -UseApi"
            return
        }
    }

    if ($UseApi -and (-not $Filter -or $Filter.Count -eq 0)) {
        Write-Warning "API mode requires at least one value name in -Filter."
        return $null
    }

    $results = @()

    if ($UseApi) {
        foreach ($valueName in $Filter) {
            try {
                [uint32]$type = 0
                [uint32]$resultSize = 0
                $unicodeStringPtr = Init-NativeString -Value $valueName -Encoding Unicode

                # Allocate a buffer to receive the value (arbitrary size like 3 KB)
                $dataSize = 3000
                $dataBuffer = [Marshal]::AllocHGlobal($dataSize)

                try {
                    $status = $Global:ntdll::ZwQueryLicenseValue(
                        $unicodeStringPtr,
                        [ref]$type,
                        $dataBuffer,
                        [uint32]$dataSize,
                        [ref]$resultSize
                    )

                    if ($status -eq 0) {
                        $result = [PSCustomObject]@{
                            Name  = $valueName
                            Type  = $type
                            Size  = $resultSize
                            Value = $null
                        }

                        # The optional Type argument provides the address of a variable that is to receive the type of data:
                        # REG_SZ (0x01) for a string; REG_BINARY (0x03) for binary data; REG_DWORD (0x04) for a dword.
                        # which is execly same 0000-------->>>>>>>>> SLDATATYPE enumeration (slpublic.h) 0000----->>> Info:
                        
                        <#
                        typedef enum _tagSLDATATYPE {
                            SL_DATA_NONE = REG_NONE,
                            SL_DATA_SZ = REG_SZ,
                            SL_DATA_DWORD = REG_DWORD,
                            SL_DATA_BINARY = REG_BINARY,
                            SL_DATA_MULTI_SZ,
                            SL_DATA_SUM = 100
                        } SLDATATYPE;
                        #>

                        $result.Value = Parse-RegistryData -dataType $type -ptr $dataBuffer -valueSize $resultSize -valueName $valueName
                        $results += $result
                    }
                    else {
                        $statusHex = "0x{0:X}" -f $status

                        switch ($statusHex) {
                            "0x00000000" {
                                # success - no warning needed
                            }
                            "0xC0000272" {
                                Write-Warning "Failed to query '$valueName' via UseApi: License quota exceeded or unsupported. Status: $statusHex"
                                break
                            }
                            "0xC0000023" {
                                Write-Warning "ZwQueryLicenseValue failed for '$valueName': Invalid handle. Status: $statusHex"
                                break
                            }
                            "0xC0000034" {
                                Write-Warning "ZwQueryLicenseValue failed for '$valueName': Value not found. Status: $statusHex"
                                break
                            }
                            "0xC000001D" {
                                Write-Warning "ZwQueryLicenseValue failed for '$valueName': Not implemented (API not supported). Status: $statusHex"
                                break
                            }
                            "0xC00000BB" {
                                Write-Warning "ZwQueryLicenseValue failed for '$valueName': Operation not supported. Status: $statusHex"
                                break
                            }
                            default {
                                Write-Warning "ZwQueryLicenseValue failed for '$valueName' with status: $statusHex"
                            }
                        }
                    }
                }
                finally {
                    if ($dataBuffer -ne [IntPtr]::Zero) { 
                        [Marshal]::FreeHGlobal($dataBuffer) }
                }
            }
            finally {
                if ($unicodeStringPtr -ne [IntPtr]::Zero) {
                    Free-NativeString -StringPtr $unicodeStringPtr
                }
            }
        }

        return $results
    }

    $policyPath = "HKLM:\SYSTEM\CurrentControlSet\Control\ProductOptions"
    $blob = (Get-ItemProperty -Path $policyPath -Name ProductPolicy).ProductPolicy
    if (-not $blob) {
        Write-Warning "ProductPolicy blob not found in registry."
        return $null
    }

    function Read-UInt16($bytes, $offset) {
        if ($offset + 2 -gt $bytes.Length) { return 0 }
        return [BitConverter]::ToUInt16($bytes, $offset)
    }

    function Read-UnicodeString($bytes, $offset, $length) {
        $length = $length -band 0xFFFE  # ensure even length
        if ($offset + $length -gt $bytes.Length) { return "" }
        $str = [System.Text.Encoding]::Unicode.GetString($bytes, $offset, $length)
        $nullIndex = $str.IndexOf([char]0)
        if ($nullIndex -ge 0) {
            $str = $str.Substring(0, $nullIndex)
        }
        return $str.Trim()
    }

    $offset = 20  # skip header
    $entryHeaderSize = 16

    $results = @()

    while ($offset -lt $blob.Length) {
        if ($offset + $entryHeaderSize -gt $blob.Length) { break }

        $cbSize = Read-UInt16 $blob $offset
        $cbName = Read-UInt16 $blob ($offset + 2)
        $type   = Read-UInt16 $blob ($offset + 4)
        $cbData = Read-UInt16 $blob ($offset + 6)

        $nameOffset = $offset + $entryHeaderSize
        $dataOffset = $nameOffset + $cbName

        if ($dataOffset + $cbData -gt $blob.Length) {
            break
        }

        $name = Read-UnicodeString $blob $nameOffset $cbName

        # The data type follows the familiar scheme for registry data:
        # REG_SZ (0x01) for a string,
        # REG_BINARY (0x03) for binary data
        # and REG_DWORD (0x04) for a dword.

        # If Filter empty => get all, else filter by name
        if (($Filter.Count -eq 0) -or ($Filter -contains $name)) {

            # Use Parse-RegistryData to parse the value, passing blob and offset
            # $val = Parse-RegistryData -dataType $type -blob $blob -dataOffset $dataOffset -valueSize $cbData -valueName $name
            
            switch ($type) {
                0 {  
                    # SL_DATA_NONE
                    $val = $null
                }

                1 {  
                    # SL_DATA_SZ (Unicode string)
                    $val = [System.Text.Encoding]::Unicode.GetString($blob, $dataOffset, $cbData).TrimEnd([char]0)
                }

                4 {  
                    # SL_DATA_DWORD
                    if ($cbData -ne 4) {
                        $val = $null
                    } else {
                        $val = [BitConverter]::ToUInt32($blob, $dataOffset)
                    }
                }

                3 {  
                    # SL_DATA_BINARY
                    if ($name -match "Security-SPP-LastWindowsActivationTime" -and $cbData -eq 8) {
                        $fileTime = [BitConverter]::ToInt64($blob, $dataOffset)
                        $val = [DateTime]::FromFileTimeUtc($fileTime)
                    }
                    elseif ($name -eq "Security-SPP-LastWindowsActivationHResult" -and $cbData -eq 4) {
                        $val = [BitConverter]::ToUInt32($blob, $dataOffset)
                    }
                    else {
                        $bytes = New-Object byte[] $cbData
                        [System.Buffer]::BlockCopy($blob, $dataOffset, $bytes, 0, $cbData)
                        $val = [BitConverter]::ToString($bytes)
                    }
                }

                7 {  
                    # SL_DATA_MULTI_SZ
                    $raw = [System.Text.Encoding]::Unicode.GetString($blob, $dataOffset, $cbData)
                    $val = $raw -split "`0" | Where-Object { $_ -ne '' }
                }

                100 {  
                    # SL_DATA_SUM
                    $val = $null
                }

                default {
                    $val = $null
                }
            }

            $results += [PSCustomObject]@{
                Name  = $name
                Type  = $type
                Value = $val
            }
        }

        if ($cbSize -lt $entryHeaderSize) { break }

        $offset += $cbSize
    }

    if ($OutList) {
        return $results.Name
    }
    return $results
}

<#
Alternative call instead of, 
SoftwareLicensingService --> OA3xOriginalProductKey

~~~~~~~~~~~~~~~~~~~~

Evasions: Firmware tables
https://evasions.checkpoint.com/src/Evasions/techniques/firmware-tables.html

typedef struct _SYSTEM_FIRMWARE_TABLE_INFORMATION {
    ULONG ProviderSignature;
    SYSTEM_FIRMWARE_TABLE_ACTION Action;
    ULONG TableID;
    ULONG TableBufferLength;
    UCHAR TableBuffer[ANYSIZE_ARRAY];  // <- the result will reside in this field
} SYSTEM_FIRMWARE_TABLE_INFORMATION, *PSYSTEM_FIRMWARE_TABLE_INFORMATION;

// helper enum
typedef enum _SYSTEM_FIRMWARE_TABLE_ACTION
{
    SystemFirmwareTable_Enumerate,
    SystemFirmwareTable_Get
} SYSTEM_FIRMWARE_TABLE_ACTION, *PSYSTEM_FIRMWARE_TABLE_ACTION;

~~~~~~~~~~~~~~~~~~~~

UINT __stdcall GetSystemFirmwareTable(
        DWORD FirmwareTableProviderSignature,
        DWORD FirmwareTableID,
        PVOID pFirmwareTableBuffer,
        DWORD BufferSize)

Heap = RtlAllocateHeap(NtCurrentPeb()->ProcessHeap, KernelBaseGlobalData, BufferSize + 16);
Heap[0] = FirmwareTableProviderSignature; // FirmwareTableProviderSignature
Heap[1] = 1;                              // Action -- 1
Heap[2] = FirmwareTableID;                // FirmwareTableID
Heap[3] = BufferSize;                     // Payload Only

v8 = BufferSize + 16;                     // HeadSize (16) & Payload Size
v11 = NtQuerySystemInformation(0x4C, Heap, v8, &ReturnLength);

So, what happen here, 
* Header  = 16 Byte's
* Heap[3] = PayLoad size, Only!
Allocate --> Header Size & Payload Size. ( DWORD BufferSize & 16 bytes above )
Set Heap[3] --> Payload Size only. ( DWORD BufferSize )
NT! Api call, Total length. ( DWORD BufferSize + 16 )

Case Fail!
 --> Heap[3] = 0
 --> ReturnLength = 16,
 * Return --> Heap[3] --> `0 (Not ReturnLength!)

~~~~~~~~~~~~~~~~~~~~

__kernel_entry NTSTATUS NtQuerySystemInformation(
  [in]            SYSTEM_INFORMATION_CLASS SystemInformationClass,
  [in, out]       PVOID                    SystemInformation,
  [in]            ULONG                    SystemInformationLength,
  [out, optional] PULONG                   ReturnLength

~~~~~~~~~~~~~~~~~~~~

FirmwareTables by vurdalakov
https://github.com/vurdalakov/firmwaretables

get_win8key by Christian Korneck
https://github.com/christian-korneck/get_win8key

ctBiosKey.cpp
https://gist.github.com/hosct/456055c0eec4e71bb504489410ed7fb6#file-ctbioskey-cpp

[C++, C#, VB.NET, PowerShell] Read MSDM license information from BIOS ACPI tables | My Digital Life Forums
https://forums.mydigitallife.net/threads/c-c-vb-net-powershell-read-msdm-license-information-from-bios-acpi-tables.43788/

ACPI Tables
https://www.kernel.org/doc/html/next/arm64/acpi_object_usage.html

Microsoft Software Licensing Tables (SLIC and MSDM)
https://learn.microsoft.com/en-us/previous-versions/windows/hardware/design/dn653305(v=vs.85)?redirectedfrom=MSDN

ACPI Software Programming Model
https://uefi.org/htmlspecs/ACPI_Spec_6_4_html/05_ACPI_Software_Programming_Model/ACPI_Software_Programming_Model.html#system-description-table-header

var table = FirmwareTables.GetAcpiTable("MDSM");
var productKeyLength = (int)table.GetPayloadUInt32(16); // offset 52
var productKey = table.GetPayloadString(20, productKeyLength); // offset 56 > Till End
Console.WriteLine("OEM Windows product key: '{0}'", productKey);

Example Code:
~~~~~~~~~~~~

Clear-Host

Write-Host
Write-Host "Get-OA3xOriginalProductKey" -ForegroundColor Green
Get-OA3xOriginalProductKey

Write-Host
Write-Host "Get-ServiceInfo" -ForegroundColor Green
Get-ServiceInfo -loopAllValues | Format-Table -AutoSize

Write-Host
Write-Host "Get-ActiveLicenseInfo" -ForegroundColor Green
Get-ActiveLicenseInfo | Format-List
);

#>
function Get-OA3xOriginalProductKey {
    
    function String-ToHex {
        param (
            [char[]]$chars,
            [switch]$rev,
            [switch]$hex2int
        )

        if ([string]::IsNullOrEmpty($chars)) {
            throw "String is null -or empty"
        }

        if ($rev) {
            [Array]::Reverse($chars)
        }

        if ($hex2int) {
            return ($chars | ForEach-Object `
                -Begin { $hexValue = New-Object System.Text.StringBuilder(256) } `
                -Process { $hexValue.AppendFormat('{0:X2}', [byte]$_) | Out-Null } `
                -End { [Convert]::ToUInt32("0x$($hexValue.ToString())", 16) })
        } else {
            return ($chars | ForEach-Object `
                -Begin {$val = 0} `
                -Process {$val = (($val -shl 8) -bor [byte]$_)} `
                -End { $val })
        }
    }

    # Constants
    [UInt32]$Provider = String-ToHex ACPI #-hex2int
    [UInt32]$TableId  = String-ToHex MSDM -rev #-hex2int
    $PayLoad, $HeaderSize, $tableInfo, $table_Get = 0x00, 0x10, 0x4C, 0x01

    # First call: dummy buffer
    $buffer  = New-IntPtr -Size $HeaderSize
    @($Provider, $table_Get, $TableId, $PayLoad) | % `
        -Begin { $i=-1 } `
        -Process { [Marshal]::WriteInt32($buffer, (++$I*4), [int]$_)}

    [int]$returnLen = 0
    $status = $Ntdll::NtQuerySystemInformation(
        $tableInfo, $buffer, $HeaderSize, [ref]$returnLen
    )

    $PayLoad = [Marshal]::ReadInt32($buffer, 0xC)
    Free-IntPtr -handle $buffer
    
    # So, if you have OEM information in UEFI,
    # this check will succeed, and results >0, >16
    # $returnLen should be at least, 
    # 16 for Header & 56 for Base & 29 for CD KEy.!
    if ($PayLoad -le 0 -or (
        $returnLen -le $HeaderSize)) {
            return $null 
    }

    # Second call: real buffer
    $buffer = New-IntPtr -Size ($HeaderSize + $PayLoad)
    @($Provider, $table_Get, $TableId, $PayLoad) | % `
        -Begin { $i=-1 } `
        -Process { [Marshal]::WriteInt32($buffer, (++$I*4), [int]$_)}
    
    try {
        [int]$returnLen = 0
        if (0 -ne $Ntdll::NtQuerySystemInformation(
           $tableInfo, $buffer, ($HeaderSize + $PayLoad), [ref]$returnLen)) {
              return $null
        }

        # memcpy_0(buffer, v10+4, v10[3]);
        # v10[0-3] => 16 bytes, v10[4-?] => Rest bytes, v10[3] => Payload Size
        $pkey = $null
        $pkLen = [Marshal]::ReadInt32($buffer, ($HeaderSize + 0x34))
        if ($pkLen -gt 0) {
           $pkey = [Marshal]::PtrToStringAnsi(
              [IntPtr]::Add($buffer, ($HeaderSize + 0x38)), $pkLen)
        }
        return $pkey
    }
    finally {
        Free-IntPtr -handle $buffer
    }
}

<#
.SYNOPSIS
Get Ubr value.

#>
function Scan-FolderWithAPI {
    param(
        [string]$folder
    )
    
    $maxUBR = $null
    $bufferSize = 592
    $cFileNameOffset = 44
    $regex = [regex]'10\.0\.\d+\.(\d+)'
    $wildcard = "$folder\*-edition*10.*.*.*"

    $pBuffer = [Marshal]::AllocHGlobal($bufferSize)
    $Global:ntdll::RtlZeroMemory($pBuffer,[UIntPtr]::new($bufferSize))

    $handle = $Global:KERNEL32::FindFirstFileW($wildcard, $pBuffer)
    if ($handle -eq [IntPtr]::Zero) {
        [Marshal]::FreeHGlobal($pBuffer)
        return $null
    }

    do {
        $strPtr = [IntPtr]::Add($pBuffer, $cFileNameOffset)
        $filename = [Marshal]::PtrToStringUni($strPtr)
        #Write-Warning $filename

        if ($regex.IsMatch($filename)) {
            $ubr = [int]$regex.Match($filename).Groups[1].Value
            if ($maxUBR -eq $null -or $ubr -gt $maxUBR) {
                $maxUBR = $ubr
            }
        }
    } while ($Global:KERNEL32::FindNextFileW($handle, $pBuffer))

    $null = $Global:KERNEL32::FindClose($handle)
    $null = [Marshal]::FreeHGlobal($pBuffer)

    return $maxUBR
}
function Get-LatestUBR {
    param (
      [bool]$UsPs1 = $false
    )
    
    $UBR = $null
    $wildcardPattern = '*-edition*10.*.*.*'
    $regexVersion = [regex]'10\.0\.\d+\.(\d+)'
    $Manifestsfolder = 'C:\Windows\WinSxS\Manifests'
    $Packagessfolder = 'C:\Windows\servicing\Packages'
    $swTotal = [System.Diagnostics.Stopwatch]::StartNew()

    # Try Packages folder
    if (!$UsPs1) {
        $UBR = Scan-FolderWithAPI $Packagessfolder
    } else {
        $files = [Directory]::EnumerateFiles(
            $Packagessfolder, $wildcardPattern, [SearchOption]::TopDirectoryOnly)
        foreach ($file in $files) {
            #Write-Warning $file
            $match = $regexVersion.Match($file)
            if ($match.Success) {
                $candidateUBR = [int]$match.Groups[1].Value
                if ($UBR -eq $null -or $candidateUBR -gt $UBR) {
                    $UBR = $candidateUBR
                }
            }
        }
    }

    # If no result, try Manifests folder
    if ((!$UBR -or $UBR -eq 0) -and !$UsPs1) {
        $UBR = Scan-FolderWithAPI $Manifestsfolder
    }
    elseif ((!$UBR -or $UBR -eq 0) -and $UsPs1) {
        $files = [Directory]::EnumerateFiles(
            $Manifestsfolder, $wildcardPattern, [SearchOption]::TopDirectoryOnly)
        foreach ($file in $files) {
            #Write-Warning $file
            $match = $regexVersion.Match($file)
            if ($match.Success) {
                $candidateUBR = [int]$match.Groups[1].Value
                if ($candidateUBR -gt $UBR) {
                    $UBR = $candidateUBR
                }
            }
        }
    }

    # Fallback to registry if still nothing
    if (!$UBR -or $UBR -eq 0) {
        try {
            $regPath = 'HKLM:\SOFTWARE\Microsoft\Windows NT\CurrentVersion'
            $UBR = Get-ItemPropertyValue -Path $regPath -Name UBR -ErrorAction Stop
        }
        catch {
            #Write-Warning "Failed to read UBR from registry: $_"
        }
    }
    
    $swTotal.Stop()
    #Write-Warning "Results: $UBR"
    #Write-Warning "Total Get-LatestUBR time: $($swTotal.ElapsedMilliseconds) ms"

    if (!$UBR) {
        return 0
    }

    return $UBR
}

function Get-StringFromBytes {
    param(
        [byte[]]$array,
        [int]$start,
        [int]$length
    )
    if ($start + $length -le $array.Length) {
        return [Encoding]::Unicode.GetString($array, $start, $length).TrimEnd([char]0)
    }
    else {
        Write-Warning "Requested string range $start to $($start + $length) exceeds array length $($array.Length)"
        return ""
    }
}
function Get-AsciiString {
    param([byte[]]$array, [int]$start, [int]$length)
    if ($start + $length -le $array.Length) {
        return [Encoding]::ASCII.GetString($array, $start, $length).TrimEnd([char]0)
    }
    else {
        Write-Warning "Requested ASCII string range $start to $($start + $length) exceeds array length $($array.Length)"
        return ""
    }
}

<#
Source,
LicensingDiagSpp.dll, LicensingWinRT.dll, SppComApi.dll, SppWinOb.dll
__int64 __fastcall CProductKeyUtilsT<CEmptyType>::BinaryDecode(__m128i *a1, __int64 a2, unsigned __int16 **a3)

# DigitalProductId (normal key)
$pKeyBytes = Get-ItemProperty -Path "HKLM:\SOFTWARE\Microsoft\Windows NT\CurrentVersion" -Name "DigitalProductId" -ErrorAction Stop | Select-Object -ExpandProperty DigitalProductId
$pKey = Get-DigitalProductKey -bCDKeyArray $pKeyBytes[52..66]
SL-InstallProductKey $pKey

# DigitalProductId4 (Windows 10/11 keys)
$pKeyBytes = Get-ItemProperty -Path "HKLM:\SOFTWARE\Microsoft\Windows NT\CurrentVersion" -Name "DigitalProductId4" -ErrorAction Stop | Select-Object -ExpandProperty DigitalProductId4
$pKey = Get-DigitalProductKey -bCDKeyArray $pKeyBytes[808..822]
SL-InstallProductKey $pKey
#>
<#
.SYNOPSIS
Extract DigitalProductId + DigitalProductId[4] Data,
using registry Key.

janek2012's magic decoding function
https://forums.mydigitallife.net/threads/the-ultimate-pid-checker.20816/
https://xdaforums.com/t/extract-windows-rt-product-key-without-jailbreak-or-pc.2442791/

PIDX Checker Class
https://github.com/IonBazan/pidgenx/blob/master/pidxcheckerclass.h

sppcomapi.dll
__int64 __fastcall CLicensingStateTools::get_DefaultKeyFromRegistry(CLicensingStateTools *this, unsigned __int16 **a2)
--> v6 = ReadProductKeyFromRegistry(0i64, &hMem);
--> Value = CRegUtilT<void *,CRegType,0,1>::GetValue(a1, v10, L"DigitalProductId", (BYTE **)&hMem, &v14);
--> v13 = CProductKeyUtilsT<CEmptyType>::BinaryDecode((char *)hMem + 52, v11, &v15);
a1: pointer to 16-byte product key data (from DigitalProductId4.m_abCdKey or registry).
a2: length of the data (unused much in the snippet).
a3: output pointer to store the decoded Unicode product key string.

__int64 __fastcall CProductKeyUtilsT(__m128i *a1)
{
  char Src[54];
  [__m128i] v21 = *a1;
  [__int16 *v20;] v20 = 0i64;
  v22 = *(_OWORD *)L"BCDFGHJKMPQRTVWXY2346789";
  if ( (_mm_srli_si128(v21, 8).m128i_u64[0] & 0xF0000000000000i64) != 0 )
    BREAK CODE
  [__int64] v6 = 24i64;
  [BOOL] v7 = (v21.m128i_i8[14] & 8) != 0;
  v21.m128i_i8[14] ^= (v21.m128i_i8[14] ^ (4 * ((v21.m128i_i8[14] & 8) != 0))) & 8;
  do
  {
    __int64 LODWORD(v8) = 0;
    for ( i = 14i64; i >= 0; --i )
    {
      v10 = v21.m128i_u8[i] + ((_DWORD)v8 << 8);
      v21.m128i_i8[i] = v10 / 0x18;
      v8 = v10 % 0x18;
    }
    *(_WORD *)&Src[2 * v6-- - 2] = *((_WORD *)v22 + v8);
  }
  while ( v6 >= 0 );
  
  if ( v21.m128i_i8[0] )
      BREAK CODE
  else
  {
    if ( v7 )
    {
      [__int64] v11 = 2 * v8;
      memmove_0(&v24, Src, 2 * v8);
      *(_WORD *)&Src[v11 - 2] = 78; ` Insert [N]
    }
    v12 = STRAPI_CreateCchBufferN(0x2Du, 0x1Eui64, &v20);
    if ( v12 >= 0 )
    {
      v13 = v20;
      v14 = &v24;
      for ( j = 0; j < 25; ++j )
      {
        v16 = *v14++;
        v17 = j + j / 5;
        v13[v17] = v16;
      }
      *a3 = v13;
    }
    else
       BREAK CODE
  }
}
#>
function Get-DigitalProductKey {
    param (
        [Parameter(Mandatory=$true)]
        [byte[]]$bCDKeyArray,

        [Parameter(Mandatory=$false)]
        [switch]$Log
    )

    # Clone input to v21 (like C++ __m128i copy)
    $keyData = $bCDKeyArray.Clone()

    # +2 for N` Logic Shift right [else fail]
    $Src = New-Object char[] 27

    # Character set for base-24 decoding
    $charset = "BCDFGHJKMPQRTVWXY2346789"

    # Validate input length
    if ($keyData.Length -lt 15 -or $keyData.Length -gt 16) {
        throw "Input data must be a 15 or 16 byte array."
    }

    # Win.8 key check
    if (($keyData[14] -band 0xF0) -ne 0) {
        throw "Failed to decode.!"
    }

    # N-flag
    $T = 0
    $BYTE14 = [byte]$keyData[14]
    $flag = (($BYTE14 -band 0x08) -ne 0)

    # BYTE14(v22) = (4 * (((BYTE14(v22) & 8) != 0) & 2)) | BYTE14(v22) & 0xF7;
    $keyData[14] = (4 * (([int](($BYTE14 -band 8) -ne 0)) -band 2)) -bor ($BYTE14 -band 0xF7)

    # BYTE14(v22) ^= (BYTE14(v22) ^ (4 * ((BYTE14(v22) & 8) != 0))) & 8;
    #$keyData[14] = $BYTE14 -bxor (($BYTE14 -bxor (4 * ([int](($BYTE14 -band 8) -ne 0)))) -band 8)

    # Base-24 decoding loop
    for ($idx = 24; $idx -ge 0; $idx--) {
        $last = 0
        for ($j = 14; $j -ge 0; $j--) {
            $val = $keyData[$j] + ($last -shl 8)
            $keyData[$j] = [math]::Floor($val / 0x18)
            $last = $val % 0x18
        }
        $Src[$idx] = $charset[$last]
    }

    if ($keyData[0] -ne 0) {
        throw "Invalid product key data"
    }

    # Handle N-flag
    $rev = $last -gt 13
    $pos = if ($rev) {25} else {-1}
    if ($Log) {
        $Output = (0..4 | % { -join $Src[(5*$_)..((5*$_)+4)] }) -join '-'
        Write-Warning "Before, $Output"
    }

    # Shift Left, Insert N, At position 0 >> $Src[0]=`N`
    if ($flag -and ($last -le 0)) {
        $Src[0] = [Char]78
    }
    # Shift right, Insert N, Count 1-25 [27 Base,0-24 & 2` Spacer's]
    elseif ($flag -and $rev) {
        while ($pos-- -gt $last){$Src[$pos + 1]=$Src[$pos]}
        $T, $Src[$last+1] = 1, [char]78
    }
    # Shift left, Insert N,
    elseif ($flag -and !$rev) {
        while (++$pos -lt $last){$Src[$pos] = $Src[$pos + 1]}
        $Src[$last] = [char]78
    }

    # Dynamically format 5x5 with dashes
    $Output = (0..4 | % { -join $Src[((5*$_)+$T)..((5*$_)+4+$T)] }) -join '-'
    if ($Log) {
        Write-Warning "After,  $Output"
    }
    return $Output
}
function Parse-DigitalProductId {
    param (
        [string]$RegistryPath = "HKLM:\SOFTWARE\Microsoft\Windows NT\CurrentVersion"
    )

    try {
        $digitalProductId = (Get-ItemProperty -Path $RegistryPath -ErrorAction Stop).DigitalProductId
    }
    catch {
        Write-Warning "Failed to read DigitalProductId from registry path $RegistryPath"
        return $null
    }

    if (-not $digitalProductId) {
        Write-Warning "DigitalProductId property not found in registry."
        return $null
    }

    # Ensure byte array
    $byteArray = if ($digitalProductId -is [byte[]]) { $digitalProductId } else { [byte[]]$digitalProductId }

    # Define offsets and lengths for each field in one hashtable
    $offsets = @{
        uiSize        = @{ Offset = 0;  Length = 4  }
        MajorVersion  = @{ Offset = 4;  Length = 2  }
        MinorVersion  = @{ Offset = 6;  Length = 2  }
        ProductId     = @{ Offset = 8;  Length = 24 }
        EditionId     = @{ Offset = 36; Length = 16 }
        bCDKey        = @{ Offset = 52; Length = 16 }
    }

    # Extract components safely
    $uiSize = [BitConverter]::ToUInt32($byteArray, $offsets.UISize.Offset)
    $productId = Get-AsciiString -array $byteArray -start $offsets.ProductId.Offset -length $offsets.ProductId.Length
    $editionId = Get-AsciiString -array $byteArray -start $offsets.EditionId.Offset -length $offsets.EditionId.Length

    # Extract bCDKey array for product key decoding
    $bCDKeyArray = $byteArray[$offsets.bCDKey.Offset..($offsets.bCDKey.Offset + $offsets.bCDKey.Length - 1)]

    # Decode Digital Product Key (placeholder function - implement accordingly)
    $digitalProductKey = Get-DigitalProductKey -bCDKeyArray $bCDKeyArray

    # Extract MajorVersion and MinorVersion from byte array
    $majorVersion = [BitConverter]::ToUInt16($byteArray, $offsets.MajorVersion.Offset)
    $minorVersion = [BitConverter]::ToUInt16($byteArray, $offsets.MinorVersion.Offset)

    # Return structured object
    return [PSCustomObject]@{
        UISize       = $uiSize
        MajorVersion = $majorVersion
        MinorVersion = $minorVersion
        ProductId    = $productId
        EditionId    = $editionId
        DigitalKey   = $digitalProductKey
    }
}
function Parse-DigitalProductId4 {
    param(
        [string]$RegistryPath = "HKLM:\SOFTWARE\Microsoft\Windows NT\CurrentVersion",
        [IntPtr]$Pointer = [System.IntPtr]::Zero,
        [int]$Length = 0,

        [switch] $FromIntPtr,
        [switch] $FromRegistry
    )

    $ParamsCheck = -not ($FromIntPtr -xor $FromRegistry)
    if ($ParamsCheck) {
        $FromIntPtr = $null
        $FromRegistry = $true
        Write-Warning "use default values, read from registry"
    }

    # Retrieve DigitalProductId4
    if ($FromIntPtr) {
        if ($Pointer -ne [System.IntPtr]::Zero -and $Length -gt 0) {
            try {
                $byteArray = New-Object byte[] $Length
                [Marshal]::Copy($Pointer, $byteArray, 0, $Length)
            }
            catch {
                Write-Warning "Failed to copy memory from pointer."
                return $null
            }
        }
    }
    if ($FromRegistry) {
        try {
            $digitalProductId4 = (Get-ItemProperty -Path $RegistryPath -ErrorAction Stop).DigitalProductId4
        }
        catch {
            Write-Warning "Failed to read DigitalProductId4 from registry path $RegistryPath"
            return $null
        }

        if (-not $digitalProductId4) {
            Write-Warning "DigitalProductId4 property not found in registry."
            return $null
        }

        # Ensure we have a byte array
        $byteArray = if ($digitalProductId4 -is [byte[]]) { $digitalProductId4 } else { [byte[]]$digitalProductId4 }
    }

    # Offsets dictionary for structured fields with length included
    $offsets = @{
        uiSize        = @{ Offset = 0;    Length = 4  }
        MajorVersion  = @{ Offset = 4;    Length = 2  }
        MinorVersion  = @{ Offset = 6;    Length = 2  }
        AdvancedPid  = @{ Offset = 8;    Length = 128 }
        ActivationId = @{ Offset = 136;  Length = 128 }
        EditionType  = @{ Offset = 280;  Length = 520 }
        EditionId    = @{ Offset = 888;  Length = 128 }
        KeyType      = @{ Offset = 1016; Length = 128 }
        EULA         = @{ Offset = 1144; Length = 128 }
        bCDKey       = @{ Offset = 808;  Length = 16  }
    }

    # Extract values
    $uiSize = if ($byteArray.Length -ge 4) { [BitConverter]::ToUInt32($byteArray, 0) } else { 0 }

    $advancedPid = Get-StringFromBytes -array $byteArray -start $offsets.AdvancedPid.Offset -length $offsets.AdvancedPid.Length
    $activationId = Get-StringFromBytes -array $byteArray -start $offsets.ActivationId.Offset -length $offsets.ActivationId.Length
    $editionType = Get-StringFromBytes -array $byteArray -start $offsets.EditionType.Offset -length $offsets.EditionType.Length
    $editionId = Get-StringFromBytes -array $byteArray -start $offsets.EditionId.Offset -length $offsets.EditionId.Length
    $keyType = Get-StringFromBytes -array $byteArray -start $offsets.KeyType.Offset -length $offsets.KeyType.Length
    $eula = Get-StringFromBytes -array $byteArray -start $offsets.EULA.Offset -length $offsets.EULA.Length

    # Extract bCDKey array used for key retrieval
    $bCDKeyOffset = $offsets.bCDKey.Offset
    $bCDKeyLength = $offsets.bCDKey.Length
    $bCDKeyArray = $byteArray[$bCDKeyOffset..($bCDKeyOffset + $bCDKeyLength - 1)]

    # Extract MajorVersion and MinorVersion from byte array
    $majorVersion = [BitConverter]::ToUInt16($byteArray, $offsets.MajorVersion.Offset)
    $minorVersion = [BitConverter]::ToUInt16($byteArray, $offsets.MinorVersion.Offset)

    # Call to external helper to decode the Digital Product Key
    # You need to define this function based on your key decoding logic
    $digitalProductKey = Get-DigitalProductKey -bCDKeyArray $bCDKeyArray

    # Return a structured object
    return [PSCustomObject]@{
        UISize       = $uiSize
        MajorVersion = $majorVersion
        MinorVersion = $minorVersion
        AdvancedPID  = $advancedPid
        ActivationID = $activationId
        EditionType  = $editionType
        EditionID    = $editionId
        KeyType      = $keyType
        EULA         = $eula
        DigitalKey   = $digitalProductKey
    }
}

<#
Adjusting Token Privileges in PowerShell
https://www.leeholmes.com/adjusting-token-privileges-in-powershell/

typedef struct _TOKEN_PRIVILEGES {
  DWORD               PrivilegeCount;
  LUID_AND_ATTRIBUTES Privileges[ANYSIZE_ARRAY];
} TOKEN_PRIVILEGES, *PTOKEN_PRIVILEGES;

typedef struct _LUID_AND_ATTRIBUTES {
  LUID  Luid;
  DWORD Attributes;
} LUID_AND_ATTRIBUTES, *PLUID_AND_ATTRIBUTES;

typedef struct _LUID {
  DWORD LowPart;
  LONG  HighPart;
} LUID, *PLUID;

--------------------

// Sources

@@
## Sample code to set LSA account previlage via P/Invoke(LsaAddAccountRights).
## https://gist.github.com/altrive/9151365

@@
## Privilege Constants (Authorization)
## https://learn.microsoft.com/en-us/windows/win32/secauthz/privilege-constants

@@
## User Rights Assignment
## https://learn.microsoft.com/en-us/previous-versions/windows/it-pro/windows-10/security/threat-protection/security-policy-settings/user-rights-assignment

@@
## WindowsProcess.c
## https://github.com/microsoft/Windows-classic-samples/blob/1d363ff4bd17d8e20415b92e2ee989d615cc0d91/Samples/ManagementInfrastructure/cpp/Process/Provider/WindowsProcess.c

// Demo

# Make sure to assigen SeAssignPrimaryTokenPrivilege Priv to Account
$AssignPrivilege = Adjust-TokenPrivileges -Query | ? Name -match SeAssignPrimaryTokenPrivilege
if (-not $AssignPrivilege) {
    try {
        if (Adjust-TokenPrivileges -Privilege SeAssignPrimaryTokenPrivilege -Account Administrator) {
            Write-Host ""
            Write-Host "Successfully applied 'SeAssignPrimaryTokenPrivilege' to the 'Administrator' account." -ForegroundColor Cyan
            Write-Host "Please log off and log back in to apply the changes." -ForegroundColor Green
            Write-Host ""
        } else {
            Write-Host ""
            Write-Host "Failed to apply 'SeAssignPrimaryTokenPrivilege' to the 'Administrator' account." -ForegroundColor Red
            Write-Host "Please check your permissions or the account status." -ForegroundColor Yellow
            Write-Host ""
        }
    }
    catch {}
}

--------------------

Clear-Host
Write-Host

Write-Host
$length = [Uint32]1
$Ptr    = [IntPtr]::Zero
$lastErr = Invoke-UnmanagedMethod `
    -Dll "ntdll.dll" `
    -Function "NtEnumerateBootEntries" `
    -Return "Int64" `
    -Params "IntPtr Ptr, ref uint length" `
    -Values @($Ptr, [ref]$length)
Parse-ErrorMessage `
    -MessageId $lastErr

Write-Host
# Get Minimal Privileges To Load Some NtDll function
Adjust-TokenPrivileges `
    -Privilege @("SeDebugPrivilege","SeImpersonatePrivilege","SeIncreaseQuotaPrivilege","SeAssignPrimaryTokenPrivilege", "SeSystemEnvironmentPrivilege") `
    -Log -SysCall

Write-Host
$length = [Uint32]1
$Ptr    = [IntPtr]::Zero
$lastErr = Invoke-UnmanagedMethod `
    -Dll "ntdll.dll" `
    -Function "NtEnumerateBootEntries" `
    -Return "Int64" `
    -Params "IntPtr Ptr, ref uint length" `
    -Values @($Ptr, [ref]$length)
Parse-ErrorMessage `
    -MessageId $lastErr
#>
Function Adjust-TokenPrivileges {
    param(
        [Parameter(Mandatory=$false)]
        [Process]$Process,

        [Parameter(Mandatory=$false)]
        [IntPtr]$hProcess,

        [Parameter(Mandatory=$false)]
        [string]$Account,

        [Parameter(Mandatory=$false)]
        [ValidateSet(
        "SeAssignPrimaryTokenPrivilege", "SeAuditPrivilege", "SeBackupPrivilege",
        "SeChangeNotifyPrivilege", "SeCreateGlobalPrivilege", "SeCreatePagefilePrivilege",
        "SeCreatePermanentPrivilege", "SeCreateSymbolicLinkPrivilege", "SeCreateTokenPrivilege",
        "SeDebugPrivilege", "SeEnableDelegationPrivilege", "SeImpersonatePrivilege",
        "SeIncreaseQuotaPrivilege", "SeIncreaseWorkingSetPrivilege", "SeLoadDriverPrivilege",
        "SeLockMemoryPrivilege", "SeMachineAccountPrivilege", "SeManageVolumePrivilege", 
        "SeProfileSingleProcessPrivilege", "SeRelabelPrivilege", "SeRemoteShutdownPrivilege",
        "SeRestorePrivilege", "SeSecurityPrivilege", "SeShutdownPrivilege", "SeSyncAgentPrivilege",
        "SeSystemEnvironmentPrivilege", "SeSystemProfilePrivilege", "SeSystemtimePrivilege",
        "SeTakeOwnershipPrivilege", "SeTcbPrivilege", "SeTimeZonePrivilege", "SeTrustedCredManAccessPrivilege",
        "SeUndockPrivilege", "SeDelegateSessionUserImpersonatePrivilege", "SeIncreaseBasePriorityPrivilege",
        "SeNetworkLogonRight", "SeInteractiveLogonRight", "SeRemoteInteractiveLogonRight", "SeDenyNetworkLogonRight",
        "SeDenyBatchLogonRight", "SeDenyServiceLogonRight", "SeDenyInteractiveLogonRight", "SeDenyRemoteInteractiveLogonRight",
        "SeBatchLogonRight", "SeServiceLogonRight"
        )]
        [string[]]$Privilege,

        [Parameter(Mandatory=$false)]
        [Switch] $AdjustAll,

        [Parameter(Mandatory=$false)]
        [switch] $Query,

        [Parameter(Mandatory=$false)]
        [Switch] $Disable,

        [Parameter(Mandatory=$false)]
        [Switch] $SysCall,

        [Parameter(Mandatory=$false)]
        [Switch] $Log
    )

    enum LSA_AccessFlags {
        VIEW_LOCAL_INFORMATION      = 0x00000001L
        VIEW_AUDIT_INFORMATION      = 0x00000002L
        GET_PRIVATE_INFORMATION     = 0x00000004L
        TRUST_ADMIN                 = 0x00000008L
        CREATE_ACCOUNT              = 0x00000010L
        CREATE_SECRET               = 0x00000020L
        CREATE_PRIVILEGE            = 0x00000040L
        SET_DEFAULT_QUOTA_LIMITS    = 0x00000080L
        SET_AUDIT_REQUIREMENTS      = 0x00000100L
        AUDIT_LOG_ADMIN             = 0x00000200L
        SERVER_ADMIN                = 0x00000400L
        LOOKUP_NAMES                = 0x00000800L
        NOTIFICATION                = 0x00001000L
    }
    function Get-PrivilegeLuid {
        param (
            [ValidateNotNullOrEmpty()]
            [string]$PrivilegeName
        )

        $policyHandle = [IntPtr]::Zero
        $objAttr = New-IntPtr -Size 60 -WriteSizeAtZero

        $status = $Global:advapi32::LsaOpenPolicy(
            [IntPtr]::Zero, $objAttr, 0x800, [ref]$policyHandle)
    
        if ($status -ne 0) {
            $policyHandle = $null
            return $null
        }
    
        try {
            $luid = [Int64]0
            $privName = Init-NativeString -Value $PrivilegeName -Encoding Unicode
            $status = $Global:advapi32::LsaLookupPrivilegeValue(
                $policyHandle, $privName, [ref]$luid)
            $Global:advapi32::LsaClose($policyHandle) | Out-Null

            if ($status -ne 0) {
                return $null
            }
        }
        Finally {
            Free-NativeString -StringPtr $privName | Out-Null
            $privName = $null
            $policyHandle = $null
        }
        return $luid
    }
    function Get-AccountInfo {
        param (
            [ValidateNotNullOrEmpty()]
            [string]$AccName = $env:USERNAME,
            [switch]$Debug
        )

        if ($Debug) { Write-Host "Starting SID retrieval for account: $AccName" }

        # Initialize variables
        [IntPtr]$pSid = [IntPtr]::Zero
        [Int32]$AccSize = 0
        [IntPtr]$domainPtr = [IntPtr]::Zero
        [Int32]$domainSize = 0
        [Bool]$peUse = $false

        # Lookup account SID
        $ret = $Global:advapi32::LookupAccountNameW(
                [IntPtr]::Zero,
                $AccName, $pSid,
                ([ref]$AccSize),
                [IntPtr]::Zero, ([ref]$domainSize),
                ([ref]$peUse)
            )

        if ($AccSize -le 0) {
            Write-Warning "Error: Account '$AccName' not found or invalid name."
            return $null
        }

        if ($Debug) { Write-Host "Account found. Allocating memory for SID and domain." }

        # Allocate memory for SID and domain
        $pSid = New-IntPtr -Size $AccSize
        $domainPtr = New-IntPtr (($domainSize + 2) * 2)

        # Second lookup to get full SID and domain name
        $ret = $Global:advapi32::LookupAccountNameW(
                [IntPtr]::Zero,
                $AccName, $pSid,
                ([ref]$AccSize),
                $domainPtr, ([ref]$domainSize),
                ([ref]$peUse)
            )

        if ($ret -ne 1) {
            Write-Warning "Error: Unable to resolve account '$AccName' to SID."
            Free-IntPtr -handle $domainPtr -Method Auto
            return $null
        }

        # Retrieve domain and free memory
        $domain = [marshal]::PtrToStringUni($domainPtr)
        Free-IntPtr -handle $domainPtr -Method Auto
        if ($Debug) { Write-Host "Domain retrieved: $domain" }

        # Convert SID to string
        $sidStringPtr = New-IntPtr -Size ([IntPtr]::Size) 
        $ret = $Global:advapi32::ConvertSidToStringSidW($pSid, $sidStringPtr)
        if ($ret) {
        
            ## Actual data hold as Pointer --> @@ by Ref @@
            ## Better than let Managed code handle it
            ## -------> [ref]Object --> Could fail .!

            $handle = [Marshal]::ReadIntPtr($sidStringPtr)
            $sidString = [Marshal]::PtrToStringUni($handle)
            Free-IntPtr -handle $sidStringPtr -Method Auto
            Free-IntPtr -handle $handle -Method Local

        } else {
            Write-Warning "Error: Unable to convert SID for account '$AccName'."
            Free-IntPtr -handle $sidStringPtr -Method Auto
            return $null
        }

        if ($Debug) { Write-Host "SID converted: $sidString" }

        # Create and return the PSCustomObject with account details
        $accountInfo = [PSCustomObject]@{
            AccountName = $AccName
            Domain      = $domain
            SID         = $sidString
            pSid        = $pSid
        }

        if ($Debug) { Write-Host "Account information retrieved successfully." }

        return $accountInfo
    }

    $TOKEN_QUERY = 0x00000008;
    $TOKEN_ADJUST_PRIVILEGES = 0x00000020;
    $SE_PRIVILEGE_ENABLED = 0x00000002;
    $SE_PRIVILEGE_DISABLED = 0x00000000;
    
    if ($Process -and $hProcess) {
        throw "-Process or -hProcess Only."
    }

    if (-not $Process -and -not $hProcess) {
        $Process = [Process]::GetCurrentProcess()
    }

    if ((!$Privilege -or $Privilege.Count -eq 0) -and !$AdjustAll -and !$Query -and !$Account) {
        throw "use -Privilege or -AdjustAll -or -Query -or -Account"
    }

    $count = [bool]($Privilege -and $Privilege.Count -gt 0) + [bool]$AdjustAll + [bool]$Query + [bool]$Account
    if ($count -gt 1) {
        $AccIf = ($count -eq 2 -and [bool]$Account -and [bool]($Privilege -and $Privilege.Count -gt 0))
        if (!$AccIf) {
          throw "use -Privilege or -AdjustAll -or -Query -or -Account"
        }
    }

    if ($Privilege ) {
        if ($Privilege.Count -gt 0 -and $AdjustAll) {
            throw "use -Privilege or -AdjustAll"
        }
    }

    # Validate the handle is valid and non-zero
    $hproc = if ($Process) {$Process.Handle} else {$hProcess}
    if ($hproc -eq [IntPtr]::Zero -or $hproc -eq 0 -or $hproc -eq $Null) {
        throw "Invalid process handle."
    }
    
    $hToken = [IntPtr]::Zero
    $hproc = [IntPtr]$hproc

    if ($SysCall) {
        $retVal = $Global:ntdll::NtOpenProcessToken(
            $hproc, ($TOKEN_ADJUST_PRIVILEGES -bor $TOKEN_QUERY), [ref]$hToken)
    }
    else {
        $retVal = $Global:advapi32::OpenProcessToken(
            $hproc, ($TOKEN_ADJUST_PRIVILEGES -bor $TOKEN_QUERY), [ref]$hToken)
    }

    # if both return same result, which can be true if both *false
    # well, in that case -> throw, and return error
    if ((!$SysCall -and $retVal -ne 0 -and $hToken -ne [IntPtr]::Zero) -eq (
        $SysCall -and $retVal -eq 0 -and $hToken -ne [IntPtr]::Zero)) {
            throw "OpenProcessToken failed with -> $retVal"
    }

    if ($AdjustAll) {
        $Privilege = (
            "SeAssignPrimaryTokenPrivilege", "SeAuditPrivilege", "SeBackupPrivilege",
            "SeChangeNotifyPrivilege", "SeCreateGlobalPrivilege", "SeCreatePagefilePrivilege",
            "SeCreatePermanentPrivilege", "SeCreateSymbolicLinkPrivilege", "SeCreateTokenPrivilege",
            "SeDebugPrivilege", "SeEnableDelegationPrivilege", "SeImpersonatePrivilege",
            "SeIncreaseQuotaPrivilege", "SeIncreaseWorkingSetPrivilege", "SeLoadDriverPrivilege",
            "SeLockMemoryPrivilege", "SeMachineAccountPrivilege", "SeManageVolumePrivilege", 
            "SeProfileSingleProcessPrivilege", "SeRelabelPrivilege", "SeRemoteShutdownPrivilege",
            "SeRestorePrivilege", "SeSecurityPrivilege", "SeShutdownPrivilege", "SeSyncAgentPrivilege",
            "SeSystemEnvironmentPrivilege", "SeSystemProfilePrivilege", "SeSystemtimePrivilege",
            "SeTakeOwnershipPrivilege", "SeTcbPrivilege", "SeTimeZonePrivilege", "SeTrustedCredManAccessPrivilege",
            "SeUndockPrivilege", "SeDelegateSessionUserImpersonatePrivilege", "SeIncreaseBasePriorityPrivilege",
            "SeNetworkLogonRight", "SeInteractiveLogonRight", "SeRemoteInteractiveLogonRight", "SeDenyNetworkLogonRight",
            "SeDenyBatchLogonRight", "SeDenyServiceLogonRight", "SeDenyInteractiveLogonRight", "SeDenyRemoteInteractiveLogonRight",
            "SeBatchLogonRight", "SeServiceLogonRight"
        )
    }

    # Query Case
    if ($Query) {
        # Allocate memory for TOKEN_PRIVILEGES
        $tokenInfoPtr = [Marshal]::AllocHGlobal($tokenInfoLength)
        try {
            $tokenInfoLength = 0
            $Global:advapi32::GetTokenInformation($hToken, 3, [IntPtr]0, 0, [ref]$tokenInfoLength) | Out-Null
            if ($tokenInfoLength -le 0) {
                throw "GetTokenInformation failed .!"
            }
            $tokenInfoPtr = New-IntPtr -Size $tokenInfoLength
            if (0 -eq (
                $Global:advapi32::GetTokenInformation($hToken, 3, $tokenInfoPtr, $tokenInfoLength, [ref]$tokenInfoLength))) { 
                    throw "GetTokenInformation failed on second call" }

            $privileges = @()
            $Count = [Marshal]::ReadInt32($tokenInfoPtr)

            for ($i=0; $i -lt $Count; $i++) {
                $offset = 4 + ($i * 12)
                $luid = [Marshal]::ReadInt64($tokenInfoPtr, $offset)
                $attr = [Marshal]::ReadInt32($tokenInfoPtr, $offset+8)
                $enabled = ($attr -band 2) -ne 0

                $size = 0
                $namePtr = [IntPtr]::Zero
                $Global:advapi32::LookupPrivilegeNameW([IntPtr]::Zero, [ref]$luid, $namePtr, [ref]$size) | Out-Null
                $namePtr = [Marshal]::AllocHGlobal(($size + 1) * 2)
                try {
                    $Global:advapi32::LookupPrivilegeNameW([IntPtr]::Zero, [ref]$luid, $namePtr, [ref]$size) | Out-Null
                    $privName = [Marshal]::PtrToStringUni($namePtr)
                    $privileges += [PSCustomObject]@{
                        Name    = $privName
                        LUID    = $luid
                        Enabled = $enabled
                    }
                }
                finally {
                    [Marshal]::FreeHGlobal($namePtr)
                }
            }

            return $privileges
        }
        finally {
            Free-IntPtr -handle $tokenInfoPtr
            Free-IntPtr -handle $hProc -Method NtHandle
            Free-IntPtr -handle $hToken -Method NtHandle
        }
    }

    # Account Case
    if ($Account) {
        $Access = 0
        [ENUM]::GetNames([LSA_AccessFlags]) | ForEach-Object {
            $Access = $Access -bor ([LSA_AccessFlags]::$_.Value__)
        }

        $policyHandle = [IntPtr]::Zero
        $AttributesSize = if ([IntPtr]::Size -gt 4) { 48 } else { 24 }
        $pObjectAttributes = New-IntPtr -Size $AttributesSize
        $ret = $global:advapi32::LsaOpenPolicy(
                [IntPtr]::Zero,
                $pObjectAttributes,
                $Access,
                ([ref]$policyHandle)
            )
        Free-IntPtr $pObjectAttributes

        if ($ret -ne 0) {
            throw "LsaOpenPolicy Failure .!"
        }
        
        <#
        $NTAccount = [NTAccount]::new($Account)
        $identity = $NTAccount.Translate([System.Security.Principal.SecurityIdentifier])
        $AccountSid = New-IntPtr -Size $identity.BinaryLength
        $buffer = New-Object byte[] $identity.BinaryLength
        $identity.GetBinaryForm($buffer, 0)
        [marshal]::Copy($buffer, 0x0, $AccountSid, $buffer.Length)
        #>

        [IntPtr]$AccountSid = Get-AccountInfo -AccName $Account | select -ExpandProperty pSid
        if (!(IsValid-IntPtr $AccountSid)) {
            throw "Not a valid AccountSid .!"
        }

        $CountOfRights = $Privilege.Length
        $blockSize = [UIntPtr]::new(([IntPtr]::Size)* 2)
        $UserRights = New-IntPtr ($CountOfRights * (([IntPtr]::Size)* 2))
 
        try {
            $idx = -1
            $allocatedRights = @()
            foreach ($Priv in $Privilege) {
                $Right = Init-NativeString -Value $Priv -Encoding Unicode
                $allocatedRights += $Right
                $offsetPtr = [IntPtr]::Add($UserRights, (++$idx * (([IntPtr]::Size)* 2)))
                $global:ntdll::RtlMoveMemory(
                   $offsetPtr, $Right, $blockSize
                )
            }
            if ($Disable) {
                $ret = $global:advapi32::LsaRemoveAccountRights(
                        $policyHandle,
                        $AccountSid,
                        0, $UserRights,
                        $CountOfRights
                    )
            }
            else {
                $ret = $global:advapi32::LsaAddAccountRights(
                        $policyHandle,
                        $AccountSid,
                        $UserRights,
                        $CountOfRights
                    )
            }
            if ($ret -ne 0) {
                Write-Warning "LsaAddAccountRights Failure, Error Code $($ret)"
            }
            return ($ret -eq 0)
        }
        catch {
            Write-Host $_ -ForegroundColor Red
            return $false
        }
        finally {
            Free-IntPtr -handle $hToken -Method NtHandle
            Free-IntPtr -handle $AccountSid -Method Auto
            Free-IntPtr -handle $policyHandle -Method LSA
            Free-IntPtr -handle $UserRights -Method Auto
            $allocatedRights | % { Free-IntPtr $_ -Method UNICODE_STRING}
        }
    }
   
    # Prepare
    $validEntries = @()
    foreach ($priv in $Privilege) {
        try {
            [Int64]$luid = 0
            if ($SysCall) {
                $luid = Get-PrivilegeLuid -PrivilegeName $priv
                if ($luid -le 0) { throw "Get-PrivilegeLuid failed for '$priv'" }
            } else {
                $result = $Global:advapi32::LookupPrivilegeValue([IntPtr]::Zero, $priv, [ref]$luid)
                if ($result -eq 0) { throw "LookupPrivilegeValue failed for '$priv'" }
            }

            if ($luid -ne 0) {
                $validEntries += [PSCustomObject]@{
                    Name = $priv
                    LUID = $luid
                }
            }
        }
        catch {
            Write-Warning $_.Exception.Message
        }
    }

    if ($validEntries.Count -eq 0) {
        Write-Warning "No valid privileges could be resolved."
        return $false
    }

    # Allocate proper size
    $Count = $validEntries.Count
    $TokPriv1LuidSize = 4 + (12 * $Count)
    $TokPriv1LuidPtr = New-IntPtr -Size $TokPriv1LuidSize -InitialValue $Count

    # Write privileges into the structure
    for ($i = 0; $i -lt $Count; $i++) {
        $offset = 4 + (12 * $i)
        [Marshal]::WriteInt64($TokPriv1LuidPtr, $offset, $validEntries[$i].LUID)

        $attrValue = if ($Disable) { $SE_PRIVILEGE_DISABLED } else { $SE_PRIVILEGE_ENABLED }
        [Marshal]::WriteInt32($TokPriv1LuidPtr, $offset + 8, $attrValue)

        if ($Log) {
            Write-Host ">>> Privilege: $($validEntries[$i].Name)"
            Write-Host ("Offset $offset (LUID) : 0x{0:X}" -f $validEntries[$i].LUID)
            Write-Host ("Offset $($offset+8) (Attr): 0x{0:X} {1}" -f $attrValue,
                $(if ($attrValue -eq 2) { 'SE_PRIVILEGE_ENABLED' }
                  elseif ($attrValue -eq 0) { 'SE_PRIVILEGE_DISABLED' }
                  else { 'UNKNOWN' }))
        }
    }
    try {
        if ($FailToWriteBlock) {
            Write-Warning "Failed to build privilege block. Skipping AdjustTokenPrivileges."
        } 
        else {
            if ($SysCall) {
                $retVal = $Global:ntdll::NtAdjustPrivilegesToken(
                    $hToken, $false, $TokPriv1LuidPtr, $TokPriv1LuidSize, [IntPtr]::Zero, [IntPtr]::Zero)
                if ($retVal -eq 0) {
                    return $true
                } elseif ($retVal -eq 262) {
                    Write-Warning "AdjustTokenPrivileges succeeded but not all privileges assigned."
                    return $true
                } else {
                    $status = Parse-ErrorMessage -MessageId $retVal -Flags NTSTATUS
                    Write-Warning "NtAdjustPrivilegesToken failed: $status"
                    return $false
                }
            } else {
                $retVal = $Global:advapi32::AdjustTokenPrivileges(
                    $hToken, $false, $TokPriv1LuidPtr, $TokPriv1LuidSize, [IntPtr]::Zero, [IntPtr]::Zero)
                $lastErr = [Marshal]::GetLastWin32Error()
                if ($retVal -eq 0) {
                    $status = Parse-ErrorMessage -MessageId $lastErr -Flags WIN32
                    Write-Warning "AdjustTokenPrivileges failed: $status"
                    returh $false
                } elseif ($lastErr -eq 1300) {
                    Write-Warning "AdjustTokenPrivileges succeeded but not all privileges assigned."
                    return $true
                } else {
                    return $true
                }
            }
        }
    }
    Finally {
        Free-IntPtr -handle $TokPriv1LuidPtr
        Free-IntPtr -handle $hProc -Method NtHandle
        Free-IntPtr -handle $hToken -Method NtHandle
    }
}

<#
SID structure (winnt.h)
https://learn.microsoft.com/en-us/windows/win32/api/winnt/ns-winnt-sid

typedef struct _SID {
  BYTE                     Revision;
  BYTE                     SubAuthorityCount;
  SID_IDENTIFIER_AUTHORITY IdentifierAuthority;
#if ...
  DWORD                    *SubAuthority[];
#else
  DWORD                    SubAuthority[ANYSIZE_ARRAY];
#endif
} SID, *PISID;

~~~~~~~~~~~~~~~~~~~

Well-known SIDs
https://learn.microsoft.com/en-us/windows/win32/secauthz/well-known-sids

The SECURITY_NT_AUTHORITY (S-1-5) predefined identifier authority produces SIDs that are not universal but are meaningful only on Windows installations.
You can use the following RID values with SECURITY_NT_AUTHORITY to create well-known SIDs.

SECURITY_LOCAL_SYSTEM_RID
String value: S-1-5-18
A special account used by the operating system.

The following table has examples of domain-relative RIDs that you can use to form well-known SIDs for **local groups** (aliases).
For more information about local and global groups, see Local Group Functions and Group Functions.

DOMAIN_ALIAS_RID_ADMINS
Value: 0x00000220
String value: S-1-5-32-544
A local group used for administration of the domain.

~~~~~~~~~~~~~~~~~~~

TOKEN_INFORMATION_CLASS enumeration (winnt.h)
https://learn.microsoft.com/en-us/windows/win32/api/winnt/ne-winnt-token_information_class

typedef enum _TOKEN_INFORMATION_CLASS {
  TokenUser = 1,
  TokenGroups,
  TokenPrivileges,
  TokenOwner,
  TokenPrimaryGroup,
  TokenDefaultDacl,
  TokenSource,
  TokenType,
  TokenImpersonationLevel,
  TokenStatistics,
  TokenRestrictedSids,
  TokenSessionId,
  TokenGroupsAndPrivileges,
  TokenSessionReference,
  ...
  ...
  ...

~~~~~~~~~~~~~~~~~~~

$isSystem = Check-AccountType -AccType System
$isAdmin  = Check-AccountType -AccType Administrator
Write-Host "is Admin* Acc ? $isAdmin"
Write-Host "is System Acc ? $isSystem"
Write-Host
#>
function Check-AccountType {
    param (
       [Parameter(Mandatory)]
       [ValidateSet("System", "Administrator", "TokenElevation")]
       [string]$AccType
    )

$isMember = $false

if (!([PSTypeName]'TOKEN').Type) {
Add-Type @'
using System;
using System.Runtime.InteropServices;
using System.Security.Principal;

public class TOKEN {
 
    [DllImport("kernelbase.dll")]
    public static extern IntPtr GetCurrentProcessId();

    [DllImport("ntdll.dll")]
    public static extern void RtlZeroMemory(
        IntPtr Destination,
        UIntPtr Length);

    [DllImport("ntdll.dll")]
    public static extern Int32 NtClose(
        IntPtr hObject);


    [DllImport("ntdll.dll")]
    public static extern Int32 RtlCheckTokenMembershipEx(
        IntPtr TokenHandle,
        IntPtr Sid,
        Int32 Flags,
        ref Boolean IsMember);

    [DllImport("ntdll.dll")]
    public static extern Int32 NtOpenProcess(
        ref IntPtr ProcessHandle,
        UInt32 DesiredAccess,
        IntPtr ObjectAttributes,
        IntPtr ClientId);

    [DllImport("ntdll.dll")]
    public static extern Int32 NtOpenProcessToken(
        IntPtr ProcessHandle,
        uint DesiredAccess,
        out IntPtr TokenHandle);

    [DllImport("ntdll.dll")]
    public static extern Int32 NtQueryInformationToken(
        IntPtr TokenHandle,
        int TokenInformationClass,
        IntPtr TokenInformation,
        UInt32 TokenInformationLength,
        out uint ReturnLength );
}
'@
  }

function Check {
    param (
        [Parameter(Mandatory)]
        [IntPtr]$pSid,

        [Parameter(Mandatory)]
        [int[]]$Subs,

        [Parameter(Mandatory)]
        [ValidateSet("Account", "Group")]
        [string]$Type
    )

    if ($null -eq $Subs -or $Subs.Length -le 0 -or $pSid -eq [IntPtr]::Zero) {
        throw "Invalid parameters: pSid or Subs is empty."
    }
    [Marshal]::WriteByte($pSid, 1, $Subs.Length)
    for ($i = 0; $i -lt $Subs.Length; $i++) {
        [Marshal]::WriteInt32($pSid, 8 + 4 * $i, $Subs[$i])
    }

    switch ($Type) {
        "Group" {
            $ret = [TOKEN]::RtlCheckTokenMembershipEx(
                0, $pSid, 0, [ref]$isMember)
        }
        "Account" {
            if ([IntPtr]::Size -eq 8) {
                # 64-bit sizes and layout
                $clientIdSize = 16
                $objectAttrSize = 48
            } else {
                # 32-bit sizes and layout (WOW64)
                $clientIdSize = 8
                $objectAttrSize = 24
            }
            $hproc  = [IntPtr]::Zero
            $procID = [TOKEN]::GetCurrentProcessId()
            $clientIdPtr   = [marshal]::AllocHGlobal($clientIdSize)
            $attributesPtr = [marshal]::AllocHGlobal($objectAttrSize)
            [TOKEN]::RtlZeroMemory($clientIdPtr, [Uintptr]::new($clientIdSize))
            [TOKEN]::RtlZeroMemory($attributesPtr, [Uintptr]::new($objectAttrSize))
            [marshal]::WriteInt32($attributesPtr, 0x0, $objectAttrSize)
            if ([IntPtr]::Size -eq 8) {
              [Marshal]::WriteInt64($clientIdPtr, 0, [Int64]$procID)
            }
            else {
              [Marshal]::WriteInt32($clientIdPtr, 0x0, $procID)
            }
            try {
                if (0 -ne [TOKEN]::NtOpenProcess(
                    [ref]$hproc, 0x0400, $attributesPtr, $clientIdPtr)) {
                        throw "NtOpenProcess fail."
                }
            }
            finally {
                @($clientIdPtr, $attributesPtr) | % {[Marshal]::FreeHGlobal($_)}
            }

            $hToken = [IntPtr]::Zero
            if (0 -ne [TOKEN]::NtOpenProcessToken(
                $hproc, 0x00000008, [ref]$hToken)) {
                    throw "NtOpenProcessToken fail."
            }
            try {
                [UInt32]$ReturnLength = 0
                $TokenInformation = [marshal]::AllocHGlobal(100)
                if (0 -ne [TOKEN]::NtQueryInformationToken(
                    $hToken,1,$TokenInformation, 100, [ref]$ReturnLength)) {
                        throw "NtQueryInformationToken fail."
                }

                $pUserSid = [Marshal]::ReadIntPtr($TokenInformation)
                $isMember = ($Subs.Length -eq [Marshal]::ReadByte($pUserSid,1)) -and
                    ([Marshal]::ReadByte($pUserSid,0) -eq [Marshal]::ReadByte($pSid,0)) -and
                    ([Marshal]::ReadByte($pUserSid,7) -eq [Marshal]::ReadByte($pSid,7))
                if ($isMember) {
                    for ($i=0; $i -lt $Subs.Length; $i++) {
                        if ([Marshal]::ReadInt32($pUserSid, 8 + 4*$i) -ne $Subs[$i]) {
                            $isMember = $false
                            break
                }}}
            }
            finally {            
                [marshal]::FreeHGlobal($TokenInformation)
                @($hproc, $hToken) | % { [TOKEN]::NtClose($_) | Out-Null }
            }
        }
    }

    return $isMember
}
function IsElavated {
    if ([IntPtr]::Size -eq 8) {
        # 64-bit sizes and layout
        $clientIdSize = 16
        $objectAttrSize = 48
    } else {
        # 32-bit sizes and layout (WOW64)
        $clientIdSize = 8
        $objectAttrSize = 24
    }
    $hproc  = [IntPtr]::Zero
    $procID = [TOKEN]::GetCurrentProcessId()
    $clientIdPtr   = [marshal]::AllocHGlobal($clientIdSize)
    $attributesPtr = [marshal]::AllocHGlobal($objectAttrSize)
    [TOKEN]::RtlZeroMemory($clientIdPtr, [Uintptr]::new($clientIdSize))
    [TOKEN]::RtlZeroMemory($attributesPtr, [Uintptr]::new($objectAttrSize))
    [marshal]::WriteInt32($attributesPtr, 0x0, $objectAttrSize)
    if ([IntPtr]::Size -eq 8) {
        [Marshal]::WriteInt64($clientIdPtr, 0, [Int64]$procID)
    }
    else {
        [Marshal]::WriteInt32($clientIdPtr, 0x0, $procID)
    }
    try {
        if (0 -ne [TOKEN]::NtOpenProcess(
            [ref]$hproc, 0x0400, $attributesPtr, $clientIdPtr)) {
                throw "NtOpenProcess fail."
        }
    }
    finally {
        @($clientIdPtr, $attributesPtr) | % {[Marshal]::FreeHGlobal($_)}
    }

    $hToken = [IntPtr]::Zero
    if (0 -ne [TOKEN]::NtOpenProcessToken(
        $hproc, 0x00000008, [ref]$hToken)) {
            throw "NtOpenProcessToken fail."
    }
    try {
        # enum TOKEN_INFORMATION_CLASS
        # https://ntdoc.m417z.com/token_information_class
        $TokenElevation, $TokenElevationType = [IntPtr]0, [IntPtr]0

        # // q: TOKEN_ELEVATION // 20
        [UInt32]$ReturnLength = 0
        $TokenElevation = [Marshal]::AllocHGlobal(4)
        [marshal]::WriteInt32($TokenElevation,0x0, 0x0)
        if (0 -ne [TOKEN]::NtQueryInformationToken(
            $hToken,20,$TokenElevation, 4, [ref]$ReturnLength)) {
                throw "NtQueryInformationToken fail."
        }

        # // q: TOKEN_ELEVATION_TYPE // 18
        [UInt32]$ReturnLength = 0
        $TokenElevationType = [Marshal]::AllocHGlobal(4)
        [marshal]::WriteInt32($TokenElevationType,0x0, 0x0)
        if (0 -ne [TOKEN]::NtQueryInformationToken(
            $hToken,18,$TokenElevationType, 4, [ref]$ReturnLength)) {
                throw "NtQueryInformationToken fail."
        }

        $ElevationStatus = [Marshal]::ReadInt32($TokenElevation, 0x0)
        $ElevationType   = [Marshal]::ReadInt32($TokenElevationType, 0x0)
        return ($ElevationType -eq 2 -or $ElevationStatus -gt 0)
    }
    finally {
        if ($TokenElevation -ne [IntPtr]0) {
            [marshal]::FreeHGlobal($TokenElevation)
        }
        if ($TokenElevationType -ne [IntPtr]0) {
            [marshal]::FreeHGlobal($TokenElevationType)
        }
        @($hproc, $hToken) | % { [TOKEN]::NtClose($_) | Out-Null }
    }
}
  
  #SECURITY_NT_AUTHORITY (S-1-5)
  $isMember = $false
  $Rev, $Auth, $Count, $MaxCount = 1,5,0,10
  $pSid = [Marshal]::AllocHGlobal(8+(4*$MaxCount))
  @($Rev, $Count, 0,0,0,0,0, $Auth) | ForEach -Begin { $i = 0 } -Process { [Marshal]::WriteByte($pSid, $i++, $_)  }
  try {
    switch ($AccType) {
        "System" {
            # S-1-5-[18] // @([1],Count,0,0,0,0,0,[5] && 18)
            $isMember = Check -pSid $pSid -Subs @(18) -Type Account
        }
        "Administrator" {
            # S-1-5-[32]-[544] // @([1],Count,0,0,0,0,0,[5] && 32,544)
            $isMember = Check -pSid $pSid -Subs @(32, 544) -Type Group
        }
        "TokenElevation" {
            $isMember = IsElavated
        }
    }
  }
  catch {
    Write-warning "An error occurred: $_"
    if (-not [Environment]::Is64BitProcess -and [Environment]::Is64BitOperatingSystem) {
        Write-warning "This script could fail on x86 PowerShell in a 64-bit system."
    }
    $isMember = $null
  }
  [Marshal]::FreeHGlobal($pSid)
  return $isMember
}

<#
* Thread Environment Block (TEB)
* https://www.geoffchappell.com/studies/windows/km/ntoskrnl/inc/api/pebteb/teb/index.htm

* Process Environment Block (PEB)
* https://www.geoffchappell.com/studies/windows/km/ntoskrnl/inc/api/pebteb/peb/index.htm

[TEB]
--> NT_TIB NtTib; 0x00
---->
    Struct {
    ...
    PNT_TIB Self; <<<<< gs:[0x30] / fs:[0x18]
    } NT_TIB
#>
if (!([PSTypeName]'TEB').Type) {
$TEB = @"
using System;
using System.Runtime.InteropServices;

public static class TEB
{
    public delegate IntPtr GetAddress();
    public delegate void GetAddressByPointer(IntPtr Ret);
    public delegate void GetAddressByReference(ref IntPtr Ret);

    public static IntPtr CallbackResult;

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    public delegate void CallbackDelegate(IntPtr callback, IntPtr TEB);

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    public delegate void RemoteThreadDelgate(IntPtr callback);

    public static CallbackDelegate GetCallback()
    {
        return new CallbackDelegate((IntPtr del, IntPtr val) =>
        {
            CallbackResult = val;
        });
    }

    // Example in C#
    public static bool IsRobustValidx64Stub(IntPtr funcAddress)
    {
        byte[] buffer = new byte[30];
        System.Runtime.InteropServices.Marshal.Copy(funcAddress, buffer, 0, 30);

        // Look for the "mov r10, rcx" pattern
        int movR10RcxIndex = -1;
        for (int i = 0; i < buffer.Length - 2; i++) {
            if (buffer[i] == 0x4C && buffer[i+1] == 0x8B && buffer[i+2] == 0xD1) {
                movR10RcxIndex = i;
                break;
            }
        }
        if (movR10RcxIndex == -1) return false;

        // Look for the "mov eax, [syscall_id]" pattern
        int movEaxIndex = -1;
        for (int i = movR10RcxIndex; i < buffer.Length - 1; i++) {
            if (buffer[i] == 0xB8) {
                movEaxIndex = i;
                break;
            }
        }
        if (movEaxIndex == -1) return false;

        // Look for the "syscall" pattern
        int syscallIndex = -1;
        for (int i = movEaxIndex; i < buffer.Length - 1; i++) {
            if (buffer[i] == 0x0F && buffer[i+1] == 0x05) {
                syscallIndex = i;
                break;
            }
        }
        if (syscallIndex == -1) return false;

        // Look for the "ret" pattern
        for (int i = syscallIndex; i < buffer.Length; i++) {
            if (buffer[i] == 0xC3) {
                return true;
            }
        }

        return false;
    }

    public static byte[] GenerateSyscallx64 (byte[] syscall)
    {
        return  new byte[]
        {
            0x4C, 0x8B, 0xD1,                                       // mov r10, rcx
            0xB8, syscall[0], syscall[1], syscall[2], syscall[3],   // mov eax, syscall
            0x0F, 0x05,                                             // syscall
            0xC3                                                    // ret
        };
    }

    public static byte[] GenerateSyscallx86(IntPtr stubAddress)
    {
        int maxStubSize = 20;
        byte[] stubBytes = new byte[maxStubSize];
        Marshal.Copy(stubAddress, stubBytes, 0, maxStubSize);

        // Validate the start: mov eax, [syscall_id] (opcode B8)
        if (stubBytes[0] != 0xB8)
        {
            throw new Exception("Invalid x86 syscall stub: 'mov eax' instruction not found.");
        }

        // Find the 'mov edx, [Wow64SystemServiceCall]' instruction (opcode BA)
        int movEdxIndex = -1;
        for (int i = 5; i < maxStubSize; i++)
        {
            if (stubBytes[i] == 0xBA)
            {
                movEdxIndex = i;
                break;
            }
        }
        if (movEdxIndex == -1)
        {
            throw new Exception("Invalid x86 syscall stub: 'mov edx' not found.");
        }

        // Find the 'call edx' instruction (opcode FF D2)
        int callEdxIndex = -1;
        for (int i = movEdxIndex + 5; i < maxStubSize - 1; i++)
        {
            if (stubBytes[i] == 0xFF && stubBytes[i + 1] == 0xD2)
            {
                callEdxIndex = i;
                break;
            }
        }
        if (callEdxIndex == -1)
        {
            throw new Exception("Invalid x86 syscall stub: 'call edx' not found.");
        }

        // Find the end of the stub: 'retn [size]' (C2) or 'ret' (C3)
        int stubLength = -1;
        for (int i = callEdxIndex + 2; i < maxStubSize; i++)
        {
            if (stubBytes[i] == 0xC2) // retn with parameters
            {
                stubLength = i + 3;
                break;
            }
            else if (stubBytes[i] == 0xC3) // ret with no parameters
            {
                stubLength = i + 1;
                break;
            }
        }
        if (stubLength == -1)
        {
            throw new Exception("Could not find the 'ret' or 'retn' instruction.");
        }

        byte[] syscallShellcode = new byte[stubLength];
        Array.Copy(stubBytes, syscallShellcode, stubLength);
        return syscallShellcode;
    }

    [DllImport("kernel32.dll", CharSet=CharSet.Unicode)]
    [DefaultDllImportSearchPaths(DllImportSearchPath.System32)]
    public static extern IntPtr LoadLibraryW(string lpLibFileName);
 
    [DllImport("kernel32.dll")]
    [DefaultDllImportSearchPaths(DllImportSearchPath.System32)]
    public static extern IntPtr GetProcAddress(
        IntPtr hModule,
        string lpProcName);

    [DllImport("kernel32.dll")]
    [DefaultDllImportSearchPaths(DllImportSearchPath.System32)]
    public static extern IntPtr GetProcessHeap();

    [DllImport("ntdll.dll", CallingConvention = CallingConvention.StdCall)]
    public static extern int ZwAllocateVirtualMemory(
        IntPtr ProcessHandle,
        ref IntPtr BaseAddress,
        UIntPtr ZeroBits,
        ref UIntPtr RegionSize,
        uint AllocationType,
        uint Protect
    );

    [DllImport("ntdll.dll", CallingConvention = CallingConvention.StdCall)]
    public static extern int ZwAllocateVirtualMemoryEx(
        IntPtr ProcessHandle,
        ref IntPtr BaseAddress,
        ref UIntPtr RegionSize,
        uint AllocationType,
        uint Protect,
        IntPtr ExtendedParameters,
        uint ParameterCount
    );

    [DllImport("ntdll.dll", CallingConvention = CallingConvention.StdCall)]
    public static extern int ZwFreeVirtualMemory(
        IntPtr ProcessHandle,
        ref IntPtr BaseAddress,
        ref UIntPtr RegionSize,
        uint FreeType
    );
 
    [DllImport("ntdll.dll", SetLastError = true)]
    public static extern int NtProtectVirtualMemory(
        IntPtr ProcessHandle,           // Handle to the process
        ref IntPtr BaseAddress,         // Base address of the memory region -> ByRef
        ref UIntPtr RegionSize,         // Size of the region to protect
        uint NewProtection,             // New protection (e.g., PAGE_EXECUTE_READWRITE)
        out uint OldProtection          // Old protection (output)
    );

    [DllImport("kernel32.dll", CallingConvention = CallingConvention.StdCall)]
    public static extern uint GetCurrentProcessId();

    [DllImport("kernel32.dll", CallingConvention = CallingConvention.StdCall)]
    public static extern uint GetCurrentThreadId();

    [DllImport("ntdll.dll", CallingConvention = CallingConvention.StdCall)]
    public static extern IntPtr RtlGetCurrentPeb();

    [DllImport("ntdll.dll", CallingConvention = CallingConvention.StdCall)]
    public static extern IntPtr RtlGetCurrentServiceSessionId();

    [DllImport("ntdll.dll", CallingConvention = CallingConvention.StdCall)]
    public static extern IntPtr RtlGetCurrentTransaction();
}
"@
Add-Type -TypeDefinition $TEB -ErrorAction Stop
}
Function NtCurrentTeb {
    
    <#
    Example Use
    NtCurrentTeb -Mode Buffer -Method Base
    NtCurrentTeb -Mode Buffer -Method Extend
    NtCurrentTeb -Mode Buffer -Method Protect
    NtCurrentTeb -Mode Remote -Method Base
    NtCurrentTeb -Mode Remote -Method Extend
    NtCurrentTeb -Mode Remote -Method Protect
    #>

    param (
        # Mode options for retrieving the TEB address:
        # Return   -> value returned directly in CPU register
        # Pinned   -> use a managed variable pinned in memory
        # Buffer   -> use an unmanaged temporary buffer
        # GCHandle -> use a GCHandle pinned buffer
        # Remote   -> using Callback, to receive to TEB pointer
        [Parameter(Mandatory = $false, Position = 1)]
        [ValidateSet("Return" ,"Pinned", "Buffer", "GCHandle", "Remote")]
        [string]$Mode = "Return",

        # Allocation method for virtual memory
        [Parameter(Mandatory = $false, Position = 2)]
        [ValidateSet("Base", "Extend", "Protect")]
        [string]$Method = "Base",

        # Optional flags to select which fields to read from TEB/PEB
        [switch]$ClientID,
        [switch]$Peb,
        [switch]$Ldr,
        [switch]$ProcessHeap,
        [switch]$Parameters,
    
        # Enable logging/debug output
        [Parameter(Mandatory = $false, Position = 7)]
        [switch]$Log = $false,

        # Self Check Function
        [Parameter(Mandatory = $false, Position = 8)]
        [switch]$SelfCheck
    )

    function Build-ASM-Shell {

        <#
        Online x86 / x64 Assembler and Disassembler
        https://defuse.ca/online-x86-assembler.htm

        add rax, 0x??           --> Add 0x?? Bytes, From Position
        mov Type, [Type + 0x??] --> Move to 0x?? Offset, read Value

        So,
        Example Read Pointer Value, 
        & Also, 
        Add 0x?? From Value

        // Return to gs:[0x00], store value at rax
        // (NtCurrentTeb) -eq ([Marshal]::ReadIntPtr((NtCurrentTeb), 0x30))
        // ([marshal]::ReadIntPtr((NtCurrentTeb),0x40)) -eq ([marshal]::ReadIntPtr((([Marshal]::ReadIntPtr((NtCurrentTeb), 0x30))),0x40))
        ** mov rax, gs:[0x30]

        // Move (de-ref`) -or Add\[+], and store value
        ** mov Type, [Type + 0x??]
        ** add rax,  0x??

        // Ret value
        ** Ret
        #>

        $shellcode        = [byte[]]@()
        $is64             = [IntPtr]::Size -gt 4
        $ret              = [byte[]]([byte]0xC3)

        if ($is64) {
            $addClient = [byte[]]@([byte]0x48,[byte]0x83,[byte]0xC0,[byte]0x40)  # add rax, 0x40          // gs:[0x40]
            $movPeb    = [byte[]]@([byte]0x48,[byte]0x8B,[byte]0x40,[byte]0x60)  # mov rax, [rax + 0x60]  // gs:[0x60] // RtlGetCurrentPeb
            $movLdr    = [byte[]]@([byte]0x48,[byte]0x8B,[byte]0x40,[byte]0x18)  # mov rax, [rax + 0x18]
            $movParams = [byte[]]@([byte]0x48,[byte]0x8B,[byte]0x40,[byte]0x20)  # mov rax, [rax + 0x20]
            $movHeap   = [byte[]]@([byte]0x48,[byte]0x8B,[byte]0x40,[byte]0x30)  # mov rax, [rax + 0x30]
            $basePtr   = [byte[]]@([byte]0x65,[byte]0x48,[byte]0x8B,[byte]0x04,  # mov rax, gs:[0x30]     #// Self dereference pointer at gs:[0x30],
                                   [byte]0x25,[byte]0x30,[byte]0x00,[byte]0x00,                           #// so, effectually, return to gs->0x0
                                   [byte]0x00)
            $InByRef  = [byte[]]@([byte]0x48,[byte]0x89,[byte]0x01)              # mov [rcx], rax         #// moves the 64-bit value from the RAX register
                                                                                                          #// into the memory location pointed to by the RCX register.
        }
        else {
            $addClient = [byte[]]@([byte]0x83,[byte]0xC0,[byte]0x20)             # add eax, 0x20          // fs:[0x20]
            $movPeb    = [byte[]]@([byte]0x8B,[byte]0x40,[byte]0x30)             # mov eax, [eax + 0x30]  // fs:[0x30] // RtlGetCurrentPeb
            $movLdr    = [byte[]]@([byte]0x8B,[byte]0x40,[byte]0x0C)             # mov eax, [eax + 0x0c]
            $movParams = [byte[]]@([byte]0x8B,[byte]0x40,[byte]0x10)             # mov eax, [eax + 0x10]
            $movHeap   = [byte[]]@([byte]0x8B,[byte]0x40,[byte]0x18)             # mov eax, [eax + 0x18]
            $basePtr   = [byte[]]@([byte]0x64,[byte]0xA1,[byte]0x18,             # mov eax, fs:[0x18]     #// Self dereference pointer at fs:[0x18], 
                                   [byte]0x00,[byte]0x00,[byte]0x00)                                      #// so, effectually, return  to fs->0x0
            $InByRef = [byte[]]@(
                [byte]0x8B, [byte]0x4C, [byte]0x24, [byte]0x04,                  # mov ecx, [esp + 4]     ; load first argument pointer from stack into ECX
                [byte]0x89, [byte]0x01                                           # mov [ecx], eax         ; store 32-bit value from EAX into memory pointed by ECX
            )
        }

        $shellcode = $basePtr
        if ($ClientID) { $shellcode += $addClient }
        if ($Peb) {
            $shellcode += $movPeb
            if ($Ldr) { $shellcode += $movLdr }
            if ($Parameters) { $shellcode += $movParams }
            if ($ProcessHeap) { $shellcode += $movHeap }
        }
        if ($Mode -ne "Return") {$shellcode += $InByRef}
        $shellcode += $ret
        $shellcode
    }

    if ($SelfCheck) {
        Clear-Host
        Write-Host
        $isX64 = [IntPtr]::Size -gt 4

        Write-Host "`nGetCurrentProcessId Test" -ForegroundColor Green
        $Offset = if ($isX64) {0x40} else {0x20}
        $procPtr = [Marshal]::ReadIntPtr((NtCurrentTeb), $Offset)
        Write-Host ("TEB offset 0x{0:X} value: {1}" -f $Offset, $procPtr)
        $clientIDProc = [Marshal]::ReadIntPtr((NtCurrentTeb -ClientID), 0x0)
        Write-Host ("ClientID Process Pointer: {0}" -f $clientIDProc)
        Write-Host ("GetCurrentProcessId(): {0}" -f [TEB]::GetCurrentProcessId())

        Write-Host "`nGetCurrentThreadId Test" -ForegroundColor Green
        $threadPtr = [Marshal]::ReadIntPtr((NtCurrentTeb), ($Offset + [IntPtr]::Size))
        Write-Host ("TEB offset 0x{0:X} value: {1}" -f ($Offset + [IntPtr]::Size), $threadPtr)
        $clientIDThread = [Marshal]::ReadIntPtr((NtCurrentTeb -ClientID), [IntPtr]::Size)
        Write-Host ("ClientID Thread Pointer: {0}" -f $clientIDThread)
        Write-Host ("GetCurrentThreadId(): {0}" -f [TEB]::GetCurrentThreadId())

        Write-Host "`nRtlGetCurrentPeb Test" -ForegroundColor Green
        $Offset = if ($isX64) {0x60} else {0x30}
        $pebPtr = [Marshal]::ReadIntPtr((NtCurrentTeb), $Offset)
        Write-Host ("TEB offset 0x{0:X} value: {1}" -f $Offset, $pebPtr)
        $pebViaFunction = NtCurrentTeb -Peb
        Write-Host ("NtCurrentTeb -Peb returned: {0}" -f $pebViaFunction)
        $pebViaTEB = [TEB]::RtlGetCurrentPeb()
        Write-Host ("RtlGetCurrentPeb(): {0}" -f $pebViaTEB)

        Write-Host "`nGetProcessHeap Test" -ForegroundColor Green
        $HeapViaFunction = NtCurrentTeb -ProcessHeap
        Write-Host ("NtCurrentTeb -ProcessHeap returned: {0}" -f $HeapViaFunction)
        $HeapViaTEB = [TEB]::GetProcessHeap()
        Write-Host ("GetProcessHeap(): {0}" -f $HeapViaTEB)
        
        Write-Host "`nRtlGetCurrentServiceSessionId Test" -ForegroundColor Green
        $serviceSessionId = [TEB]::RtlGetCurrentServiceSessionId()
        Write-Host ("Service Session Id: {0}" -f $serviceSessionId)
        $Offset = if ($isX64) {0x90} else {0x50}
        $sessionPtr = [Marshal]::ReadIntPtr((NtCurrentTeb -Peb), $Offset)
        Write-Host ("PEB offset 0x{0:X} value: {1}" -f $Offset, $sessionPtr)

        Write-Host "`nRtlGetCurrentTransaction Test" -ForegroundColor Green
        $transaction = [TEB]::RtlGetCurrentTransaction()
        Write-Host ("Current Transaction: {0}" -f $transaction)
        $Offset = if ($isX64) {0x17B8} else {0x0FAC}
        $txnPtr = [Marshal]::ReadIntPtr((NtCurrentTeb -Peb), $Offset)
        Write-Host ("PEB offset 0x{0:X} value: {1}" -f $Offset, $txnPtr)

        Write-Host "`nNtCurrentTeb Mode Test" -ForegroundColor Green
        $defaultPtr = [Marshal]::ReadIntPtr((NtCurrentTeb -Log), [IntPtr]::Size)
        Write-Host ("Default Mode Ptr: {0}" -f $defaultPtr)
        $returnPtr = [Marshal]::ReadIntPtr((NtCurrentTeb -Mode Return -Log), [IntPtr]::Size)
        Write-Host ("Return Mode Ptr: {0}" -f $returnPtr)

        $bufferPtr = [Marshal]::ReadIntPtr((NtCurrentTeb -Mode Buffer -Log), [IntPtr]::Size)
        Write-Host ("Buffer Mode Ptr: {0}" -f $bufferPtr)
        $pinnedPtr = [Marshal]::ReadIntPtr((NtCurrentTeb -Mode Pinned -Log), [IntPtr]::Size)
        Write-Host ("Pinned Mode Ptr: {0}" -f $pinnedPtr)
        $gcHandlePtr = [Marshal]::ReadIntPtr((NtCurrentTeb -Mode GCHandle -Log), [IntPtr]::Size)
        Write-Host ("GCHandle Mode Ptr: {0}" -f $gcHandlePtr)
        $callbackHandlePtr = [Marshal]::ReadIntPtr((NtCurrentTeb -Mode Remote -Log), [IntPtr]::Size)
        Write-Host ("Remote Mode Ptr: {0}" -f $callbackHandlePtr)

        Write-Host
        return
    }

    if ($Ldr -or $Parameters -or $ProcessHeap) {
      $Peb = $true
    }
    $Count = [bool]$Ldr -and [bool]$Parameters + [bool]$ProcessHeap
    if ($Count -ge 1) {
        throw "Cannot specify both -Ldr and -Parameters. Choose one."
    }
    if ($ClientID -and $Peb) {
        throw "Cannot specify both -ClientID and -Peb. Choose one."
    }

    if ($Mode -eq 'Remote') {
        [TEB]::CallbackResult = 0
        if (!$Global:MyCallbackDelegate) {
          $callbackDelegate = {
            param([IntPtr] $delPtr, [IntPtr] $valPtr)
            [TEB]::CallbackResult = $valPtr
          }
          $handle = [gchandle]::Alloc($callbackDelegate, [GCHandleType]::Normal)
          $Global:MyCallbackDelegate = $callbackDelegate
          #$Global:MyCallbackDelegate = [Teb]::GetCallback();
        }
        $callbackPtr = [Marshal]::GetFunctionPointerForDelegate(([TEB+CallbackDelegate]$Global:MyCallbackDelegate));

        [byte[]]$shellcode = $null
        if ([IntPtr]::Size -eq 8)
        {
            [byte[]]$shellcode = [byte[]]@(
                0x48, 0x89, 0xC8,                  ## mov rax, rcx      ## Move function address (first param) to rax.
                0x65, 0x48, 0x8B, 0x14, 0x25, 0x30, 0x00, 0x00, 0x00,   ## mov rdx, gs:[0x30]
                                                                        ## Set second param (rdx) from a known memory location.
                0x48, 0x83, 0xEC, 0x28,            ## sub rsp, 40       ## Allocate space on the stack for the call.
                0xFF, 0xD0,                        ## call rax          ## Call the function using the address from rax.
                0x48, 0x83, 0xC4, 0x28,            ## add rsp, 40       ## Clean up the stack.
                0xC3                               ## ret               ## Return to the caller.
            );
        }
        elseif ([IntPtr]::Size -eq 4)
        {
            [byte[]]$shellcode = [byte[]]@(
                0x64, 0xA1, 0x18, 0x00, 0x00, 0x00, ## mov eax, fs:[0x18] ## Get a specific address from the Thread Information Block.
                0x50,                               ## push eax           ## Push this address onto the stack to use later.
                0x8B, 0x44, 0x24, 0x08,             ## mov eax, [esp + 8] ## Get a second value (a function pointer or argument) from the stack.
                0x50,                               ## push eax           ## Push this value onto the stack as well.
                0xFF, 0x14, 0x24,                   ## call [esp]         ## Call the function whose address is now at the top of the stack.
                0x83, 0xC4, 0x08,                   ## add esp, 8         ## Clean up the two values we pushed on the stack.
                0xC3                                ## ret                ## Return to the calling code.
            )
        }

        $baseAddressPtr = $null
        $len = $shellcode.Length
        $lpflOldProtect = [UInt32]0
        $baseAddress = [IntPtr]::Zero
        $regionSize = [uintptr]::new($len)
    
        if ($Method -match "Base|Extend") {
        
            ## Allocate
            $ntStatus = if ($Method -eq "Base") {
                [TEB]::ZwAllocateVirtualMemory(
                   [IntPtr]::new(-1),
                   [ref]$baseAddress,
                   [UIntPtr]::new(0x00),
                   [ref]$regionSize,
                   0x3000, 0x40)
            } elseif ($Method -eq "Extend") {
                [TEB]::ZwAllocateVirtualMemoryEx(
                   [IntPtr]::new(-1),
                   [ref]$baseAddress,
                   [ref]$regionSize,
                   0x3000, 0x40,
                   [IntPtr]0,0)
            }

            if ($ntStatus -ne 0) {
                throw "ZwAllocateVirtualMemory failed with result: $ntStatus"
            }

            $Address = [IntPtr]::Zero
            [marshal]::Copy($shellcode, 0x00, $baseAddress, $len)
            ## Allocate

        } else {
        
            ## Protect
            $baseAddressPtr = [gchandle]::Alloc($shellcode, 'pinned')
            $baseAddress = $baseAddressPtr.AddrOfPinnedObject()
            [IntPtr]$tempBase = $baseAddress
            if ([TEB]::NtProtectVirtualMemory(
                    [IntPtr]::new(-1),
                    [ref]$tempBase,
                    ([ref]$regionSize),
                    0x00000040,
                    [ref]$lpflOldProtect) -ne 0) {
                throw "Fail to Protect Memory for SysCall"
            }
            ## Protect
        }

        $handle = [IntPtr]::Zero
        try
        {
            $Caller = [Marshal]::GetDelegateForFunctionPointer($baseAddress, [TEB+RemoteThreadDelgate]);
            $handle = [gchandle]::Alloc($Caller, [GCHandleType]::Normal)
            $Caller.Invoke($callbackPtr);
        }
        catch {}
        finally
        {
            Start-Sleep -Milliseconds 400
            if ($handle.IsAllocated) { $handle.Free() }

            if ($baseAddressPtr -ne $null) {
                $baseAddressPtr.Free()
            } else {
                [TEB]::ZwFreeVirtualMemory(
                    [IntPtr]::new(-1),
                    [ref]$baseAddress,
                    [ref]$regionSize,
                    0x4000) | Out-Null
            }
        }

        if ($Log) {
            Write-Warning "Mode: Remote. TypeOf: Callback Delegate"
        }
    
        if (-not [TEB]::CallbackResult -or [TEB]::CallbackResult -eq [IntPtr]::Zero) {
            throw "Failure to get results from callback!"
        }

        $isX64 = [IntPtr]::Size -eq 8

        if ($ClientID) {
            if ($isX64) {
                return [IntPtr]::Add([TEB]::CallbackResult, 0x40)
            } else {
                return [IntPtr]::Add([TEB]::CallbackResult, 0x20)
            }
        }

        if ($Peb) {
            if ($isX64) {
                $CallbackResult = [Marshal]::ReadIntPtr([TEB]::CallbackResult, 0x60)
                if ($Ldr) { $CallbackResult = [Marshal]::ReadIntPtr($CallbackResult, 0x18) }
                if ($Parameters) { $CallbackResult = [Marshal]::ReadIntPtr($CallbackResult, 0x20) }
                if ($ProcessHeap) { $CallbackResult = [Marshal]::ReadIntPtr($CallbackResult, 0x30) }
            } else {
                $CallbackResult = [Marshal]::ReadIntPtr([TEB]::CallbackResult, 0x30)
                if ($Ldr) { $CallbackResult = [Marshal]::ReadIntPtr($CallbackResult, 0x0c) }
                if ($Parameters) { $CallbackResult = [Marshal]::ReadIntPtr($CallbackResult, 0x10) }
                if ($ProcessHeap) { $CallbackResult = [Marshal]::ReadIntPtr($CallbackResult, 0x18) }
            }
            return $CallbackResult
        }

        return [TEB]::CallbackResult
    }
    
    [byte[]]$shellcode = [byte[]](Build-ASM-Shell)
    $baseAddressPtr = $null
    $len = $shellcode.Length
    $lpflOldProtect = [UInt32]0
    $baseAddress = [IntPtr]::Zero
    $regionSize = [uintptr]::new($len)
    
    if ($Method -match "Base|Extend") {
        
        ## Allocate
        $ntStatus = if ($Method -eq "Base") {
            [TEB]::ZwAllocateVirtualMemory(
               [IntPtr]::new(-1),
               [ref]$baseAddress,
               [UIntPtr]::new(0x00),
               [ref]$regionSize,
               0x3000, 0x40)
        } elseif ($Method -eq "Extend") {
            [TEB]::ZwAllocateVirtualMemoryEx(
               [IntPtr]::new(-1),
               [ref]$baseAddress,
               [ref]$regionSize,
               0x3000, 0x40,
               [IntPtr]0,0)
        }

        if ($ntStatus -ne 0) {
            throw "ZwAllocateVirtualMemory failed with result: $ntStatus"
        }

        $Address = [IntPtr]::Zero
        [marshal]::Copy($shellcode, 0x00, $baseAddress, $len)
        ## Allocate

    } else {
        
        ## Protect
        $Address = [IntPtr]::Zero
        $baseAddressPtr = [gchandle]::Alloc($shellcode, 'pinned')
        $baseAddress = $baseAddressPtr.AddrOfPinnedObject()
        [IntPtr]$tempBase = $baseAddress
        if ([TEB]::NtProtectVirtualMemory(
                [IntPtr]::new(-1),
                [ref]$tempBase,
                ([ref]$regionSize),
                0x00000040,
                [ref]$lpflOldProtect) -ne 0) {
            throw "Fail to Protect Memory for SysCall"
        }
        ## Protect
    }

    try {
        switch ($Mode) {
          "Return" {
            if ($log) {
               Write-Warning "Mode: Return.   TypeOf:GetAddress"
            }
            $Address = [Marshal]::GetDelegateForFunctionPointer(
                $baseAddress,[TEB+GetAddress]).Invoke()
          }
          "Buffer" {
            if ($log) {
               Write-Warning "Mode: Buffer.   TypeOf:GetAddressByPointer"
            }
            $baseAdd = [marshal]::AllocHGlobal([IntPtr]::Size)
            [Marshal]::GetDelegateForFunctionPointer(
                $baseAddress,[TEB+GetAddressByPointer]).Invoke($baseAdd)
            $Address = [marshal]::ReadIntPtr($baseAdd)
            [marshal]::FreeHGlobal($baseAdd)
          }
          "GCHandle" {
            if ($log) {
               Write-Warning "Mode: GCHandle. TypeOf:GetAddressByPointer"
            }
            $gcHandle = [GCHandle]::Alloc($Address, [GCHandleType]::Pinned)
            $baseAdd = $gcHandle.AddrOfPinnedObject()
            [Marshal]::GetDelegateForFunctionPointer(
                $baseAddress,[TEB+GetAddressByPointer]).Invoke($baseAdd)
            $gcHandle.Free()
          }
          "Pinned" {
            if ($log) {
               Write-Warning "Mode: [REF].    TypeOf:GetAddressByReference"
            }
            [Marshal]::GetDelegateForFunctionPointer(
                $baseAddress,[TEB+GetAddressByReference]).Invoke([ref]$Address)
          }
        }
        return $Address
    }
    finally {
        if ($baseAddressPtr -ne $null) {
            $baseAddressPtr.Free()
        } else {
            [TEB]::ZwFreeVirtualMemory(
                [IntPtr]::new(-1),
                [ref]$baseAddress,
                [ref]$regionSize,
                0x4000) | Out-Null
        }
    }
}

<#
    LdrLoadDll Data Convert Helper
    ------------------------------
    
    >>>>>>>>>>>>>>>>>>>>>>>>>>>
    API-SPY --> SLUI 0x2a ERROR
    >>>>>>>>>>>>>>>>>>>>>>>>>>>

    0x00000010 - LOAD_IGNORE_CODE_AUTHZ_LEVEL
    LdrLoadDll(1,[Ref]0, 0x000000cae83fda50, 0x000000cae83fda98)
    
    0x00000008 - LOAD_WITH_ALTERED_SEARCH_PATH            
    LdrLoadDll(9,[Ref]0, 0x000000cae7fee930, 0x000000cae7fee978)
            
    0x00000800 - LOAD_LIBRARY_SEARCH_SYSTEM32
    LdrLoadDll(2049, [Ref]0, 0x000000cae83fed00, 0x000000cae83fed48 )
    
    0x00002000 -bor 0x00000008 - LOAD_LIBRARY_SAFE_CURRENT_DIRS & LOAD_WITH_ALTERED_SEARCH_PATH
    LdrLoadDll(8201, [Ref]0, 0x000000cae85fcbb0, 0x000000cae85fcbf8 )

    >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
    HMODULE __stdcall LoadLibraryExW(LPCWSTR lpLibFileName,HANDLE hFile,DWORD dwFlags)
    >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

    if ((dwFlags & 0x62) == 0) {
    local_res8[0] = 0;
    if ((dwFlags & 1) != 0) {
        local_res8[0] = 2;
        uVar3 = 2;
    }
    if ((char)dwFlags < '\0') {
        uVar3 = uVar3 | 0x800000;
        local_res8[0] = uVar3;
    }
    if ((dwFlags & 4) != 0) {
        uVar3 = uVar3 | 4;
        local_res8[0] = uVar3;
    }
    if ((dwFlags >> 0xf & 1) != 0) {
        local_res8[0] = uVar3 | 0x80000000;
    }
    iVar1 = LdrLoadDll(dwFlags & 0x7f08 | 1,local_res8,local_28,&local_res20);
    }

    >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
    void LdrLoadDll(ulonglong param_1,uint *param_2,uint *param_3,undefined8 *param_4)
    >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

      if (param_2 == (uint *)0x0) {
        uVar4 = 0;
      }
      else {
        uVar4 = (*param_2 & 4) * 2;
        uVar3 = uVar4 | 0x40;
        if ((*param_2 & 2) == 0) {
          uVar3 = uVar4;
        }
        uVar4 = uVar3 | 0x80;
        if ((*param_2 & 0x800000) == 0) {
          uVar4 = uVar3;
        }
        uVar3 = uVar4 | 0x100;
        if ((*param_2 & 0x1000) == 0) {
          uVar3 = uVar4;
        }
        uVar4 = uVar3 | 0x400000;
        if (-1 < (int)*param_2) {
          uVar4 = uVar3;
        }
      }

    SearchPath
    ----------
    (0x00000001 -band 0x7f08) -bor 1 // DONT_RESOLVE_DLL_REFERENCES
    (0x00000010 -band 0x7f08) -bor 1 // LOAD_IGNORE_CODE_AUTHZ_LEVEL
    (0x00000200 -band 0x7f08) -bor 1 // LOAD_LIBRARY_SEARCH_APPLICATION_DIR
    (0x00001000 -band 0x7f08) -bor 1 // LOAD_LIBRARY_SEARCH_DEFAULT_DIRS
    (0x00000100 -band 0x7f08) -bor 1 // LOAD_LIBRARY_SEARCH_DLL_LOAD_DIR
    (0x00000800 -band 0x7f08) -bor 1 // LOAD_LIBRARY_SEARCH_SYSTEM32
    (0x00000400 -band 0x7f08) -bor 1 // LOAD_LIBRARY_SEARCH_USER_DIRS
    (0x00000008 -band 0x7f08) -bor 1 // LOAD_WITH_ALTERED_SEARCH_PATH
    (0x00000080 -band 0x7f08) -bor 1 // LOAD_LIBRARY_REQUIRE_SIGNED_TARGET
    (0x00002000 -band 0x7f08) -bor 1 // LOAD_LIBRARY_SAFE_CURRENT_DIRS

    This --> will auto bypass to LoadLibraryEx?
    0x00000002, LOAD_LIBRARY_AS_DATAFILE
    0x00000040, LOAD_LIBRARY_AS_DATAFILE_EXCLUSIVE
    0x00000020, LOAD_LIBRARY_AS_IMAGE_RESOURCE

    DllCharacteristics
    ------------------
    Auto deteced by function.
    According to dwFlag value,
    who provide by user.
#>
enum LOAD_LIBRARY {
    NO_DLL_REF = 0x00000001
    IGNORE_AUTHZ = 0x00000010
    AS_DATAFILE = 0x00000002
    AS_DATAFILE_EXCL = 0x00000040
    AS_IMAGE_RES = 0x00000020
    SEARCH_APP = 0x00000200
    SEARCH_DEFAULT = 0x00001000
    SEARCH_DLL_LOAD = 0x00000100
    SEARCH_SYS32 = 0x00000800
    SEARCH_USER = 0x00000400
    ALTERED_SEARCH = 0x00000008
    REQ_SIGNED = 0x00000080
    SAFE_CURRENT = 0x00002000
}
function Ldr-LoadDll {
    param (
        [Parameter(Mandatory = $true)]
        [LOAD_LIBRARY]$dwFlags,
        
        [Parameter(Mandatory = $true)]
        [ValidateNotNullOrEmpty()]
        [string]$dll,

        [Parameter(Mandatory = $false)]
        [switch]$Log,

        [Parameter(Mandatory = $false)]
        [switch]$ForceNew
    )
    $Zero = [IntPtr]::Zero
    $HResults, $FlagsPtr, $stringPtr = $Zero, $Zero, $Zero

    if (!$dwFlags -or [Int32]$dwFlags -eq $null) {
        throw "can't access dwFlags value"
    }

    if ([Int32]$dwFlags -lt 0) {
        throw "dwFlags Can't be less than 0"
    }

    if (-not $global:LoadedModules) {
        $global:LoadedModules = Get-LoadedModules -SortType Memory | 
            Select-Object BaseAddress, ModuleName, LoadAsData
    }

    # $ForceNew == $Log ==> $false
    $ReUseHandle = !$Log -and !$ForceNew

    # Equivalent to: if ((dwFlags & 0x62) == 0)
    # AS_DATAFILE, AS_DATAFILE_EXCLUSIVE, AS_IMAGE_RESOURCE
    $IsDataLoad = ([Int32]$dwFlags -band 0x62) -ne 0

    if ($ReUseHandle) {
        $dllObjList = $global:LoadedModules |
            Where-Object { $_.ModuleName -ieq $dll }

        if ($dllObjList) {
            if ($IsDataLoad) {
                $dllObj = $dllObjList | Where-Object { $_.LoadAsData } | Select-Object -Last 1 -ExpandProperty BaseAddress
            } else {
                $dllObj = $dllObjList | Where-Object { -not $_.LoadAsData } | Select-Object -Last 1 -ExpandProperty BaseAddress
            }

            if ($dllObj) {
                #Write-Warning "Returning reusable module object for $dll"
                return $dllObj
            }
        }
    }

    try {
        $FlagsPtr = New-IntPtr -Size 4
        if ($IsDataLoad) {
            
            # Data Load -> Begin
            if ($Log) {
                Write-host "Flags      = $([Int32]$dwFlags)"
                Write-host "SearchPath = NULL"
                Write-host "Function   = LoadLibraryExW"
                return
            }

            #Write-Warning 'Logging only --> LoadLibraryExW'
            $HResults = $Global:kernel32::LoadLibraryExW(
                $dll, [IntPtr]::Zero, [Int32]$dwFlags)
            
            if ($HResults -ne [IntPtr]::Zero) {
                $dllInfo = [PSCustomObject]@{
                    BaseAddress = $HResults
                    ModuleName  = $dll
                    LoadAsData  = $true
                }
                $global:LoadedModules += $dllInfo
            }
            return $HResults
            # Data Load -> End

        } else {
            
            # Normal Load -> Begin
            $LoadFlags = 0
            if (([Int32]$dwFlags -band 1) -ne 0) { $LoadFlags = 2 }
            if (([Int32]$dwFlags -band 0x80) -ne 0) { $LoadFlags = $LoadFlags -bor 0x800000 }
            if (([Int32]$dwFlags -band 4) -ne 0) { $LoadFlags = $LoadFlags -bor 4 }
            if ((([Int32]$dwFlags -shr 15) -band 1) -ne 0) { $LoadFlags = $LoadFlags -bor 0x80000000 }
            $Flags = ([Int32]$dwFlags -band 0x7f08) -bor 1
            $DllCharacteristics = $LoadFlags

            if ($Log) {
                Write-host "Flags      = $Flags"
                Write-host "SearchPath = $DllCharacteristics"
                Write-host "Function   = LdrLoadDll"
                return
            }

            # parameter [1] Filepath
            $FilePath = [IntPtr]::new($Flags)
            
            # parameter [2] DllCharacteristics
            [Marshal]::WriteInt32(
                $FlagsPtr, $DllCharacteristics)
            
            # parameter [3] UnicodeString
            $stringPtr = Init-NativeString -Value $dll -Encoding Unicode
            
            # Out Results
            #Write-Warning 'Logging only --> LdrLoadDll'
            $null = $Global:ntdll::LdrLoadDll(
                $FilePath,         # Flags
                $FlagsPtr,         # NULL / [REF]Long
                $stringPtr,        # [REF]UnicodeString
                [ref]$HResults     # [Out]Handle
            )
            if ($HResults -ne [IntPtr]::Zero) {
                $dllInfo = [PSCustomObject]@{
                    BaseAddress = $HResults
                    ModuleName  = $dll
                    LoadAsData  = $false
                }
                $global:LoadedModules += $dllInfo
            }
            return $HResults
            # Normal Load -> End
        }
    }
    catch {
    }
    finally {
        $FilePath = $null
        Free-IntPtr -handle $FlagsPtr  -Method Auto
        Free-IntPtr -handle $stringPtr -Method UNICODE_STRING
    }

    return $HResults
}

<#
PEB structure (winternl.h)
https://learn.microsoft.com/en-us/windows/win32/api/winternl/ns-winternl-peb

PEB_LDR_DATA structure (winternl.h)
https://learn.microsoft.com/en-us/windows/win32/api/winternl/ns-winternl-peb_ldr_data

PEB
https://www.geoffchappell.com/studies/windows/km/ntoskrnl/inc/api/pebteb/peb/index.htm

PEB_LDR_DATA
https://www.geoffchappell.com/studies/windows/km/ntoskrnl/inc/api/ntpsapi_x/peb_ldr_data.htm?tx=185

LDR_DATA_TABLE_ENTRY
https://www.geoffchappell.com/studies/windows/km/ntoskrnl/inc/api/ntldr/ldr_data_table_entry/index.htm?tx=179,185

.........................

typedef struct PEB {
  BYTE                          Reserved1[2];
  BYTE                          BeingDebugged;
  BYTE                          Reserved2[1];
  PVOID                         Reserved3[2];
  
  PPEB_LDR_DATA                 Ldr;
  ---> Pointer to PEB_LDR_DATA struct
}

typedef struct PEB_LDR_DATA {
 0x0C, 0x10, LIST_ENTRY InLoadOrderModuleList;
 0x14, 0x20, LIST_ENTRY InMemoryOrderModuleList;
 0x1C, 0x30, LIST_ENTRY InInitializationOrderModuleList;
  ---> Pointer to LIST_ENTRY struct

}

typedef struct LIST_ENTRY {
   struct LDR_DATA_TABLE_ENTRY *Flink;
   ---> Pointer to next _LDR_DATA_TABLE_ENTRY struct
}

typedef struct LDR_DATA_TABLE_ENTRY {
    0x00 0x00 LIST_ENTRY InLoadOrderLinks;
    0x08 0x10 LIST_ENTRY InMemoryOrderLinks;
    0x10 0x20 LIST_ENTRY InInitializationOrderLinks;
    ---> Actual LIST_ENTRY struct, Not Pointer

    ...
    PVOID DllBase;
    PVOID EntryPoint;
    ...
    UNICODE_STRING FullDllName;
}

.........................

** x64 system example **
You don't get Pointer to [LDR_DATA_TABLE_ENTRY] Offset 0x0, it depend
So, you need to consider, [LinkPtr] & [+Data Offset -0x00\0x10\0x20] -> Actual Offset of Data to read

[PEB_LDR_DATA] & 0x10 -> Read Pointer -> \ List Head [LIST_ENTRY]->Flink \ -> [LDR_DATA_TABLE_ENTRY]->[LIST_ENTRY]->0x00 [AKA] InLoadOrderLinks           [& Repeat]
[PEB_LDR_DATA] & 0x20 -> Read Pointer -> \ List Head [LIST_ENTRY]->Flink \ -> [LDR_DATA_TABLE_ENTRY]->[LIST_ENTRY]->0x10 [AKA] InMemoryOrderLinks         [& Repeat]
[PEB_LDR_DATA] & 0x30 -> Read Pointer -> \ List Head [LIST_ENTRY]->Flink \ -> [LDR_DATA_TABLE_ENTRY]->[LIST_ENTRY]->0x20 [AKA] InInitializationOrderLinks [& Repeat]


.........................

- (*PPEB_LDR_DATA)->InMemoryOrderModuleList -> [LIST_ENTRY] head
- each [LIST_ENTRY] contain [*flink], which point to next [LIST_ENTRY]
- [LDR_DATA_TABLE] is also [LIST_ENTRY], first offset 0x0 is [LIST_ENTRY],
  Like this -> (LDR_DATA_TABLE_ENTRY *) = (LIST_ENTRY *)

the result of this is!
[LIST_ENTRY] head, is actually [LIST_ENTRY] And not [LDR_DATA_TABLE]
only used to start the Loop chain, to Read the next [LDR_DATA_TABLE]
and than, read next [LDR_DATA_TABLE] item from [0x0  LIST_ENTRY] InLoadOrderLinks
which is actually [0x0] flink* -> pointer to another [LDR_DATA_TABLE]

C Code ->

LIST_ENTRY* head = &Peb->Ldr->InMemoryOrderModuleList;
LIST_ENTRY* current = head->Flink;

while (current != head) {
    LDR_DATA_TABLE_ENTRY* module = (LDR_DATA_TABLE_ENTRY*)current;
    wprintf(L"Loaded Module: %wZ\n", &module->FullDllName);
    current = current->Flink;
}

Diagram ->

[PEB_LDR_DATA]
 --- InMemoryOrderModuleList (LIST_ENTRY head)
        - Flink
[LDR_DATA_TABLE_ENTRY]
 --- LIST_ENTRY InLoadOrderLinks (offset 0x0)
 --- DllBase, EntryPoint, SizeOfImage, etc.
        - Flink
Another [LDR_DATA_TABLE_ENTRY]

.........................

Managed code ? sure.
[Process]::GetCurrentProcess().Modules

#>
function Read-MemoryValue {
    param (
        [Parameter(Mandatory)]
        [IntPtr]$LinkPtr,

        [Parameter(Mandatory)]
        [int]$Offset,

        [Parameter(Mandatory)]
        [ValidateSet("IntPtr","Int16", "UInt16", "Int32", "UInt32", "UnicodeString")]
        [string]$Type
    )

    # Calculate the actual address to read from:
    $Address = [IntPtr]::Add($LinkPtr, $Offset)

    try {
        switch ($Type) {
            "IntPtr" {
                return [Marshal]::ReadIntPtr($Address)
            }
            "Int16" {
                return [Marshal]::ReadInt16($Address)
            }
            "UInt16" {
                $rawValue = [Marshal]::ReadInt16($Address)
                return [UInt16]($rawValue -band 0xFFFF)
            }
            "Int32" {
                return [Marshal]::ReadInt32($Address)
            }
            "UInt32" {
                return [UInt32]([Marshal]::ReadInt32($Address))
            }
            "UnicodeString" {
                try {
                    $strData = Parse-NativeString -StringPtr $Address -Encoding Unicode | Select-Object -ExpandProperty StringData
                    return $strData
                }
                catch {}
                return $null
            }
        }
    }
    catch {
        Write-Warning "Failed to read memory value at offset 0x$([Convert]::ToString($Offset,16)) (Type: $Type). Error: $_"
        return $null
    }
}
function Get-LoadedModules {
    param (
        [Parameter(Mandatory=$true)]
        [ValidateSet("Load", "Memory", "Init")]
        [string]$SortType = "Memory",

        [Parameter(Mandatory=$false)]
        [IntPtr]$Peb = [IntPtr]::Zero
    )

    Enum PebOffset_x86 {
        ldrOffset = 0x0C
        InLoadOrderModuleList = 0x0C
        InMemoryOrderModuleList = 0x14
        InInitializationOrderModuleList = 0x1C
        InLoadOrderLinks = 0x00
        InMemoryOrderLinks = 0x08
        InInitializationOrderLinks = 0x10
        DllBase = 0x18
        EntryPoint = 0x1C
        SizeOfImage = 0x20
        FullDllName = 0x24
        BaseDllName = 0x2C
        Flags = 0x34
        
        # ObsoleteLoadCount
        LoadCount = 0x38

        LoadReason = 0x94
        ReferenceCount = 0x9C
    }
    Enum PebOffset_x64 {
        ldrOffset = 0x18
        InLoadOrderModuleList = 0x10
        InMemoryOrderModuleList = 0x20
        InInitializationOrderModuleList = 0x30
        InLoadOrderLinks = 0x00
        InMemoryOrderLinks = 0x10
        InInitializationOrderLinks = 0x20
        DllBase = 0x30
        EntryPoint = 0x38
        SizeOfImage = 0x40
        FullDllName = 0x48
        BaseDllName = 0x58
        Flags = 0x68

        # ObsoleteLoadCount
        LoadCount = 0x6C

        LoadReason = 0x010C
        ReferenceCount = 0x0114
    }
    if ([IntPtr]::Size -eq 8) {
        $PebOffset = [PebOffset_x64]
    } else {
        $PebOffset = [PebOffset_x86]
    }

    # Get Peb address pointr
    #$Peb = NtCurrentTeb -Peb
    
    # Get PEB->Ldr address pointr
    #$ldrPtr = [Marshal]::ReadIntPtr(
    #    [IntPtr]::Add($Peb, $PebOffset::ldrOffset.value__))

    $ldrPtr = NtCurrentTeb -Ldr
    if (-not $ldrPtr -or (
        $ldrPtr -eq [IntPtr]::Zero)) {
            throw "PEB->Ldr is null. Cannot continue."
    }

    try {
        
        # Storage to hold module list
        $modules = @()

        # Determine offsets based on sorting type
        switch ($SortType) {
            "Load" {
                $ModuleListOffset   = $PebOffset::InLoadOrderModuleList.value__
                $LinkOffsetInEntry  = $PebOffset::InLoadOrderLinks.value__
            }
            "Memory" {
                $ModuleListOffset   = $PebOffset::InMemoryOrderModuleList.value__
                $LinkOffsetInEntry  = $PebOffset::InMemoryOrderLinks.value__
            }
            "Init" {
                $ModuleListOffset   = $PebOffset::InInitializationOrderModuleList.value__
                $LinkOffsetInEntry  = $PebOffset::InInitializationOrderLinks.value__
            }
        }

        <#
            PEB_LDR_DATA->?*ModuleList --> [LIST_ENTRY] Head
            Results depend on List Type, by user choice.
        #>
        $ListHeadPtr = [IntPtr]::Add($ldrPtr, $ModuleListOffset)

        <#
            *Flink --> First [LDR_DATA_TABLE_ENTRY] -> Offset of:
            InLoadOrderLinks -or InMemoryOrderLinks -or InInitializationOrderLinks
            So, you dont get base address of [LDR_DATA_TABLE_ENTRY], it shifted, depend, result from:

            * InLoadOrderLinks = if ([IntPtr]::Size -eq 8) { 0x00 } else { 0x00 }
            * InMemoryOrderLinks = if ([IntPtr]::Size -eq 8) { 0x10 } else { 0x08 }
            * InInitializationOrderLinks = if ([IntPtr]::Size -eq 8) { 0x20 } else { 0x10 }
        #>
        $NextLinkPtr = [Marshal]::ReadIntPtr($ListHeadPtr)

        <#
           Shift offset, to Fix BaseAddress MAP,
           so, calculate -> NextLinkPtr & (+Offset -StructBaseOffset) == Data Object *Fixed* Offset
           will be used later when call Read-MemoryValue function.
        #>
        $PebOffsetMap = @{}
        foreach ($Name in ("DllBase", "EntryPoint", "SizeOfImage", "FullDllName", "BaseDllName", "Flags", "LoadCount" , "LoadReason", "ReferenceCount")) {
            $PebOffsetMap[$Name] = $PebOffset.GetField($Name).GetRawConstantValue() - $LinkOffsetInEntry
        }

        # Start parse Data

        enum LdrFlagsMap {
            PackagedBinary         = 0x00000001
            MarkedForRemoval       = 0x00000002
            ImageDll               = 0x00000004
            LoadNotificationsSent  = 0x00000008
            TelemetryEntryProcessed= 0x00000010
            ProcessStaticImport    = 0x00000020
            InLegacyLists          = 0x00000040
            InIndexes              = 0x00000080
            ShimDll                = 0x00000100
            InExceptionTable       = 0x00000200
            LoadInProgress         = 0x00001000
            LoadConfigProcessed    = 0x00002000
            EntryProcessed         = 0x00004000
            ProtectDelayLoad       = 0x00008000
            DontCallForThreads     = 0x00040000
            ProcessAttachCalled    = 0x00080000
            ProcessAttachFailed    = 0x00100000
            CorDeferredValidate    = 0x00200000
            CorImage               = 0x00400000
            DontRelocate           = 0x00800000
            CorILOnly              = 0x01000000
            ChpeImage              = 0x02000000
            Redirected             = 0x10000000
            CompatDatabaseProcessed= 0x80000000
        }

        enum LdrLoadReasonMap {
            StaticDependency = 0
            StaticForwarderDependency = 1
            DynamicForwarderDependency = 2
            DelayloadDependency = 3
            DynamicLoad = 4
            AsImageLoad = 5
            AsDataLoad = 6
            EnclavePrimary = 7
            EnclaveDependency = 8
            Unknown = -1
        }

        do {

            $flagsValue = Read-MemoryValue -LinkPtr $NextLinkPtr -Offset $PebOffsetMap['Flags'] -Type UInt32
            $allFlagValues = [Enum]::GetValues([LdrFlagsMap])
            $FlagNames = $allFlagValues | ? {  ($flagsValue -band [int]$_) -ne 0  } | ForEach-Object { $_.ToString() }
            $ReadableFlags = if ($FlagNames.Count -gt 0) {  $FlagNames -join ", "  } else {  "None"  }

            $LoadReasonValue = Read-MemoryValue -LinkPtr $NextLinkPtr -Offset $PebOffsetMap['LoadReason'] -Type UInt32
            try {
                $LoadReasonName = [LdrLoadReasonMap]$LoadReasonValue
            } catch {
                $LoadReasonName = "Unknown ($LoadReasonValue)"
            }

            $modules += [PSCustomObject]@{
                BaseAddress = Read-MemoryValue -LinkPtr $NextLinkPtr -Offset $PebOffsetMap['DllBase']     -Type IntPtr
                EntryPoint  = Read-MemoryValue -LinkPtr $NextLinkPtr -Offset $PebOffsetMap['EntryPoint']  -Type IntPtr
                SizeOfImage = Read-MemoryValue -LinkPtr $NextLinkPtr -Offset $PebOffsetMap['SizeOfImage'] -Type UInt32
                FullDllName = Read-MemoryValue -LinkPtr $NextLinkPtr -Offset $PebOffsetMap['FullDllName'] -Type UnicodeString
                ModuleName  = Read-MemoryValue -LinkPtr $NextLinkPtr -Offset $PebOffsetMap['BaseDllName'] -Type UnicodeString
                Flags       = $ReadableFlags
                LoadReason  = $LoadReasonName
                ReferenceCount = Read-MemoryValue -LinkPtr $NextLinkPtr -Offset $PebOffsetMap['ReferenceCount'] -Type UInt16
                LoadAsData  = $false
            }

            <#
                [LIST_ENTRY], 0x? -> [LIST_ENTRY] ???OrderLinks
                *Flink --> Next [LIST_ENTRY] -> [LDR_DATA_TABLE_ENTRY]
                So, we Read Item Pointer for next [LIST_ENTRY], AKA [LDR_DATA_TABLE_ENTRY]
                but, again, not BaseAddress of [LDR_DATA_TABLE_ENTRY], it depend on user Req.
                [LDR_DATA_TABLE_ENTRY] --> 0x0 -> [LIST_ENTRY], [LIST_ENTRY], [LIST_ENTRY], [Actuall Data]
            #>
			
            $NextLinkPtr = [Marshal]::ReadIntPtr($NextLinkPtr)

        } while ($NextLinkPtr -ne $ListHeadPtr)
    }
    catch {
        Write-Warning "Failed to enumerate modules. Error: $_"
    }

    return $modules
}
function Get-DllHandle {
    [CmdletBinding()]
    param (
        [Parameter(Mandatory=$true)]
        [string]$DllName,

        [Parameter(Mandatory=$false)]
        [ValidateSet("AddReference", "SkipReference", "PinReference", IgnoreCase=$true)]
        [string]$Flags = "SkipReference"
    )

    # Enum declaration
    enum LdrGetDllHandleFlags {
        AddReference   = 0
        SkipReference  = 1
        PinReference   = 2
    }

    $FlagValue = [enum]::Parse([LdrGetDllHandleFlags], $Flags) -as [Int32]
    $StringPtr = Init-NativeString -Value $DllName -Encoding Unicode

    try {
        $DllHandle = [IntPtr]::Zero
        $Ntstatus = $Global:ntdll::LdrGetDllHandleEx(
            $FlagValue, [IntPtr]::Zero, [IntPtr]::Zero, $StringPtr, [Ref]$DllHandle)

        if ($Ntstatus -eq 0) {
            return [IntPtr]$DllHandle
        } elseif ($Ntstatus -eq 3221225781) {
            Write-Warning "DLL module not found: $DllName"
        } else {
            Write-Warning "ERROR ($($Ntstatus)): $(Parse-ErrorMessage -MessageId $Ntstatus -Flags NTSTATUS)"
        }
    }
    finally {
        Free-NativeString -StringPtr $StringPtr | Out-Null
        $DllName = $Ntstatus = $StringPtr = $null
        if ($DllHandle -eq [IntPtr]::Zero) {
            $DllHandle = $null
        }
    }

    return [IntPtr]::Zero
}

    if (!([PSTypeName]'TokenHelper').Type) {
        $tokenHelperCode = @'
using System;
using System.Runtime.InteropServices;
using System.Security.Principal;

public class TokenHelper {
 
   // Token Integrity Constants (RID values)
    private const int TokenIntegrityLevel = 25;
    private const int SECURITY_MANDATORY_UNTRUSTED_RID         = 0x00000000;
    private const int SECURITY_MANDATORY_LOW_RID               = 0x00001000;
    private const int SECURITY_MANDATORY_MEDIUM_RID            = 0x00002000;
    private const int SECURITY_MANDATORY_MEDIUM_PLUS_RID       = 0x00003000;
    private const int SECURITY_MANDATORY_HIGH_RID              = 0x00004000;
    private const int SECURITY_MANDATORY_SYSTEM_RID            = 0x00005000;
    private const int SECURITY_MANDATORY_PROTECTED_PROCESS_RID = 0x00006000;

    [DllImport("ntdll.dll")]
    public static extern int NtQueryInformationToken(IntPtr TokenHandle, int TokenInformationClass, IntPtr TokenInformation, int TokenInformationLength, out int ReturnLength);

    [DllImport("advapi32.dll", SetLastError = true)]
    public static extern bool OpenProcessToken(IntPtr ProcessHandle, uint DesiredAccess, out IntPtr TokenHandle);

    [DllImport("kernel32.dll")]
    public static extern IntPtr GetCurrentProcess();

    // Define NtSetInformationToken signature
    [DllImport("ntdll.dll", SetLastError = true)]
    public static extern int NtSetInformationToken(
        IntPtr TokenHandle,
        Int32 TokenInformationClass,
        IntPtr TokenInformation,
        uint TokenInformationLength
    );

    // Define the SID structure
    [StructLayout(LayoutKind.Sequential)]
    public struct SID
    {
        public byte Revision;
        public byte SubAuthorityCount;
        public SID_IDENTIFIER_AUTHORITY IdentifierAuthority;
        [MarshalAs(UnmanagedType.ByValArray, SizeConst = 8)]
        public int[] SubAuthority;
    }

    // Define the SID_IDENTIFIER_AUTHORITY structure
    [StructLayout(LayoutKind.Sequential)]
    public struct SID_IDENTIFIER_AUTHORITY
    {
        public byte Value0;
        public byte Value1;
        public byte Value2;
        public byte Value3;
        public byte Value4;
        public byte Value5;
    }

    // Define SID_AND_ATTRIBUTES structure
    [StructLayout(LayoutKind.Sequential)]
    public struct SID_AND_ATTRIBUTES
    {
        public IntPtr Sid;
        public uint Attributes;
    }

    // Query the token integrity level
    public static int QueryTokenIntegrityLevel(IntPtr tokenHandle)
    {
        int returnLength = 0;
        int status = NtQueryInformationToken(tokenHandle, TokenIntegrityLevel, IntPtr.Zero, 0, out returnLength);
        IntPtr buffer = Marshal.AllocHGlobal(returnLength);

        try
        {
            status = NtQueryInformationToken(tokenHandle, TokenIntegrityLevel, buffer, returnLength, out returnLength);
            if (status == 0)  // Success
            {
                SID_AND_ATTRIBUTES sid = Marshal.PtrToStructure<SID_AND_ATTRIBUTES>(buffer);
                return RtlxRidSid(sid.Sid);
            }
        }
        finally
        {
            Marshal.FreeHGlobal(buffer);
        }

        return SECURITY_MANDATORY_UNTRUSTED_RID; // Default to Untrusted
    }

    // Extract the integrity level from the SID (last sub-authority)
    static int RtlxRidSid(IntPtr sid)
    {
        int subAuthorityCount = Marshal.ReadByte(sid, 1); // Second byte in SID is SubAuthorityCount
        IntPtr subAuthorityPtr = IntPtr.Add(sid, 2 + Marshal.SizeOf(typeof(SID_IDENTIFIER_AUTHORITY)));
        int lastSubAuthority = Marshal.ReadInt32(IntPtr.Add(subAuthorityPtr, (subAuthorityCount - 1) * sizeof(int)));
        return MapIntegrityLevel(lastSubAuthority);
    }

    // Map sub-authority to integrity level using a traditional switch statement
    static int MapIntegrityLevel(int subAuthority)
    {
        switch (subAuthority)
        {
            case 0x00000000:
                return SECURITY_MANDATORY_UNTRUSTED_RID;  // Untrusted
            case 0x00001000:
                return SECURITY_MANDATORY_LOW_RID;        // Low Integrity
            case 0x00002000:
                return SECURITY_MANDATORY_MEDIUM_RID;     // Medium Integrity
            case 0x00003000:
                return SECURITY_MANDATORY_MEDIUM_PLUS_RID; // Medium High Integrity
            case 0x00004000:
                return SECURITY_MANDATORY_HIGH_RID;       // High Integrity
            case 0x00005000:
                return SECURITY_MANDATORY_SYSTEM_RID;     // System Integrity
            case 0x00006000:
                return SECURITY_MANDATORY_PROTECTED_PROCESS_RID; // Protected Process
            default:
                return SECURITY_MANDATORY_UNTRUSTED_RID;  // Default to Untrusted if unknown
        }
    }

    // Function to create a SID for the integrity level
    public static Int32 CreateIntegritySid(int integrityLevel, ref IntPtr siaPointer)
    {
        IntPtr sidPointer = IntPtr.Zero;

        try
        {
            // Prepare the SID structure
            SID sid = new SID
            {
                Revision = 1,               // SID revision version
                SubAuthorityCount = 1,      // We will use just one sub-authority (integrity level)
                IdentifierAuthority = new SID_IDENTIFIER_AUTHORITY
                {
                    Value0 = 0,
                    Value1 = 0,
                    Value2 = 0,
                    Value3 = 0,
                    Value4 = 0,
                    Value5 = 16             // S-1-16 (Integrity level authority)
                },
                SubAuthority = new int[8]   // Initialize the SubAuthority array with 8 elements
                {
                    integrityLevel,         // First element holds the integrity level (e.g., 0x00002000 for Medium)
                    0, 0, 0, 0, 0, 0, 0     // Pad the rest with 0s
                }
            };

            // Allocate memory for the SID structure
            int sidSize = Marshal.SizeOf(sid);
            sidPointer = Marshal.AllocHGlobal(sidSize);
            Marshal.StructureToPtr(sid, sidPointer, false); // Marshal SID structure to the allocated memory

            // Prepare the SID_AND_ATTRIBUTES structure
            SID_AND_ATTRIBUTES mandatoryLabel = new SID_AND_ATTRIBUTES
            {
                Sid = sidPointer,          // SID pointer
                Attributes = 0x00000040     // SE_GROUP_INTEGRITY_ENABLED (just an example attribute)
            };

            // Allocate memory for the SID_AND_ATTRIBUTES structure
            int siaSize = Marshal.SizeOf(mandatoryLabel);
            siaPointer = Marshal.AllocHGlobal(siaSize);
            Marshal.StructureToPtr(mandatoryLabel, siaPointer, false); // Marshal SID_AND_ATTRIBUTES structure to the allocated memory

            // Return the size of the SID_AND_ATTRIBUTES structure
            return siaSize;
        }
        catch (Exception ex)
        {
            Console.WriteLine("Error: " + ex.Message);
        }

        return 0; // Return 0 in case of failure
    }
}
'@
        Add-Type $tokenHelperCode -Language CSharp -ErrorAction Stop
    }
ENUM SERVICE_STATUS {
    STOPPED = 0x00000001
    START_PENDING = 0x00000002
    STOP_PENDING = 0x00000003
    RUNNING = 0x00000004
    CONTINUE_PENDING = 0x00000005
    PAUSE_PENDING = 0x00000006
    PAUSED = 0x00000007
}
function Query-Process {
    param (
        [int]    $ProcessId,
        [string] $ProcessName,
        [switch] $First
    )

    if ($ProcessId -and $ProcessName) {
        throw "or use none, or 1 option, not both"
    }
        
    $results = @()
    $ProcessHandle = [IntPtr]::Zero
    $NewProcessHandle = [IntPtr]::Zero
    $FilterSearch = $PSBoundParameters.ContainsKey('ProcessName') -or $PSBoundParameters.ContainsKey('ProcessId')

    while (!$global:ntdll::NtGetNextProcess(
            $ProcessHandle, 0x02000000, 0, 0, [ref]$NewProcessHandle)) {
        
        $Procid = 0x0
        $Procname = $null
        $buffer = [IntPtr]::Zero
        $hProcess = $NewProcessHandle

        try {

            # Get Process Info using, NtQueryInformationProcess -> 0x0 -> PROCESS_BASIC_INFORMATION
            # https://crashpad.chromium.org/doxygen/structcrashpad_1_1process__types_1_1PROCESS__BASIC__INFORMATION.html
            # x64 padding, should be 8, x86 padding should be 4, So, 32 At x64, and 16 on x86

            $retLen = 0
            $size = if ([IntPtr]::Size -gt 4) {0x30} else {0x18}
            $pbiPtr = New-IntPtr -Size $size
            $status = $global:ntdll::NtQueryInformationProcess(
                $hProcess,0,$pbiPtr,[uint32]$size, [ref]$retLen)
            if ($status -eq 0) {
                # ~~~~~~~~
                $pebOffset = if ([IntPtr]::Size -eq 8) {8} else {4}
                $Peb = [Marshal]::ReadIntPtr($pbiPtr, $pebOffset)
                # ~~~~~~~~
                $pidoffset = if ([IntPtr]::Size -eq 8) {32} else {16}
                $pidPtr = [Marshal]::ReadIntPtr($pbiPtr, $pidoffset)
                $Procid = if ([IntPtr]::Size -eq 8) { $pidPtr.ToInt64() } else { $pidPtr.ToInt32() }
                # ~~~~~~~~
                $inheritOffset = if ([IntPtr]::Size -eq 8) {40} else {20}
                $inheritPtr = [Marshal]::ReadIntPtr($pbiPtr, $inheritOffset)
                $InheritedPid = if ([IntPtr]::Size -eq 8) { $inheritPtr.ToInt64() } else { $inheritPtr.ToInt32() }
                # ~~~~~~~~
            }

            # Get Process Name using, NtQueryInformationProcess -> 0x1b
            # .. should be large enough to hold a UNICODE_STRING structure as well as the string itself.

            $bufSize, $retLen = 1024, 0
            $buffer = New-IntPtr -Size $bufSize
            $status = $global:ntdll::NtQueryInformationProcess(
                $hProcess,27, $buffer, $bufSize,[ref]$retLen)
            if ($status -eq 0) {
                $Procname = Parse-NativeString -StringPtr $buffer -Encoding Unicode | select -ExpandProperty StringData
            }
        }
        finally {
            Free-IntPtr -handle $pbiPtr
            Free-IntPtr -handle $buffer
        }

        $ProcObj = [PSCustomObject]@{
                PebBaseAddress = $Peb
                UniqueProcessId   = $procId
                InheritedFromUniqueProcessId = $InheritedPid
                ImageFileName = $procName
            }

        if ($FilterSearch) {
            $match = $false

            if ($PSBoundParameters.ContainsKey('ProcessId') -and $procId -eq $ProcessId) {
                $match = $true
            }
            if ($PSBoundParameters.ContainsKey('ProcessName')) {
                $filterName = if ($ProcessName -like '*.exe') { $ProcessName } else { "$ProcessName.exe" }
                $fullname = $procName.ToLower()
                $LiteName = $filterName.ToLower()
                if ($fullname.EndsWith($LiteName)) {
                    $match = $true
                }
            }

            if ($match) {
                $results += $ProcObj
                if ($First) {
                    break
                }
            }
        } else {
            $results += $ProcObj
        }
        Free-IntPtr -handle $ProcessHandle -Method NtHandle
        $ProcessHandle = $NewProcessHandle
        $hProcess = $null
    }
    
    # free the last object
    Free-IntPtr -handle $ProcessHandle -Method NtHandle

    return $results
}
function Lsa-UpdateInfo {
    param (
        [IntPtr]$StructPtr,      # Pointer to MSV1_0_INTERACTIVE_LOGON
        [int]$Index,             # 0=Domain, 1=UserName, 2=Password
        [string]$Value,          # The string to write
        [ref]$StringPtr,         # [ref] pointer that moves forward
        [pscustomobject]$OffsetMap
    )

    if ([string]::IsNullOrEmpty($Value)) {
        $unicodePtr = Init-NativeString -Encoding Unicode
    } else {
        $unicodePtr = Init-NativeString -Value $Value -Encoding Unicode
    }

    # Offset to the UNICODE_STRING field in the struct
    $fieldOffset = [IntPtr]::Add($StructPtr, ($OffsetMap.Base + ($OffsetMap.BlockSize * $Index)))

    # Copy UNICODE_STRING struct (Length, MaxLength, Buffer) into structure
    $ntdll::RtlMoveMemory($fieldOffset, $unicodePtr, [UIntPtr]::new($OffsetMap.BlockSize))

    # Get the actual string buffer from unicodePtr (UNICODE_STRING.Buffer)
    $buffer = [Marshal]::ReadIntPtr($unicodePtr, [IntPtr]::Size)

    # Copy the actual string data into the stringPtr buffer
    $ntdll::RtlMoveMemory(
        $StringPtr.Value,
        $buffer,
        [UIntPtr]::new((($Value.Length + 1) * 2))
    )

    # Write pointer to actual string into UNICODE_STRING.Buffer
    [Marshal]::WriteIntPtr($fieldOffset, [IntPtr]::Size, $StringPtr.Value)

    # Advance the string pointer
    $StringPtr.Value = [IntPtr]::Add($StringPtr.Value, (($Value.Length + 1) * 2))

    # Clean up native string
    Free-NativeString -StringPtr $unicodePtr
}
Function Lsa-LogonUser {
    param (
        [ValidateNotNullOrEmpty()]
        [string]$UserName,
        [string]$Password = "",
        [string]$Domain = ".",
        [Int32]$LogonType = 0x02,
        [Switch]$Logging
    )

    try {
        $Module = [AppDomain]::CurrentDomain.GetAssemblies()| ? { $_.ManifestModule.ScopeName -eq "LSA" } | select -Last 1
        $LSA = $Module.GetTypes()[0]
    }
    catch {
        $Module = [AppDomain]::CurrentDomain.DefineDynamicAssembly("null", 1).DefineDynamicModule("LSA", $False).DefineType("null")
        @(
            @('null', 'null', [int], @()), # place holder
            @('RtlAllocateHeap',                'NTDLL.dll', [IntPtr],  @([IntPtr], [Int32], [UIntPtr])),
            @('NtAllocateLocallyUniqueId',      'NTDLL.dll', [int32], @([Int64].MakeByRefType())),
            @('LsaConnectUntrusted',            'SSPICLI.dll',  [int32], @([IntPtr].MakeByRefType())),
            @('LsaDeregisterLogonProcess',      'SSPICLI.dll',  [int32], @([IntPtr])),
            @('LsaLookupAuthenticationPackage', 'SSPICLI.dll',  [int32], @([IntPtr],[IntPtr], [UInt32].MakeByRefType()))
        ) | % {
            $Module.DefinePInvokeMethod(($_[0]), ($_[1]), 22, 1, [Type]($_[2]), [Type[]]($_[3]), 1, 3).SetImplementationFlags(128) # Def` 128, fail-safe 0 
        }
        $LSA = $Module.CreateType()
    }

    $AuthPackageMapping = [PSObject]@{
        MSV1_0_PACKAGE_NAME       = 'MICROSOFT_AUTHENTICATION_PACKAGE_V1_0'
        MICROSOFT_KERBEROS_NAME_A = 'Kerberos'
        NEGOSSP_NAME_A            = 'Negotiate'
        NTLMSP_NAME_A             = 'NTLM'
    }
    
    # Handle from LSA
    $hLsa = [IntPtr]::Zero;
    $LSA::LsaConnectUntrusted([ref]$hLsa) | Out-Null
    if ($LsaHandle -eq [IntPtr]::Zero) {
        Write-warning 'LsaConnectUntrusted failed'
        return [IntPtr]::Zero;
    }
        
    try {
        # [Second] parameter
        $originName = Init-NativeString -Value "LocalApp" -Encoding Ansi

        # [Third] parameter
        [UInt32]$authPackageId = 0

        $packageName = Init-NativeString -Value $AuthPackageMapping.NEGOSSP_NAME_A -Encoding Ansi
        #$packageName = Init-NativeString -Value $AuthPackageMapping.MSV1_0_PACKAGE_NAME -Encoding Ansi
        $status = $LSA::LsaLookupAuthenticationPackage(
            $hLsa, $packageName, [ref]$authPackageId)

        if ($status -ne 0) {
            $StatusError = Parse-ErrorMessage -MessageId $status -Flags NTSTATUS
            Write-warning "LsaLookupAuthenticationPackage failed with Code Error:"
            Write-warning "$StatusError"
            return [IntPtr]::Zero;
        }

        $offsetMap = [PSCustomObject ]@{
            Base       = [IntPtr]::Size
            BlockSize  = if ([IntPtr]::Size -gt 4) { 0x10 } else { 0x08 }
            Length     = if ([IntPtr]::Size -gt 4) { 0x38 } else { 0x1C }
        }
        
        $heap = (NtCurrentTeb -ProcessHeap)
        $authInfo = $LSA::RtlAllocateHeap(
            [IntPtr]$heap,
            0x00000008,
            [UIntPtr]::new(1024)
        )
        if (!$authInfo -or $authInfo -eq [IntPtr]::Zero) {
            Write-warning 'HeapAlloc failed.'
            return [IntPtr]::Zero;
        } else {
            $stringMap = [IntPtr]::Add($authInfo, $offsetMap.Length)
        }

        # MSV1_0_LOGON_SUBMIT_TYPE MessageType;
        $MsV1_0InteractiveLogon = 0x02
        [marshal]::WriteInt32($authInfo, 0x00, $MsV1_0InteractiveLogon)
        # Domain, User, Password
        Lsa-UpdateInfo -StructPtr $authInfo -Index 0 -Value $Domain   -StringPtr ([ref]$stringMap) -OffsetMap $offsetMap
        Lsa-UpdateInfo -StructPtr $authInfo -Index 1 -Value $Username -StringPtr ([ref]$stringMap) -OffsetMap $offsetMap
        Lsa-UpdateInfo -StructPtr $authInfo -Index 2 -Value $Password -StringPtr ([ref]$stringMap) -OffsetMap $offsetMap

        ($Domain, $Username, $Password) |  % `
            -Begin {
                $authInfoSize = $offsetMap.Length
            } `
            -Process {
                if ($_.Length -ge 0) {
                    $authInfoSize += (($_.Length+1)*2)
            }} `
            -End {
                # just to make sure.
                $authInfoSize += 0x02
            }

        $heap = (NtCurrentTeb -ProcessHeap)
        $tokenSource = $LSA::RtlAllocateHeap(
            [IntPtr]$heap,
            0x00000008,
            [UIntPtr]::new(16)
        )
        $sourceName = [System.Text.Encoding]::ASCII.GetBytes("UserLog0")
        [Int64]$Luid = 0; $status = $LSA::NtAllocateLocallyUniqueId([ref]$Luid)
        [Marshal]::Copy($sourceName, 0, $tokenSource, $sourceName.Length)
        [Marshal]::WriteInt64($tokenSource, 0x08, $Luid)

        # Buffer Allocations
        $Buffer       = New-IntPtr -Size ([IntPtr]::Size)
        $BufferLength = New-IntPtr -Size ([IntPtr]::Size)
        $hLogonId     = New-IntPtr -Size ([IntPtr]::Size)
        $Token        = New-IntPtr -Size ([IntPtr]::Size)
        $hQuotas      = New-IntPtr -Size (([IntPtr]::Size)*6)
        $hSubStatus   = New-IntPtr -Size ([IntPtr]::Size)

        $Status = Invoke-UnmanagedMethod SSPICLI.dll LsaLogonUser -Values @(
            $hLsa, $originName, $LogonType,            # 1-3
            $authPackageId, $authInfo, $authInfoSize,  # 4-6
            [IntPtr]::Zero, $tokenSource,              # 7-8
            $Buffer,                                   # 9. ProfileBuffer
            $BufferLength,                             # 10. ProfileBufferLength
            $hLogonId,                                 # 11. LogonId
            $Token,                                    # 12. Token (Correct)
            $hQuotas,                                  # 13. Quotas
            $hSubStatus                                # 14. SubStatus
        )

        if ($Logging) {
            Write-Host "`n=== DEBUG: Variables passed to LsaLogonUser ===" -ForegroundColor Cyan
            Write-Host "`n[authInfo]" -ForegroundColor Yellow
            Write-Host "Pointer: $authInfo"
            Write-Host "Size: $authInfoSize"

            For ($i = 0; $i -lt 3; $i++) {
                $offset = [IntPtr]::Add($authInfo, $offsetMap.Base + ($i * $offsetMap.BlockSize))
                $length     = [Marshal]::ReadInt16($offset, 0)
                $maxLength  = [Marshal]::ReadInt16($offset, 2)
                $bufferPtr  = [Marshal]::ReadIntPtr($offset, [IntPtr]::Size)
                $bufferStr  = [Marshal]::PtrToStringUni($bufferPtr)
                Write-Host "Field [$i] | Length: $length, MaxLength: $maxLength, Ptr: $bufferPtr, Value: '$bufferStr'" -ForegroundColor Green
            }

            Write-Host "`n[originName]" -ForegroundColor Yellow
            $originBufferPtr = [Marshal]::ReadIntPtr($originName, [IntPtr]::Size)  # Offset to Buffer field
            $originNameStr = [System.Runtime.InteropServices.Marshal]::PtrToStringAnsi($originBufferPtr)
            Write-Host "Pointer: $originName"
            Write-Host "Buffer: $originBufferPtr"
            Write-Host "Value: $originNameStr"

            Write-Host "`n[Authentication Package]" -ForegroundColor Yellow
            Write-Host "ID: $authPackageId"

            Write-Host "`n[Token Source]" -ForegroundColor Yellow
            $sourceBytes = New-Object byte[] 8
            [System.Runtime.InteropServices.Marshal]::Copy($tokenSource, $sourceBytes, 0, 8)
            $sourceNameStr = [System.Text.Encoding]::ASCII.GetString($sourceBytes)
            $luid = [System.Runtime.InteropServices.Marshal]::ReadInt64($tokenSource, 8)
            Write-Host "Ptr: $tokenSource"
            Write-Host "Name: $sourceNameStr"
            Write-Host "LUID: $luid"
            Write-Host "`n=========================================================`n" -ForegroundColor Cyan
            return
        }

        if ($Status -ne 0x00) {
            $NtStatusMSG = Parse-ErrorMessage -MessageId $Status -Flags NTSTATUS
            Write-Warning "LsaLogonUser return with error code:"
            Write-Warning "$NtStatusMSG"
            return [IntPtr]::Zero
        }

        $hToken = [Marshal]::ReadIntPtr($token)
        return $hToken
    }
    finally {
        $LSA::LsaDeregisterLogonProcess($hLsa) | Out-Null
        Free-IntPtr -handle $originName   -Method STRING
        Free-IntPtr -handle $packageName  -Method STRING
        Free-IntPtr -handle $authInfo     -Method Heap
        Free-IntPtr -handle $tokenSource  -Method Heap
        Free-IntPtr -handle $Buffer       -Method Auto
        Free-IntPtr -handle $BufferLength -Method Auto
        Free-IntPtr -handle $hLogonId     -Method Auto
        Free-IntPtr -handle $Token        -Method Auto
        Free-IntPtr -handle $hQuotas      -Method Auto
        Free-IntPtr -handle $hSubStatus   -Method Auto
    }
}
Function Obtain-UserToken {
    param (
        [ValidateNotNullOrEmpty()]
        [String] $UserName,

        [String] $Password,
        [String] $Domain,

        [Int32]  $LogonType = 0x02,
        [Int32]  $TokenType = 0x01,

        [ValidateSet("LogonUserExExW", "LsaLogonUser")]
        [String] $Method = "LogonUserExExW",

        [switch] $LoadProfile
    )

    try {
        $Module = [AppDomain]::CurrentDomain.GetAssemblies()| ? { $_.ManifestModule.ScopeName -eq "USER" } | select -Last 1
        $USER = $Module.GetTypes()[0]
    }
    catch {
        $Module = [AppDomain]::CurrentDomain.DefineDynamicAssembly("null", 1).DefineDynamicModule("USER", $False).DefineType("null")
        @(
            @('null', 'null', [int], @()), # place holder
            @('NtDuplicateToken', 'ntdll.dll',   [int32], @([IntPtr], [Int], [IntPtr], [Int], [Int], [IntPtr].MakeByRefType())),
            @('LoadUserProfileW', 'Userenv.dll', [bool],  @([IntPtr], [IntPtr])),
            @('LogonUserExExW',   'sspicli.dll', [bool],  @([IntPtr], [IntPtr], [IntPtr], [Int], [Int], [IntPtr], [IntPtr].MakeByRefType(), [IntPtr], [IntPtr], [IntPtr], [IntPtr]))
        ) | % {
            $Module.DefinePInvokeMethod(($_[0]), ($_[1]), 22, 1, [Type]($_[2]), [Type[]]($_[3]), 1, 3).SetImplementationFlags(128) # Def` 128, fail-safe 0 
        }
        $USER = $Module.CreateType()
    }

    $phToken = [IntPtr]::Zero
    $UserNamePtr = [Marshal]::StringToHGlobalUni($UserName)
    $PasswordPtr = if ([string]::IsNullOrEmpty($Password)) { [IntPtr]::Zero } else { [Marshal]::StringToHGlobalUni($Password) }
    $DomainPtr = if ([string]::IsNullOrEmpty($Domain)) { [IntPtr]::Zero } else { [Marshal]::StringToHGlobalUni($Domain) }

    try {

        <#
          LogonUser --> LogonUserExExW
          A handle to the primary token that represents a user
          The handle must have the TOKEN_QUERY, TOKEN_DUPLICATE, and TOKEN_ASSIGN_PRIMARY access rights
          For more information, see Access Rights for Access-Token Objects
          The user represented by the token must have read and execute access to the application
          specified by the lpApplicationName or the lpCommandLine parameter.
        #>
        if ($Method -eq "LogonUserExExW") {
            if (!(Invoke-UnmanagedMethod `
                -Dll sspicli `
                -Function LogonUserExExW `
                -CallingConvention StdCall `
                -CharSet Unicode `
                -Return bool `
                -Values @(
                    $UserNamePtr, $DomainPtr, $PasswordPtr,
                    $LogonType, # 0x02, 0x03, 0x07, 0x08
                    0x00,       # LOGON32_PROVIDER_DEFAULT
                    [IntPtr]0, ([ref]$phToken), [IntPtr]0,
                    [IntPtr]0, [IntPtr]0, [IntPtr]0))) {
                        throw "LogonUserExExW Failure .!"
                    }
            
            # according to MS article, this is primary Token
            # we can return this --> $phToken, Directly.!
            # return $phToken
        } 
        elseif ($Method -eq "LsaLogonUser") {           
            [Intptr]$phToken = Lsa-LogonUser -UserName $UserName -Password $Password -Domain $Domain -LogonType $LogonType
            if (!(IsValid-IntPtr $phToken)) {
                throw "LsaLogonUser Failure .!"
            }
        }

        # Duplicate token to Primary
        $hToken = [IntPtr]0
        
        $ret = $USER::NtDuplicateToken(
            $phToken,      # [in] Existing Token Handle
            0xF01FF,       # [in] DesiredAccess (TOKEN_ALL_ACCESS)
            [IntPtr]0,     # [in] ObjectAttributes (NULL)
            0x00,          # [in] BOOLEAN EffectiveOnly (FALSE)
            0x01,          # [in] TOKEN_TYPE (TokenPrimary)
            ([ref]$hToken) # [out] New Token Handle
        )

        if ($ret -ne 0) {
            $MinimumFlags = 0x0002 -bor 0x0004 -and 0x0008
            $ret = $USER::NtDuplicateToken(
                $phToken,        # [in] Existing Token Handle
                $MinimumFlags,   # [in] DesiredAccess (TOKEN_ALL_ACCESS)
                [IntPtr]0,       # [in] ObjectAttributes (NULL)
                0x00,            # [in] BOOLEAN EffectiveOnly (FALSE)
                0x01,            # [in] TOKEN_TYPE (TokenPrimary)
                ([ref]$hToken)   # [out] New Token Handle
            )

            if ($ret -ne 0) {
                #Free-IntPtr -handle $hToken -Method NtHandle
                $hToken = [IntPtr]$phToken
                $retMsg = Parse-ErrorMessage -MessageId $ret -Flags NTSTATUS
                
                Write-Host
                Write-Warning "Failed to Call NtDuplicateToken."
                Write-Warning $retMsg
            }
        }

        if (!$LoadProfile) {
            if ($phToken -ne $hToken) {
              Free-IntPtr -handle $phToken -Method NtHandle
            }
            return $hToken
        }

        $dwSize = if ([IntPtr]::Size -gt 4) { 0x38 } else { 0x20 }
        $lpProfileInfo = New-IntPtr -Size $dwSize -WriteSizeAtZero
        $lpUserName = [Marshal]::StringToCoTaskMemUni($UserName)
        [Marshal]::WriteIntPtr($lpProfileInfo, 0x08, $lpUserName)
        if (!($USER::LoadUserProfileW($hToken, $lpProfileInfo))) {
                throw "Failed to Load User profile."
            }

        Free-IntPtr -handle $sessionIdPtr
        if ($phToken -ne $hToken) {
          Free-IntPtr -handle $phToken -Method NtHandle
        }
        return $hToken
    }
    finally {
        ($lpProfileInfo, $lpUserName) | % { Free-IntPtr $_ }
        ($UserNamePtr, $PasswordPtr, $DomainPtr) | % { Free-IntPtr $_ }
    }
}
Function Process-UserToken {
    param (
        [PSObject]$Params = $null,
        [IntPtr]$hToken = [IntPtr]0,
        [switch]$UseCurrent
    )

        <#
    try {
        # Set the path to the DLL file
        $dllPath = "C:\temp\dacl.dll"
    
        # Read the DLL file bytes
        $dllBytes = [System.IO.File]::ReadAllBytes($dllPath)
    
        # Create a MemoryStream to write the compressed data
        $memoryStream = New-Object System.IO.MemoryStream
        $gzipStream = New-Object System.IO.Compression.GZipStream($memoryStream, [System.IO.Compression.CompressionMode]::Compress)
    
        # Write the DLL bytes into the GZipStream for compression
        $gzipStream.Write($dllBytes, 0, $dllBytes.Length)
        $gzipStream.Close()  # Close the GZipStream to finish compression

        # Get the compressed bytes from the MemoryStream
        $compressedBytes = $memoryStream.ToArray()
    
        # Convert the compressed bytes to a Base64 string
        $base64String = [Convert]::ToBase64String($compressedBytes)

        # Save the Base64 string to a text file on the Desktop
        $desktopPath = [System.Environment]::GetFolderPath('Desktop')
        $base64FilePath = Join-Path $desktopPath "dacl_compressed_base64.txt"
    
        Set-Content -Path $base64FilePath -Value $base64String

        Write-Host "Base64 compressed string saved to $base64FilePath"
    }
    catch {
        Write-Host "Error: $_"
    }
    #>

try {
  if (!([Io.file]::Exists("c:\temp\dacl.dll"))) {
$base64String = @'
H4sIAAAAAAAEAO07DXhTVZY3adKmhZIATSkFJUiwBadM2xTsD0giCb5qqpW2WhVIQ/pKA2mSSV6goK5lQh3DIyMz6+w6M447Oui4880q/sxQKrOmFGkrMBZkR5BxqA6jqUWnOK6Af2/PufelTQt847ffOrvzre/ry7n33HPOPffec849973Xqjt3kBRCiApuSSKkg7DLTL7EpSBk0qzOSeSF9MOzOxT2w7Nrm91Bgz/gWxtwthhcTq/XJxjW8IZAyGtwew3WW2oMLb5GfkFmZoZRFvGZU53RQdbfkbifbT1/x16ASyPr6jspbK5/kUJf/S4KvfXPAzy0ZV39S5Rn3R1tAOdF1lD6eZH19XsofOgOBt20vsLtakb544dQbSOk8f5U8p+3f9CcwA2TqwwTlJO+QXKhIiu6cyb86GixTUHkspKQVJknAckOeTJpc4MiwZQAF9dZsbqCkI8AWhcTsh2RfkLOI2yAojJJ4TZCvoE8CynJZa9+E6yhIglRSMguxWXJyQKBbxUAPpwjK5Q7Oo7EZQBtFgQanYKTkDemMJkkC+4rx9KZ4W8BIyNtODHVhM4VKb6ILrbAzwjpGBvkPksuIS8QDLiIPCd+WV7ppeh4j8/F5gjnitKVX0R3/eVn4v/XxUXV7uWEdB+SLy5iN2q4SK1RZ49YjTl2qBpqbrudC58p5MQLXFQw1u9BM5L0a2YDt3g83ilJks3Ux0UEo8Eu9nDia5yokfQV2BzeX+hYfdeIcLg6kDkJYa4D6ZZaS53lNsvtXNRjHOS2nHkYFRPVDUsBmPZzEZvEibb7TBKUnqkUz3JRWw8XqdttEwc4UNLAiW9wkaqXQIke2ym0H5spxkXufZ2L1p2K3NtjF89axT9bRUnSX20gpD0WWi3pX5hFSPj8Zm37MjAQcVWPpN8GGKvY3amhnfdK+i2AsItxrj2m3XqFEhurerDrKvFl1i2IrxR/K+n7Z6FU7daDCuRctdserfq0Ujxsj9pQhXOS/tSVjOAJSlD1Oqpne5frsQ3Rztr7hCste5R0NeretXRMpPP7nMzkp0wHJf2tgAjHNBbtM/tTbEMR26vicUl/7MpxWh+8ErUeplovBFax7lVLhzLR2iILTYOWsnvPCStF27vtMaFOPKWd1UbtAdQDxV+FVYzc+6qknykz/I6g2KpXO1GUpQPWXIKxW7S7LUqcC0k/dAUj/DdUvrti1buBF8RTtvbTwnWwds9w1xzAxWvaAfJ3UxlWcWKqVUxFezPQWXycChD8SC51c+EDKkvF7wOgwllooOOzdOQnxvGnK1Cd8zBKYemLCoYVX5P0dUzINWALVeIB8bVKEQSUMmQ29P0SLlqVCMs9lQ3M9qmk3wHtQG06SkVvxlr7+0KWpN9IG16WG5y0QcKG1bShR27goIaGXyVxpkPxXIh43Jb9aMMWh2W1ZZVlJfjAqu6L7J0Tz4CttzFbFxYnbH0Y7bxql118D1YgBgbXEbm3A9Tup0ZHjbxfNnKr+K54Dsxb0lfRIYbulPQnZ8qGPZ8adoekf3bmOBN5aiZO3gA1ERUz7A7sp0rcnzDsfrok52ayNX0OZhiMOm6P7DX2oyFEbbFK8RDQHZP0SpkIt8Wy0DHt1gCz8hjYtXYrD5Wmsm+ptFvvghIYfrTuuGzrEdtxZusR24Ck757BxJQpUKHQ7yX9BcDYxAOjeg/PSCy6dusUBdoDNUbxd7T1+7KANwnVQ9go2o6jPaFpm4l21lYi23cM1O+l9g1ci2WunzP77rWUFoX0ldFbNeDAkv7jXDqtc2kL2nqS+eNMUfM6S4mEZrT644FHJb15xsUGWzIDC8MXGezO3CSD7cHYCfP+ndwRg92Fi2EXD0C8nTFisKdyk82vD2pD6pcUdARsgarA78BMd1O6/TLdY7kYaz7GhkdzkTZh8Q/kyvY7jPZ7Zwq1X7TLi6wX9ofwmVJY2B6r0RwDK+R6YjgXUK2ms6u1ddmjdmM1Bz9mCw321MOhn/jkTyQJdoTS5O2AyYsCO4qQFFqC7PXUDBk74OtRdPzohUuwj+UHsuFkfiXjr70vhcmZwOor0X3i376kPHMd7nXN4JFvl8oeCUM1vY/bWwN2VGiP3GOstoufRDzGwk5myB5jKd0BqX/GOPGs+DnE7xxqO0aID9OpSwrTJf0SKIr9XDTzNMx5/MHzkjS4A90l8ogRE0dxpbFQ0pPp4xz2XA4W0PBDIONCjixDAxYRvwllWKnT2I2FTENYTNSFaYcGdTXTBZj3JphTkHkSMuNeIL5phwHWl83S3v8BZbIbcZmFVLA75PgLF60FTNc7Ki7lHCfeDBv8K9OQDrHRzCtRWNc5SRKX6+YCf2wJ/gjToMmBTU9CE7jHrMCTgw9S8ShgyzRUeljS63LGOXoaICojaTjebEmfnlA5B+fsLhA1tMIuLtdwYr8FB/e9aXRwBeAX02RKtO940Tnco2ZJ+l3T0Nq7ZWv/EdSGJgPRs0g0EYh+w1wHxs+JbB3o+O0iLDQn4rqzmajHEbMNYBUVmfDAG7Dfl5HJjB6EKTRYVrNjxG2amkbiT0VmZBEhIR3X1aVrOtclSSFFN9fVpxvcBkZK7Tm//ahQFn5PIeTjT3b4E4WQwTwpvD+/O35jKrp7fAYA7a9jFFcJgwY4qKWuH9P+oItWc6hlrcR8TjDqOLBbA+w64TPgjR/CrmHqi3eCkK0Q/XrRISxqQrYdfwDM3bxbEV5yAU4kRNv+MvqMerCCnvZIfLsaOYRb4g+mQ+234Enx9zEORPXP4exEM38GIP70RLok8+LzGDlsKfpvs/Ygtj8wEYU+VMHSc3OxtO1g/LtpUNoqhZbGj6XRzJILlxLBiJHjJFVTyIGQRW0aNidOTLGLmV9kQ5CSjkjqX8FxiM7RkBIdENwIF66UgyXkYC4MltXde9Ko/vC7g+a5MC80rTVvuyCqQwtR4fsyGbOZJq7dUm9EvRIa4nkqeWYM4SVvw2FCGVoUr4CRxf+QgnavwcH0yIcMGMl+UNd01Lzt1fgf6CIdj18HxGL30M+YDhrUAZTgcL+tN9gj5pxINawPp4HUABfIXCkOi5/AErUfDWnL9MfhPHRfmik2+Cfgjl4vhc8rNpohQvmz0R5jIXW0XjEEDjWsh16Ow8AK209qtz5NjfqA+DrMVvyJz8E3j0NQKMTN7h+Tm9Z9lGgKS4rQIpBXTLcGbLsZ2mDLAIOKH/wCiqL6Mz3tU5iUoJH0mwAFXqEOSymhxSNiTUk9CnOBc58+SVtdgk7Sl49oPZRqOolQ7MZFaIVFMFtWO1Z3j9owLhhsuuch4RfPgmOE1PEfK6gn0p0zaeFhzR2DPwadMabXMKM/YeqT9M9PldPpwFTMsl+g1d7OdBVBXzLcxUlzn5rKdi0Nbi57ptFs/JGpdEtOo6nL4XlgyB/CCTv+rzRYWKHDiPpECRo4liFLh7q7hGZ2+xBE1CYTozRD+doStJhMwGC3Peo0E/OuHvVkudRBY+H6GHpMOnL2qBTKMXgx01JM1VQZEkgFID0JJDDWw9k8LsEc7GD7nJkd5MB0Tkj6FDrw5/E8bZJw14IA30A3C/cUtsSLMbo34E7ezMGuSQ/bdrEXZwa2mAPY4MdKPm59K/EMkAecUk9YUt7zNC4eHv2wJacOU116glRvLwLhLxY/fqrgh9dgNOwObeSiVTo4C9EHIpLehb2LNh1mwpLeBjUxxhVheR4rR6tyWH0y1m05gBjmugYMnAnKJhvkMF3cHoleIGkOVEyjvXFaaxcsQCpqAcZSzZ3rx/UoYmdViNcwbYMQn8EKjk6m8TiaeQLqg6+k0bPym1Duxhgd7x7G9EFjjL8j0YKSRmIav+PfSaPGMpvnRNXcQmoinGZIzVX0Clmm2DCnfTZzJ24CHxSz+L1LMXSO5TL58ZsYb1r8FxB0hqbHD0I/EAKbGVpVHBtKizvT8GEOZUUeCOQFChrIf8DkJWTVpCE2hExT4stZJS2+BApDZ5L449cAJn71qNBEfMTMRoeOlyM73gUMTOB7g/GdqTTCZ4c/VYQmy6nkYQ4PVusms7ygXsQ8kHmkB0OxQOMquOU/4QkJ+3VQIYIOJnnnQra/DX4PcPFHmXR1PJIqb3vyOLfI9cFWWUZ7XyjtgHoVcCvirRiNHakjY86Kr2CVdOC8AbfN90YGyGJC2xLjQky7ToTWhi8oNq6LH1ZTjfLbT4aMoNUkjP4XKC6EWmZjfZDRLIAeTE1anzodBxzulf6ivU/9JnP2dwBg9R1W/TOAA+o98KugChju6t6jxp3gCyLv+bC1dXVU3YlnJbX7D5AUtHKuzEegABvnHQhSXtlShs8qQ46OCUoks+SEau3X7NPuvjWLC+/L4VKOwPkklYtObLNHJ77CRbKMlRVHhBzxxon2iq5Ahni9JqXLXhELQFDblz90CtYLNhc6S+HNRnIvljLADlMBKqlZ5nSzOdp2Ir5bhRsajHnC1pOhNO47+ndMdBlgHIl5PGnCve+EoNp6NDQx/oaKboSvqWSTMtBnQOA/apiD7h712ya2WXYzO6vjor80mj+FYW45E8Ot8oQcda+exKxePHh43h58TB3H4wboDj5v6cBjcPxamn1UQTwomoSG95M4fY7yg+MqGuchskn6f85kEW0pJzJ8NDpADy8XRbVuaIqrWPjPp5EFTy+4b9yEMsT2XsqOlh1px55QF4q0dNCnVjT0tz+Aqv4kZZQD9sEGPKHAXmfGEwl7hObIxK0PwiceYOhBA47hw1jgJH1GJuvJLOl7WDqVCc4maKJcSryTbsaPGPvV9KyGc7aqezSngeB/xWtZyL7kEIChKZAt4fghhz2EUsPdGq7iVGCQeSf6ZPcY3p8z3p+O491xGd59YMTIr8N4kUMfBKIknSlm6tM+vuWsV+A9Wz50e/nKCUfEOE3TtvzlBt4bmvBalJO0j4sXQqvnDi+VtFyPuhfiND63heLL1+ArCUlaEktVECF/SUOqkgizl/gR5Kp3XfgMEiHDRiO3R0EUdNPktD/rCmZZRfWDEM8t4V6FNaLeCsWhNMDdXYSPTPos4lmbeMQmngh/nnaP2RK1pKGO4odW8aC284/pwQnApwQ+exGe2RT3ZHZgyhblPtE+bhWPduDbgIr4PZTJKp6EDW0CbizhgS961OprEru4NJ8ltuD6Z6Co7Xw3KzgLiP7cox4YbToyH2lfm89eHgDRDG3YhA9J+rSKfq7rbQM3oR+fxBqgaaY2/JmcahiMqYtTte3vY9xS/xC4nxsI92p61PdDEV0Exgwly8ddBmFNuNfQo26Bqpo2rIfSHqDqB71roGyd0wdafQ662LBW0Re6lvZw1b7yfSHM2RYAOpxpgl8I3QMne9SzZW2BZcp8nFkgSqdDfGdacCKn7RyG9VefmwcKaDvfnhq8cVTeUot40AIO1jWomysRFQm/lRpRv/VNNOA+oFdw545wczL3zkPhmb8CsFixYQIXfuslqD4pC9QH9VQgdDQwNZgOYOE2aEpDY8zH3N0zmv/pHBhzTLEy9QNAAlsjPYxJc6/PALOaW0J/r6a/DfR3M/310N/V9Lea/s4fR3/o0C5FN8hle32VaIGt7ZVK8Ug8k8hnkMQeaq6xiTmc+IYl/MfzdrHP8jFR2cUjwlSLaNZUuapV547bU45wrl77nCOVru4bxSwdJy7TQaoAQPOxVZGiFXTaXwPcM4w5xpwue0qv3QR99d01+MJZQM39h3TU5+Jr9LwpDfyV9rmdIMNcxzLk97ZV0T161SD5BFLnJLQh/sEFlkgaINKMNDBix/kEcSHiRIWoowEUjdcezcwHXe2izS/WNXNiVUP8p+eYpEImiXKY+raUgpHGtA91iV2AJ19ff5PLvJTB92R4TIa9MvylDLfLUJDhOhk2yFAnw2/IUGVmsHrp2P56LQy+IMMfybDzOgafluEjMtwhw9MyXZtcV8pv8LJlOF+Gy2XYIMO9MtwgwydluF2G91vG6ndGln/surH4Wnk8JTKcKcP+cW8SU2V55TK8SoaPyvSnZfiKDDtk+AvzWDl+ub59HN5qZO+fE3AgT34fnT8OytfevLH1/6lrRzWTW3jrWPnSuOsGwhOB1BIfWQ8lL6mEuwlqAdJCnNDihrKXGEDtIhKEuoG4SDO0eAHyZB7Um6DmJh6oNUKtAO5C0krmwm8pwAy5Xw7ancRPLEDpAZmuL8n5ZfUbKyufFAO28RLaXk6/GpBsJeXQOhfGScgykOsnmwDvpnK+3CgJ7dsOvGupXvNoS0bS/Ju/isXGq/rSdrSriOFjRZexs69Kn8tcbQsvrUeHrF+vDPtleFyGA0n6J74FwTztVrhPw6nv9JyxbfjeCj99KIVzfKlxbBsmAvXAbIc2+7i2SeP0wmfFKW0pbQ8vZJ89HFrIcMuuIOQluI/BvWoWIUG4TVcRUgB6OOD+l7kQK+HWXQ2xDu5n4d4xHcrQeUkeIXgCSc0n5PsAV9RYa/79xXW/3lEtLn9++aSAf/t7M3Csy8pX1gX5QHClpbHF7XUHhYBT8AVWWvngesHnX9nodHlWti4qWbmC9/DOIE8RC/yNaxK66+Ub52kq3Dcsq7XjtyP90+TvSYwtXqTrB31gKkZwxsLCEd0YrnXk+5QFbvwehJ7K0bboJx4LCgtdTWvxiT4h+KhrwbIVtcb6ZTSyDo/F3Ym482NwlSwCF4/BUTrNGFw1pdONxVG6nDG4WkpnKGafycg4SlcIuGpIwRPfyIAtgjcn6sYNPo/Q0ijb037lCH7z5s2Na2B45KlSuZ+A4DJWWmg/u8bg7qT9dCTjahldbAyO0fUC7gHsp5Xpk/jGaAHP6vitUSsZmXP6dc7excyuZRw9p/cvHrM29Osc3IfvVI3gFtE5rmaf3Ix8+4Mv5OC0sGBNMEjbG9h3PolvfvA7ngaqczDgMhYWURLAPTyKG/fF0OUvxQwVmbFimj+7QV84PS+DTFdMJZnDEwbS+9Niar+qIaVQWb04j+k3fY6G6D+8uA0/K5qtURLNR7nEDwZdABPxEczhbFQ1qa5QKYgKvGB6dgpJ25fiV8I4kd+M/FoV0X6UQdSNE4kO/CAf7sVlstySKbR+P9zViFMrifr0BFrHl1zNZayv8fUxPGijSXLRjyfrYTxCOtE3phF9SSrRF08eGL6a+SW+M8PXyehveL0H5f9MqivgNJ1arKyenKEiGSUakrEi1Y+8+Ir0mzMg/sF9hUxrhDIP9yK57oXypqR2rG9OaqfzBPlRem4qyS3RktxA9kCWf2oDyke9nwXa784k5MZ8BqkuK5TVCm0q0cJYtDAWbfEEvyJdQdJhvhUaFdEEVP6UBmWhrHehIlNFMuFwlrkitTod+4MYmZAvwmTpod6Wz6BCqSC4VoosDclqhLs2jWRBH1nFOr9Cr4a56yR6RQdJRRo6H6kkozjVz+iBthZoS9Qka4rOn9grEFK5haO2yB49Q44rvzRLle9WqO+A+ym42yB4tGVDzIA7ls3WFG3sN9B2Am584YZv4LTge8bFrCclnO9VcJSncbjR4yGWxkaLy8UHgxaPx7eRhwp/PQTqxppKK2vja31yNB+pVwd8yDFSv93tbfRtrBGcgtvnJTfwgt231uetcTcuD/haan3reS9Zwbf4NvDjewqOdGVeMjr2AxAX/DAXA0k4FZwBdEUsjiSuSegsQHc+iW414PKBrjkp97ZCdHsYcIYkXCPgqosuFQW+Ps/8vZ1ntivR5JxBwRYI+AKE3J3C8U4/WpmL/BHbZHtFLCH30dblAZ7H6GL3uZweWrnJtuJmm91UTL2CvKMAPsxsblmzjncJNbwrFHALm8gDKTWXxNfV2FYkeDnkTbSA77gCbj8kRVZwOTIH2ywuT6W3yRdoYQ6zCHF23rtWaAafgXioqPS6BbfT494MHuMhVzEe0DdbdjmI15dyXFsr2ZzEe7EKhLytrLmsbmqF7Vshp4fqcBf2SV03WdO7yTKfdwMfEICm1lcjBNzetVC8nZB2aPFvQlaL9TZLdWViLjTE4VjmCPp5l7vJ7XI0O72NHh70mAv4oNDoEDb5eYcbunA08pA8+jY5PJBEEnIdaeFbgjyUblu2ou7m2soqW1FJIZOZxnjdPofL19Li8zo2NG30gypCE1qDw+F0BQSH27fG0RTyuiBrBPluQeADLeTa0bKDJ0uJI8g3O5rcHkA4UHQOAZHeJvfaUIB3eJ1gThsdzsDaDZA3M042sYkm3rvBHfB5W3ivgJl3MoXPy7e6BYfgXOOB1bqKOPhWmHRhXEM29IdVQpx+d0FLsGCj21sA2hfQ4RV4igqKCtigx7UHQl7B3cInU2jUKwTPMqdfAN1hlei32DrE2X2+9SH/cpgLXEObVwhsImQattzmDgiw4HVeEAtr/om6zssWqNHW6uL9SL6cTg4hu9Vo95drNqOXLQsFAjATic3hdXUtTLPb6xT4BIrsTqkMyhVfYDnvRF2rA3wQJ7BNdWuID2yq5gPU3rwuGAWMEqRbLpZe2UhsSdja5gDvbAQkmZ6CvrcpKPAttTBBliBoyGOJ/DAlyTPsYGQQBhrJM6CRlV8TWruWDyQ0WYy25/JvIl9fX+pKvIn/716HVxmONh1LvG4fff6DeQ/7twVNgpRW/8aPA76+/sqlgzyU17GzIuak6yAHPVY69ryD8CQc9HVlDOZDvmosY7mrAHdJGctln5fLmM+mTGPl5LNK8jkm+YyDcNJ0Qu4pYzAb7h1lDM6H+6dlDDrg3gVlP8Dvwh0rY888BuBeWc4gfrG7H/DnAd4N5wsN4O+Zwf5/p7GcwbfgfgjKpwHmXAE5SzmD+An7TiifAdhwJeSK5QxqZ0FfUC4BeMss1lc1wIhc3o7tchnhf8jl4wDxn2awjFAvl3MAtsL9UTmDT8l4hHvlMsKP5fJ5gOHZTM+tAGfCWeZQOYPmqxgeoVsutwE8OAfGDueHQwiN0GcFg1a5zAF8E85Jxgp2dr0jj/W1Mo8+MybWCvpsmbwNdyl+CZjPzozmCgbpma+cwUVyGeGNchkhnru2lzP4MNxnysdb39fX/61LQZ895rDHJGPwGLwLL4FPx68bCHtu871LSFy8tLXFY4C0MwgZx5K8ogWFeQbe6/I1Qva5JK+udnlBaZ4hKEBq4vRAerUkbxMfzFt6XWbGYmcwyLes8WwygABvcEleKOAtD7qa+RZnsKDF7Qr4gr4moQCyyHJnsGXBhqI8AyQe7ibIRG9L7g1FfTMhCypfxbT9PV+F7H/ldj3W8Vjssd7H+h8beKz0cfPj+TvNO7md/TvjO4d3nt9JntA88b+t6NfXV3H9F+qLlpoAPAAA
'@
    $compressedBytes = [System.Convert]::FromBase64String($base64String)
    $memoryStream = New-Object System.IO.MemoryStream
    $memoryStream.Write($compressedBytes, 0, $compressedBytes.Length)
    $memoryStream.Position = 0

    $decompressedStream = New-Object System.IO.Compression.GZipStream($memoryStream, [System.IO.Compression.CompressionMode]::Decompress)
    $outputMemoryStream = New-Object System.IO.MemoryStream

    $decompressedStream.CopyTo($outputMemoryStream)
    $originalBytes = $outputMemoryStream.ToArray()

    $decompressedStream.Dispose()
    $memoryStream.Dispose()
    $outputMemoryStream.Dispose()
    $dllPath = "c:\temp\dacl.dll"
    New-Item -Path 'C:\' -Name 'temp' -ItemType Directory -Force -ErrorAction SilentlyContinue | Out-Null
    [System.IO.File]::WriteAllBytes($dllPath, $originalBytes)
  }
}
catch {
  throw "Can't load dacl.dll file .!"
}
    Ldr-LoadDll -dll "C:\Temp\dacl.dll" -dwFlags ALTERED_SEARCH | Out-Null
    Ldr-LoadDll -dll "C:\Temp\dacl.dll" -dwFlags ALTERED_SEARCH | Out-Null

    try {
        $Module = [AppDomain]::CurrentDomain.GetAssemblies()| ? { $_.ManifestModule.ScopeName -eq "Token" } | select -Last 1
        $Token = $Module.GetTypes()[0]
    }
    catch {
        $Module = [AppDomain]::CurrentDomain.DefineDynamicAssembly("null", 1).DefineDynamicModule("Token", $False).DefineType("null")
        @(
            @('null', 'null', [int], @()), # place holder
            @('OpenWindowStationW',           'User32.dll',   [intptr], @([string], [Int], [Int])),
            @('GetProcessWindowStation',      'User32.dll',   [intptr], @()),
            @('SetProcessWindowStation',      'User32.dll',   [bool],   @([IntPtr])),
            @('GetThreadDesktop',             'User32.dll',   [intptr], @([int])),
            @('OpenDesktopW',                 'User32.dll',   [intptr], @([string], [int], [int], [int])),
            @('SetTokenInformation',          'advapi32.dll', [bool],   @([IntPtr], [Int], [IntPtr], [Int])),
            @('GetCurrentThreadId',           'Kernel32.dll', [int],    @()),
            @('WTSGetActiveConsoleSessionId', 'Kernel32.dll', [int],    @())
        ) | % {
            $Module.DefinePInvokeMethod(($_[0]), ($_[1]), 22, 1, [Type]($_[2]), [Type[]]($_[3]), 1, 3).SetImplementationFlags(128) # Def` 128, fail-safe 0 
        }
        $Token = $Module.CreateType()
        Start-Sleep 1
    }

    if ($Params -ne $null) {
        if (!$UseCurrent) {
            Invoke-UnmanagedMethod -Dll "C:\temp\dacl.dll" -Function RemoveAccessAllowedAcesBasedSID -Return bool -Values @($Params.hWinSta, $Params.LogonSid)  | Out-Null
            Invoke-UnmanagedMethod -Dll "C:\temp\dacl.dll" -Function RemoveAccessAllowedAcesBasedSID -Return bool -Values @($Params.hDesktop, $Params.LogonSid) | Out-Null
        }
        
        Free-IntPtr -handle $Params.hToken    -Method NtHandle
        Free-IntPtr -handle $Params.LogonSid  -Method NtHandle

        if (!$UseCurrent) {
            Free-IntPtr -handle ($Params.hDesktop) -Method Desktop
            Free-IntPtr -handle ($Params.hWinSta)  -Method WindowStation
        }
    }
    elseif ($hToken -ne [IntPtr]::Zero) {
        $hDesktop, $hWinSta = [IntPtr]0, [IntPtr]0
        $activeSessionIdPtr, $LogonSid = [IntPtr]0, [IntPtr]0

        if ($UseCurrent) {
            $hWinSta = $Token::GetProcessWindowStation()
            $hDesktop = $Token::GetThreadDesktop(
                ($Token::GetCurrentThreadId()))
        } else {
            $hWinSta = $Token::OpenWindowStationW("winsta0", 0x00, (0x00020000 -bor 0x00040000L))
            if ($hWinSta -eq [IntPtr]::Zero) {
                throw "OpenWindowStationW failed .!"
            }

            $WinstaOld = $Token::GetProcessWindowStation()
            if (!($Token::SetProcessWindowStation($hWinSta))) {
                throw "SetProcessWindowStation failed .!"
            }
            $hDesktop = $Token::OpenDesktopW("default", 0x00, 0x00, (0x00020000 -bor 0x00040000 -bor 0x0080 -bor 0x0001))
            $Token::SetProcessWindowStation($WinstaOld) | Out-Null
        }

        ## Call helper DLL
        if (!(Invoke-UnmanagedMethod -Dll "C:\temp\dacl.dll" -Function GetLogonSidFromToken -Return bool -Values @($hToken, ([ref]$LogonSid)))) {
            throw "GetLogonSidFromToken helper failed .!"
        }

        ## Call helper DLL
        if (!(Invoke-UnmanagedMethod -Dll "C:\temp\dacl.dll" -Function AddAceToWindowStation -Return bool -Values @($hWinSta, $LogonSid))) {
            throw "AddAceToWindowStation helper failed .!"
        }

        ## Call helper DLL
        if (!(Invoke-UnmanagedMethod -Dll "C:\temp\dacl.dll" -Function AddAceToDesktop -Return bool -Values @($hDesktop, $LogonSid))) {
            throw "AddAceToWindowStation helper failed .!"
        }

        ## Call helper DLL
        if (!(Invoke-UnmanagedMethod -Dll "C:\temp\dacl.dll" -Function AddAceToProcess -Return bool -Values @(0x00, $LogonSid))) {
            throw "AddAceToProcess helper failed .!"
        }
        
        ## any other case will fail
        if (Check-AccountType -AccType System) {
            $activeSessionId = $Token::WTSGetActiveConsoleSessionId()
            $activeSessionIdPtr = New-IntPtr -Size 4 -InitialValue $activeSessionId
            if (!(Invoke-UnmanagedMethod -Dll ADVAPI32 -Function SetTokenInformation -Return bool -Values @(
                $hToken, 0xc, $activeSessionIdPtr, 4
                )))
            {
	            Write-Warning "Fail to Set Token Information SessionId.!"
            }
        }

        return [PSObject]@{
           hWinSta  = $hWinSta
           hDesktop = $hDesktop
           LogonSid = $LogonSid
           hToken   = $hToken
        }
    }
}
function Get-ProcessHandle {
    param (
        [int]    $ProcessId,
        [string] $ProcessName,
        [string] $ServiceName,
        [switch] $Impersonat
    )

    $scManager = $tiService = [IntPtr]::Zero
    $buffer = $clientIdPtr = $attributesPtr = [IntPtr]::Zero

    function Open-HandleFromPid($ProcID, $IsProcessToken) {
        try {
            
            $handle = [IntPtr]::Zero
            if ([IntPtr]::Size -eq 8) {
                # 64-bit sizes and layout
                $clientIdSize = 16
                $objectAttrSize = 48
            } else {
                # 32-bit sizes and layout (WOW64)
                $clientIdSize = 8
                $objectAttrSize = 24
            }
            $attributesPtr = New-IntPtr -Size $objectAttrSize -WriteSizeAtZero
            $clientIdPtr   = New-IntPtr -Size $clientIdSize   -InitialValue $ProcID -UsePointerSize
            
            # Try with MAXIMUM_ALLOWED (0x02000000) first
            $ntStatus = $Global:ntdll::NtOpenProcess(
                [ref]$handle, 0x02000000, $attributesPtr, $clientIdPtr
            )

            # If MAXIMUM_ALLOWED fails (status code non-zero), try with specific access rights (0x0B)
            if ($ntStatus -ne 0) {
                $ntStatus = $Global:ntdll::NtOpenProcess(
                    [ref]$handle, (0x0080 -bor 0x0800 -bor 0x0040 -bor 0x0400), $attributesPtr, $clientIdPtr
                )
            }

            if (!$Impersonat) {
                return $handle
            }
            $tokenHandle = [IntPtr]::Zero

            # Try with MAXIMUM_ALLOWED (0x02000000) first
            $ret = $Global:ntdll::NtOpenProcessToken(
                $handle, 0x02000000, [ref]$tokenHandle
            )

            # If MAXIMUM_ALLOWED fails, try with specific access rights (0x0B)
            if ($ret -ne 0) {
                $ret = $Global:ntdll::NtOpenProcessToken(
                    $handle, (0x02 -bor 0x01 -bor 0x08), [ref]$tokenHandle
                )
            }
            Free-IntPtr -handle $handle -Method NtHandle
            if ($tokenHandle -eq [IntPtr]::Zero) {
                throw "NtOpenProcessToken failue .!"
            }

            # Impersonate the user
            if (!(Invoke-UnmanagedMethod -Dll Advapi32 -Function ImpersonateLoggedOnUser -Return bool -Values @($tokenHandle))) {
                throw "ImpersonateLoggedOnUser failed.!"
            }

            $NewTokenHandle = [IntPtr]0
            $ret = $Global:ntdll::NtDuplicateToken(
                $tokenHandle,
                (0x0080 -bor 0x0100 -bor 0x08 -bor 0x02 -bor 0x01),
                [IntPtr]0, $false, 0x01,
                [ref]$NewTokenHandle
            )
            Free-IntPtr -handle $tokenHandle -Method NtHandle

            $null = $Global:kernel32::RevertToSelf()
            return $NewTokenHandle
        }
        finally {
            Free-IntPtr -handle $clientIdPtr
            Free-IntPtr -handle $attributesPtr
        }
    }
    
    try {
            if ($ProcessId -ne 0) {
                if ($Impersonat) {
                    return Open-HandleFromPid -ProcID $ProcessId -IsProcessToken $true
                } else {
                    return Open-HandleFromPid -ProcID $ProcessId
                }
            }

            if (![string]::IsNullOrEmpty($ProcessName)) {
                $proc = Query-Process -ProcessName $ProcessName -First
                if ($proc -and $proc.UniqueProcessId) {
                    if ($Impersonat) {
                        return Open-HandleFromPid -ProcID $proc.UniqueProcessId -IsProcessToken $true
                    } else {
                        return Open-HandleFromPid -ProcID $proc.UniqueProcessId
                    }
                }
                throw "Error receive ID for selected Process"
            }

            if (![string]::IsNullOrEmpty($ServiceName)) {
                $ReturnLength = 0
                $hSCManager = $Global:advapi32::OpenSCManagerW(0,0, (0x0001 -bor 0x0002))

                if ($hSCManager -eq [IntPtr]::Zero) {
                    throw "OpenSCManagerW failed to open the service manger"
                }

                $lpServiceName = [Marshal]::StringToHGlobalAuto($ServiceName)
                $hService = $Global:advapi32::OpenServiceW(
                    $hSCManager, $lpServiceName, 0x0004 -bor 0x0010)

                if ($hService -eq [IntPtr]::Zero) {
                    throw "OpenServiceW failed"
                }

                $cbBufSize = 100;
                $pcbBytesNeeded = 0
                $dwCurrentState = 0
                $lpBuffer = New-IntPtr -Size $cbBufSize
                $ret = $Global:advapi32::QueryServiceStatusEx(
                    $hService, 0, $lpBuffer, $cbBufSize, [ref]$pcbBytesNeeded)
                if (!$ret) {
                    throw "QueryServiceStatusEx failed to query status of $ServiceName Service"
                }
                $dwCurrentState = [Marshal]::ReadInt32($lpBuffer, 4)
                Write-Warning ("Service State [Cur]: {0}" -f [SERVICE_STATUS]$dwCurrentState)

                if ($dwCurrentState -ne ([Int][SERVICE_STATUS]::RUNNING)) {
                    $Ret = $Global:advapi32::StartServiceW(
                        $hService, 0, 0)
                    if (!$Ret) {
                        throw "StartServiceW failed to start $ServiceName Service"
                    }
                }

                $svcLoadCount, $svcLoadMaxTries = 0, 8
                do {
                    Start-Sleep -Milliseconds 300
                    $ret = $Global:advapi32::QueryServiceStatusEx(
                        $hService, 0, $lpBuffer, $cbBufSize, [ref]$pcbBytesNeeded)

                    if (!$ret) {
                        throw "QueryServiceStatusEx failed to query status of $ServiceName Service"
                    }

                    if ($svcLoadCount++ -ge $svcLoadMaxTries) {
                        throw "Too many tries to load $ServiceName Service"
                    }

                    $dwCurrentState = [Marshal]::ReadInt32($lpBuffer, 4)

                } while ($dwCurrentState -ne ([Int][SERVICE_STATUS]::RUNNING))
                Write-Warning ("Service State [New]: {0}" -f [SERVICE_STATUS]$dwCurrentState)
                
                start-sleep -Seconds 1
                $svcProcID = [Marshal]::ReadInt32($lpBuffer, 28)
                if ($Impersonat) {
                    return Open-HandleFromPid -ProcID $svcProcID -IsProcessToken $true
                } else {
                    return Open-HandleFromPid -ProcID $svcProcID
                }
            }
    }
    finally {
        Free-IntPtr -handle $lpBuffer
        Free-IntPtr -handle $lpServiceName
        Free-IntPtr -handle $hSCManager -Method ServiceHandle
        Free-IntPtr -handle $hService   -Method ServiceHandle
        $lpBuffer = $lpServiceName = $hSCManager = $hService = $null
    }
}
Function Get-ProcessHelper {
        param (
            [int]    $ProcessId,
            [string] $ProcessName,
            [string] $ServiceName,
            [bool]   $Impersonat
        )
    <#
        Work with this Services:
        * cmd
        * lsass
        * spoolsv
        * Winlogon
        * TrustedInstaller
        * OfficeClickToRun

        And a lot of more, some service / Apps
        like Amd* GoodSync, etc, can be easyly use too.

    #>

    if ($ProcessName) {
        $Service = Get-CimInstance -ClassName Win32_Service -Filter "PathName LIKE '%$($ProcessName).exe%'" | Select-Object -Last 1
    }
    else {
        $Service = Get-CimInstance -ClassName Win32_Service -Filter "name = '$ServiceName'" | Select-Object -Last 1
    }
    if ($Service) {
                
        if ($Service.state -eq 'Running') {
            $ProcessId = [Int32]::Parse($Service.ProcessId)
            if ($Impersonat) {
                return Get-ProcessHandle -ProcessId $ProcessId -Impersonat
            } else {
                return Get-ProcessHandle -ProcessId $ProcessId
            }
        }
        else {
            # Managed Code fail to get handle,
            # if service need [re] Start. 
            # so, i have to call function twice
            # instead, this, work on first place.!
            $ServiceName = $Service.Name
            if ($Impersonat) {
                return Get-ProcessHandle -ServiceName $ServiceName -Impersonat
            } else {
                return Get-ProcessHandle -ServiceName $ServiceName
            }
        }
    } 
    elseif ($ProcessName) {
        if ($Impersonat) {
            return Get-ProcessHandle -ProcessName $ProcessName -Impersonat
        } else {
            return Get-ProcessHandle -ProcessName $ProcessName
        }
    }
}

<#
Privilege Escalation
https://www.ired.team/offensive-security/privilege-escalation

* Primary Access Token Manipulation
* https://www.ired.team/offensive-security/privilege-escalation/t1134-access-token-manipulation

* Windows NamedPipes 101 + Privilege Escalation
* https://www.ired.team/offensive-security/privilege-escalation/windows-namedpipes-privilege-escalation

* DLL Hijacking
* https://www.ired.team/offensive-security/privilege-escalation/t1038-dll-hijacking

* WebShells
* https://www.ired.team/offensive-security/privilege-escalation/t1108-redundant-access

* Image File Execution Options Injection
* https://www.ired.team/offensive-security/privilege-escalation/t1183-image-file-execution-options-injection

* Unquoted Service Paths
* https://www.ired.team/offensive-security/privilege-escalation/unquoted-service-paths

* Pass The Hash: Privilege Escalation with Invoke-WMIExec
* https://www.ired.team/offensive-security/privilege-escalation/pass-the-hash-privilege-escalation-with-invoke-wmiexec

* Environment Variable $Path Interception
* https://www.ired.team/offensive-security/privilege-escalation/environment-variable-path-interception

* Weak Service Permissions
* https://www.ired.team/offensive-security/privilege-escalation/weak-service-permissions

--------------

* Execute a command or a program with Trusted Installer privileges.
* Copyright (C) 2022  Matthieu `Rubisetcie` Carteron

* github Source C Code
* https://github.com/RubisetCie/god-mode

* fgsec (Felipe Gaspar)  GitHub
* https://github.com/fgsec/SharpGetSystem
* https://github.com/fgsec/Offensive/tree/master
* https://github.com/fgsec/SharpTokenTheft/tree/main

--------------

SERVICE_STATUS structure (winsvc.h)
https://learn.microsoft.com/en-us/windows/win32/api/winsvc/ns-winsvc-service_status

--------------

Clear-host
write-host

#$ConsoleApp = 'cmd'
$ConsoleApp = 'Conhost'

# Make sure to assigen SeAssignPrimaryTokenPrivilege Priv to Account
$AssignPrivilege = Adjust-TokenPrivileges -Query | ? Name -match SeAssignPrimaryTokenPrivilege
if (-not $AssignPrivilege) {
    try {
        if (Adjust-TokenPrivileges -Privilege SeAssignPrimaryTokenPrivilege -Account Administrator) {
            Write-Host ""
            Write-Host "Successfully applied 'SeAssignPrimaryTokenPrivilege' to the 'Administrator' account." -ForegroundColor Cyan
            Write-Host "Please log off and log back in to apply the changes." -ForegroundColor Green
            Write-Host ""
        } else {
            Write-Host ""
            Write-Host "Failed to apply 'SeAssignPrimaryTokenPrivilege' to the 'Administrator' account." -ForegroundColor Red
            Write-Host "Please check your permissions or the account status." -ForegroundColor Yellow
            Write-Host ""
        }
    }
    catch {}
}

Invoke-Process `
    -CommandLine "cmd /k echo Hello From TrustedInstaller && whoami" `
    -ServiceName TrustedInstaller `
    -RunAsConsole `
    -RunAsParent

Invoke-Process `
    -CommandLine "cmd /k echo Hello From winlogon && whoami" `
    -ProcessName winlogon `
    -RunAsConsole `
    -UseDuplicatedToken

# Could Fail to start from system/TI
Write-Host 'Invoke-ProcessAsUser, As Logon/Imprsanate' -ForegroundColor Green
Invoke-ProcessAsUser `
    -Application $ConsoleApp `
    -UserName Administrator `
    -Password 0444 `
    -Mode Hybrid `
    -Method LsaLogonUser `
    -LogonType 0x03 `
    -RunAsConsole

# Could Fail to start from system/TI
Write-Host 'Invoke-ProcessAsUser, As Logon/Imprsanate' -ForegroundColor Green
Invoke-ProcessAsUser `
    -Application $ConsoleApp `
    -UserName Administrator `
    -Password 0444 `
    -Mode Hybrid `
    -Method LogonUserExExW `
    -LogonType 0x03 `
    -RunAsConsole

# Could Fail to start from system/TI
Write-Host 'Invoke-ProcessAsUser, As Logon' -ForegroundColor Green
Invoke-ProcessAsUser `
    -Application $ConsoleApp `
    -UserName Administrator `
    -Password 0444 `
    -Mode Logon `
    -RunAsConsole

# Work From both Normal/Admin/System/TI Account
Write-Host 'Invoke-ProcessAsUser, As Token' -ForegroundColor Green
Invoke-ProcessAsUser `
    -Application $ConsoleApp `
    -UserName Administrator `
    -Password 0444 `
    -Mode Token `
    -RunAsConsole

# Could fail to start if not system Account
Write-Host 'Invoke-ProcessAsUser, As User' -ForegroundColor Green
Invoke-ProcessAsUser `
    -Application $ConsoleApp `
    -UserName Administrator `
    -Password 0444 `
    -Mode User `
    -RunAsConsole

#>
Function Invoke-Process {
    Param (
        [Parameter(Mandatory=$false)]
        [ValidateNotNullOrEmpty()]
        [string] $CommandLine,

        [Parameter(Mandatory=$false)]
        [ValidateSet('lsass', 'winlogon', 'TrustedInstaller', 'cmd', 'spoolsv', 'OfficeClickToRun')]
        [string] $ProcessName,

        [Parameter(Mandatory=$false)]
        [ValidateNotNullOrEmpty()]
        [string] $ServiceName,

        [Parameter(Mandatory=$false)]
        [switch] $WaitForExit,

        [Parameter(Mandatory=$false)]
        [switch] $RunAsConsole,

        [Parameter(Mandatory=$false)]
        [switch] $RunAsParent,

        [Parameter(Mandatory=$false)]
        [switch] $UseDuplicatedToken
    )

    try {
        $tHandle = [IntPtr]::Zero

        if ($ProcessName -or $ServiceName -or $RunAsParent -or $UseDuplicatedToken) {
            if (!($ProcessName -xor $ServiceName)) {
                throw "Please Provide ProcessName -or ServiceName"
            }
            if (!($RunAsParent -xor $UseDuplicatedToken)) {
                throw "-ProcessName or -ServiceName Parameters, Must Run with -RunAsParent or -UseDuplicatedToken"
            }
            if ($UseDuplicatedToken) {
                Write-Warning "`nToken duplication may fail for highly privileged service processes (e.g., TrustedInstaller)`ndue to restrictive Access Control Lists (ACLs) or Protected Process status.`n"
            }
        }

        $ret = Adjust-TokenPrivileges -Privilege SeDebugPrivilege -SysCall
        if (!$ret) {
            return $false
        }
        $processInfoSize = if ([IntPtr]::Size -eq 8) { 24  } else { 16  }
        $startupInfoSize = if ([IntPtr]::Size -eq 8) { 112 } else { 104 }

        $startupInfo = New-IntPtr -Size $startupInfoSize -WriteSizeAtZero
        $processInfo = New-IntPtr -Size $processInfoSize

        $flags = if ($RunAsConsole) {
            (0x00000004 -bor 0x00080000) -bor 0x00000010
        } else { 
            (0x00000004 -bor 0x00080000) -bor 0x08000000
        }
        
        # Add flags -> STARTF_USESHOWWINDOW 0x00000001
        $dwFlagsOffset = if ([IntPtr]::Size -eq 8) {0x3C} else {0x2C}
        [Marshal]::WriteInt32($startupInfo, $dwFlagsOffset, 0x00000001)

        # Add flags -> SW_SHOWNORMAL 0x00000001
        $wShowWindowOffset = if ([IntPtr]::Size -eq 8) {0x40} else {0x30}
        [Marshal]::WriteInt16($startupInfo, $wShowWindowOffset, 0x00000001)

        # Init lpAttributeList, like InitializeProcThreadAttributeList Api .!
        # Clean List, Offset 4 -> Int32 -> Value 1
        # Populate List with 1 item, in both, x64, x86:
        # Offst 0,4,8 --> Int32 -> 1,1,1, As you see later
        $lpAttributeListSize = if ([IntPtr]::Size -eq 8) {0x30} else {0x20}
        $lpAttributeList = New-IntPtr -Size $lpAttributeListSize
        [Marshal]::WriteInt32($lpAttributeList, 4, 1)

        if ($RunAsParent) {
            
            $tHandle = Get-ProcessHelper `
                -ProcessId $ProcessId `
                -ProcessName $ProcessName `
                -ServiceName $ServiceName `
                -Impersonat $false

            # Allocate unmanaged memory for the handle pointer
            if (-not (IsValid-IntPtr $tHandle)) {
                throw "Invalid Process\Service Handle"
            }
            $handlePtr = New-IntPtr -hHandle $tHandle -MakeRefType

            # Offset based on reverse-engineered memory layout
            # Set Parent Process as $tHandle, Work the same as
            # UpdateProcThreadAttribute Api .!
            0..2 | ForEach-Object { [Marshal]::WriteInt32($lpAttributeList, ($_ * 4), [Int32]1) }
            if ([IntPtr]::Size -eq 8) {
                [Marshal]::WriteInt32($lpAttributeList, 0x1a, 2)
                [Marshal]::WriteInt32($lpAttributeList, 0x20, 8)
                [Marshal]::WriteInt64($lpAttributeList, 0x28, $handlePtr)
            } else {
                [Marshal]::WriteByte($lpAttributeList, 0x16, 0x02)
                [Marshal]::WriteByte($lpAttributeList, 0x18, 0x04)
                [Marshal]::WriteInt32($lpAttributeList, 0x1C, $handlePtr)
            }
        }
        if ($UseDuplicatedToken) {
            $tHandle = Get-ProcessHelper `
                -ProcessId $ProcessId `
                -ProcessName $ProcessName `
                -ServiceName $ServiceName `
                -Impersonat $true
            # Allocate unmanaged memory for the handle pointer
            if (-not (IsValid-IntPtr $tHandle)) {
                throw "Invalid Process\Service Handle"
            }
        }
        
        # Now, Update -> lpAttributeList
        if ([IntPtr]::Size -eq 8) {
            [Marshal]::WriteInt64(
                $startupInfo, 0x68, $lpAttributeList.ToInt64())
        } else {
            [Marshal]::WriteInt32(
                $startupInfo, 0x44, $lpAttributeList.ToInt32())
        }
      
        $CommandLinePtr = [Marshal]::StringToHGlobalUni($CommandLine)
        if ($UseDuplicatedToken) {
            $flags = 0x00000004 -bor 0x00000010
            #$ret = Invoke-UnmanagedMethod -Dll Advapi32 -Function CreateProcessWithTokenW -CallingConvention StdCall -Return bool -CharSet Unicode -Values @(
            $ret = $Global:advapi32::CreateProcessWithTokenW(
                $tHandle,        # handle from process / user
                0x00000001,      # LOGON_WITH_PROFILE
                [IntPtr]0,       # lpApplicationName
                $CommandLinePtr, # lpCommandLine
                $flags,          # dwCreationFlags
                [IntPtr]0,       # lpEnvironment
                [IntPtr]0,       # lpCurrentDirectory
                $startupInfo,    # lpStartupInfo
                $processInfo     # lpProcessInformation
            )
        } else {
            # Call CreateProcessAsUserW (needs the duplicated Primary Token)
            $ret = $Global:kernel32::CreateProcessW(
                0, $CommandLinePtr, 0, 0, $false, $flags, 0, 0, $startupInfo, $processInfo)
        }
        
        $err = [Marshal]::GetLastWin32Error()
        if (!$ret) {
            $msg = Parse-ErrorMessage -MessageId $err -Flags HRESULT
            Write-Warning "`nCreateProcessW fail with Error: $err`n$msg"
            return $false
        }

        $hProcess = [Marshal]::ReadIntPtr($processInfo, 0x0)
        $hThread  = [Marshal]::ReadIntPtr($processInfo, [IntPtr]::Size)
        $ret = $Global:kernel32::ResumeThread($hThread)
        if (!$ret) {
            return $false
        }

        if ($WaitForExit) {
            $null = $Global:kernel32::WaitForSingleObject(
                $hProcess, 0xFFFFFFFF)
        }
        return $true
    }
    Finally {
        # Free everything
        Free-IntPtr -handle $processInfo
        Free-IntPtr -handle $startupInfo
        Free-IntPtr -handle $lpAttributeList
        Free-IntPtr -handle $CommandLinePtr
        Free-IntPtr -handle $handlePtr
        Free-IntPtr -handle $buffer
        Free-IntPtr -handle $clientIdPtr
        Free-IntPtr -handle $attributesPtr
        Free-IntPtr -handle $hProcess  -Method Handle
        Free-IntPtr -handle $hThread   -Method Handle
        Free-IntPtr -handle $tHandle   -Method NtHandle

        # Nullify everything
        $buffer = $clientIdPtr = $attributesPtr = $null
        $processInfo = $startupInfo = $lpAttributeList = $null
        $CommandLinePtr = $hProcess = $hThread = $tHandle = $handlePtr = $null
    }
}
Function Invoke-ProcessAsUser {
    Param (
        [Parameter(Mandatory=$true)]
        [ValidateNotNullOrEmpty()]
        [string] $Application,

        [Parameter(Mandatory=$false)]
        [string] $CommandLine,

        [ValidateNotNullOrEmpty()]
        [String] $UserName,
        [ValidateNotNullOrEmpty()]
        [String] $Password,
        [String] $Domain,

        [Int32]  $LogonType  = 0x02,
        [Int32]  $TokenType  = 0x01,
        [Int32]  $LogonFlags = 0x01,

        [ValidateSet("Token", "Logon", "User", "Hybrid")]
        [String] $Mode = "Logon",

        [ValidateSet("LogonUserExExW", "LsaLogonUser")]
        [String] $Method = "LogonUserExExW",

        [Parameter(Mandatory=$false)]
        [switch] $RunAsConsole,

        [Parameter(Mandatory=$false)]
        [switch] $LoadProfile
    )

    <#
    Custom Dll based on logue project.

    @ Starting an Interactive Client Process in C++
    # https://learn.microsoft.com/en-us/previous-versions//aa379608(v=vs.85)?redirectedfrom=MSDN

    @ CreateProcessAsUser example
    # https://github.com/msmania/logue/blob/master/logue.cpp

    @ Win2000: logon32.c   -> L32pLogonUser
    @ LAtest.: sspicli.dll -> L32pLogonUser -> SspipLogonUser
    # https://en.verysource.com/item/win2ksrc_rar-290464.html
    # https://en.verysource.com/code/10350396_1/logon32.c.html

    @ RunAsHighIL.dpr
    @ Spawn a high-integrity process from medium integrity via admin credentials (641 KiB on x64)
    # https://github.com/diversenok/NtUtilsLibrary-Examples/tree/master?tab=readme-ov-file
    # https://github.com/diversenok/NtUtilsLibrary-Examples/blob/master/RunAsHighIL/RunAsHighIL.dpr

    @ https://x.com/splinter_code/status/1458054161472307204
    * LogonUser (Network) -> Set token IL to Medium -> 
    * Set Everyone FullControl on your current process DACL -> Impersonate -> 
    * CreateProcessWithLogon (LOGON_NETCREDENTIALS_ONLY) and specify the admin credentials. 
    * Enjoy High IL process with Interactive SID
    
    @ from 0xc000142 to understanding windows login setup
    # https://0xswitch.fr/posts/windows-from-0xc000142-to-login-process

    @ PrintSpoofer
    # https://github.com/itm4n/PrintSpoofer/tree/master

    @ Coerced potato
    # https://github.com/Prepouce/CoercedPotato
    #>
    
    try {
        $hProcess, $hThread = [IntPtr]0, [IntPtr]0
        $infoSize = [PSCustomobject]@{
            # _STARTUPINFOW   struc
            lpStartupInfoSize = if ([IntPtr]::Size -gt 4) { 0x68 } else { 0x44 }
            # _PROCESS_INFORMATION struc
            ProcessInformationSize = if ([IntPtr]::Size -gt 4) { 0x18 } else { 0x10 }
        
        }
        
        $lpProcessInformation = New-IntPtr -Size $infoSize.ProcessInformationSize
        $lpStartupInfo = New-IntPtr -Size $infoSize.lpStartupInfoSize -WriteSizeAtZero
        $CreateFlags = [PsObject]@{
            SUSPENDED    = 0x00000004
            ENVIRONMENT  = 0x00000400
            CONSOLE      = 0x00000010
            GUI          = 0x08000000
        }
        $flags = if ($RunAsConsole) {
            $CreateFlags.CONSOLE -bor $CreateFlags.ENVIRONMENT -bor $CreateFlags.SUSPENDED
        } else {
            $CreateFlags.GUI     -bor $CreateFlags.ENVIRONMENT -bor $CreateFlags.SUSPENDED
        }

        $AppPath = (Get-Command $Application).Source
        $ApplicationPtr = [Marshal]::StringToHGlobalUni($AppPath)
        $FullCommandLine = """$AppPath"" $CommandLine"
        $CommandLinePtr = [Marshal]::StringToHGlobalUni($FullCommandLine)
        $lpEnvironment = [IntPtr]::Zero

        try {
            Adjust-TokenPrivileges -Privilege SeDebugPrivilege | Out-Null
        }
        catch {}
        if ($LoadProfile) {
            $hToken = Obtain-UserToken `
                -UserName $UserName `
                -Password $Password `
                -Domain $Domain `
                -LogonType $LogonType `
                -TokenType $TokenType `
                -Method $Method `
                -loadProfile
        } else {
            $hToken = Obtain-UserToken `
                -UserName $UserName `
                -Password $Password `
                -Domain $Domain `
                -LogonType $LogonType `
                -TokenType $TokenType `
                -Method $Method 
        }

        if (!(Invoke-UnmanagedMethod -Dll Userenv -Function CreateEnvironmentBlock -Return bool -Values @(([ref]$lpEnvironment), $hToken, $false))) {
            $lastError = [Marshal]::GetLastWin32Error()
            Write-Warning "Failed to create environment block. Last error: $lastError"
        }

        $OffsetList = [PSCustomObject]@{
            WindowFlags = if ([IntPtr]::Size -eq 8) { 0xA4 } else { 0x68 }
            lpDesktopOff = if ([IntPtr]::Size -gt 4) { 0x10 } else { 0x08 }
            ShowWindowFlags = if ([IntPtr]::Size -eq 8) { 0xA8 } else { 0x6C }
        }

        if ($Mode -eq 'Hybrid') {
            
            ####################
            # Hybrid Mode @@@@@@
            ####################

            $tokenHandle = [IntPtr]::Zero;
            [TokenHelper]::OpenProcessToken([TokenHelper]::GetCurrentProcess(), 0x0008, [ref]$tokenHandle) | Out-Null

            $ProcessLevel = [TokenHelper]::QueryTokenIntegrityLevel($tokenHandle)
            $hTokenLevel  = [TokenHelper]::QueryTokenIntegrityLevel($hToken)

            $levelCheck = (
                $ProcessLevel -ne $null -and $ProcessLevel -ge 0 -and (
                    $hTokenLevel -ne $null -and $hTokenLevel -ge 0
                )
            )

            if (!$levelCheck) {
                throw "Fail to get level Check"
            }

            if ($ProcessLevel -ne $hTokenLevel) {
                $TokenLength = 0;
                $TokenInformation = [IntPtr]::Zero;
                $TokenLength = [TokenHelper]::CreateIntegritySid($ProcessLevel, [ref]$TokenInformation);
                if ($TokenInformation -ne 0) {
                    [TokenHelper]::NtSetInformationToken($hToken, 25, $TokenInformation, $TokenLength) | Out-Null
                    Free-IntPtr -handle ([marshal]::ReadIntPtr($TokenInformation, 0x0))
                    Free-IntPtr -handle $TokenInformation
                }

                $ProcessLevel = [TokenHelper]::QueryTokenIntegrityLevel($tokenHandle)
                $hTokenLevel  = [TokenHelper]::QueryTokenIntegrityLevel($hToken)
                $levelCheck = (
                    $ProcessLevel -ne $null -and $ProcessLevel -ge 0 -and (
                        $hTokenLevel -ne $null -and $hTokenLevel -ge 0
                    ) -and (
                        $ProcessLevel -eq $hTokenLevel
                    )
                )
                if (!$levelCheck) {
                    Write-Warning "Fail to get level Check -or cant' reduce level check"
                }
            }

            if (!(Invoke-UnmanagedMethod -Dll Advapi32 -Function ImpersonateLoggedOnUser -Return bool -Values @($hToken))) {
                Write-Host
                throw "ImpersonateLoggedOnUser failed.!"
            }
            
            try {
                Adjust-TokenPrivileges -Privilege SeDebugPrivilege | Out-Null
            }
            catch { }

            # Prefere hToken for current User
            $hInfo = Process-UserToken -hToken $hToken -UseCurrent

            $UserNamePtr = [Marshal]::StringToHGlobalUni($UserName)
            $PasswordPtr = if ([string]::IsNullOrEmpty($Password)) { [IntPtr]::Zero } else { [Marshal]::StringToHGlobalUni($Password) }
            $DomainPtr   = if ([string]::IsNullOrEmpty($Domain)) { [IntPtr]::Zero } else { [Marshal]::StringToHGlobalUni($Domain) }

            # Call internally to Advapi32->CreateProcessWithLogonCommonW->RPC call
            $ret = Invoke-UnmanagedMethod -Dll Advapi32 -Function CreateProcessWithLogonW -CallingConvention StdCall -Return bool -CharSet Unicode -Values @(
                $UserNamePtr, $DomainPtr, $PasswordPtr,
                $LogonFlags,
                $ApplicationPtr, $CommandLinePtr,
                $flags, [Int64]0, "c:\", $lpStartupInfo, $lpProcessInformation
            )

            # Revert to your original, privileged context
            Invoke-UnmanagedMethod -Dll Advapi32 -Function RevertToSelf -Return bool | Out-Null

            # Clean Params laters
            Process-UserToken -Params $hInfo -UseCurrent

            ####################
            # Hybrid Mode @@@@@@
            ####################

        } elseif ($Mode -eq 'Logon') {

            if (Check-AccountType -AccType System){
                Write-Warning "Could fail under system Account.!"
                #return $false
            }
            $UserNamePtr = [Marshal]::StringToHGlobalUni($UserName)
            $PasswordPtr = if ([string]::IsNullOrEmpty($Password)) { [IntPtr]::Zero } else { [Marshal]::StringToHGlobalUni($Password) }
            $DomainPtr   = if ([string]::IsNullOrEmpty($Domain)) { [IntPtr]::Zero } else { [Marshal]::StringToHGlobalUni($Domain) }

            # Call internally to Advapi32->CreateProcessWithLogonCommonW->RPC call
            $ret = Invoke-UnmanagedMethod -Dll Advapi32 -Function CreateProcessWithLogonW -CallingConvention StdCall -Return bool -CharSet Unicode -Values @(
                $UserNamePtr, $DomainPtr, $PasswordPtr,
                $LogonFlags,
                $ApplicationPtr, $CommandLinePtr,
                $flags, $lpEnvironment, "c:\", $lpStartupInfo, $lpProcessInformation
            )

        } elseif ($Mode -eq 'Token') {

            # Prefere hToken for current User
            $hInfo = Process-UserToken -hToken $hToken -UseCurrent

            # Set lpDesktop Info
            #$lpDesktopPtr = [Marshal]::StringToHGlobalUni("winsta0\default")
            #[Marshal]::WriteIntPtr($lpStartupInfo, $OffsetList.lpDesktopOff, $lpDesktopPtr)

            # Set WindowFlags to STARTF_USESHOWWINDOW (0x00000001)
            [Marshal]::WriteInt32([IntPtr]::Add($lpStartupInfo, $OffsetList.WindowFlags), 0x01)

            # Set ShowWindowFlags to SW_SHOW (5)
            [Marshal]::WriteInt32([IntPtr]::Add($lpStartupInfo, $OffsetList.ShowWindowFlags), 0x05)

            # Call internally to Advapi32->CreateProcessWithLogonCommonW->RPC call
            $homeDrive = [marshal]::StringToCoTaskMemUni("c:\")
            $ret = $Global:advapi32::CreateProcessWithTokenW(
                $hToken,
                0x00000001,
                $ApplicationPtr, $CommandLinePtr,
                $flags, $lpEnvironment, $homeDrive, $lpStartupInfo, $lpProcessInformation
            )

            # Clean Params laters
            Process-UserToken -Params $hInfo -UseCurrent

        } elseif ($Mode -eq 'User') {
            $AssignPrivilege = Adjust-TokenPrivileges -Query | ? Name -match SeAssignPrimaryTokenPrivilege
            if (!(Check-AccountType -AccType System) -or -not $AssignPrivilege) {
                if (-not $AssignPrivilege) {        
                    Write-Warning "Missing Priv, {SeAssignPrimaryTokenPrivilege}, Could fail if not system Account .!"
                    Write-Warning "Call -> Adjust-TokenPrivileges -Privilege SeAssignPrimaryTokenPrivilege -Account `$env:USERNAME"
                    #return $false
                }
            }
            
            # Prefere hToken for current User
            $hInfo = Process-UserToken -hToken $hToken -UseCurrent
            
            # Impersonate the user
            if (!(Invoke-UnmanagedMethod -Dll Advapi32 -Function ImpersonateLoggedOnUser -Return bool -Values @($hToken))) {
                throw "ImpersonateLoggedOnUser failed.!"
            }

            # Set lpDesktop Info
            #$lpDesktopPtr = [Marshal]::StringToHGlobalUni("winsta0\default")
            #[Marshal]::WriteIntPtr($lpStartupInfo, $OffsetList.lpDesktopOff, $lpDesktopPtr)

            # Set WindowFlags to STARTF_USESHOWWINDOW (0x00000001)
            [Marshal]::WriteInt32([IntPtr]::Add($lpStartupInfo, $OffsetList.WindowFlags), 0x01)

            # Set ShowWindowFlags to SW_SHOW (5)
            [Marshal]::WriteInt32([IntPtr]::Add($lpStartupInfo, $OffsetList.ShowWindowFlags), 0x05)

            # Call internally to Advapi32->Kernel32->KernelBase->CreateProcessAsUserW->CreateProcessInternalW
            $ret = Invoke-UnmanagedMethod -Dll Kernel32 -Function CreateProcessAsUserW -CallingConvention StdCall -Return bool -CharSet Unicode -Values @(
                $hToken,
                $ApplicationPtr, $CommandLinePtr,
                [IntPtr]0, [IntPtr]0, 0x00,
                $flags, $lpEnvironment, "c:\", $lpStartupInfo, $lpProcessInformation
            )

            # Revert to your original, privileged context
            Invoke-UnmanagedMethod -Dll Advapi32 -Function RevertToSelf -Return bool | Out-Null

            # Clean Params laters
            Process-UserToken -Params $hInfo -UseCurrent
        }

        if ($ret) {
            <#
            typedef struct _PROCESS_INFORMATION {
                HANDLE hProcess;
                HANDLE hThread;
                DWORD  dwProcessId;
                DWORD  dwThreadId;
            } PROCESS_INFORMATION, *PPROCESS_INFORMATION, *LPPROCESS_INFORMATION;
            #>

            [IntPtr]$hProcess = [marshal]::ReadIntPtr($lpProcessInformation, 0x00)
            [IntPtr]$hThread  = [marshal]::ReadIntPtr($lpProcessInformation, [IntPtr]::Size)
            Invoke-UnmanagedMethod ntdll.dll NtResumeThread -Values @($hThread, [IntPtr]::Zero) | Out-Null
        }
        
        if (!$ret) {
            $msg = Parse-ErrorMessage -LastWin32Error
            Write-Warning "Failed with Error: $err`n$msg"
            return $false
        }
        $hProcess = [Marshal]::ReadIntPtr(
            $lpProcessInformation, 0x0)
        $hThread  = [Marshal]::ReadIntPtr(
            $lpProcessInformation, [IntPtr]::Size)
        return $true
    }
    Finally {
        ($lpEnvironment) | % { Free-IntPtr $_ -Method Heap }
        ($hProcess, $hThread) | % { Free-IntPtr $_ -Method NtHandle }
        ($lpProcessInformation, $lpStartupInfo, $ApplicationPtr) | % { Free-IntPtr $_ }
        ($CommandLinePtr, $UserNamePtr, $PasswordPtr, $DomainPtr) | % { Free-IntPtr $_ }
        ($lpDesktopPtr, $homeDrive) | % { Free-IntPtr $_ }
    }
}

<#
Examples.

Invoke-NativeProcess `
    -ImageFile cmd `
    -commandLine "/k whoami"

try {
    $hProc = Get-ProcessHandle `
        -ProcessName 'TrustedInstaller.exe'
}
catch {
    $hProc = Get-ProcessHandle `
        -ServiceName 'TrustedInstaller'
}

if ($hProc -ne [IntPtr]::Zero) {
    Invoke-NativeProcess `
        -ImageFile cmd `
        -commandLine "/k whoami" `
        -hProc $hProc
}

Invoke-NativeProcess `
    -ImageFile "notepad.exe" `
    -Register

# Could fail to start if not system Account
Write-Host 'Invoke-NativeProcess, with hToken' -ForegroundColor Green
$hToken = Obtain-UserToken `
    -UserName user `
    -Password 0444 `
    -loadProfile
Invoke-NativeProcess `
    -ImageFile cmd `
    -commandLine "/k whoami" `
    -hToken $hToken

Free-IntPtr $hToken -Method NtHandle
Free-IntPtr $hProc  -Method NtHandle

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Sources.
https://ntdoc.m417z.com/ntcreateuserprocess
https://ntdoc.m417z.com/rtl_user_process_parameters

https://github.com/capt-meelo/NtCreateUserProcess
https://github.com/BlackOfWorld/NtCreateUserProcess
https://github.com/Microwave89/createuserprocess
https://github.com/peta909/NtCreateUserProcess_
https://github.com/PorLaCola25/PPID-Spoofing

PPID Spoofing & BlockDLLs with NtCreateUserProcess
https://offensivedefence.co.uk/posts/nt-create-user-process/

Making NtCreateUserProcess Work
https://captmeelo.com/redteam/maldev/2022/05/10/ntcreateuserprocess.html

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

[Original] Native API Series- Using NtCreateUserProcess to Create a Normally Working Process - Programming Technology - Kanxu
https://bbs.kanxue.com/thread-272798.htm

Creating Processes Using System Calls - Core Labs
https://www.coresecurity.com/core-labs/articles/creating-processes-using-system-calls

GitHub - D0pam1ne705-Direct-NtCreateUserProcess- Call NtCreateUserProcess directly as normal-
https://github.com/D0pam1ne705/Direct-NtCreateUserProcess

GitHub - je5442804-NtCreateUserProcess-Post- NtCreateUserProcess with CsrClientCallServer for mainstream Windows x64 version
https://github.com/je5442804/NtCreateUserProcess-Post

PS_CREATE_INFO
https://www.geoffchappell.com/studies/windows/km/ntoskrnl/inc/api/ntpsapi/ps_create_info/index.htm

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

PEB
https://www.geoffchappell.com/studies/windows/km/ntoskrnl/inc/api/pebteb/peb/index.htm

RTL_USER_PROCESS_PARAMETERS
https://www.geoffchappell.com/studies/windows/km/ntoskrnl/inc/api/pebteb/rtl_user_process_parameters.htm

Must:
* 00000000 MaximumLength    0x440 [Int32]
* 00000004 Length           0x440 [Int32]
* 00000008 Flags            0x01  [Int32]
* 00000038 DosPath          UNICODE_STRING ?
* 00000060 ImagePathName    UNICODE_STRING ?
* 00000070 CommandLine      UNICODE_STRING ?
* 00000080 Environment      Pointer [Int64]
* 000003F0 EnvironmentSize  Size_T [Size]
#>
Function Invoke-NativeProcess {
    param (
        [Parameter(Mandatory = $false)]
        [ValidateNotNullOrEmpty()]
        [string]$ImageFile = "C:\Windows\System32\cmd.exe",

        [Parameter(Mandatory = $false)]
        [string]$commandLine,

        [Parameter(Mandatory = $false)]
        [IntPtr]$hProc = [IntPtr]::Zero,

        [Parameter(Mandatory = $false)]
        [IntPtr]$hToken = [IntPtr]::Zero,

        [switch]$Register,
        [switch]$Auto,
        [switch]$Log
    )

function Write-AttributeEntry {
    param (
        [IntPtr] $BasePtr,
        [Int64]  $EntryType,
        [long]   $EntryLength,
        [IntPtr] $EntryBuffer
    )
    [Marshal]::WriteInt64($BasePtr,  0x00, $EntryType)
    if ([IntPtr]::Size -eq 8) {
        [Marshal]::WriteInt64($BasePtr,  0x08, $EntryLength)
        [Marshal]::WriteIntPtr($BasePtr, 0x10, $EntryBuffer)
    } else {
        [Marshal]::WriteInt32($BasePtr,  0x08, [int]$EntryLength)
        [Marshal]::WriteIntPtr($BasePtr, 0x0C, $EntryBuffer)
    }
}
function Get-EnvironmentBlockLength {
    param(
        [Parameter(Mandatory=$true)]
        [IntPtr]$lpEnvironment
    )

    <#
    ## Based on logic of KERNEL32 -> GetEnvironmentStrings
    ## LPWCH __stdcall GetEnvironmentStringsW()

    do
    {
    v3 = -1i64;
    while ( Environment[++v3] != 0 )
        ;
    Environment += v3 + 1;
    }
    while ( *Environment );
    #>

    $CurrentPtr = [IntPtr]$lpEnvironment
    $LengthInBytes = 0

    do {
        $Character = [Marshal]::ReadInt16($CurrentPtr)
        $CurrentPtr = [IntPtr]::Add($CurrentPtr, 2)
        $LengthInBytes += 2
        if ($Character -eq 0) {
            $NextCharacter = [Marshal]::ReadInt16($CurrentPtr)
            
            if ($NextCharacter -eq 0) {
                $LengthInBytes += 2
                break
            }
        }

    } while ($true)

    return $LengthInBytes
}
    try {
        $AssignPrivilege = Adjust-TokenPrivileges -Query | ? Name -match SeAssignPrimaryTokenPrivilege
        if ($hToken -ne [IntPtr]::Zero -and (!(Check-AccountType -AccType System) -or -not $AssignPrivilege)) {
            if (-not $AssignPrivilege) {        
                Write-Warning "Missing Priv, {SeAssignPrimaryTokenPrivilege}, Could fail if not system Account .!"
                Write-Warning "Call -> Adjust-TokenPrivileges -Privilege SeAssignPrimaryTokenPrivilege -Account `$env:USERNAME"
                #return $false
            }
        }

        $hProcess, $hThread = [IntPtr]::Zero, [IntPtr]::Zero
        if (-not ([System.IO.Path]::IsPathRooted($ImageFile))) {
            try {
                $resolved = (Get-Command $ImageFile -ErrorAction Stop).Source
                $ImageFile = $resolved
            }
            catch {
                Write-Error "Could not resolve full path for '$ImageFile'"
                return
            }
        }

        $CreateInfoSize = if ([IntPtr]::Size -eq 8) { 0x58 } else { 0x48 }
        $CreateInfo = New-IntPtr -Size $CreateInfoSize -WriteSizeAtZero

        # 0x08 + (4x Size_T) [+ Optional (4x Size_T) ]
        # So, 0x0->0x8, Total size, Rest, Array[], each 32/24 BYTE'S

        $attrCount = 1
        $is64Bit    = ([IntPtr]::Size -eq 8)
        $SizeOfAtt  = if ($is64Bit) { 0x20 } else { 0x18 }
        if ($Register) { $attrCount += 2 }
        if ($hProc -ne [IntPtr]::Zero) { $attrCount += 1 }
        if ($hToken  -ne [IntPtr]::Zero) { $attrCount += 1 }
        
        # even for X86, 4 bytes for TotalLength + 4 padding
        $TotalLength = 0x08 + ($SizeOfAtt * $attrCount)
        $AttributeList = New-IntPtr -Size $TotalLength -InitialValue $TotalLength -UsePointerSize

        $ImagePath = Init-NativeString -Value $ImageFile -Encoding Unicode
        if ($commandLine) {
            $Params = Init-NativeString -Value "`"$ImageFile`" $commandLine" -Encoding Unicode
        }
        else {
            $Params = 0
        }

        $OffsetList = [PSCustomObject]@{
            
            # PEB Offset
            Params = if ([IntPtr]::Size -eq 8) {0x20} else {0x10}

            # RTL_USER_PROCESS_PARAMETERS Offset
            Length = if ([IntPtr]::Size -gt 4) { 0x440 } else { 0x2C0 }
            Cur = if ([IntPtr]::Size -eq 8) { 0x38 } else { 0x24 }
            Image = if ([IntPtr]::Size -eq 8) { 0x60 } else { 0x38 }
            CmdLine = if ([IntPtr]::Size -eq 8) { 0x70 } else { 0x40 }
            Env = if ([IntPtr]::Size -eq 8) { 0x80 } else { 0x48 }
            EnvSize = if ([IntPtr]::Size -eq 8) { 0x3F0 } else { 0x290 }
            DesktopInfo = if ([IntPtr]::Size -eq 8) { 0xC0 } else { 0x78 }
            WindowFlags = if ([IntPtr]::Size -eq 8) { 0xA4 } else { 0x68 }
            ShowWindowFlags = if ([IntPtr]::Size -eq 8) { 0xA8 } else { 0x6C }
        }

        # do not use,
        # it cause memory error messege, in console window
        # create WindowTitle, DesktopInfo, ShellInfo with fake value 00

        # Create Struct manually
        # to avoid memory error

        $CleanMode = "Auto"
        $Size_T = [UintPtr]::new(0x10)
        $Parameters = New-IntPtr -Size $OffsetList.Length
        ($paramSize, $paramSize, 0x01) | % -Begin { $i = 0 } -Process { [Marshal]::WriteInt32([IntPtr]::Add($Parameters, $i++ * 4), $_); }

        # RtlCreateEnvironmentEx(0), NtCurrentPeb()->ProcessParameters; -> Environment, EnvironmentSize
        [Marshal]::WriteIntPtr(
            $Parameters,
            $OffsetList.Env,
            ([Marshal]::ReadIntPtr(
                (NtCurrentTeb -Parameters), $OffsetList.Env))
        )
        if ([IntPtr]::Size -gt 4) {
            [Marshal]::WriteInt64(
                $Parameters,
                $OffsetList.EnvSize,
                ([Marshal]::ReadInt64(
                    (NtCurrentTeb -Parameters), $OffsetList.EnvSize))
            )
        } else {
            [Marshal]::WriteInt32(
                $Parameters,
                $OffsetList.EnvSize,
                ([Marshal]::ReadInt32(
                    (NtCurrentTeb -Parameters), $OffsetList.EnvSize))
            )
        }

        if ($hToken -ne [IntPtr]::Zero) {
            $lpEnvironment = [IntPtr]::Zero
            if (!(Invoke-UnmanagedMethod -Dll Userenv -Function CreateEnvironmentBlock -Return bool -Values @(([ref]$lpEnvironment), $hToken, $false))) {
                $lastError = [Marshal]::GetLastWin32Error()
                Write-Warning "Failed to create environment block. Last error: $lastError"
            }
            $lpLength = Get-EnvironmentBlockLength -lpEnvironment $lpEnvironment
            [Marshal]::WriteIntPtr(
                $Parameters, $OffsetList.Env, $lpEnvironment)
            if ([IntPtr]::Size -gt 4) {
                [Marshal]::WriteInt64(
                    $Parameters, $OffsetList.EnvSize, $lpLength
                )
            } else {
                [Marshal]::WriteInt32(
                    $Parameters, $OffsetList.EnvSize, $lpLength
                )
            }

            Adjust-TokenPrivileges -Privilege @("SeAssignPrimaryTokenPrivilege", "SeIncreaseQuotaPrivilege", "SeImpersonatePrivilege", "SeTcbPrivilege") -SysCall | Out-Null

            ## any other case will fail
            if (Check-AccountType -AccType System) {
                $activeSessionId = Invoke-UnmanagedMethod -Dll Kernel32 -Function WTSGetActiveConsoleSessionId -Return intptr
                $activeSessionIdPtr = New-IntPtr -Size 4 -InitialValue $activeSessionId
                if (!(Invoke-UnmanagedMethod -Dll ADVAPI32 -Function SetTokenInformation -Return bool -Values @(
                    $hToken, 0xc, $activeSessionIdPtr, 4
                    )))
                {
	                Write-Warning "Fail to Set Token Information SessionId.!"
                }
            }

            $hInfo = Process-UserToken -hToken $hToken -UseCurrent
        }

        $DosPath = Init-NativeString -Value "$env:SystemDrive\" -Encoding Unicode
        [IntPtr]$CommandLine = if ($Params -ne 0) {[IntPtr]$Params} else {[IntPtr]$ImagePath}
        $ntdll::RtlMoveMemory(([IntPtr]::Add($Parameters, $OffsetList.Cur)),     $DosPath,     $Size_T)
        $ntdll::RtlMoveMemory(([IntPtr]::Add($Parameters, $OffsetList.Image)),   $ImagePath,   $Size_T)
        $ntdll::RtlMoveMemory(([IntPtr]::Add($Parameters, $OffsetList.CmdLine)), $CommandLine, $Size_T)

        $DesktopInfo = Init-NativeString -Value "winsta0\default" -Encoding Unicode
        $ntdll::RtlMoveMemory(([IntPtr]::Add($Parameters, $OffsetList.DesktopInfo)), $DesktopInfo, $Size_T)

        # Set WindowFlags to STARTF_USESHOWWINDOW (0x00000001)
        [Marshal]::WriteInt32([IntPtr]::Add($Parameters, $OffsetList.WindowFlags), 0x01)

        # Set ShowWindowFlags to SW_SHOW (5)
        [Marshal]::WriteInt32([IntPtr]::Add($Parameters, $OffsetList.ShowWindowFlags), 0x05)

        $NtImagePath = Init-NativeString -Value "\??\$ImageFile" -Encoding Unicode
        $Length = [Marshal]::ReadInt16($NtImagePath)
        $Buffer = [Marshal]::ReadIntPtr([IntPtr]::Add($NtImagePath, [IntPtr]::Size))

        <#
            * PS_ATTRIBUTE_NUM - NtDoc
            * https://ntdoc.m417z.com/ps_attribute_num

            PsAttributeToken, // in HANDLE
            PsAttributeClientId, // out PCLIENT_ID
            PsAttributeParentProcess, // in HANDLE

            * PsAttributeValue - NtDoc
            * https://ntdoc.m417z.com/psattributevalue
        
            PS_ATTRIBUTE_TOKEN = 0x60002;
            PS_ATTRIBUTE_PARENT_PROCESS = 0x60000;
            PS_ATTRIBUTE_CLIENT_ID = 0x10003;
            PS_ATTRIBUTE_IMAGE_NAME = 0x20005;
            PS_ATTRIBUTE_IMAGE_INFO = 0x00006;
        #>

        if ($Auto) {
            
            <#
            NTSTATUS
            NTAPI
            RtlCreateProcessParametersEx(
                _Out_ PRTL_USER_PROCESS_PARAMETERS* pProcessParameters,
                _In_ PUNICODE_STRING ImagePathName,
                _In_opt_ PUNICODE_STRING DllPath,
                _In_opt_ PUNICODE_STRING CurrentDirectory,
                _In_opt_ PUNICODE_STRING CommandLine,
                _In_opt_ PVOID Environment,
                _In_opt_ PUNICODE_STRING WindowTitle,
                _In_opt_ PUNICODE_STRING DesktopInfo,
                _In_opt_ PUNICODE_STRING ShellInfo,
                _In_opt_ PUNICODE_STRING RuntimeData,
                _In_ ULONG Flags
            );
            #>

            $CleanMode = "Heap"
            Free-IntPtr $Parameters
            $Parameters = [IntPtr]::Zero
            if (0 -ne $global:ntdll::RtlCreateProcessParametersEx(
                [ref]$Parameters, $ImagePath, 0,$DosPath, $Params, 0,0,0,0,0,0x01)) {
                return $false
            }
        }

        if ($Log) {
            
            <#
            Dump-MemoryAddress `
                -Pointer $Parameters `
                -Length ([Marshal]::ReadInt32($Parameters, 0x04))
            #>

            $MaximumLength = [marshal]::ReadInt32($Parameters, 0x00)
            $Length = [marshal]::ReadInt32($Parameters, 0x04)
            $Flags  = [marshal]::ReadInt32($Parameters, 0x08)
            $EnvStr =  [Marshal]::PtrToStringUni(
                [Marshal]::ReadIntPtr([IntPtr]::Add($Parameters, $OffsetList.Env)),
                (([marshal]::ReadInt64($Parameters, $OffsetList.EnvSize)) / 2)) 
            $DosPath =  Parse-NativeString -StringPtr ([IntPtr]::Add($Parameters, $OffsetList.Cur))     -Encoding Unicode
            $ExePath =  Parse-NativeString -StringPtr ([IntPtr]::Add($Parameters, $OffsetList.Image))   -Encoding Unicode
            $cmdLine =  Parse-NativeString -StringPtr ([IntPtr]::Add($Parameters, $OffsetList.CmdLine)) -Encoding Unicode

            write-warning "Flags = $Flags"
            write-warning "Dos Path = $($DosPath.StringData)"
            write-warning "Image Path = $($ExePath.StringData)"
            write-warning "Command Line= $($cmdLine.StringData)"
            write-warning "Length, MaximumLength = $Length, $MaximumLength"
            write-warning "Environment = $EnvStr"
        }
        
        # PS_ATTRIBUTE_IMAGE_NAME
        $AttributeListPtr = [IntPtr]::Add($AttributeList, 0x08)
        Write-AttributeEntry $AttributeListPtr 0x20005 $Length $Buffer

        if ($hProc -ne [IntPtr]::Zero) {
            # Parent Process, Jump offset +32/+24
            $AttributeListPtr = [IntPtr]::Add($AttributeListPtr, $SizeOfAtt)
            Write-AttributeEntry $AttributeListPtr 0x60000 ([IntPtr]::Size) $hProc
        }

        if ($hToken -ne [IntPtr]::Zero) {
            # Parent Process, Jump offset +32/+24
            $AttributeListPtr = [IntPtr]::Add($AttributeListPtr, $SizeOfAtt)
            Write-AttributeEntry $AttributeListPtr 0x60002 ([IntPtr]::Size) $hToken
        }

        if ($Register) {
            # CLIENT_ID, Jump offset +32/+24
            $ClientSize = if ([IntPtr]::Size -gt 4) { 0x10 } else { 0x08 }
            $ClientID = New-IntPtr -Size $ClientSize
            $AttributeListPtr = [IntPtr]::Add($AttributeListPtr, $SizeOfAtt)
            Write-AttributeEntry $AttributeListPtr 0x10003 $ClientSize $ClientID

            # SECTION_IMAGE_INFORMATION, Jump offset +32/+24
            $SectionImageSize = if ([IntPtr]::Size -gt 4) { 0x40 } else { 0x30 }
            $SectionImageInformation = New-IntPtr -Size $SectionImageSize
            $AttributeListPtr = [IntPtr]::Add($AttributeListPtr, $SizeOfAtt)
            Write-AttributeEntry $AttributeListPtr 0x06 $SectionImageSize $SectionImageInformation

            # PS_CREATE_INFO, InitFlags = 3
            $InitFlagsOffset = if ([IntPtr]::Size -gt 4) { 0x10 } else { 0x08 }
            [Marshal]::WriteInt32($CreateInfo, $InitFlagsOffset, 0x3)
            
            # PS_CREATE_INFO, AdditionalFileAccess = FILE_READ_ATTRIBUTES, FILE_READ_DATA
            $AdditionalFileAccessOffset = if ([IntPtr]::Size -gt 4) { 0x14 } else { 0xC }
            [Marshal]::WriteInt32($CreateInfo, $AdditionalFileAccessOffset, [Int32](0x0080 -bor 0x0001))

            # PROCESS_CREATE_FLAGS_SUSPENDED,       0x00000200
            # THREAD_CREATE_FLAGS_CREATE_SUSPENDED, 0x00000001
            $Ret = $global:ntdll::NtCreateUserProcess(
                [ref]$hProcess, [ref]$hThread,
                0x2000000, 0x2000000, 0, 0, 0x00000200, 0x00000001,
                $Parameters, $CreateInfo, $AttributeList)
            if ($Ret -ne 0) {
                return $false
            }

            try {
                return Send-CsrClientCall `
                    -hProcess $hProcess `
                    -hThread $hThread `
                    -ImagePath $ImagePath `
                    -NtImagePath $NtImagePath `
                    -ClientID $ClientID `
                    -CreateInfo $CreateInfo
            }
            finally {
                if ($hToken -ne [IntPtr]::Zero -and $hInfo -ne $null) {
                    Process-UserToken -Params $hInfo -UseCurrent
                }
            }
        }

        <#
          NtCreateUserProcess - NtDoc
          https://ntdoc.m417z.com/ntcreateuserprocess
          
          Process Creation Flags
          https://learn.microsoft.com/en-us/windows/win32/procthread/process-creation-flags
        #>
        $Ret = $global:ntdll::NtCreateUserProcess(
            [ref]$hProcess, [ref]$hThread,
            0x2000000, 0x2000000,            # ACCESS_MASK
            [IntPtr]0, [IntPtr]0,            # ObjectAttributes -> Null
            0x00000200,                      # PROCESS_CREATE_FLAGS_* // -bor 0x00080000 // Fail under windows 10
            0x00000000,                      # THREAD_CREATE_FLAGS_
            $Parameters,                     # RTL_USER_PROCESS_PARAMETERS *ProcessParameters
            $CreateInfo,                     # PS_CREATE_INFO *CreateInfo
            $AttributeList                   # PS_ATTRIBUTE_LIST *AttributeList
        )
        if ($hToken -ne [IntPtr]::Zero -and $hInfo -ne $null) {
            Process-UserToken -Params $hInfo
        }

        if ($Ret -eq 0) {
            return $true
        }
        $RetMsg = Parse-ErrorMessage $Ret -Flags NTSTATUS
        Write-Warning "NtCreateUserProcess Fail with Error Code $RetMsg"
        return $false
    }
    finally {
        if (![string]::IsNullOrEmpty($CleanMode)) {
            Free-IntPtr -handle $Parameters -Method $CleanMode
        }
        ($hProcess, $hThread) | % { Free-IntPtr -handle $_ -Method NtHandle }
        ($Params, $DosPath, $ImagePath, $NtImagePath, $Dummy, $DesktopInfo) | % { Free-IntPtr -handle $_ -Method UNICODE_STRING }
        ($EnvPtr, $CreateInfo, $AttributeList, $ClientID) | % { Free-IntPtr -handle $_ }
        ($pbiPtr, $baseApiMsg, $unicodeBuf, $FileInfoPtr, $SectionImageInformation) | % { Free-IntPtr -handle $_ }

        $Params = $Parameters = $hProcess = $NtImagePath = [IntPtr]0l
        $CreateInfo = $AttributeList = $ImagePath = $hThread = [IntPtr]0l
        $ClientID = $SectionImageInformation = $pbiPtr = $baseApiMsg = [IntPtr]0l
        $SpaceUnicode = $unicodeBuf = $FileInfoPtr = $AttributeListPtr = [IntPtr]0l
    }
}
function Send-CsrClientCall {
    param (
        [IntPtr]$hProcess,
        [IntPtr]$hThread,
        [IntPtr]$ImagePath,
        [IntPtr]$NtImagePath,
        [IntPtr]$ClientID,
        [IntPtr]$CreateInfo
    )

    $baseApiMsg, $AssemblyName = [IntPtr]::Zero, [IntPtr]::Zero
    $pbiPtr, $unicodeBuf, $FileInfoPtr = [IntPtr]::Zero, [IntPtr]::Zero, [IntPtr]::Zero

    try {
        # === Query process info to get PEB ===
        $size, $retLen = 0x30, 0
        $pbiPtr = New-IntPtr -Size $size
        $status = $global:ntdll::NtQueryInformationProcess($hProcess, 0, $pbiPtr, [uint32]$size, [ref]$retLen)
        if ($status -ne 0) {
            Write-Error "NtQueryInformationProcess failed with status 0x{0:X}" -f $status
            return $false
        }

        $pidoffset = if ([IntPtr]::Size -eq 8) { 32 } else { 16 }
        $pidPtr = [Marshal]::ReadIntPtr($pbiPtr, $pidoffset)
        $Procid = if ([IntPtr]::Size -eq 8) { $pidPtr.ToInt64() } else { $pidPtr.ToInt32() }

        $pebOffset = if ([IntPtr]::Size -eq 8) { 8 } else { 4 }
        $Peb = [Marshal]::ReadIntPtr($pbiPtr, $pebOffset)

        if ([IntPtr]::Size -eq 8) {
            $UniqueProcess = [Marshal]::ReadIntPtr($ClientID, 0x00)
            $UniqueThread  = [Marshal]::ReadIntPtr($ClientID, 0x08)
        }
        else {
            $UniqueProcess = [Marshal]::ReadIntPtr($ClientID, 0x00)
            $UniqueThread  = [Marshal]::ReadIntPtr($ClientID, 0x04)
        }

        # === Prepare CSR API message ===

        $offsetOf = [PSCustomObject]@{
            Size       = if ([IntPtr]::Size -eq 8) { 0x258 } else { 0x1F0 }
            Stub       = if ([IntPtr]::Size -eq 8) { 0x218 } else { 0x1C0 }

            # 64-bit offsets
            Arch       = if ([IntPtr]::Size -eq 8) { 0x250 } else { 0x1E8 }
            Flags      = if ([IntPtr]::Size -eq 8) { 0x078 } else { 0x50 }
            PFlags     = if ([IntPtr]::Size -eq 8) { 0x07C } else { 0x54 }
            hProc      = if ([IntPtr]::Size -eq 8) { 0x040 } else { 0x30 }
            hThrd      = if ([IntPtr]::Size -eq 8) { 0x048 } else { 0x34 }
            UPID       = if ([IntPtr]::Size -eq 8) { 0x050 } else { 0x38 }
            UTID       = if ([IntPtr]::Size -eq 8) { 0x058 } else { 0x3C }
            PEB        = if ([IntPtr]::Size -eq 8) { 0x240 } else { 0x1D8 }
            FHand      = if ([IntPtr]::Size -eq 8) { 0x080 } else { 0x58 }
            MAddr      = if ([IntPtr]::Size -eq 8) { 0x0C8 } else { 0x84 }
            MSize      = if ([IntPtr]::Size -eq 8) { 0x0D0 } else { 0x88 }
    
            # cfHandle, cmAddress, cmSize are offsets within some internal struct
            cfHandle   = if ([IntPtr]::Size -eq 8) { 0x18 } else { 0x0C }
            cmAddress  = if ([IntPtr]::Size -eq 8) { 0x48 } else { 0x38 }
            cmSize     = if ([IntPtr]::Size -eq 8) { 0x50 } else { 0x40 }
        }

        $baseApiMsg = New-IntPtr -Size $offsetOf.Size                                       # SizeOf -> According to VS <.!>
        [Marshal]::WriteInt16($baseApiMsg, $offsetOf.Arch, 9)                               # ProcessorArchitecture, AMD64(=9)
        [Marshal]::WriteInt32($baseApiMsg, $offsetOf.Flags, 0x0040)                         # Sxs.Flags, Must
        [Marshal]::WriteInt32($baseApiMsg, $offsetOf.PFlags, 0x4001)                        # Sxs.ProcessParameterFlags, can be 0
        [Marshal]::WriteInt64($baseApiMsg, $offsetOf.hProc, ($hProcess -bor 2))             # hProcess, Not Must, can be 0
        [Marshal]::WriteInt64($baseApiMsg, $offsetOf.hThrd, $hThread)                       # hThread,  Not Must, can be 0
        [Marshal]::WriteInt64($baseApiMsg, $offsetOf.UPID, $UniqueProcess)                  # Unique Process ID, Must!
        [Marshal]::WriteInt64($baseApiMsg, $offsetOf.UTID, $UniqueThread)                   # Unique Thread  ID, Must!
        [Marshal]::WriteInt64($baseApiMsg, $offsetOf.PEB, $Peb)                             # Proc PEB Address,  Must!

        [Marshal]::WriteInt64($baseApiMsg, $offsetOf.FHand, ([Marshal]::ReadIntPtr([IntPtr]::Add($CreateInfo, $offsetOf.cfHandle))))   # createInfo.SuccessState.FileHandle
        [Marshal]::WriteInt64($baseApiMsg, $offsetOf.MAddr, ([Marshal]::ReadIntPtr([IntPtr]::Add($CreateInfo, $offsetOf.cmAddress))))  # createInfo.SuccessState.ManifestAddress
        [Marshal]::WriteInt64($baseApiMsg, $offsetOf.MSize, ([Marshal]::ReadIntPtr([IntPtr]::Add($CreateInfo, $offsetOf.cmSize))))     # createInfo.SuccessState.ManifestSize;

        # BaseCreateProcessMessage->Sxs.Win32ImagePath
        # BaseCreateProcessMessage->Sxs.NtImagePath
        # BaseCreateProcessMessage->Sxs.CultureFallBacks
        # BaseCreateProcessMessage->Sxs.AssemblyName

        $Size = [UIntPtr]::new(16)
        $AssemblyName = Init-NativeString -Value "Custom" -Encoding Unicode
        $FallBacks    = Init-NativeString -Value "en-US"  -Encoding Unicode -Length 0x10 -MaxLength 0x14 -BufferSize 0x28

        # Define the offset mapping based on pointer size
        $Offsets = if ([intPtr]::Size -eq 8) {
            @(
                @{ Offset = 0x088; Ptr = $ImagePath },
                @{ Offset = 0x098; Ptr = $NtImagePath },
                @{ Offset = 0x100; Ptr = $FallBacks },
                @{ Offset = 0x120; Ptr = $AssemblyName }
            )
        } else {
            @(
                @{ Offset = 0x5C; Ptr = $ImagePath },
                @{ Offset = 0x64; Ptr = $NtImagePath },
                @{ Offset = 0xAC; Ptr = $FallBacks },
                @{ Offset = 0xC4; Ptr = $AssemblyName }
            )
        }

        # Perform memory copy operation based on offsets
        $Offsets | ForEach-Object {
            $destPtr = [IntPtr]::Add($baseApiMsg, $_.Offset)
            $global:ntdll::RtlMoveMemory($destPtr, $_.Ptr, $Size)
        }

        # Cleanup vars
        $Size = $null
        $destPtr = $null

        # Define the FileInfo pointer array (same offsets for 32 and 64 bit, just handled differently)
        $FileInfoPtr = New-IntPtr -Size ([IntPtr]::Size * 4)
        $FileInfoData = $Offsets | ForEach-Object { $_.Offset }

        # Write the pointer values to $FileInfoPtr
        $FileInfoData | ForEach-Object -Begin { $i = -1 } -Process {
            $dest = [IntPtr]::Add($baseApiMsg, $_)
            $position = (++$i) * [IntPtr]::Size
            [Marshal]::WriteInt64($FileInfoPtr, $position, $dest)
            $dest = $null
        }

        # === Capture CSR message ===
        $bufferPtr = [IntPtr]::Zero
        $ret = $global:ntdll::CsrCaptureMessageMultiUnicodeStringsInPlace(
            [ref]$bufferPtr, 4, $FileInfoPtr)
        if ($ret -ne 0) {
            $ntLastError = Parse-ErrorMessage -MessageId $ret -Flags NTSTATUS
            Write-Error "CsrCaptureMessageMultiUnicodeStringsInPlace failure: $ntLastError"
            return $false
        }

        # === Send CSR message ===
        # CreateProcessInternalW, Reverse engineer code From IDA
        # CsrClientCallServer(ApiMessage, CaptureBuffer, (CSR_API_NUMBER)0x1001D, 0x218u);
        $ret = $global:ntdll::CsrClientCallServer(
            $baseApiMsg, $bufferPtr, 0x1001D, $offsetOf.Stub)

        if ($ret -ne 0) {
            $ntLastError = Parse-ErrorMessage -MessageId $ret -Flags NTSTATUS
            Write-Error "CsrClientCallServer failure: $ntLastError"
            return $false
        }

        # === Resume the thread ===
        $ret = $global:ntdll::NtResumeThread(
            $hThread, 0)
        if ($ret -ne 0) {
            $ntLastError = Parse-ErrorMessage -MessageId $ret -Flags NTSTATUS
            Write-Error "NtResumeThread failure: $ntLastError"
            return $false
        }

        return $true
    }
    finally {
        Free-IntPtr -handle $pbiPtr
        Free-IntPtr -handle $unicodeBuf
        Free-IntPtr -handle $FileInfoPtr
        Free-IntPtr -handle $baseApiMsg
        Free-IntPtr -handle $AssemblyName -Method UNICODE_STRING
        Free-IntPtr -handle $FallBacks    -Method UNICODE_STRING

        $pbiPtr = $unicodeBuf = $FileInfoPtr = $null
        $baseApiMsg = $AssemblyName = $FallBacks = $null
    }
}

<#
Examples.

.DESCRIPTION
    Creates a COM object to access licensing state and related properties.
    Parses various status enums into readable strings.
    Returns a PSCustomObject with detailed licensing info or $null if unable to create the COM object.

.EXAMPLE
    $licInfo = Get-LicensingInfo
    if ($licInfo) {
        $licInfo | Format-List
    } else {
        Write-Error "Failed to retrieve licensing info."
    }
#>
function Get-LicensingInfo {
    try {
        $clsid = "AA04CA0B-7597-4F3E-99A8-36712D13D676"
        $obj = [Activator]::CreateInstance([type]::GetTypeFromCLSID($clsid))
    }
    catch {
        return $null
    }
    try {
        
        # ENUM mappings
        $licensingStatusMap = @{
            0 = "Unlicensed (LICENSING_STATUS_UNLICENSED)"
            1 = "Licensed (LICENSING_STATUS_LICENSED)"
            2 = "In Grace Period (LICENSING_STATUS_IN_GRACE_PERIOD)"
            3 = "Notification Mode (LICENSING_STATUS_NOTIFICATION)"
        }

        $gracePeriodTypeMap = @{
            0   = "Out of Box Grace Period (E_GPT_OUT_OF_BOX)"
            1   = "Hardware Out-of-Tolerance Grace Period (E_GPT_HARDWARE_OOT)"
            2   = "Time-Based Validity Grace Period (E_GPT_TIMEBASED_VALIDITY)"
            255 = "Undefined Grace Period (E_GPT_UNDEFINED)"
        }

        $channelMap = @{
            0   = "Invalid License (LB_Invalid)"
            1   = "Hardware Bound (LB_HardwareId)"
            2   = "Environment-Based License (LB_Environment)"
            4   = "BIOS COA - Certificate of Authenticity (LB_BiosCOA)"
            8   = "BIOS SLP - System Locked Pre-installation (LB_BiosSLP)"
            16  = "BIOS Hardware ID License (LB_BiosHardwareID)"
            32  = "Token-Based Activation (LB_TokenActivation)"
            64  = "Automatic Virtual Machine Activation (LB_AutomaticVMActivation)"
            17  = "Hardware Binding - Any (LB_BindingHardwareAny)"
            12  = "BIOS Binding - Any (LB_BindingBiosAny)"
            28  = "BIOS Channel - Any (LB_ChannelBiosAny)"
            -1  = "Any Channel - Wildcard (LB_ChannelAny)"
        }

        $activationReasonMap = @{
            0   = "Generic Activation Error (E_AR_GENERIC_ERROR)"
            1   = "Activated Successfully (E_AR_ACTIVATED)"
            2   = "Invalid Product Key (E_AR_INVALID_PK)"
            3   = "Product Key Already Used (E_AR_USED_PRODUCT_KEY)"
            4   = "No Internet Connection (E_AR_NO_INTERNET)"
            5   = "Unexpected Error During Activation (E_AR_UNEXPECTED_ERROR)"
            6   = "Cannot Activate in Safe Mode (E_AR_SAFE_MODE_ERROR)"
            7   = "System State Error Preventing Activation (E_AR_SYSTEM_STATE_ERROR)"
            8   = "OEM COA Error (E_AR_OEM_COA_ERROR)"
            9   = "Expired License(s) (E_AR_EXPIRED_LICENSES)"
            10  = "No Product Key Installed (E_AR_NO_PKEY_INSTALLED)"
            11  = "Tampering Detected (E_AR_TAMPER_DETECTED)"
            12  = "Reinstallation Required for Activation (E_AR_REINSTALL_REQUIRED)"
            13  = "System Reboot Required (E_AR_REBOOT_REQUIRED)"
            14  = "Non-Genuine Windows Detected (E_AR_NON_GENUINE)"
            15  = "Token-Based Activation Error (E_AR_TOKENACTIVATION_ERROR)"
            16  = "Blocked Product Key Due to IP/Location (E_AR_BLOCKED_IPLOCATION_PK)"
            17  = "DNS Resolution Error (E_AR_DNS_ERROR)"
            18  = "Product Key Validation Error (E_VR_PRODUCTKEY_ERROR)"
            19  = "Raw Product Key Error (E_VR_PRODUCTKEY_RAW_ERROR)"
            20  = "Product Key Blocked by UI Policy (E_VR_PRODUCTKEY_UI_BLOCK)"
            255 = "Activation Reason Not Found (E_AR_NOT_FOUND)"
        }

        $systemStateFlagsMap = @{
            1  = "Reboot Policy Detected (SYSTEM_STATE_REBOOT_POLICY_FOUND)"
            2  = "System Tampering Detected (SYSTEM_STATE_TAMPERED)"
            8  = "Trusted Store Tampered (SYSTEM_STATE_TAMPERED_TRUSTED_STORE)"
            32 = "Kernel-Mode Cache Tampered (SYSTEM_STATE_TAMPERED_KM_CACHE)"
        }

        # Parse bitfield SystemStateFlags
        $stateFlags = $obj.SystemStateFlags
        $parsedStateFlags = @()
        foreach ($flag in $systemStateFlagsMap.Keys) {
            if ($stateFlags -band $flag) {
                $parsedStateFlags += $systemStateFlagsMap[$flag]
            }
        }

        $state = $obj.LicensingState
        $errMsg = Parse-ErrorMessage -MessageId $state.StatusReasonCode

        $result = [PSCustomObject]@{
            LicensingSystemDate         = $obj.LicensingSystemDate
            SystemStateFlags      = $parsedStateFlags -join ', '
            ActiveLicenseChannel  = $channelMap[$obj.ActiveLicenseChannel]
            ProductKeyType              = $obj.ProductKeyType
            IsTimebasedKeyInstalled     = [bool]$obj.IsTimebasedKeyInstalled
            DefaultKeyFromRegistry      = $obj.DefaultKeyFromRegistry
            IsLocalGenuine              = $obj.IsLocalGenuine
            skuId                   = $state.skuId
            Status            = $licensingStatusMap[$state.Status]
            StatusReasonCategory    = $activationReasonMap[$state.StatusReasonCategory]
            StatusReasonCode        = $errMsg
            Channel           = $channelMap[$state.Channel]
            GracePeriodType   = $gracePeriodTypeMap[$state.GracePeriodType]
            ValidityExpiration      = $state.ValidityExpiration
            KernelExpiration        = $state.KernelExpiration
        }

        return $result
    }
    catch {
    }
    finally {
        $null = [Marshal]::ReleaseComObject($obj)
        $null = [GC]::Collect()
        $null = [GC]::WaitForPendingFinalizers()
    }
}

<#
 Source ... 
 https://github.com/asdcorp/clic
 https://github.com/gravesoft/CAS
#>
function IsDigitalLicense {
    $interfaceSpec = Build-ComInterfaceSpec `
       -CLSID "17CCA47D-DAE5-4E4A-AC42-CC54E28F334A" `
       -IID "F2DCB80D-0670-44BC-9002-CD18688730AF" `
       -Index 5 `
       -Name AcquireModernLicenseForWindows `
       -Return int `
       -Params "int bAsync, out int lmReturnCode"

    try {
        $comObject = $interfaceSpec | Initialize-ComObject
        [int]$lmReturnCode = 0
        $hr = $comObject | Invoke-ComObject -Params (
            @(1, [ref]$lmReturnCode))

        if ($hr -eq 0) {
            return ($lmReturnCode -ne 1 -and $lmReturnCode -le [int32]::MaxValue)
        } else {
            return $false
        }

    } catch {
        Write-Warning "An error occurred: $($_.Exception.Message)"
        return $false
    } finally {
        $comObject | Release-ComObject
    }
}

<#
Source: Clic.C
Check if SubscriptionStatus
#>
function IsSubscriptionStatus {
    $dwSupported = 0 
    $ConsumeAddonPolicy = Get-ProductPolicy -Filter 'ConsumeAddonPolicySet' -UseApi
    if (-not $ConsumeAddonPolicy -or $ConsumeAddonPolicy.Value -eq $null) {
        return $false
    }
    
    $dwSupported = $ConsumeAddonPolicy.Value
    if ($dwSupported -eq 0) {
        return $false
    }

    $StatusPtr = [IntPtr]::Zero
    $ClipResult = $Global:CLIPC::ClipGetSubscriptionStatus([ref]$StatusPtr, [intPtr]::zero, [intPtr]::zero, [intPtr]::zero)
    if ($ClipResult -ne 0 -or $StatusPtr -eq [IntPtr]::Zero) {
        return $false
    }

    # so, it hold return data, no return data, no entiries
    # no entiries --> $False
    try {
        $dwStatus = [Marshal]::ReadInt32($StatusPtr)
        if ($dwStatus -and $dwStatus -gt 0) {
            return $true
        }
        return $false
    }
    finally {
        Free-IntPtr -handle $StatusPtr -Method Heap
    }
}

<#
Source: Clic.C
HRESULT WINAPI ClipGetSubscriptionStatus(
    SUBSCRIPTIONSTATUS **ppStatus
);

typedef struct _tagSUBSCRIPTIONSTATUS {
    DWORD dwEnabled;
    DWORD dwSku;
    DWORD dwState;
} SUBSCRIPTIONSTATUS;   

BOOL PrintSubscriptionStatus() {
    SUBSCRIPTIONSTATUS *pStatus;
    DWORD dwSupported = 0;

    if(SLGetWindowsInformationDWORD(L"ConsumeAddonPolicySet", &dwSupported))
        return FALSE;

    wprintf(L"SubscriptionSupportedEdition=%ws\n", BoolToWStr(dwSupported));

    if(ClipGetSubscriptionStatus(&pStatus))
        return FALSE;

    wprintf(L"SubscriptionEnabled=%ws\n", BoolToWStr(pStatus->dwEnabled));

    if(pStatus->dwEnabled == 0) {
        LocalFree(pStatus);
        return TRUE;
    }

    wprintf(L"SubscriptionSku=%d\n", pStatus->dwSku);
    wprintf(L"SubscriptionState=%d\n", pStatus->dwState);

    LocalFree(pStatus);
    return TRUE;
}

----------------------

typedef struct {
    int count;          // 4 bytes, at offset 0
    struct {
        int field1;     // 4 bytes
        int field2;     // 4 bytes
    } entries[];        // Followed by 'count' of these 8-byte pairs
} ClipSubscriptionData;

#>
function GetSubscriptionStatus {
    $StatusPtr = [IntPtr]::Zero
    $ClipResult = $Global:CLIPC::ClipGetSubscriptionStatus([ref]$StatusPtr, [intPtr]::zero, [intPtr]::zero, [intPtr]::zero)
    if ($ClipResult -ne 0 -or $StatusPtr -eq [IntPtr]::Zero) {
        return $false
    }

    try {
        $currentOffset = 4
        $subscriptionEntries = @()
        $dwStatus = [Marshal]::ReadInt32($StatusPtr)

        for ($i = 0; $i -lt $dwStatus; $i++) {
            $dwField1 = [Marshal]::ReadInt32([IntPtr]::Add($StatusPtr, $currentOffset))
            $currentOffset += 4

            $dwField2 = [Marshal]::ReadInt32([IntPtr]::Add($StatusPtr, $currentOffset))
            $currentOffset += 4

            $entry = [PSCustomObject]@{
                Sku   = $dwField1
                State = $dwField2
            }
            $subscriptionEntries += $entry
        }
        return $subscriptionEntries
    }
    finally {
        Free-IntPtr -handle $StatusPtr -Method Heap
    }
}

if ($null -eq $PSVersionTable -or $null -eq $PSVersionTable.PSVersion -or $null -eq $PSVersionTable.PSVersion.Major) {
    Clear-host
    Write-Host
    Write-Host "Unable to determine PowerShell version." -ForegroundColor Green
    Write-Host "This script requires PowerShell 5.0 or higher!" -ForegroundColor Green
    Write-Host
    Read-Host "Press Enter to exit..."
    Read-Host
    return
}

if ($PSVersionTable.PSVersion.Major -lt 5) {
    Clear-host
    Write-Host
    Write-Host "This script requires PowerShell 5.0 or higher!" -ForegroundColor Green
    Write-Host "Windows 10 & Above are supported." -ForegroundColor Green
    Write-Host
    Read-Host "Press Enter to exit..."
    Read-Host
    return
}

# Check if the current user is System or an Administrator
$isSystem = Check-AccountType -AccType System
$isAdmin  = Check-AccountType -AccType Administrator

if (![bool]$isSystem -and ![bool]$isAdmin) {
    Clear-host
    Write-Host
    if ($isSystem -eq $null -or $isAdmin -eq $null) {
        Write-Host "Unable to determine if the current user is System or Administrator." -ForegroundColor Yellow
        Write-Host "There may have been an internal error or insufficient permissions." -ForegroundColor Yellow
        return
    }
    Write-Host "This script must be run as Administrator or System!" -ForegroundColor Green
    Write-Host "Please run this script as Administrator." -ForegroundColor Green
    Write-Host "(Right-click and select 'Run as Administrator')" -ForegroundColor Green
    Write-Host
    Read-Host "Press Enter to exit..."
    Read-Host
    return
}

# LOAD DLL Function
$Global:SLC       = Init-SLC
$Global:ntdll     = Init-NTDLL
$Global:CLIPC     = Init-CLIPC
$Global:DismAPI   = Init-DismApi
$Global:PIDGENX   = Init-PIDGENX
$Global:kernel32  = Init-KERNEL32
$Global:advapi32  = Init-advapi32
$Global:PKHElper  = Init-PKHELPER
$Global:PKeyDatabase = Init-XMLInfo

# Instead of RtlGetCurrentPeb
$Global:PebPtr = NtCurrentTeb -Peb

# LOAD BASE ADDRESS for RtlFindMessage Api
$ApiMapList = @(
    # win32 errors
    "Kernel32.dll"
    "KernelBase.dll", 
    #"api-ms-win-core-synch-l1-2-0.dll",

    # NTSTATUS errors
    "ntdll.dll",

    # Activation errors
    "slc.dll",
    "sppc.dll"

    # Network Management errors
    "netmsg.dll",  # Network
    "winhttp.dll", # HTTP SERVICE
    "qmgr.dll"     # BITS
)
$baseMap = @{}
$global:LoadedModules = Get-LoadedModules -SortType Memory | 
    Select-Object BaseAddress, ModuleName, LoadAsData
$LoadedModules | Where-Object { $ApiMapList -contains $_.ModuleName } | 
    ForEach-Object { $baseMap[$_.ModuleName] = $_.BaseAddress
}
$flags = [LOAD_LIBRARY]::SEARCH_SYS32
$ApiMapList | Where-Object { $_ -notin $baseMap.Keys } | ForEach-Object {   
    $HResults = Ldr-LoadDll -dwFlags $flags -dll $_
    if ($HResults -ne [IntPtr]::Zero) {
        write-warning "LdrLoadDll Succedded to load $_"
    }
    else {
        write-warning "LdrLoadDll failed to load $_"
    }
    if ([IntPtr]::Zero -ne $HResults) {
        $baseMap[$_] = $HResults
    }
}

<#
# due too side effect (activation window crash)
# will remove this part for now. ?

# Get Minimal Privileges To Load Some NtDll function
$PrivilegeList = @("SeDebugPrivilege", "SeImpersonatePrivilege", "SeIncreaseQuotaPrivilege", "SeAssignPrimaryTokenPrivilege", "SeSystemEnvironmentPrivilege")
Adjust-TokenPrivileges -Privilege $PrivilegeList -Log -SysCall
#>

# INIT Global Variables
$Global:OfficeAppId  = '0ff1ce15-a989-479d-af46-f275c6370663'
$Global:windowsAppID  = '55c92734-d682-4d71-983e-d6ec3f16059f'
$Global:knownAppGuids = @($windowsAppID, $OfficeAppId)
$Global:CurrentVersion = 'HKLM:\SOFTWARE\Microsoft\Windows NT\CurrentVersion'
$Global:ubr = try { Get-LatestUBR } catch { 0 }
$Global:osVersion = Init-osVersion
$OperatingSystem = Get-CimInstance Win32_OperatingSystem -ea 0
$Global:OperatingSystemInfo = [PSCustomObject]@{
    dwOSMajorVersion = $Global:osVersion.Major
    dwOSMinorVersion = $Global:osVersion.Minor
    dwSpMajorVersion = try {$Global:osVersion.ServicePackMajor} catch {0};
    dwSpMinorVersion = try {$Global:osVersion.ServicePackMinor} catch {0};
}

#define hwid supported products table
$hashTable = @'
ID,KEY,SKU_ID,Key_part,value,Status,Type,Product
8b351c9c-f398-4515-9900-09df49427262,XGVPP-NMH47-7TTHJ-W3FW7-8HV2C,4,X19-99683,HGNKjkKcKQHO6n8srMUrDh/MElffBZarLqCMD9rWtgFKf3YzYOLDPEMGhuO/auNMKCeiU7ebFbQALS/MyZ7TvidMQ2dvzXeXXKzPBjfwQx549WJUU7qAQ9Txg9cR9SAT8b12Pry2iBk+nZWD9VtHK3kOnEYkvp5WTCTsrSi6Re4,0,OEM:NONSLP,Enterprise
c83cef07-6b72-4bbc-a28f-a00386872839,3V6Q6-NQXCX-V8YXR-9QCYV-QPFCT,27,X19-98746,NHn2n0N1UfVf00CfaI5LCDMDsKdVAWpD/HAfUrcTAKsw9d2Sks4h5MhyH/WUx+B6dFi8ol7D3AHorR8y9dqVS1Bd2FdZNJl/tTR1PGwYn6KL88NS19aHmFNdX8s4438vaa+Ty8Qk8EDcwm/wscC8lQmi3/RgUKYdyGFvpbGSVlk,0,Volume:MAK,EnterpriseN
4de7cb65-cdf1-4de9-8ae8-e3cce27b9f2c,VK7JG-NPHTM-C97JM-9MPGT-3V66T,48,X19-98841,Yl/jNfxJ1SnaIZCIZ4m6Pf3ySNoQXifNeqfltNaNctx+onwiivOx7qcSn8dFtURzgMzSOFnsRQzb5IrvuqHoxWWl1S3JIQn56FvKsvSx7aFXIX3+2Q98G1amPV/WEQ0uHA5d7Ya6An+g0Z0zRP7evGoomTs4YuweaWiZQjQzSpA,0,Retail,Professional
9fbaf5d6-4d83-4422-870d-fdda6e5858aa,2B87N-8KFHP-DKV6R-Y2C8J-PKCKT,49,X19-98859,Ge0mRQbW8ALk7T09V+1k1yg66qoS0lhkgPIROOIOgxKmWPAvsiLAYPKDqM4+neFCA/qf1dHFmdh0VUrwFBPYsK251UeWuElj4bZFVISL6gUt1eZwbGfv5eurQ0i+qZiFv+CcQOEFsd5DD4Up6xPLLQS3nAXODL5rSrn2sHRoCVY,0,Retail,ProfessionalN
f742e4ff-909d-4fe9-aacb-3231d24a0c58,4CPRK-NM3K3-X6XXQ-RXX86-WXCHW,98,X19-98877,vel4ytVtnE8FhvN87Cflz9sbh5QwHD1YGOeej9QP7hF3vlBR4EX2/S/09gRneeXVbQnjDOCd2KFMKRUWHLM7ZhFBk8AtlG+kvUawPZ+CIrwrD3mhi7NMv8UX/xkLK3HnBupMEuEwsMJgCUD8Pn6om1mEiQebHBAqu4cT7GN9Y0g,0,Retail,CoreN
1d1bac85-7365-4fea-949a-96978ec91ae0,N2434-X9D7W-8PF6X-8DV9T-8TYMD,99,X19-99652,Nv17eUTrr1TmUX6frlI7V69VR6yWb7alppCFJPcdjfI+xX4/Cf2np3zm7jmC+zxFb9nELUs477/ydw2KCCXFfM53bKpBQZKHE5+MdGJGxebOCcOtJ3hrkDJtwlVxTQmUgk5xnlmpk8PHg82M2uM5B7UsGLxGKK4d3hi0voSyKeI,0,Retail,CoreCountrySpecific
3ae2cc14-ab2d-41f4-972f-5e20142771dc,BT79Q-G7N6G-PGBYW-4YWX6-6F4BT,100,X19-99661,FV2Eao/R5v8sGrfQeOjQ4daokVlNOlqRCDZXuaC45bQd5PsNU3t1b4AwWeYM8TAwbHauzr4tPG0UlsUqUikCZHy0poROx35bBBMBym6Zbm9wDBVyi7nCzBtwS86eOonQ3cU6WfZxhZRze0POdR33G3QTNPrnVIM2gf6nZJYqDOA,0,Retail,CoreSingleLanguage
2b1f36bb-c1cd-4306-bf5c-a0367c2d97d8,YTMG3-N6DKC-DKB77-7M9GH-8HVX7,101,X19-98868,GH/jwFxIcdQhNxJIlFka8c1H48PF0y7TgJwaryAUzqSKXynONLw7MVciDJFVXTkCjbXSdxLSWpPIC50/xyy1rAf8aC7WuN/9cRNAvtFPC1IVAJaMeq1vf4mCqRrrxJQP6ZEcuAeHFzLe/LLovGWCd8rrs6BbBwJXCvAqXImvycQ,0,Retail,Core
2a6137f3-75c0-4f26-8e3e-d83d802865a4,XKCNC-J26Q9-KFHD2-FKTHY-KD72Y,119,X19-99606,hci78IRWDLBtdbnAIKLDgV9whYgtHc1uYyp9y6FszE9wZBD5Nc8CUD2pI2s2RRd3M04C4O7M3tisB3Ov/XVjpAbxlX3MWfUR5w4MH0AphbuQX0p5MuHEDYyfqlRgBBRzOKePF06qfYvPQMuEfDpKCKFwNojQxBV8O0Arf5zmrIw,0,OEM:NONSLP,PPIPro
e558417a-5123-4f6f-91e7-385c1c7ca9d4,YNMGQ-8RYV3-4PGQ3-C8XTP-7CFBY,121,X19-98886,x9tPFDZmjZMf29zFeHV5SHbXj8Wd8YAcCn/0hbpLcId4D7OWqkQKXxXHIegRlwcWjtII0sZ6WYB0HQV2KH3LvYRnWKpJ5SxeOgdzBIJ6fhegYGGyiXsBv9sEb3/zidPU6ZK9LugVGAcRZ6HQOiXyOw+Yf5H35iM+2oDZXSpjvJw,0,Retail,Education
c5198a66-e435-4432-89cf-ec777c9d0352,84NGF-MHBT6-FXBX8-QWJK7-DRR8H,122,X19-98892,jkL4YZkmBCJtvL1fT30ZPBcjmzshBSxjwrE0Q00AZ1hYnhrH+npzo1MPCT6ZRHw19ZLTz7wzyBb0qqcBVbtEjZW0Xs2MYLxgriyoONkhnPE6KSUJBw7C0enFVLHEqnVu/nkaOFfockN3bc+Eouw6W2lmHjklPHc9c6Clo04jul0,0,Retail,EducationN
f6e29426-a256-4316-88bf-cc5b0f95ec0c,PJB47-8PN2T-MCGDY-JTY3D-CBCPV,125,X23-50331,OPGhsyx+Ctw7w/KLMRNrY+fNBmKPjUG0R9RqkWk4e8ez+ExSJxSLLex5WhO5QSNgXLmEra+cCsN6C638aLjIdH2/L7D+8z/C6EDgRvbHMmidHg1lX3/O8lv0JudHkGtHJYewjorn/xXGY++vOCTQdZNk6qzEgmYSvPehKfdg8js,1,Volume:MAK,EnterpriseS,Ge
cce9d2de-98ee-4ce2-8113-222620c64a27,KCNVH-YKWX8-GJJB9-H9FDT-6F7W2,125,X22-66075,GCqWmJOsTVun9z4QkE9n2XqBvt3ZWSPl9QmIh9Q2mXMG/QVt2IE7S+ES/NWlyTSNjLVySr1D2sGjxgEzy9kLwn7VENQVJ736h1iOdMj/3rdqLMSpTa813+nPSQgKpqJ3uMuvIvRP0FdB7Y4qt8qf9kNKK25A1QknioD/6YubL/4,1,Volume:MAK,EnterpriseS,VB
d06934ee-5448-4fd1-964a-cd077618aa06,43TBQ-NH92J-XKTM7-KT3KK-P39PB,125,X21-83233,EpB6qOCo8pRgO5kL4vxEHck2J1vxyd9OqvxUenDnYO9AkcGWat/D74ZcFg5SFlIya1U8l5zv+tsvZ4wAvQ1IaFW1PwOKJLOaGgejqZ41TIMdFGGw+G+s1RHsEnrWr3UOakTodby1aIMUMoqf3NdaM5aWFo8fOmqWC5/LnCoighs,0,OEM:NONSLP,EnterpriseS,RS5
706e0cfd-23f4-43bb-a9af-1a492b9f1302,NK96Y-D9CD8-W44CQ-R8YTK-DYJWX,125,X21-05035,ntcKmazIvLpZOryft28gWBHu1nHSbR+Gp143f/BiVe+BD2UjHBZfSR1q405xmQZsygz6VRK6+zm8FPR++71pkmArgCLhodCQJ5I4m7rAJNw/YX99pILphi1yCRcvHsOTGa825GUVXgf530tHT6hr0HQ1lGeGgG1hPekpqqBbTlg,0,OEM:NONSLP,EnterpriseS,RS1
faa57748-75c8-40a2-b851-71ce92aa8b45,FWN7H-PF93Q-4GGP8-M8RF3-MDWWW,125,X19-99617,Fe9CDClilrAmwwT7Yhfx67GafWRQEpwyj8R+a4eaTqbpPcAt7d1hv1rx8Sa9AzopEGxIrb7IhiPoDZs0XaT1HN0/olJJ/MnD73CfBP4sdQdLTsSJE3dKMWYTQHpnjqRaS/pNBYRr8l9Mv8yfcP8uS2MjIQ1cRTqRmC7WMpShyCg,0,OEM:NONSLP,EnterpriseS,TH
3d1022d8-969f-4222-b54b-327f5a5af4c9,2DBW3-N2PJG-MVHW3-G7TDK-9HKR4,126,X21-04921,zLPNvcl1iqOefy0VLg+WZgNtRNhuGpn8+BFKjMqjaNOSKiuDcR6GNDS5FF1Aqk6/e6shJ+ohKzuwrnmYq3iNQ3I2MBlYjM5kuNfKs8Vl9dCjSpQr//GBGps6HtF2xrG/2g/yhtYC7FbtGDIE16uOeNKFcVg+XMb0qHE/5Etyfd8,0,Volume:MAK,EnterpriseSN,RS1
60c243e1-f90b-4a1b-ba89-387294948fb6,NTX6B-BRYC2-K6786-F6MVQ-M7V2X,126,X19-98770,kbXfe0z9Vi1S0yfxMWzI5+UtWsJKzxs7wLGUDLjrckFDn1bDQb4MvvuCK1w+Qrq33lemiGpNDspa+ehXiYEeSPFcCvUBpoMlGBFfzurNCHWiv3o1k3jBoawJr/VoDoVZfxhkps0fVoubf9oy6C6AgrkZ7PjCaS58edMcaUWvYYg,0,Volume:MAK,EnterpriseSN,TH
01eb852c-424d-4060-94b8-c10d799d7364,3XP6D-CRND4-DRYM2-GM84D-4GG8Y,139,X23-37869,PVW0XnRJnsWYjTqxb6StCi2tge/uUwegjdiFaFUiZpwdJ620RK+MIAsSq5S+egXXzIWNntoy2fB6BO8F1wBFmxP/mm/3rn5C33jtF5QrbNqY7X9HMbqSiC7zhs4v4u2Xa4oZQx8JQkwr8Q2c/NgHrOJKKRASsSckhunxZ+WVEuM,1,Retail,ProfessionalCountrySpecific,Zn
eb6d346f-1c60-4643-b960-40ec31596c45,DXG7C-N36C4-C4HTG-X4T3X-2YV77,161,X21-43626,MaVqTkRrGnOqYizl15whCOKWzx01+BZTVAalvEuHXM+WV55jnIfhWmd/u1GqCd5OplqXdU959zmipK2Iwgu2nw/g91nW//sQiN/cUcvg1Lxo6pC3gAo1AjTpHmGIIf9XlZMYlD+Vl6gXsi/Auwh3yrSSFh5s7gOczZoDTqQwHXA,0,Retail,ProfessionalWorkstation
89e87510-ba92-45f6-8329-3afa905e3e83,WYPNQ-8C467-V2W6J-TX4WX-WT2RQ,162,X21-43644,JVGQowLiCcPtGY9ndbBDV+rTu/q5ljmQTwQWZgBIQsrAeQjLD8jLEk/qse7riZ7tMT6PKFVNXeWqF7PhLAmACbE8O3Lvp65XMd/Oml9Daynj5/4n7unsffFHIHH8TGyO5j7xb4dkFNqC5TX3P8/1gQEkTIdZEOTQQXFu0L2SP5c,0,Retail,ProfessionalWorkstationN
62f0c100-9c53-4e02-b886-a3528ddfe7f6,8PTT6-RNW4C-6V7J2-C2D3X-MHBPB,164,X21-04955,CEDgxI8f/fxMBiwmeXw5Of55DG32sbGALzHihXkdbYTDaE3pY37oAA4zwGHALzAFN/t254QImGPYR6hATgl+Cp804f7serJqiLeXY965Zy67I4CKIMBm49lzHLFJeDnVTjDB0wVyN29pvgO3+HLhZ22KYCpkRHFFMy2OKxS68Yc,0,Retail,ProfessionalEducation
13a38698-4a49-4b9e-8e83-98fe51110953,GJTYN-HDMQY-FRR76-HVGC7-QPF8P,165,X21-04956,r35zp9OfxKSBcTxKWon3zFtbOiCufAPo6xRGY5DJqCRFKdB0jgZalNQitvjmaZ/Rlez2vjRJnEart4LrvyW4d9rrukAjR3+c3UkeTKwoD3qBl9AdRJbXCa2BdsoXJs1WVS4w4LuVzpB/SZDuggZt0F2DlMB427F5aflook/n1pY,0,Retail,ProfessionalEducationN
df96023b-dcd9-4be2-afa0-c6c871159ebe,NJCF7-PW8QT-3324D-688JX-2YV66,175,X21-41295,rVpetYUmiRB48YJfCvJHiaZapJ0bO8gQDRoql+rq5IobiSRu//efV1VXqVpBkwILQRKgKIVONSTUF5y2TSxlDLbDSPKp7UHfbz17g6vRKLwOameYEz0ZcK3NTbApN/cMljHvvF/mBag1+sHjWu+eoFzk8H89k9nw8LMeVOPJRDc,0,Retail,ServerRdsh
d4ef7282-3d2c-4cf0-9976-8854e64a8d1e,V3WVW-N2PV2-CGWC3-34QGF-VMJ2C,178,X21-32983,Xzme9hDZR6H0Yx0deURVdE6LiTOkVqWng5W/OTbkxRc0rq+mSYpo/f/yqhtwYlrkBPWx16Yok5Bvcb34vbKHvEAtxfYp4te20uexLzVOtBcoeEozARv4W/6MhYfl+llZtR5efsktj4N4/G4sVbuGvZ9nzNfQO9TwV6NGgGEj2Ec,0,Retail,Cloud
af5c9381-9240-417d-8d35-eb40cd03e484,NH9J3-68WK7-6FB93-4K3DF-DJ4F6,179,X21-32987,QGRDZOU/VZhYLOSdp2xDnFs8HInNZctcQlWCIrORVnxTQr55IJwN4vK3PJHjkfRLQ/bgUrcEIhyFbANqZFUq8yD1YNubb2bjNORgI/m8u85O9V7nDGtxzO/viEBSWyEHnrzLKKWYqkRQKbbSW3ungaZR0Ti5O2mAUI4HzAFej50,0,Retail,CloudN
8ab9bdd1-1f67-4997-82d9-8878520837d9,XQQYW-NFFMW-XJPBH-K8732-CKFFD,188,X21-99378,djy0od0uuKd2rrIl+V1/2+MeRltNgW7FEeTNQsPMkVSL75NBphgoso4uS0JPv2D7Y1iEEvmVq6G842Kyt52QOwXgFWmP/IQ6Sq1dr+fHK/4Et7bEPrrGBEZoCfWqk0kdcZRPBij2KN6qCRWhrk1hX2g+U40smx/EYCLGh9HCi24,0,OEM:DM,IoTEnterprise
ed655016-a9e8-4434-95d9-4345352c2552,QPM6N-7J2WJ-P88HH-P3YRH-YY74H,191,X21-99682,qHs/PzfhYWdtSys2edzcz4h+Qs8aDqb8BIiQ/mJ/+0uyoJh1fitbRCIgiFh2WAGZXjdgB8hZeheNwHibd8ChXaXg4u+0XlOdFlaDTgTXblji8fjETzDBk9aGkeMCvyVXRuUYhTSdp83IqGHz7XuLwN2p/6AUArx9JZCoLGV8j3w,0,OEM:NONSLP,IoTEnterpriseS,VB
6c4de1b8-24bb-4c17-9a77-7b939414c298,CGK42-GYN6Y-VD22B-BX98W-J8JXD,191,X23-12617,J/fpIRynsVQXbp4qZNKp6RvOgZ/P2klILUKQguMlcwrBZybwNkHg/kM5LNOF/aDzEktbPnLnX40GEvKkYT6/qP4cMhn/SOY0/hYOkIdR34ilzNlVNq5xP7CMjCjaUYJe+6ydHPK6FpOuEoWOYYP5BZENKNGyBy4w4shkMAw19mA,0,OEM:NONSLP,IoTEnterpriseS,Ge
d4bdc678-0a4b-4a32-a5b3-aaa24c3b0f24,K9VKN-3BGWV-Y624W-MCRMQ-BHDCD,202,X22-53884,kyoNx2s93U6OUSklB1xn+GXcwCJO1QTEtACYnChi8aXSoxGQ6H2xHfUdHVCwUA1OR0UeNcRrMmOzZBOEUBtdoGWSYPg9AMjvxlxq9JOzYAH+G6lT0UbCWgMSGGrqdcIfmshyEak3aUmsZK6l+uIAFCCZZ/HbbCRkkHC5rWKstMI,0,Retail,CloudEditionN
92fb8726-92a8-4ffc-94ce-f82e07444653,KY7PN-VR6RX-83W6Y-6DDYQ-T6R4W,203,X22-53847,gD6HnT4jP4rcNu9u83gvDiQq1xs7QSujcDbo60Di5iSVa9/ihZ7nlhnA0eDEZfnoDXriRiPPqc09T6AhSnFxLYitAkOuPJqL5UMobIrab9dwTKlowqFolxoHhLOO4V92Hsvn/9JLy7rEzoiAWHhX/0cpMr3FCzVYPeUW1OyLT1A,0,Retail,CloudEdition
5a85300a-bfce-474f-ac07-a30983e3fb90,N979K-XWD77-YW3GB-HBGH6-D32MH,205,X23-15042,blZopkUuayCTgZKH4bOFiisH9GTAHG5/js6UX/qcMWWc3sWNxKSX1OLp1k3h8Xx1cFuvfG/fNAw/I83ssEtPY+A0Gx1JF4QpRqsGOqJ5ruQ2tGW56CJcCVHkB+i46nJAD759gYmy3pEYMQbmpWbhLx3MJ6kvwxKfU+0VCio8k50,0,OEM:DM,IoTEnterpriseSK
80083eae-7031-4394-9e88-4901973d56fe,P8Q7T-WNK7X-PMFXY-VXHBG-RRK69,206,X23-62084,habUJ0hhAG0P8iIKaRQ74/wZQHyAdFlwHmrejNjOSRG08JeqilJlTM6V8G9UERLJ92/uMDVHIVOPXfN8Zdh8JuYO8oflPnqymIRmff/pU+Gpb871jV2JDA4Cft5gmn+ictKoN4VoSfEZRR+R5hzF2FsoCExDNNw6gLdjtiX94uA,0,OEM:DM,IoTEnterpriseK
'@
$customObjectArray = $hashTable | ConvertFrom-Csv

# Pre Defined Extract system file's
$PreDefinedXt = @(
  "** ERROR:"
  "** Registry-WMI"
  "** Interface-Com"
  "** Kernel-Policies"
  "** Active License Info"
  "X:\sources\product.ini",
  "X:\sources\winsetup.dll",
  "X:\sources\setupcore.dll",
  "X:\sources\gatherosstate.exe",
  "C:\Windows\System32\ClipUp.exe",
  "C:\Windows\System32\clipwinrt.dll",
  "C:\Windows\System32\pkeyhelper.dll",
  "C:\Windows\System32\gatherosstate.exe",
  "C:\Windows\System32\oobe\winsetup.dll",
  "C:\Windows\System32\LicensingWinRT.dll",
  "C:\Windows\System32\Dism\TransmogProvider.dll",
  "C:\Program Files\Microsoft Office\root\Office16\protocolhandler.exe",
  "C:\Program Files\Common Files\microsoft shared\ClickToRun\OfficeClickToRun.exe",
  "C:\Program Files\Microsoft Office\root\vfs\ProgramFilesCommonX64\Microsoft Shared\Office16\Mso20win32client.dll",
  "C:\Program Files\Microsoft Office\root\vfs\ProgramFilesCommonX64\Microsoft Shared\Office16\Mso30win32client.dll",
  "C:\Program Files\Microsoft Office\root\vfs\ProgramFilesCommonX64\Microsoft Shared\Office16\Mso98win32client.dll",
  "C:\Program Files\Microsoft Office\root\vfs\ProgramFilesCommonX86\Microsoft Shared\Office16\Mso20win32client.dll",
  "C:\Program Files\Microsoft Office\root\vfs\ProgramFilesCommonX86\Microsoft Shared\Office16\Mso30win32client.dll",
  "C:\Program Files\Microsoft Office\root\vfs\ProgramFilesCommonX86\Microsoft Shared\Office16\Mso98win32client.dll"
)

# Define your list of SKUs
$keys = @(
    "ServerHyper", "ServerStandardEvalCorCore", "ServerTurbine",
    "ServerTurbineCore", "analogonecore", "andromeda", "business", "businessn", "cloud",
    "cloude", "cloudedition", "cloudeditionn", "clouden", "cloudn", "connectedcar", "core", "corearm",
    "coreconnected", "coreconnectedcountryspecific", "coreconnectedn", "coreconnectedsinglelanguage",
    "corecountryspecific", "coren", "coresinglelanguage", "coresystemserver", "durangohostos", "education", "educationn", "embedded", "embeddeda",
    "embeddedautomotive", "embeddede", "embeddedeeval", "embeddedeval", "embeddedindustry", "embeddedindustrya", "embeddedindustryae", "embeddedindustrye",
    "embeddedindustryeeval", "embeddedindustryeval", "enterprise", "enterprisee", "enterpriseeval", "enterpriseg", "enterprisegn", "enterprisen", "enterpriseneval",
    "enterprises", "enterpriseseval", "enterprisesn", "enterprisesneval", "enterprisesubscription",
    "enterprisesubscriptionn", "gamecorexbox", "gameos", "gvlkServerDatacenter", "gvlkServerDatacenterCore",
    "gvlkServerTurbine", "gvlkServerTurbineCore", "gvlkcloudedition", "gvlkcloudeditionn", "gvlkcore",
    "gvlkcorecountryspecific", "gvlkcoren", "gvlkcoresinglelanguage", "gvlkeducation", "gvlkeducationn", "gvlkenterprise", "gvlkenterpriseg",
    "gvlkenterprisegn", "gvlkenterprisen", "gvlkenterprises", "gvlkenterprisesn", "gvlkiotenterprises", "gvlkprofessional", "gvlkprofessionaleducation", "gvlkprofessionaleducationn",
    "gvlkprofessionaln", "gvlkprofessionalworkstation", "gvlkprofessionalworkstationn", "gvlkserverazurecor",
    "gvlkserverazurecorCore", "gvlkserverrdsh", "gvlkserverrdshCore", "gvlkserverstandard", "gvlkserverstandardCore", "holographic", "homebasic", "homebasice",
    "homebasicn", "homepremium", "homepremiume", "homepremiumn", "hubos", "industryhandheld",
    "iotedgeos", "iotenterprise", "iotenterprisek", "iotenterprises", "iotenterpriseseval", "iotenterprisesk",
    "iotos", "iotuap", "lite", "onecoreupdateos", "ppipro", "professional",
    "professionalcountryspecific", "professionale", "professionaleducation", "professionaleducationn", "professionalembedded",
    "professionaln", "professionals", "professionalsinglelanguage", "professionalsn", "professionalstudent",
    "professionalstudentn", "professionalwmc", "professionalworkstation", "professionalworkstationn", "scarletthostos",
    "serverarm64", "serverazurecor", "serverazurecorCore", "serverazurenano", "serverazurenanoCore", "serverazurestackhcicor",
    "serverazurestackhcicorCore", "servercloudstorage", "serverdatacenter", "serverdatacenteracor",
    "serverdatacentercor", "serverdatacentercorCore", "serverdatacentercore", "serverdatacentereval", "serverdatacenterevalCore",
    "serverdatacenterevalcor", "serverdatacenterevalcorCore", "serverdatacenternano", "serverdatacenternanoCore", "serverdatacenterv",
    "serverdatacentervcore", "serverembeddedsolution", "serverembeddedsolutioncore", "serverenterprise",
    "serverenterprisecore", "serverenterpriseia64", "serverenterprisev", "serverenterprisevcore",
    "serveressentialadditional", "serveressentialadditionalsvc", "serveressentialmanagement", "serveressentialmanagementsvc",
    "serverforsbsolutions", "serverforsbsolutionsem", "serverhi", "serverhomepremium",
    "serverhomestandard", "serverhpc", "serverhpcv",
    "serverhypercore", "servermediumbusinessmanagement", "servermediumbusinessmessaging", "servermediumbusinesssecurity",
    "servermultipointpremium", "servermultipointstandard", "serverrdsh", "serverrdshCore", "serversbspremium",
    "serversbspremiumcore", "serversbsstandard", "serversolution", "serversolutionem", "serversolutionspremium", "serversolutionspremiumcore",
    "serverstandard", "serverstandardCore", "serverstandardacor", "serverstandardcor", "serverstandardcorCore",
    "serverstandardcore", "serverstandardeval", "serverstandardevalcor", "serverstandardnano", "serverstandardnanoCore",
    "serverstandardv", "serverstandardvcore", "serverstorageenterprise", "serverstorageenterprisecore", "serverstorageexpress",
    "serverstorageexpresscore", "serverstoragestandard", "serverstoragestandardcore", "serverstoragestandardeval",
    "serverstorageworkgroup", "serverstorageworkgroupcore", "serverstorageworkgroupeval", "serverturbinecor", "serverturbinecorCore", "serverweb",
    "serverwebCore", "serverwebcore", "serverwinfoundation", "serverwinsb", "serverwinsbv", "starter",
    "startere", "startern", "systemos", "thinpc", "ultimate",
    "ultimatee", "ultimaten", "utilityvm", "wnc", "xboxnativeos"
)

# Add predefined locations
$predefinedLocations = @(
    "-------------------------- BASE LOCATION -------------------------------"
    "$env:windir\System32\spp\tokens\pkeyconfig\pkeyconfig.xrm-ms",
    "$env:windir\Syswow64\spp\tokens\pkeyconfig\pkeyconfig.xrm-ms",
    "$env:ProgramFiles\Microsoft Office\root\Licenses16\pkeyconfig-office.xrm-ms",
    "-------------------------- MORE LOCATION -------------------------------"
	"$env:windir\System32\spp\tokens\pkeyconfig\pkeyconfig-csvlk.xrm-ms",
    "$env:windir\Syswow64\spp\tokens\pkeyconfig\pkeyconfig-csvlk.xrm-ms"
    "$env:windir\System32\spp\tokens\pkeyconfig\pkeyconfig-downlevel.xrm-ms",
    "$env:windir\Syswow64\spp\tokens\pkeyconfig\pkeyconfig-downlevel.xrm-ms"
)

# CRC32 table
$crc32_table = (
    0x0,
    0x04c11db7, 0x09823b6e, 0x0d4326d9, 0x130476dc, 0x17c56b6b,
    0x1a864db2, 0x1e475005, 0x2608edb8, 0x22c9f00f, 0x2f8ad6d6,
    0x2b4bcb61, 0x350c9b64, 0x31cd86d3, 0x3c8ea00a, 0x384fbdbd,
    0x4c11db70, 0x48d0c6c7, 0x4593e01e, 0x4152fda9, 0x5f15adac,
    0x5bd4b01b, 0x569796c2, 0x52568b75, 0x6a1936c8, 0x6ed82b7f,
    0x639b0da6, 0x675a1011, 0x791d4014, 0x7ddc5da3, 0x709f7b7a,
    0x745e66cd, 0x9823b6e0, 0x9ce2ab57, 0x91a18d8e, 0x95609039,
    0x8b27c03c, 0x8fe6dd8b, 0x82a5fb52, 0x8664e6e5, 0xbe2b5b58,
    0xbaea46ef, 0xb7a96036, 0xb3687d81, 0xad2f2d84, 0xa9ee3033,
    0xa4ad16ea, 0xa06c0b5d, 0xd4326d90, 0xd0f37027, 0xddb056fe,
    0xd9714b49, 0xc7361b4c, 0xc3f706fb, 0xceb42022, 0xca753d95,
    0xf23a8028, 0xf6fb9d9f, 0xfbb8bb46, 0xff79a6f1, 0xe13ef6f4,
    0xe5ffeb43, 0xe8bccd9a, 0xec7dd02d, 0x34867077, 0x30476dc0,
    0x3d044b19, 0x39c556ae, 0x278206ab, 0x23431b1c, 0x2e003dc5,
    0x2ac12072, 0x128e9dcf, 0x164f8078, 0x1b0ca6a1, 0x1fcdbb16,
    0x018aeb13, 0x054bf6a4, 0x0808d07d, 0x0cc9cdca, 0x7897ab07,
    0x7c56b6b0, 0x71159069, 0x75d48dde, 0x6b93dddb, 0x6f52c06c,
    0x6211e6b5, 0x66d0fb02, 0x5e9f46bf, 0x5a5e5b08, 0x571d7dd1,
    0x53dc6066, 0x4d9b3063, 0x495a2dd4, 0x44190b0d, 0x40d816ba,
    0xaca5c697, 0xa864db20, 0xa527fdf9, 0xa1e6e04e, 0xbfa1b04b,
    0xbb60adfc, 0xb6238b25, 0xb2e29692, 0x8aad2b2f, 0x8e6c3698,
    0x832f1041, 0x87ee0df6, 0x99a95df3, 0x9d684044, 0x902b669d,
    0x94ea7b2a, 0xe0b41de7, 0xe4750050, 0xe9362689, 0xedf73b3e,
    0xf3b06b3b, 0xf771768c, 0xfa325055, 0xfef34de2, 0xc6bcf05f,
    0xc27dede8, 0xcf3ecb31, 0xcbffd686, 0xd5b88683, 0xd1799b34,
    0xdc3abded, 0xd8fba05a, 0x690ce0ee, 0x6dcdfd59, 0x608edb80,
    0x644fc637, 0x7a089632, 0x7ec98b85, 0x738aad5c, 0x774bb0eb,
    0x4f040d56, 0x4bc510e1, 0x46863638, 0x42472b8f, 0x5c007b8a,
    0x58c1663d, 0x558240e4, 0x51435d53, 0x251d3b9e, 0x21dc2629,
    0x2c9f00f0, 0x285e1d47, 0x36194d42, 0x32d850f5, 0x3f9b762c,
    0x3b5a6b9b, 0x0315d626, 0x07d4cb91, 0x0a97ed48, 0x0e56f0ff,
    0x1011a0fa, 0x14d0bd4d, 0x19939b94, 0x1d528623, 0xf12f560e,
    0xf5ee4bb9, 0xf8ad6d60, 0xfc6c70d7, 0xe22b20d2, 0xe6ea3d65,
    0xeba91bbc, 0xef68060b, 0xd727bbb6, 0xd3e6a601, 0xdea580d8,
    0xda649d6f, 0xc423cd6a, 0xc0e2d0dd, 0xcda1f604, 0xc960ebb3,
    0xbd3e8d7e, 0xb9ff90c9, 0xb4bcb610, 0xb07daba7, 0xae3afba2,
    0xaafbe615, 0xa7b8c0cc, 0xa379dd7b, 0x9b3660c6, 0x9ff77d71,
    0x92b45ba8, 0x9675461f, 0x8832161a, 0x8cf30bad, 0x81b02d74,
    0x857130c3, 0x5d8a9099, 0x594b8d2e, 0x5408abf7, 0x50c9b640,
    0x4e8ee645, 0x4a4ffbf2, 0x470cdd2b, 0x43cdc09c, 0x7b827d21,
    0x7f436096, 0x7200464f, 0x76c15bf8, 0x68860bfd, 0x6c47164a,
    0x61043093, 0x65c52d24, 0x119b4be9, 0x155a565e, 0x18197087,
    0x1cd86d30, 0x029f3d35, 0x065e2082, 0x0b1d065b, 0x0fdc1bec,
    0x3793a651, 0x3352bbe6, 0x3e119d3f, 0x3ad08088, 0x2497d08d,
    0x2056cd3a, 0x2d15ebe3, 0x29d4f654, 0xc5a92679, 0xc1683bce,
    0xcc2b1d17, 0xc8ea00a0, 0xd6ad50a5, 0xd26c4d12, 0xdf2f6bcb,
    0xdbee767c, 0xe3a1cbc1, 0xe760d676, 0xea23f0af, 0xeee2ed18,
    0xf0a5bd1d, 0xf464a0aa, 0xf9278673, 0xfde69bc4, 0x89b8fd09,
    0x8d79e0be, 0x803ac667, 0x84fbdbd0, 0x9abc8bd5, 0x9e7d9662,
    0x933eb0bb, 0x97ffad0c, 0xafb010b1, 0xab710d06, 0xa6322bdf,
    0xa2f33668, 0xbcb4666d, 0xb8757bda, 0xb5365d03, 0xb1f740b4
);
$crc32_table = $crc32_table | % {
    $value = $_
    if ($value -lt 0) {
        $value += 0x100000000
    }
    [uint32]($value -band 0xFFFFFFFF)
}

# product.ini [SOURCES\PRODUCT.INI + from uupdump release's]
# Windows Keys: winsetup.dll, pkeyhelper.dll, LicensingWinRT.dll, TransmogProvider.dll
# Windows Keys: ClipUp.exe, clipwinrt.dll
# Office Keys: -> OfficeClickToRun.exe, protocolhandler,
# Office Keys: -> Mso20win32client.dll, Mso98win32client.dll, Mso20win32client.dll, Mso98win32client.dll

# https://learn.microsoft.com/en-us/office/volume-license-activation/gvlks
# https://learn.microsoft.com/en-us/windows-server/get-started/kms-client-activation-keys
# https://learn.microsoft.com/en-us/previous-versions/windows/it-pro/windows-server-2012-r2-and-2012/jj612867(v=ws.11)

# KMS_VL_ALL by [abbodi1406].
# Change edition by [Windows Addict].

# https://blog.03k.org/post/gvlk.html
# https://py-kms.readthedocs.io/en/latest/Keys.html
# https://gist.github.com/rvrsh3ll/0810c6ed60e44cf7932e4fbae25880df
# https://github.com/YerongAI/Office-Tool/blob/main/doc/Tech%20Articles/Products.md

# validation function
# $KeysRef.GetEnumerator() | % { $res = keyinfo ($_).Value | select-string ($_).key; if (-not $res) {($_).Value} }

# Create a hash table for key-ref pairs with integer references
$KeysText = @{
    20 = "RTM_HomeStudent_Retail"
	22 = "RTM_HomeBusinessDemo_BypassTrial"
	30 = "RTM_Professional_Trial"
	52 = "RTM_HomeStudent_OEM_Perp3"
	54 = "RTM_HomeBusiness_Retail3"
	56 = "RTM_Professional_Trial2"
	58 = "RTM_HSOneNote_SubPrepid"
	60 = "RTM_VisioPro_SubPrepid"
	62 = "RTM_VisioStd_Retail"
	74 = "RTM_ProjectPro_Retail"
	76 = "RTM_PowerPoint_Retail"
	78 = "RTM_ProfessionalAcad_Trial"
	96 = "RTM_Groove_Retail"
	98 = "RTM_ProjectStd_KMS_Client"
	138 = "RTM_Groove_KMS_Client"
	140 = "RTM_ProPlusSub_Subscription2"
	142 = "Vista OCUR Retail"
	150 = "Embedded Standard Retail Prem Edtn Eval OEM"
	152 = "ServerHyper, Hyper-V ProdAct All Programs"
	156 = "Windows Small Business Server 2011 Essentials ServerSolution OEM:NONSLP"
	164 = "Windows Home Server 2011 SERVERHOMEPREMIUM OEM:SLP"
	168 = "Server 2008 R2 Std and Ent Volume:CSVLK (KMS_B)"
	170 = "OCUR, Windows 7 OCUR Retail"
	172 = "Windows 7 All Volume Editions Volume:CSVLK"
	174 = "Windows 7 Home Premium OEM:NONSLP"
	176 = "Windows 7 HomePremiumE OEM:NONSLP"
	178 = "Windows Embedded Standard Extended Security Updates add-on Volume:MAK"
	180 = "Windows 7 ProfessionalE OEM:NONSLP"
	182 = "Windows 7 Ultimate OEM:NONSLP"
	184 = "Windows 7 Professional OEM:COA"
	186 = "Windows 7 ProfessionalE OEM:COA"
	188 = "Windows 7 Ultimate OEM:COA"
	190 = "Windows 7 StarterE OEM:COA"
	192 = "Windows 7 HomeBasicE OEM:COA"
	194 = "Windows 7 Starter OEM:COA"
	196 = "Windows 7 Home Premium OEM:COA"
	198 = "Windows 7 Home Premium OEM:COA"
	204 = "WinNext Beta Prerelease;PrereleaseN;PrereleaseARM;Enterprise;EnterpriseN;Professional;ProfessionalN Volume:CSVLK"
	206 = "Office15_KMSHostVL_KMS_Host"
	208 = "Server 2008 R2 SP1 Std and Ent Volume:MAK (MAK_B)"
	212 = "Windows 7 SP1 Professional;ProfessionalN;Enterprise;EnterpriseN Volume:MAK"
	1034 = "Win Next HomePremium OEM:DM"
	1035 = "Win Next HomePremium OEM:SLP"
	1036 = "Win Next HomePremium OEM:NONSLP"
	1037 = "Win Next HomePremium OEM:COA"
	1038 = "Win Next Professional OEM:DM"
	1039 = "Win Next Professional OEM:SLP"
	1040 = "Win Next Professional OEM:NONSLP"
	1041 = "Win Next Professional OEM:COA"
	1042 = "WinServer Next ServerDatacenter OEM:DM"
	1043 = "WinServer Next ServerDatacenter OEM:SLP"
	1044 = "WinServer Next ServerDatacenter OEM:NONSLP"
	1045 = "WinServer Next ServerDatacenter OEM:COA"
	1046 = "WinServer Next ServerEnterprise OEM:DM"
	1047 = "WinServer Next ServerEnterprise OEM:SLP"
	1048 = "WinServer Next ServerEnterprise OEM:NONSLP"
	1049 = "WinServer Next ServerEnterprise OEM:COA"
	1050 = "WinServer Next ServerWinFoundation OEM:DM"
	1051 = "WinServer Next ServerWinFoundation OEM:SLP"
	1052 = "WinServer Next ServerWinFoundation OEM:NONSLP"
	1053 = "WinServer Next ServerWinFoundation OEM:COA"
	1054 = "WinServer Next ServerStandard OEM:DM"
	1055 = "WinServer Next ServerStandard OEM:SLP"
	1056 = "WinServer Next ServerStandard OEM:NONSLP"
	1057 = "WinServer Next ServerStandard OEM:COA"
	1058 = "ServerWeb, WinServer Next ServerWeb OEM:DM"
	1059 = "ServerWeb, WinServer Next ServerWeb OEM:SLP"
	1060 = "ServerWeb, WinServer Next ServerWeb OEM:NONSLP"
	1061 = "ServerWeb, WinServer Next ServerWeb OEM:COA"
	1062 = "Win Next Ultimate OEM:DM"
	1063 = "Win Next Ultimate OEM:SLP"
	1064 = "Win Next Ultimate OEM:NONSLP"
	1065 = "Win Next Ultimate OEM:COA"
	1066 = "WinNext Beta Prerelease OEM:DM"
	1067 = "WinNext Beta PrereleaseARM OEM:DM"
	1068 = "WinServer Next ServerStorageWorkgroup OEM:DM"
	1069 = "WinServer Next ServerStorageStandard OEM:DM"
	1070 = "WinServer Next ServerHPC OEM:DM"
	1071 = "WinServer Next ServerMultiPointStandard OEM:DM"
	1072 = "WinServer Next ServerMultiPointPremium OEM:DM"
	1073 = "WinServerSolutions Next ServerSolution OEM:DM"
	1074 = "WinServerSolutions Next ServerSolutionsPremium OEM:DM"
	1076 = "CoreARM, Win 8 RC CoreARM OEM:DM"
	1077 = "Core, Win 8 RC Core OEM:DM"
	1078 = "CoreCountrySpecific, Win 8 RC CoreCountrySpecific OEM:DM"
	1079 = "CoreN, Win 8 RC CoreN OEM:DM"
	1080 = "CoreSingleLanguage, Win 8 RC CoreSingleLanguage OEM:DM"
	1081 = "Professional, Win 8 RC Professional OEM:DM"
	1082 = "ProfessionalN, Win 8 RC ProfessionalN OEM:DM"
	1277 = "WinNext Beta Prerelease OEM:NONSLP"
	1278 = "WinNext Beta Prerelease Retail"
	1279 = "WinNext Beta Prerelease Volume:GVLK"
	1280 = "WinNext Beta PrereleaseN Retail"
	1281 = "WinNext Beta PrereleaseARM OEM:NONSLP"
	1282 = "WinNext Beta PrereleaseARM Retail"
	1283 = "WinNext Beta PrereleaseARM Volume:GVLK"
	1284 = "WinNext Beta EnterpriseEval Retail:TB:Eval"
	1285 = "WinNext Beta EnterpriseNEval Retail:TB:Eval"
	1286 = "WinNext Beta Ultimate Retail"
	1287 = "WinNext Beta Professional Retail"
	1289 = "WinServer Next ServerStandardEval Retail:TB:Eval"
	1290 = "WinServer Next ServerDatacenterEval Retail:TB:Eval"
	1291 = "WinServer Next ServerStorageWorkgroup Retail:TB:Eval"
	1292 = "WinServer Next ServerStorageWorkgroup OEM:SLP"
	1293 = "WinServer Next ServerStorageWorkgroup OEM:NONSLP"
	1294 = "WinServer Next ServerStorageWorkgroup OEM:COA"
	1295 = "WinServer Next ServerStorageStandard Retail:TB:Eval"
	1296 = "WinServer Next ServerStorageStandard OEM:SLP"
	1297 = "WinServer Next ServerStorageStandard OEM:NONSLP"
	1298 = "WinServer Next ServerStorageStandard OEM:COA"
	1299 = "WinServer Next ServerHPC Retail:TB:Eval"
	1300 = "WinServer Next ServerHPC OEM:SLP"
	1301 = "WinServer Next ServerHPC OEM:NONSLP"
	1302 = "WinServer Next ServerHPC OEM:COA"
	1303 = "WinServer Next ServerHPC Volume:MAK"
	1304 = "WinServer Next ServerHPC Volume:GVLK"
	1305 = "WinServer Next ServerMultiPointStandard Retail:TB:Eval"
	1306 = "WinServer Next ServerMultiPointStandard OEM:SLP"
	1307 = "WinServer Next ServerMultiPointStandard OEM:NONSLP"
	1308 = "WinServer Next ServerMultiPointStandard OEM:COA"
	1309 = "WinServer Next ServerMultiPointStandard Volume:MAK"
	1310 = "WinServer Next ServerMultiPointStandard Volume:GVLK"
	1311 = "WinServer Next ServerMultiPointPremium Retail:TB:Eval"
	1312 = "WinServer Next ServerMultiPointPremium OEM:SLP"
	1313 = "WinServer Next ServerMultiPointPremium OEM:NONSLP"
	1314 = "WinServer Next ServerMultiPointPremium OEM:COA"
	1315 = "WinServer Next ServerMultiPointPremium Volume:MAK"
	1316 = "WinServer Next ServerMultiPointPremium Volume:GVLK"
	1318 = "WinServerSolutions Next ServerSolution Retail"
	1319 = "WinServerSolutions Next ServerSolution Retail:TB:Eval"
	1320 = "WinServerSolutions Next ServerSolution OEM:SLP"
	1321 = "WinServerSolutions Next ServerSolution OEM:NONSLP"
	1322 = "WinServerSolutions Next ServerSolution OEM:COA"
	1323 = "WinServerSolutions Next ServerSolution Volume:MAK"
	1324 = "WinServerSolutions Next ServerSolutionsPremium Retail"
	1325 = "WinServerSolutions Next ServerSolutionsPremium Retail:TB:Eval"
	1326 = "WinServerSolutions Next ServerSolutionsPremium OEM:SLP"
	1327 = "WinServerSolutions Next ServerSolutionsPremium OEM:NONSLP"
	1328 = "WinServerSolutions Next ServerSolutionsPremium OEM:COA"
	1329 = "WinServerSolutions Next ServerSolutionsPremium Volume:MAK"
	1333 = "WinServer Next ServerDatacenter Retail"
	1334 = "WinServer Next ServerDatacenter Retail:TB:Eval"
	1335 = "WinServer Next ServerDatacenter Volume:MAK"
	1336 = "WinServer Next ServerDatacenter Volume:GVLK"
	1337 = "WinServer Next ServerEnterprise Retail"
	1338 = "WinServer Next ServerEnterprise Retail:TB:Eval"
	1339 = "WinServer Next ServerEnterprise Volume:GVLK"
	1340 = "WinServer Next ServerWinFoundation Retail:TB:Eval"
	1341 = "WinServer Next ServerStandard Retail"
	1342 = "WinServer Next ServerStandard Retail:TB:Eval"
	1343 = "WinServer Next ServerStandard Volume:GVLK"
	1344 = "WinServer Next ServerStandard;ServerEnterprise Volume:MAK"
	1345 = "ServerWeb, WinServer Next ServerWeb Retail"
	1346 = "ServerWeb, WinServer Next ServerWeb Retail:TB:Eval"
	1347 = "ServerWeb, WinServer Next ServerWeb Volume:MAK"
	1348 = "ServerWeb, WinServer Next ServerWeb Volume:GVLK"
	1349 = "ServerHomeStandard, WinServerSolutions Next ServerHomeStandard Retail"
	1350 = "ServerHomeStandard, WinServerSolutions Next ServerHomeStandard OEM:SLP"
	1351 = "ServerHomeStandard, WinServerSolutions Next ServerHomeStandard OEM:NONSLP"
	1352 = "APPXLOB, WinNext Beta APPXLOB Volume:MAK"
	1353 = "Embedded, Cassini Platform 8 Pre-Beta Embedded Retail"
	1354 = "Embedded, Cassini Platform 8 Pre-Beta Embedded Retail"
	1355 = "Embedded, Cassini Platform 8 Pre-Beta Embedded Retail"
	1356 = "Embedded, Cassini Platform 8 Pre-Beta Embedded Retail"
	1357 = "Embedded, Cassini Platform 8 Pre-Beta Embedded Retail"
	1361 = "CoreARM, Win 8 RC CoreARM OEM:NONSLP"
	1362 = "Core, Win 8 RC Core OEM:NONSLP"
	1363 = "CoreCountrySpecific, Win 8 RC CoreCountrySpecific OEM:NONSLP"
	1364 = "CoreN, Win 8 RC CoreN OEM:NONSLP"
	1365 = "CoreSingleLanguage, Win 8 RC CoreSingleLanguage OEM:NONSLP"
	1366 = "Professional, Win 8 RC Professional OEM:NONSLP"
	1367 = "ProfessionalN, Win 8 RC ProfessionalN OEM:NONSLP"
	1368 = "Core, Win 8 RC Core Retail"
	1369 = "CoreN, Win 8 RC CoreN Retail"
	1371 = "Professional, Win 8 RC Professional Retail"
	1372 = "ProfessionalN, Win 8 RC ProfessionalN Retail"
	1373 = "ProfessionalWMC, Win 8 RC ProfessionalWMC Retail"
	1374 = "CoreARM, Win 8 RC CoreARM Retail"
	1375 = "Enterprise, Win 8 RC Enterprise Retail"
	1376 = "EnterpriseN, Win 8 RC EnterpriseN Retail"
	1377 = "CoreCountrySpecific, Win 8 RC CoreCountrySpecific Retail"
	1378 = "CoreSingleLanguage, Win 8 RC CoreSingleLanguage Retail"
	1379 = "EnterpriseEval, Win 8 RC EnterpriseEval Retail:TB:Eval"
	1380 = "EnterpriseNEval, Win 8 RC EnterpriseNEval Retail:TB:Eval"
	1381 = "Professional;ProfessionalN;Enterprise;EnterpriseN, Win 8 RC Professional;ProfessionalN;Enterprise;EnterpriseN Volume:MAK"
	1777 = "Win 8 RTM CoreN Retail"
	1778 = "Win 8 RTM Core Retail"
	1780 = "Win 8 RTM ProfessionalN Retail"
	1781 = "Win 8 RTM Professional Retail"
	1782 = "Win 8 RTM ProfessionalWMC Retail"
	1783 = "EnterpriseNEval, Win 8 RTM EnterpriseNEval Retail:TB:Eval"
	1784 = "EnterpriseEval, Win 8 RTM EnterpriseEval Retail:TB:Eval"
	1785 = "Win 8 RTM Professional;ProfessionalN;Enterprise;EnterpriseN Volume:MAK"
	1786 = "ProfessionalN, Win 8 RTM ProfessionalN Volume:GVLK"
	1787 = "Professional, Win 8 RTM Professional Volume:GVLK"
	1788 = "EnterpriseN, Win 8 RTM EnterpriseN Volume:GVLK"
	1789 = "Enterprise, Win 8 RTM Enterprise Volume:GVLK"
	1790 = "CoreN, Win 8 RTM CoreN OEM:DM"
	1791 = "CoreN, Win 8 RTM CoreN OEM:NONSLP"
	1792 = "CoreCountrySpecific, Win 8 RTM CoreCountrySpecific OEM:DM"
	1793 = "Win 8 RTM CoreCountrySpecific OEM:NONSLP"
	1794 = "CoreSingleLanguage, Win 8 RTM CoreSingleLanguage OEM:DM"
	1795 = "CoreSingleLanguage, Win 8 RTM CoreSingleLanguage OEM:NONSLP"
	1796 = "Win 8 RTM Core OEM:DM"
	1797 = "Core, Win 8 RTM Core OEM:NONSLP"
	1798 = "ProfessionalN, Win 8 RTM ProfessionalN OEM:DM"
	1799 = "ProfessionalN, Win 8 RTM ProfessionalN OEM:NONSLP"
	1801 = "Win 8 RTM Professional OEM:DM"
	1802 = "Professional, Win 8 RTM Professional OEM:NONSLP"
	1805 = "APPXLOB-Client, Win 8 RTM APPXLOB-Client Volume:MAK"
	1807 = "Win 8 RTM ProfessionalN Retail"
	1808 = "Win 8 RTM Professional Retail"
	1809 = "Win 8 RTM ProfessionalWMC Retail"
	1810 = "Win 8 RTM ProfessionalWMC Retail"
	1812 = "ServerMultiPointStandard, MultiPoint Server 2012 RTM ServerMultiPointStandard OEM:SLP"
	1813 = "ServerMultiPointStandard, MultiPoint Server 2012 RTM ServerMultiPointStandard OEM:NONSLP"
	1814 = "ServerMultiPointStandard, MultiPoint Server 2012 RTM ServerMultiPointStandard Volume:GVLK"
	1815 = "ServerMultiPointStandard, MultiPoint Server 2012 RTM ServerMultiPointStandard Retail"
	1816 = "ServerMultiPointStandard, MultiPoint Server 2012 RTM ServerMultiPointStandard Retail:TB:Eval"
	1817 = "ServerMultiPointStandard, MultiPoint Server 2012 RTM ServerMultiPointStandard Volume:MAK"
	1818 = "ServerMultiPointPremium, MultiPoint Server 2012 RTM ServerMultiPointPremium OEM:SLP"
	1819 = "ServerMultiPointPremium, MultiPoint Server 2012 RTM ServerMultiPointPremium OEM:NONSLP"
	1820 = "ServerMultiPointPremium, MultiPoint Server 2012 RTM ServerMultiPointPremium Volume:GVLK"
	1821 = "ServerMultiPointPremium, MultiPoint Server 2012 RTM ServerMultiPointPremium Retail"
	1822 = "ServerMultiPointPremium, MultiPoint Server 2012 RTM ServerMultiPointPremium Retail:TB:Eval"
	1823 = "ServerMultiPointPremium, MultiPoint Server 2012 RTM ServerMultiPointPremium Volume:MAK"
	1824 = "ServerMultiPointStandard, MultiPoint Server 2012 RTM ServerMultiPointStandard OEM:SLP (MUI locked to zh-CN)"
	1825 = "ServerMultiPointStandard, MultiPoint Server 2012 RTM ServerMultiPointStandard OEM:NONSLP (MUI locked to zh-CN)"
	1826 = "ServerMultiPointPremium, MultiPoint Server 2012 RTM ServerMultiPointPremium OEM:SLP (MUI locked to zh-CN)"
	1827 = "ServerMultiPointPremium, MultiPoint Server 2012 RTM ServerMultiPointPremium OEM:NONSLP (MUI locked to zh-CN)"
	1828 = "ServerStorageStandard, Storage Server 2012 RTM ServerStorageStandard OEM:SLP"
	1829 = "ServerStorageStandard, Storage Server 2012 RTM ServerStorageStandard OEM:NONSLP"
	1830 = "ServerStorageStandard, Storage Server 2012 RTM ServerStorageStandard Retail"
	1831 = "ServerStorageStandard, Storage Server 2012 RTM ServerStorageStandard Volume:MAK"
	1832 = "ServerStorageStandardEval, Storage Server 2012 RTM ServerStorageStandardEval Retail:TB:Eval"
	1833 = "ServerStorageWorkgroup, Storage Server 2012 RTM ServerStorageWorkgroup OEM:SLP"
	1834 = "ServerStorageWorkgroup, Storage Server 2012 RTM ServerStorageWorkgroup OEM:NONSLP"
	1835 = "ServerStorageWorkgroup, Storage Server 2012 RTM ServerStorageWorkgroup Retail"
	1836 = "ServerStorageWorkgroup, Storage Server 2012 RTM ServerStorageWorkgroup Volume:MAK"
	1837 = "ServerStorageWorkgroupEval, Storage Server 2012 RTM ServerStorageWorkgroupEval Retail:TB:Eval"
	1838 = "ServerStandard, Windows Server 2012 RTM ServerStandard Retail"
	1839 = "ServerStandardEval, Windows Server 2012 RTM ServerStandardEval Retail:TB:Eval"
	1840 = "ServerStandard, Windows Server 2012 RTM ServerStandard OEM:SLP"
	1841 = "ServerStandard, Windows Server 2012 RTM ServerStandard OEM:NONSLP"
	1842 = "ServerStandard, Windows Server 2012 RTM ServerStandard Volume:MAK"
	1843 = "ServerStandard, Windows Server 2012 RTM ServerStandard Volume:GVLK"
	1844 = "ServerDatacenterEval, Windows Server 2012 RTM ServerDatacenterEval Retail:TB:Eval"
	1845 = "ServerDatacenter, Windows Server 2012 RTM ServerDatacenter OEM:SLP"
	1846 = "ServerDatacenter, Windows Server 2012 RTM ServerDatacenter OEM:NONSLP"
	1847 = "ServerDatacenter, Windows Server 2012 RTM ServerDatacenter Retail"
	1848 = "ServerDatacenter, Windows Server 2012 RTM ServerDatacenter Volume:MAK"
	1849 = "ServerDatacenter, Windows Server 2012 RTM ServerDatacenter Volume:GVLK"
	1850 = "ServerWinFoundation, Windows Server 2012 RTM ServerWinFoundation OEM:SLP"
	1851 = "ServerWinFoundation, Windows Server 2012 RTM ServerWinFoundation OEM:NONSLP"
	1852 = "ServerWinFoundation, Windows Server 2012 RTM ServerWinFoundation Retail"
	1853 = "APPXLOB-Server, Windows Server 2012 RTM APPXLOB-Server Volume:MAK"
	1854 = "ServerStandard, Windows Server 2012 RTM ServerStandard OEM:SLP (MUI locked to zh-CN)"
	1855 = "ServerStandard, Windows Server 2012 RTM ServerStandard OEM:NONSLP (MUI locked to zh-CN)"
	1856 = "ServerWinFoundation, Windows Server 2012 RTM ServerWinFoundation OEM:SLP (MUI locked to zh-CN)"
	1857 = "ServerWinFoundation, Windows Server 2012 RTM ServerWinFoundation OEM:NONSLP (MUI locked to zh-CN)"
	1858 = "ServerStandard, Windows Server 2012 RTM ServerStandard Volume:MAK (MUI locked to zh-CN)"
	1859 = "ServerDatacenter, Windows Server 2012 RTM ServerDatacenter Volume:MAK (MUI locked to zh-CN)"
	1860 = "ServerSolution, Windows Server Essentials 2012 RTM ServerSolution OEM:SLP"
	1861 = "ServerSolution, Windows Server Essentials 2012 RTM ServerSolution OEM:NONSLP"
	1862 = "ServerSolution, Windows Server Essentials 2012 RTM ServerSolution Retail"
	1863 = "ServerSolution, Windows Server Essentials 2012 RTM ServerSolution Volume:MAK"
	1864 = "ServerSolution, Windows Server Essentials 2012 RTM ServerSolution Retail:TB:Eval"
	1865 = "CoreARM, Win 8 RTM CoreARM OEM:DM"
	1866 = "Embedded, Windows Embedded Standard 8 RC Embedded Retail:TB:Eval"
	1867 = "Embedded, Windows Embedded Standard 8 RC Embedded Retail"
	1868 = "Embedded, Windows Embedded Standard 8 RC Embedded Retail"
	1869 = "Embedded, Windows Embedded Standard 8 RC Embedded Retail"
	1870 = "Embedded, Windows Embedded Standard 8 RC Embedded Retail"
	1871 = "Embedded, Windows Embedded Standard 8 RC Embedded Retail"
	1872 = "Embedded, Windows Embedded Standard 8 RC Embedded Retail"
	1873 = "Embedded, Windows Embedded Standard 8 RC Embedded Retail:TB:Eval"
	1874 = "Embedded, Windows Embedded Standard 8 RC Embedded Retail:TB:Eval"
	1875 = "Embedded, Windows Embedded Standard 8 RC Embedded Retail"
	1876 = "EmbeddedA, Windows Embedded Standard 8 RC EmbeddedA Retail:TB:Eval"
	1877 = "EmbeddedA, Windows Embedded Standard 8 RC EmbeddedA Retail"
	1878 = "EmbeddedA, Windows Embedded Standard 8 RC EmbeddedA Retail"
	1879 = "EmbeddedA, Windows Embedded Standard 8 RC EmbeddedA Retail"
	1880 = "EmbeddedA, Windows Embedded Standard 8 RC EmbeddedA Retail"
	1881 = "EmbeddedA, Windows Embedded Standard 8 RC EmbeddedA Retail"
	1882 = "EmbeddedA, Windows Embedded Standard 8 RC EmbeddedA Retail:TB:Eval"
	1883 = "EmbeddedA, Windows Embedded Standard 8 RC EmbeddedA Retail:TB:Eval"
	1884 = "EmbeddedE, Windows Embedded Standard 8 RC EmbeddedE Retail:TB:Eval"
	1885 = "EmbeddedE, Windows Embedded Standard 8 RC EmbeddedE Retail"
	1886 = "EmbeddedE, Windows Embedded Standard 8 RC EmbeddedE Retail"
	1887 = "EmbeddedE, Windows Embedded Standard 8 RC EmbeddedE Retail"
	1888 = "EmbeddedE, Windows Embedded Standard 8 RC EmbeddedE Retail"
	1889 = "CoreN, Win 8 RC CoreN Volume:GVLK"
	1890 = "CoreCountrySpecific, Win 8 RC CoreCountrySpecific Volume:GVLK"
	1891 = "CoreSingleLanguage, Win 8 RC CoreSingleLanguage Volume:GVLK"
	1892 = "Core, Win 8 RC Core Volume:GVLK"
	1893 = "ProfessionalWMC, Win 8 RC ProfessionalWMC Volume:GVLK"
	1894 = "CoreARM, Win 8 RC CoreARM Retail"
	1899 = "ServerStorageStandardEval, Windows Server 2012 RC ServerStorageStandardEval Retail:TB:Eval"
	1900 = "ServerStorageWorkgroupEval, Windows Server 2012 RC ServerStorageWorkgroupEval Retail:TB:Eval"
	1901 = "CoreARM, Win 8 RC CoreARM Volume:GVLK"
	1904 = "CoreN, Win 8 RTM CoreN Volume:GVLK"
	1905 = "CoreCountrySpecific, Win 8 RTM CoreCountrySpecific Volume:GVLK"
	1906 = "CoreSingleLanguage, Win 8 RTM CoreSingleLanguage Volume:GVLK"
	1907 = "Core, Win 8 RTM Core Volume:GVLK"
	1908 = "ProfessionalWMC, Win 8 RTM ProfessionalWMC Volume:GVLK"
	1909 = "CoreARM, Win 8 RTM CoreARM Volume:GVLK"
	1910 = "CoreARM, Win 8 RTM CoreARM Retail"
	1911 = "Win 8 RTM CoreCountrySpecific Retail"
	1912 = "Win 8 RTM CoreSingleLanguage Retail"
	1913 = "CoreSingleLanguage, Win 8 RTM CoreSingleLanguage OEM:DM"
	1914 = "Win 8 RTM Core OEM:DM"
	1915 = "Win 8 RTM Professional OEM:DM"
	1916 = "EmbeddedIndustryE, Windows Embedded Industry 8 TAP-CTP"
	1917 = "EmbeddedIndustryE, Windows Embedded Industry 8 TAP-CTP"
	1918 = "EmbeddedIndustryE, Windows Embedded Industry 8 TAP-CTP"
	1919 = "EmbeddedIndustryE, Windows Embedded Industry 8 TAP-CTP"
	1920 = "EmbeddedIndustryE, Windows Embedded Industry 8 TAP-CTP"
	1921 = "Office15_O365SmallBusPremR_PIN"
	1922 = "Office15_O365HomePremR_PIN2"
	1923 = "Office15_O365HomePremR_PIN1"
	1924 = "Office15_O365HomePremR_PIN3"
	1925 = "Office15_O365HomePremR_PIN4"
	1926 = "Office15_O365HomePremR_PIN5"
	1927 = "Office15_O365HomePremR_PIN6"
	1928 = "Office15_O365HomePremR_PIN7"
	1929 = "Office15_O365HomePremR_PIN8"
	1930 = "Office15_O365HomePremR_PIN9"
	1931 = "Office15_O365HomePremR_PIN10"
	1932 = "Office15_O365HomePremR_PIN11"
	1933 = "Office15_O365HomePremR_PIN12"
	1934 = "Office15_O365HomePremR_PIN13"
	1935 = "Office15_O365HomePremR_PIN14"
	1936 = "Office15_O365HomePremR_PIN15"
	1937 = "Office15_O365HomePremR_PIN16"
	1938 = "Office15_O365HomePremR_PIN17"
	1939 = "Office15_O365HomePremR_PIN18"
	1940 = "Office15_O365HomePremR_PIN19"
	1941 = "Office15_AccessR_Grace"
	1942 = "Office15_AccessR_OEM_Perp"
	1943 = "Office15_AccessR_Retail"
	1944 = "Office15_AccessR_Trial"
	1945 = "Office15_AccessRuntimeR_Bypass"
	1946 = "Office15_AccessVL_KMS_Client"
	1947 = "Office15_AccessVL_MAK"
	1948 = "Office15_ExcelR_Grace"
	1949 = "Office15_ExcelR_OEM_Perp"
	1950 = "Office15_ExcelR_Retail"
	1951 = "Office15_ExcelR_Trial"
	1952 = "Office15_ExcelVL_KMS_Client"
	1953 = "Office15_ExcelVL_MAK"
	1954 = "Office15_GrooveR_Grace"
	1955 = "Office15_GrooveR_Retail"
	1956 = "Office15_GrooveR_Trial"
	1957 = "Office15_GrooveVL_KMS_Client"
	1958 = "Office15_GrooveVL_MAK"
	1959 = "Office15_HomeBusinessDemoR_BypassTrial180"
	1960 = "Office15_HomeBusinessR_Grace"
	1961 = "Office15_HomeBusinessR_OEM_Perp"
	1962 = "Office15_HomeBusinessR_Retail"
	1963 = "Office15_HomeBusinessR_Subscription"
	1964 = "Office15_HomeBusinessR_SubTest"
	1965 = "Office15_HomeBusinessR_SubTrial"
	1966 = "Office15_HomeBusinessR_Trial"
	1967 = "Office15_HomeStudentDemoR_BypassTrial180"
	1968 = "Office15_HomeStudentARMPreInstallR_OEM_ARM"
	1969 = "Office15_HomeStudentR_Grace"
	1970 = "Office15_HomeStudentR_OEM_Perp"
	1971 = "Office15_HomeStudentR_Retail"
	1972 = "Office15_HomeStudentR_Subscription"
	1973 = "Office15_HomeStudentR_SubTest"
	1974 = "Office15_HomeStudentR_SubTrial"
	1975 = "Office15_HomeStudentR_Trial"
	1976 = "Office15_InfoPathR_Grace"
	1977 = "Office15_InfoPathR_Retail"
	1978 = "Office15_InfoPathR_Trial"
	1979 = "Office15_InfoPathVL_KMS_Client"
	1980 = "Office15_InfoPathVL_MAK"
	1982 = "Office15_LyncEntryR_PrepidBypass"
	1983 = "Office15_LyncR_Grace"
	1984 = "Office15_LyncR_Retail"
	1985 = "Office15_LyncR_Trial"
	1986 = "Office15_LyncVDI_Bypass"
	1987 = "Office15_LyncVL_KMS_Client"
	1988 = "Office15_LyncVL_MAK"
	1989 = "Office15_MondoR_BypassTrial180"
	1990 = "Office15_MondoR_Grace"
	1991 = "Office15_MondoR_OEM_Perp"
	1992 = "Office15_MondoR_Retail"
	1993 = "Office15_MondoR_Subscription"
	1994 = "Office15_MondoR_SubTest"
	1995 = "Office15_MondoR_SubTrial"
	1996 = "Office15_MondoR_Trial"
	1997 = "Office15_MondoVL_KMS_Client"
	1998 = "Office15_MondoVL_MAK"
	1999 = "Office15_MOSS_Bypass"
	2000 = "Office15_MOSS_BypassTrial180"
	2001 = "Office15_MOSSFISEnt_Bypass"
	2002 = "Office15_MOSSFISEnt_BypassTrial180"
	2003 = "Office15_MOSSFISStd_Bypass"
	2004 = "Office15_MOSSFISStd_BypassTrial180"
	2005 = "Office15_MOSSPremium_Bypass"
	2006 = "Office15_MOSSPremium_BypassTrial180"
	2007 = "Office16_O365HomePremR_Grace"
	2008 = "Office15_O365HomePremR_Subscription1"
	2009 = "Office15_O365HomePremR_Subscription2"
	2010 = "Office15_O365HomePremR_Subscription3"
	2011 = "Office16_O365HomePremR_Subscription4"
	2012 = "Office15_O365HomePremR_Subscription5"
	2013 = "Office15_O365HomePremR_SubTest1"
	2014 = "Office15_O365HomePremR_SubTest2"
	2015 = "Office15_O365HomePremR_SubTest3"
	2016 = "Office15_O365HomePremR_SubTest4"
	2017 = "Office15_O365HomePremR_SubTest5"
	2018 = "Office15_O365HomePremR_SubTrial1"
	2019 = "Office15_O365HomePremR_SubTrial2"
	2020 = "Office15_O365HomePremR_SubTrial3"
	2021 = "Office15_O365HomePremR_SubTrial4"
	2022 = "Office15_O365HomePremR_SubTrial5"
	2023 = "Office16_O365ProPlusR_Grace"
	2024 = "Office15_O365ProPlusR_Retail"
	2025 = "Office16_O365ProPlusR_Subscription1"
	2026 = "Office15_O365ProPlusR_Subscription2"
	2027 = "Office15_O365ProPlusR_Subscription3"
	2028 = "Office15_O365ProPlusR_Subscription4"
	2029 = "Office15_O365ProPlusR_Subscription5"
	2030 = "Office15_O365ProPlusR_SubTrial1"
	2031 = "Office15_O365ProPlusR_SubTrial2"
	2032 = "Office15_O365ProPlusR_SubTrial3"
	2033 = "Office15_O365ProPlusR_SubTrial4"
	2034 = "Office15_O365ProPlusR_SubTrial5"
	2035 = "Office16_O365SmallBusPremR_Grace"
	2036 = "Office15_O365SmallBusPremR_Retail"
	2037 = "Office15_O365SmallBusPremR_Subscription1"
	2038 = "Office15_O365SmallBusPremR_Subscription2"
	2039 = "Office15_O365SmallBusPremR_Subscription3"
	2040 = "Office15_O365SmallBusPremR_Subscription4"
	2041 = "Office15_O365SmallBusPremR_Subscription5"
	2042 = "Office15_O365SmallBusPremR_SubTrial1"
	2043 = "Office15_O365SmallBusPremR_SubTrial2"
	2044 = "Office15_O365SmallBusPremR_SubTrial3"
	2045 = "Office15_O365SmallBusPremR_SubTrial4"
	2046 = "Office15_O365SmallBusPremR_SubTrial5"
	2047 = "Office15_OfficeLPK_Bypass"
	2050 = "Office15_OneNoteR_Grace"
	2051 = "Office15_OneNoteR_OEM_Perp"
	2052 = "Office15_OneNoteR_Retail"
	2053 = "Office15_OneNoteR_Trial"
	2054 = "Office15_OneNoteVL_KMS_Client"
	2055 = "Office15_OneNoteVL_MAK"
	2056 = "Office15_OutlookR_Grace"
	2057 = "Office15_OutlookR_OEM_Perp"
	2058 = "Office15_OutlookR_Retail"
	2059 = "Office15_OutlookR_Trial"
	2060 = "Office15_OutlookVL_KMS_Client"
	2061 = "Office15_OutlookVL_MAK"
	2062 = "Office15_PersonalDemoR_BypassTrial180"
	2063 = "Office15_PersonalR_Grace"
	2064 = "Office15_PersonalR_OEM_Perp"
	2065 = "Office15_PersonalR_Retail"
	2066 = "Office15_PersonalR_Trial"
	2070 = "Office15_MondoR_KMS_Automation"
	2072 = "Office15_MondoPreInstallR_OEM_ARM"
	2119 = "Office15_PowerPointR_Grace"
	2120 = "Office15_PowerPointR_OEM_Perp"
	2121 = "Office15_PowerPointR_Retail"
	2122 = "Office15_PowerPointR_Trial"
	2123 = "Office15_PowerPointVL_KMS_Client"
	2124 = "Office15_PowerPointVL_MAK"
	2125 = "Office15_ProfessionalDemoR_BypassTrial180"
	2126 = "Office15_ProfessionalR_Grace"
	2127 = "Office15_ProfessionalR_OEM_Perp"
	2128 = "Office15_ProfessionalR_Retail"
	2129 = "Office15_ProfessionalR_Trial"
	2130 = "Office15_ProjectLPK_Bypass"
	2131 = "Office15_ProjectProCO365R_Subscription"
	2132 = "Office15_ProjectProCO365R_SubTest"
	2133 = "Office15_ProjectProCO365R_SubTrial"
	2134 = "Office15_ProjectProDemoR_BypassTrial180"
	2135 = "Office15_ProjectProMSDNR_Retail"
	2136 = "Office15_ProjectProO365R_Subscription"
	2137 = "Office15_ProjectProO365R_SubTest"
	2138 = "Office15_ProjectProO365R_SubTrial"
	2139 = "Office15_ProjectProR_Grace"
	2140 = "Office15_ProjectProR_OEM_Perp"
	2141 = "Office15_ProjectProR_Retail"
	2142 = "Office15_ProjectProR_Trial"
	2143 = "Office15_ProjectProVL_KMS_Client"
	2144 = "Office15_ProjectProVL_MAK"
	2145 = "Office15_ProjectServer_Bypass"
	2146 = "Office15_ProjectServer_BypassTrial180"
	2147 = "Office15_ProjectStdCO365R_Subscription"
	2148 = "Office15_ProjectStdCO365R_SubTest"
	2149 = "Office15_ProjectStdCO365R_SubTrial"
	2150 = "Office15_ProjectStdO365R_Subscription"
	2151 = "Office15_ProjectStdO365R_SubTest"
	2152 = "Office15_ProjectStdO365R_SubTrial"
	2153 = "Office15_ProjectStdR_Grace"
	2154 = "Office15_ProjectStdR_OEM_Perp"
	2155 = "Office15_ProjectStdR_Retail"
	2156 = "Office15_ProjectStdVL_KMS_Client"
	2157 = "Office15_ProjectStdVL_MAK"
	2158 = "Office15_ProPlusDemoR_BypassTrial180"
	2159 = "Office15_ProPlusMSDNR_Retail"
	2160 = "Office15_ProPlusR_Grace"
	2161 = "Office15_ProPlusR_OEM_Perp"
	2162 = "Office15_ProPlusR_Retail"
	2163 = "Office15_ProPlusR_Trial"
	2164 = "Office15_ProPlusVL_KMS_Client"
	2165 = "Office15_ProPlusVL_MAK"
	2166 = "Office15_PTK_Bypass"
	2167 = "Office15_PublisherR_Grace"
	2168 = "Office15_PublisherR_OEM_Perp"
	2169 = "Office15_PublisherR_Retail"
	2170 = "Office15_PublisherR_Trial"
	2171 = "Office15_PublisherVL_KMS_Client"
	2172 = "Office15_PublisherVL_MAK"
	2173 = "Office15_ServerLPK_Bypass"
	2174 = "Office15_SPDFreeR_PrepidBypass"
	2175 = "Office15_StandardMSDNR_Retail"
	2176 = "Office15_StandardR_Grace"
	2177 = "Office15_StandardR_Retail"
	2178 = "Office15_StandardR_Trial"
	2179 = "Office15_StandardVL_KMS_Client"
	2180 = "Office15_StandardVL_MAK"
	2181 = "Office15_VisioLPK_Bypass"
	2182 = "Office15_VisioProCO365R_Subscription"
	2183 = "Office15_VisioProCO365R_SubTest"
	2184 = "Office15_VisioProCO365R_SubTrial"
	2185 = "Office15_VisioProDemoR_BypassTrial180"
	2186 = "Office15_VisioProMSDNR_Retail"
	2187 = "Office15_VisioProO365R_Subscription"
	2188 = "Office15_VisioProO365R_SubTest"
	2189 = "Office15_VisioProO365R_SubTrial"
	2190 = "Office15_VisioProR_Grace"
	2191 = "Office15_VisioProR_OEM_Perp"
	2192 = "Office15_VisioProR_Retail"
	2193 = "Office15_VisioProR_Trial"
	2194 = "Office15_VisioProVL_KMS_Client"
	2195 = "Office15_VisioProVL_MAK"
	2196 = "Office15_VisioStdCO365R_Subscription"
	2197 = "Office15_VisioStdCO365R_SubTest"
	2198 = "Office15_VisioStdCO365R_SubTrial"
	2199 = "Office15_VisioStdO365R_Subscription"
	2200 = "Office15_VisioStdO365R_SubTest"
	2201 = "Office15_VisioStdO365R_SubTrial"
	2202 = "Office15_VisioStdR_Grace"
	2203 = "Office15_VisioStdR_OEM_Perp"
	2204 = "Office15_VisioStdR_Retail"
	2205 = "Office15_VisioStdVL_KMS_Client"
	2206 = "Office15_VisioStdVL_MAK"
	2207 = "Office15_WacServerLPK_Bypass"
	2208 = "Office15_WCServer_Bypass"
	2209 = "Office15_WordR_Grace"
	2210 = "Office15_WordR_OEM_Perp"
	2211 = "Office15_WordR_Retail"
	2212 = "Office15_WordR_Trial"
	2213 = "Office15_WordVL_KMS_Client"
	2214 = "Office15_WordVL_MAK"
	2217 = "CoreARM, Win 8 RTM CoreARM OEM:DM"
	2220 = "Embedded, Windows Embedded Standard 8 Beta Embedded Retail:TB:Eval"
	2221 = "Embedded, Windows Embedded Standard 8 Beta Embedded Retail:TB:Eval"
	2222 = "Embedded, Windows Embedded Standard 8 Beta Embedded Retail:TB:Eval"
	2223 = "Embedded, Windows Embedded Standard 8 Beta Embedded Retail"
	2224 = "Embedded, Windows Embedded Standard 8 Beta Embedded OEM:DM"
	2225 = "Embedded, Windows Embedded Standard 8 Beta Embedded OEM:NONSLP"
	2226 = "APPXLOB-Embedded, Windows Embedded Standard 8 Beta APPXLOB-Embedded Volume:MAK"
	2227 = "EmbeddedA, Windows Embedded Standard 8 Beta EmbeddedA Retail:TB:Eval"
	2228 = "EmbeddedA, Windows Embedded Standard 8 Beta EmbeddedA OEM:DM"
	2229 = "EmbeddedA, Windows Embedded Standard 8 Beta EmbeddedA OEM:NONSLP"
	2240 = "CoreARM, Win 8 RTM CoreARM OEM:NONSLP"
	2247 = "EmbeddedIndustry, POSReady 8 Beta EmbeddedIndustry OEM:NONSLP"
	2248 = "EmbeddedIndustry, POSReady 8 Beta EmbeddedIndustry Retail:TB:Eval"
	2249 = "EmbeddedIndustry, POSReady 8 Beta EmbeddedIndustry Retail"
	2250 = "EmbeddedIndustryE, POSReady 8 Beta EmbeddedIndustryE Retail"
	2251 = "EmbeddedIndustryE, POSReady 8 Beta EmbeddedIndustryE Volume:GVLK"
	2252 = "EmbeddedIndustryE, POSReady 8 Beta EmbeddedIndustryE Volume:MAK"
	2253 = "EmbeddedIndustryE, POSReady 8 Beta EmbeddedIndustryE Retail:TB:Eval"
	2263 = "Embedded, Windows Embedded Standard 8 RTM Embedded Retail:TB:Eval"
	2264 = "Embedded, Windows Embedded Standard 8 RTM Embedded Retail:TB:Eval"
	2265 = "Embedded, Windows Embedded Standard 8 RTM Embedded Retail:TB:Eval"
	2266 = "Embedded, Windows Embedded Standard 8 RTM Embedded Retail"
	2267 = "APPXLOB-Embedded, Windows Embedded Standard 8 RTM APPXLOB-Embedded OEM:NONSLP"
	2268 = "APPXLOB-Embedded, Windows Embedded Standard 8 RTM APPXLOB-Embedded Retail:TB:Eval"
	2269 = "APPXLOB-Embedded, Windows Embedded Standard 8 RTM APPXLOB-Embedded Volume:MAK"
	2270 = "APPXLOB-Embedded, Windows Embedded Standard 8 RTM APPXLOB-Embedded Volume:MAK"
	2271 = "APPXLOB-Embedded, Windows Embedded Standard 8 RTM APPXLOB-Embedded Volume:MAK"
	2272 = "Embedded, Windows Embedded Standard 8 RTM Embedded OEM:NONSLP"
	2273 = "Embedded, Windows Embedded Standard 8 RTM Embedded OEM:NONSLP"
	2274 = "Embedded, Windows Embedded Standard 8 RTM Embedded OEM:DM"
	2275 = "Embedded, Windows Embedded Standard 8 RTM Embedded OEM:DM"
	2276 = "Embedded, Windows Embedded Standard 8 RTM Embedded Retail"
	2277 = "ServerSolution, Windows Server Essentials 2012 RTM ServerSolution Volume:GVLK"
	2281 = "ServerStandard, Windows vNext Test ServerStandard VT:IA"
	2282 = "ServerDatacenter, Windows vNext Test ServerDatacenter VT:IA"
	2284 = "EmbeddedIndustry, Windows Embedded Industry 8 RTM EmbeddedIndustry Retail:TB:Eval"
	2285 = "EmbeddedIndustry, Windows Embedded Industry 8 RTM EmbeddedIndustry Retail:TB:Eval"
	2286 = "EmbeddedIndustry, Windows Embedded Industry 8 RTM EmbeddedIndustry Retail:TB:Eval"
	2287 = "EmbeddedIndustry, Windows Embedded Industry 8 RTM EmbeddedIndustry Retail"
	2288 = "EmbeddedIndustry, Windows Embedded Industry 8 RTM EmbeddedIndustry OEM:NONSLP"
	2289 = "EmbeddedIndustry, Windows Embedded Industry 8 RTM EmbeddedIndustry OEM:DM"
	2290 = "EmbeddedIndustry, Windows Embedded Industry 8 RTM EmbeddedIndustry OEM:DM"
	2291 = "EmbeddedIndustry, Windows Embedded Industry 8 RTM EmbeddedIndustry OEM:DM"
	2292 = "EmbeddedIndustry, Windows Embedded Industry 8 RTM EmbeddedIndustry Volume:MAK"
	2293 = "APPXLOB-Embedded, Windows Embedded Industry 8 RTM APPXLOB-Embedded Volume:MAK"
	2294 = "APPXLOB-Embedded, Windows Embedded Industry 8 RTM APPXLOB-Embedded Volume:MAK"
	2295 = "APPXLOB-Embedded, Windows Embedded Industry 8 RTM APPXLOB-Embedded Volume:MAK"
	2296 = "EmbeddedIndustry, Windows Embedded Industry 8 RTM EmbeddedIndustry Volume:GVLK"
	2297 = "EmbeddedIndustryE, Windows Embedded Industry 8 RTM EmbeddedIndustryE Retail:TB:Eval"
	2298 = "EmbeddedIndustryE, Windows Embedded Industry 8 RTM EmbeddedIndustryE Retail:TB:Eval"
	2299 = "EmbeddedIndustryE, Windows Embedded Industry 8 RTM EmbeddedIndustryE Retail:TB:Eval"
	2300 = "EmbeddedIndustryE, Windows Embedded Industry 8 RTM EmbeddedIndustryE Retail"
	2301 = "EmbeddedIndustryE, Windows Embedded Industry 8 RTM EmbeddedIndustryE Volume:MAK"
	2302 = "APPXLOB-Embedded, Windows Embedded Industry 8 RTM APPXLOB-Embedded Volume:MAK"
	2303 = "APPXLOB-Embedded, Windows Embedded Industry 8 RTM APPXLOB-Embedded Volume:MAK"
	2304 = "APPXLOB-Embedded, Windows Embedded Industry 8 RTM APPXLOB-Embedded Volume:MAK"
	2305 = "EmbeddedIndustryE, Windows Embedded Industry 8 RTM EmbeddedIndustryE Volume:GVLK"
	2315 = "Office15_HomeStudentPlusARMPreInstallR_OEM_ARM"
	2316 = "ServerCloudStorage, ServerCloudStorage Next Beta ServerCloudStorage OEM:SLP"
	2317 = "ServerCloudStorage, ServerCloudStorage Next Beta ServerCloudStorage OEM:NONSLP"
	2331 = "Office15_OneNoteFreeR_Bypass"
	2500 = "EmbeddedIndustryEval, Windows Embedded Industry Next Beta EmbeddedIndustryEval Retail:TB:Eval"
	2501 = "EmbeddedIndustry, Windows Embedded Industry Next Beta EmbeddedIndustry OEM:NONSLP"
	2502 = "EmbeddedIndustry, Windows Embedded Industry Next Beta EmbeddedIndustry OEM:DM"
	2503 = "EmbeddedIndustry, Windows Embedded Industry Next Beta EmbeddedIndustry Volume:GVLK"
	2504 = "EmbeddedIndustry, Windows Embedded Industry Next Beta EmbeddedIndustry Volume:MAK"
	2505 = "EmbeddedIndustryEEval, Windows Embedded Industry Next Beta EmbeddedIndustryEEval Retail:TB:Eval"
	2507 = "EmbeddedIndustryE, Windows Embedded Industry Next Beta EmbeddedIndustryE OEM:NONSLP"
	2508 = "EmbeddedIndustryE, Windows Embedded Industry Next Beta EmbeddedIndustryE Volume:GVLK"
	2509 = "EmbeddedIndustryE, Windows Embedded Industry Next Beta EmbeddedIndustryE Volume:MAK"
	2511 = "EmbeddedIndustryA, Windows Embedded Industry Next Beta EmbeddedIndustryA OEM:NONSLP"
	2512 = "EmbeddedIndustryA, Windows Embedded Industry Next Beta EmbeddedIndustryA OEM:DM"
	2513 = "EmbeddedIndustryA, Windows Embedded Industry Next Beta EmbeddedIndustryA Volume:GVLK"
	2514 = "EmbeddedIndustryA, Windows Embedded Industry Next Beta EmbeddedIndustryA Volume:MAK"
	2515 = "ServerStandard, Windows Server Next Beta ServerStandard VT:IA"
	2516 = "ServerDatacenter, Windows Server Next Beta ServerDatacenter VT:IA"
	2517 = "ServerStandard, Windows Server Next Beta ServerStandard OEM:SLP"
	2518 = "ServerDatacenter, Windows Server Next Beta ServerDatacenter OEM:SLP"
	2519 = "ServerSolution, Windows Server Essentials Next Beta ServerSolution VT:IA"
	2520 = "ServerStandard, Windows Server 12 R2 RTM ServerStandard Retail"
	2521 = "ServerStandardEval, Windows Server 12 R2 RTM ServerStandardEval Retail:TB:Eval"
	2522 = "ServerStandard, Windows Server 12 R2 RTM ServerStandard OEM:SLP"
	2523 = "ServerStandard, Windows Server 12 R2 RTM ServerStandard OEM:SLP (MUI locked to zh-CN)"
	2524 = "ServerStandard, Windows Server 12 R2 RTM ServerStandard OEM:NONSLP"
	2525 = "ServerStandard, Windows Server 12 R2 RTM ServerStandard OEM:NONSLP (MUI locked to zh-CN)"
	2526 = "ServerStandard, Windows Server 12 R2 RTM ServerStandard Volume:MAK"
	2527 = "ServerStandard, Windows Server 12 R2 RTM ServerStandard Volume:GVLK"
	2528 = "ServerDatacenter, Windows Server 12 R2 RTM ServerDatacenter Retail"
	2529 = "ServerDatacenterEval, Windows Server 12 R2 RTM ServerDatacenterEval Retail:TB:Eval"
	2530 = "ServerDatacenter, Windows Server 12 R2 RTM ServerDatacenter OEM:SLP"
	2531 = "ServerDatacenter, Windows Server 12 R2 RTM ServerDatacenter OEM:SLP (MUI locked to zh-CN)"
	2532 = "ServerDatacenter, Windows Server 12 R2 RTM ServerDatacenter OEM:NONSLP"
	2533 = "ServerDatacenter, Windows Server 12 R2 RTM ServerDatacenter OEM:NONSLP (MUI locked to zh-CN)"
	2534 = "ServerDatacenter, Windows Server 12 R2 RTM ServerDatacenter Volume:MAK"
	2535 = "ServerDatacenter, Windows Server 12 R2 RTM ServerDatacenter Volume:GVLK"
	2536 = "ServerWinFoundation, Windows Server 12 R2 RTM ServerWinFoundation OEM:SLP"
	2537 = "ServerWinFoundation, Windows Server 12 R2 RTM ServerWinFoundation OEM:SLP (MUI locked to zh-CN)"
	2538 = "ServerWinFoundation, Windows Server 12 R2 RTM ServerWinFoundation OEM:NONSLP"
	2539 = "ServerWinFoundation, Windows Server 12 R2 RTM ServerWinFoundation OEM:NONSLP (MUI locked to zh-CN)"
	2540 = "ServerWinFoundation, Windows Server 12 R2 RTM ServerWinFoundation Retail"
	2541 = "ServerStandard, Windows Server 12 R2 RTM ServerStandard VT:IA"
	2542 = "ServerDatacenter, Windows Server 12 R2 RTM ServerDatacenter VT:IA"
	2543 = "ServerCloudStorage, ServerCloudStorage 12 R2 RTM ServerCloudStorage Retail"
	2544 = "ServerCloudStorage, ServerCloudStorage 12 R2 RTM ServerCloudStorage OEM:SLP"
	2545 = "ServerCloudStorage, ServerCloudStorage 12 R2 RTM ServerCloudStorage OEM:NONSLP"
	2546 = "ServerCloudStorage, ServerCloudStorage 12 R2 RTM ServerCloudStorage Volume:GVLK"
	2570 = "ServerStorageStandard, Storage Server 2012 R2 RTM ServerStorageStandard OEM:SLP"
	2571 = "ServerStorageStandard, Storage Server 2012 R2 RTM ServerStorageStandard OEM:NONSLP"
	2572 = "ServerStorageStandard, Storage Server 2012 R2 RTM ServerStorageStandard Retail"
	2573 = "ServerStorageStandardEval, Storage Server 2012 R2 RTM ServerStorageStandardEval Retail:TB:Eval"
	2574 = "ServerStorageWorkgroupEval, Storage Server 2012 R2 RTM ServerStorageWorkgroupEval Retail:TB:Eval"
	2575 = "ServerStorageWorkgroup, Storage Server 2012 R2 RTM ServerStorageWorkgroup OEM:SLP"
	2576 = "ServerStorageWorkgroup, Storage Server 2012 R2 RTM ServerStorageWorkgroup OEM:NONSLP"
	2577 = "ServerStorageWorkgroup, Storage Server 2012 R2 RTM ServerStorageWorkgroup Retail"
	2578 = "ServerSolution, Windows Server Essentials 2012 R2 RTM ServerSolution OEM:SLP"
	2579 = "ServerSolution, Windows Server Essentials 2012 R2 RTM ServerSolution OEM:SLP (MUI locked to zh-CN)"
	2580 = "ServerSolution, Windows Server Essentials 2012 R2 RTM ServerSolution OEM:NONSLP"
	2581 = "ServerSolution, Windows Server Essentials 2012 R2 RTM ServerSolution OEM:NONSLP (MUI locked to zh-CN)"
	2582 = "ServerSolution, Windows Server Essentials 2012 R2 RTM ServerSolution Retail"
	2583 = "ServerSolution, Windows Server Essentials 2012 R2 RTM ServerSolution Volume:MAK"
	2584 = "ServerSolution, Windows Server Essentials 2012 R2 RTM ServerSolution Volume:GVLK"
	2585 = "ServerSolution, Windows Server Essentials 2012 R2 RTM ServerSolution VT:IA"
	2586 = "Win 8.1 RTM Core OEM:DM"
	2587 = "Win 8.1 RTM Professional OEM:DM"
	2588 = "Win 8.1 RTM ProfessionalN OEM:DM"
	2589 = "Win 8.1 RTM Core OEM:NONSLP"
	2590 = "CoreARM, Win 8.1 RTM CoreARM OEM:NONSLP"
	2591 = "Win 8.1 RTM CoreCountrySpecific OEM:NONSLP"
	2592 = "Win 8.1 RTM CoreN OEM:NONSLP"
	2593 = "Win 8.1 RTM CoreSingleLanguage OEM:NONSLP"
	2594 = "Win 8.1 RTM Professional OEM:NONSLP"
	2595 = "Win 8.1 RTM ProfessionalN OEM:NONSLP"
	2596 = "Win 8.1 RTM Core Retail"
	2597 = "Win 8.1 RTM Core OEM:DM"
	2599 = "Win 8.1 RTM CoreN Retail"
	2600 = "Win 8.1 RTM Professional Retail"
	2601 = "Win 8.1 RTM ProfessionalN Retail"
	2602 = "Win 8.1 RTM ProfessionalN Retail"
	2603 = "Win 8.1 RTM ProfessionalWMC Retail"
	2604 = "Win 8.1 RTM ProfessionalWMC Retail"
	2605 = "EnterpriseNEval, Win 8.1 RTM EnterpriseNEval Retail:TB:Eval"
	2606 = "EnterpriseEval, Win 8.1 RTM EnterpriseEval Retail:TB:Eval"
	2607 = "Core, Win 8.1 RTM Core Volume:GVLK"
	2608 = "CoreARM, Win 8.1 RTM CoreARM OEM:DM"
	2609 = "CoreARM, Win 8.1 RTM CoreARM Volume:GVLK"
	2610 = "CoreCountrySpecific, Win 8.1 RTM CoreCountrySpecific Volume:GVLK"
	2611 = "CoreN, Win 8.1 RTM CoreN Volume:GVLK"
	2612 = "CoreSingleLanguage, Win 8.1 RTM CoreSingleLanguage Volume:GVLK"
	2613 = "Enterprise, Win 8.1 RTM Enterprise Volume:GVLK"
	2614 = "EnterpriseN, Win 8.1 RTM EnterpriseN Volume:GVLK"
	2615 = "Professional, Win 8.1 RTM Professional Volume:GVLK"
	2616 = "ProfessionalN, Win 8.1 RTM ProfessionalN Volume:GVLK"
	2617 = "ProfessionalWMC, Win 8.1 RTM ProfessionalWMC Volume:GVLK"
	2618 = "Professional;ProfessionalN;Enterprise;EnterpriseN, Win 8.1 RTM Professional;ProfessionalN;Enterprise;EnterpriseN Volume:MAK"
	2619 = "CoreARM, Win 8.1 RTM CoreARM OEM:DM"
	2620 = "Win 8.1 RTM ProfessionalWMC Retail"
	2621 = "Win 8.1 RTM CoreCountrySpecific OEM:DM"
	2622 = "Win 8.1 RTM CoreN OEM:DM"
	2623 = "Win 8.1 RTM CoreSingleLanguage OEM:DM"
	2624 = "Win 8.1 RTM CoreSingleLanguage OEM:DM"
	2625 = "Win 8.1 RTM Professional OEM:DM"
	2626 = "EmbeddedIndustryEval, Windows Embedded Industry 8.1 RTM EmbeddedIndustryEval Retail:TB:Eval"
	2627 = "EmbeddedIndustryEval, Windows Embedded Industry 8.1 RTM EmbeddedIndustryEval Retail:TB:Eval"
	2628 = "EmbeddedIndustryEval, Windows Embedded Industry 8.1 RTM EmbeddedIndustryEval Retail:TB:Eval"
	2629 = "EmbeddedIndustry, Windows Embedded Industry 8.1 RTM EmbeddedIndustry Retail"
	2630 = "EmbeddedIndustry, Windows Embedded Industry 8.1 RTM EmbeddedIndustry OEM:NONSLP"
	2631 = "EmbeddedIndustry, Windows Embedded Industry 8.1 RTM EmbeddedIndustry OEM:NONSLP"
	2632 = "EmbeddedIndustry, Windows Embedded Industry 8.1 RTM EmbeddedIndustry OEM:NONSLP"
	2633 = "EmbeddedIndustry, Windows Embedded Industry 8.1 RTM EmbeddedIndustry OEM:NONSLP"
	2634 = "EmbeddedIndustry, Windows Embedded Industry 8.1 RTM EmbeddedIndustry OEM:DM"
	2635 = "EmbeddedIndustry, Windows Embedded Industry 8.1 RTM EmbeddedIndustry OEM:DM"
	2636 = "EmbeddedIndustry, Windows Embedded Industry 8.1 RTM EmbeddedIndustry OEM:DM"
	2637 = "EmbeddedIndustry, Windows Embedded Industry 8.1 RTM EmbeddedIndustry OEM:DM"
	2638 = "EmbeddedIndustry, Windows Embedded Industry 8.1 RTM EmbeddedIndustry OEM:DM"
	2639 = "EmbeddedIndustry, Windows Embedded Industry 8.1 RTM EmbeddedIndustry Volume:MAK"
	2640 = "EmbeddedIndustry, Windows Embedded Industry 8.1 RTM EmbeddedIndustry Volume:GVLK"
	2642 = "EmbeddedIndustryEEval, Windows Embedded Industry 8.1 RTM EmbeddedIndustryEEval Retail:TB:Eval"
	2643 = "EmbeddedIndustryEEval, Windows Embedded Industry 8.1 RTM EmbeddedIndustryEEval Retail:TB:Eval"
	2644 = "EmbeddedIndustryEEval, Windows Embedded Industry 8.1 RTM EmbeddedIndustryEEval Retail:TB:Eval"
	2645 = "EmbeddedIndustryE, Windows Embedded Industry 8.1 RTM EmbeddedIndustryE Retail"
	2646 = "EmbeddedIndustryE, Windows Embedded Industry 8.1 RTM EmbeddedIndustryE Volume:MAK"
	2647 = "EmbeddedIndustryE, Windows Embedded Industry 8.1 RTM EmbeddedIndustryE Volume:GVLK"
	2648 = "EmbeddedIndustryA, Windows Embedded Industry 8.1 RTM EmbeddedIndustryA OEM:NONSLP"
	2649 = "EmbeddedIndustryA, Windows Embedded Industry 8.1 RTM EmbeddedIndustryA OEM:DM"
	2650 = "EmbeddedIndustryA, Windows Embedded Industry 8.1 RTM EmbeddedIndustryA OEM:DM"
	2651 = "EmbeddedIndustryA, Windows Embedded Industry 8.1 RTM EmbeddedIndustryA OEM:DM"
	2652 = "EmbeddedIndustryA, Windows Embedded Industry 8.1 RTM EmbeddedIndustryA OEM:DM"
	2653 = "EmbeddedIndustryA, Windows Embedded Industry 8.1 RTM EmbeddedIndustryA Volume:MAK"
	2654 = "EmbeddedIndustryA, Windows Embedded Industry 8.1 RTM EmbeddedIndustryA Volume:GVLK"
	2655 = "ServerSolution, Windows Server Essentials 2012 R2 RTM ServerSolution Retail:TB:Eval"
	2656 = "Office16_O365BusinessR_Grace"
	2657 = "Office15_O365BusinessR_Retail"
	2658 = "Office16_O365BusinessR_Subscription"
	2659 = "Office15_O365BusinessR_SubTrial"
	2660 = "Office15_O365BusinessR_SubTest"
	2661 = "Office16_PersonalPipcR_Grace"
	2662 = "Office15_PersonalPipcR_OEM_Perp"
	2663 = "Office16_HomeBusinessPipcR_Grace"
	2664 = "Office15_HomeBusinessPipcR_OEM_Perp"
	2665 = "Office16_ProfessionalPipcR_Grace"
	2666 = "Office15_ProfessionalPipcR_OEM_Perp"
	2667 = "Win 8.1 RTM CoreConnected OEM:DM"
	2668 = "Win 8.1 RTM CoreConnected OEM:DM"
	2669 = "Win 8.1 RTM CoreConnected OEM:NONSLP"
	2670 = "Win 8.1 RTM CoreConnected Retail"
	2671 = "CoreConnected, Win 8.1 RTM CoreConnected Volume:GVLK"
	2672 = "Win 8.1 RTM CoreConnectedN OEM:DM"
	2673 = "Win 8.1 RTM CoreConnectedN OEM:NONSLP"
	2674 = "Win 8.1 RTM CoreConnectedN Retail"
	2675 = "CoreConnectedN, Win 8.1 RTM CoreConnectedN Volume:GVLK"
	2676 = "Win 8.1 RTM ProfessionalStudent OEM:DM"
	2677 = "Win 8.1 RTM ProfessionalStudent OEM:DM"
	2678 = "Win 8.1 RTM ProfessionalStudent OEM:NONSLP"
	2679 = "Win 8.1 RTM ProfessionalStudent Retail"
	2680 = "ProfessionalStudent, Win 8.1 RTM ProfessionalStudent Volume:GVLK"
	2681 = "Win 8.1 RTM ProfessionalStudentN OEM:DM"
	2682 = "Win 8.1 RTM ProfessionalStudentN OEM:NONSLP"
	2683 = "Win 8.1 RTM ProfessionalStudentN Retail"
	2684 = "ProfessionalStudentN, Win 8.1 RTM ProfessionalStudentN Volume:GVLK"
	2685 = "Win 8.1 RTM CoreConnectedSingleLanguage OEM:DM"
	2686 = "Win 8.1 RTM CoreConnectedSingleLanguage OEM:DM"
	2687 = "Win 8.1 RTM CoreConnectedSingleLanguage OEM:NONSLP"
	2688 = "CoreConnectedSingleLanguage, Win 8.1 RTM CoreConnectedSingleLanguage Volume:GVLK"
	2689 = "Win 8.1 RTM CoreConnectedCountrySpecific OEM:DM"
	2690 = "Win 8.1 RTM CoreConnectedCountrySpecific OEM:NONSLP"
	2691 = "CoreConnectedCountrySpecific, Win 8.1 RTM CoreConnectedCountrySpecific Volume:GVLK"
	2787 = "CoreConnected, Win Next Pre-Release CoreConnected OEM:DM"
	2788 = "CoreConnected, Win Next Pre-Release CoreConnected OEM:NONSLP"
	2789 = "CoreConnected, Win Next Pre-Release CoreConnected Retail"
	2790 = "CoreConnected, Win Next Pre-Release CoreConnected Volume:GVLK"
	2791 = "CoreConnected, Win Next Pre-Release CoreConnected Volume:MAK"
	2792 = "CoreConnectedCountrySpecific, Win Next Pre-Release CoreConnectedCountrySpecific OEM:DM"
	2793 = "CoreConnectedCountrySpecific, Win Next Pre-Release CoreConnectedCountrySpecific OEM:NONSLP"
	2794 = "CoreConnectedCountrySpecific, Win Next Pre-Release CoreConnectedCountrySpecific Retail"
	2795 = "CoreConnectedCountrySpecific, Win Next Pre-Release CoreConnectedCountrySpecific Volume:GVLK"
	2796 = "CoreConnectedCountrySpecific, Win Next Pre-Release CoreConnectedCountrySpecific Volume:MAK"
	2797 = "CoreConnectedN, Win Next Pre-Release CoreConnectedN OEM:DM"
	2798 = "CoreConnectedN, Win Next Pre-Release CoreConnectedN OEM:NONSLP"
	2799 = "CoreConnectedN, Win Next Pre-Release CoreConnectedN Retail"
	2800 = "CoreConnectedN, Win Next Pre-Release CoreConnectedN Volume:GVLK"
	2801 = "CoreConnectedN, Win Next Pre-Release CoreConnectedN Volume:MAK"
	2802 = "CoreConnectedSingleLanguage, Win Next Pre-Release CoreConnectedSingleLanguage OEM:DM"
	2803 = "CoreConnectedSingleLanguage, Win Next Pre-Release CoreConnectedSingleLanguage OEM:NONSLP"
	2804 = "CoreConnectedSingleLanguage, Win Next Pre-Release CoreConnectedSingleLanguage Retail"
	2805 = "CoreConnectedSingleLanguage, Win Next Pre-Release CoreConnectedSingleLanguage Volume:GVLK"
	2806 = "CoreConnectedSingleLanguage, Win Next Pre-Release CoreConnectedSingleLanguage Volume:MAK"
	2807 = "ProfessionalStudent, Win Next Pre-Release ProfessionalStudent OEM:DM"
	2808 = "ProfessionalStudent, Win Next Pre-Release ProfessionalStudent OEM:NONSLP"
	2809 = "ProfessionalStudent, Win Next Pre-Release ProfessionalStudent Retail"
	2810 = "ProfessionalStudent, Win Next Pre-Release ProfessionalStudent Volume:GVLK"
	2811 = "ProfessionalStudent, Win Next Pre-Release ProfessionalStudent Volume:MAK"
	2812 = "ProfessionalStudentN, Win Next Pre-Release ProfessionalStudentN OEM:DM"
	2813 = "ProfessionalStudentN, Win Next Pre-Release ProfessionalStudentN OEM:NONSLP"
	2814 = "ProfessionalStudentN, Win Next Pre-Release ProfessionalStudentN Retail"
	2815 = "ProfessionalStudentN, Win Next Pre-Release ProfessionalStudentN Volume:GVLK"
	2816 = "ProfessionalStudentN, Win Next Pre-Release ProfessionalStudentN Volume:MAK"
	2829 = "Office15_PersonalPipcR_PIN"
	2830 = "Office15_HomeBusinessPipcR_PIN"
	2831 = "Office15_ProfessionalPipcR_PIN"
	2832 = "Office16_SkypeServiceBypassR_PrepidBypass"
	2956 = "Professional, Win Next Pre-Release Professional Volume:MAK"
	2957 = "ProfessionalN, Win Next Pre-Release ProfessionalN Volume:MAK"
	2958 = "Enterprise, Win Next Pre-Release Enterprise Volume:MAK"
	2959 = "EnterpriseN, Win Next Pre-Release EnterpriseN Volume:MAK"
	2960 = "Office15_O365HomePremR_PIN21"
	2961 = "Office15_O365HomePremR_PIN22"
	2962 = "Office15_O365HomePremR_PIN23"
	2963 = "Office15_HomeBusinessR_PIN"
	2964 = "Office15_ProfessionalR_PIN"
	2965 = "Office15_HomeStudentR_PIN"
	2966 = "Office15_O365HomePremR_PIN24"
	2967 = "Office15_O365HomePremR_PIN25"
	2968 = "Office15_O365HomePremR_PIN26"
	2969 = "Office15_O365HomePremR_PIN27"
	2970 = "Office15_O365HomePremR_PIN28"
	2971 = "Office15_O365HomePremR_PIN29"
	2972 = "Office15_O365HomePremR_PIN30"
	2973 = "Office15_O365HomePremR_PIN31"
	2974 = "Office15_O365HomePremR_PIN32"
	2975 = "Office15_O365HomePremR_PIN33"
	2976 = "Office15_O365HomePremR_PIN34"
	2977 = "Office15_O365HomePremR_PIN35"
	2978 = "Office15_O365HomePremR_PIN36"
	2979 = "Office15_O365HomePremR_PIN37"
	2994 = "Education, Win Next Pre-Release Education OEM:DM"
	2995 = "Education, Win Next Pre-Release Education Retail"
	2996 = "Education, Win Next Pre-Release Education Volume:GVLK"
	2997 = "Education, Win Next Pre-Release Education Volume:MAK"
	2998 = "Education, Win Next Pre-Release Education Volume:CSVLK"
	3002 = "Office15_O365HomePremR_PIN38"
	3003 = "Office15_O365HomePremR_PIN39"
	3004 = "Office15_O365HomePremR_PIN40"
	3005 = "Office15_O365HomePremR_PIN41"
	3006 = "Office15_O365HomePremR_PIN42"
	3007 = "Office15_O365HomePremR_PIN43"
	3008 = "Office15_O365HomePremR_PIN44"
	3009 = "Office15_O365HomePremR_PIN45"
	3010 = "Office15_O365HomePremR_PIN46"
	3011 = "Office15_O365HomePremR_PIN47"
	3012 = "Office15_O365HomePremR_PIN48"
	3013 = "Office15_O365HomePremR_PIN49"
	3014 = "Office15_O365HomePremR_PIN50"
	3015 = "Office15_O365HomePremR_PIN51"
	3016 = "Office15_O365HomePremR_PIN52"
	3017 = "Office15_O365HomePremR_PIN53"
	3018 = "Office15_O365HomePremR_PIN54"
	3019 = "Office15_O365HomePremR_PIN55"
	3020 = "Office15_O365HomePremR_PIN56"
	3021 = "Office15_O365HomePremR_PIN57"
	3022 = "Office15_O365HomePremR_PIN58"
	3023 = "Office15_O365HomePremR_PIN59"
	3024 = "Office15_O365HomePremR_PIN60"
	3025 = "Office15_O365HomePremR_PIN61"
	3026 = "Office15_O365HomePremR_PIN62"
	3027 = "Office15_O365HomePremR_PIN63"
	3028 = "Office15_O365HomePremR_PIN64"
	3029 = "Office15_O365HomePremR_PIN65"
	3030 = "Office15_O365HomePremR_PIN66"
	3031 = "Office15_O365HomePremR_PIN67"
	3032 = "Office15_O365HomePremR_PIN68"
	3033 = "Office15_O365HomePremR_PIN69"
	3034 = "Office15_O365HomePremR_PIN70"
	3035 = "Office15_O365HomePremR_PIN71"
	3036 = "Office15_O365HomePremR_PIN72"
	3037 = "Office15_O365HomePremR_PIN73"
	3038 = "Office15_O365HomePremR_PIN74"
	3039 = "Office15_O365HomePremR_PIN75"
	3040 = "Office15_O365HomePremR_PIN76"
	3041 = "Office15_O365HomePremR_PIN77"
	3042 = "Office15_O365HomePremR_PIN78"
	3043 = "Office15_O365HomePremR_PIN79"
	3044 = "Office15_O365HomePremR_PIN80"
	3045 = "Office15_O365HomePremR_PIN81"
	3046 = "Office15_O365HomePremR_PIN82"
	3047 = "Office15_O365HomePremR_PIN83"
	3048 = "Office15_O365HomePremR_PIN84"
	3049 = "Office15_O365HomePremR_PIN85"
	3050 = "Office15_O365HomePremR_PIN86"
	3051 = "Office15_O365HomePremR_PIN87"
	3052 = "Office15_O365HomePremR_PIN88"
	3053 = "Office15_O365HomePremR_PIN89"
	3054 = "Office15_O365HomePremR_PIN90"
	3055 = "Office15_O365HomePremR_PIN91"
	3056 = "Office15_O365HomePremR_PIN92"
	3057 = "Office15_O365HomePremR_PIN93"
	3058 = "Office15_O365HomePremR_PIN94"
	3059 = "Office15_O365HomePremR_PIN95"
	3060 = "Office15_O365HomePremR_PIN96"
	3061 = "Office15_O365HomePremR_PIN97"
	3062 = "Office15_O365HomePremR_PIN98"
	3063 = "Office15_O365HomePremR_PIN99"
	3064 = "Office15_O365HomePremR_PIN100"
	3065 = "Office15_O365HomePremR_PIN101"
	3066 = "Office15_O365HomePremR_PIN102"
	3067 = "Office15_O365HomePremR_PIN103"
	3068 = "Office15_O365HomePremR_PIN104"
	3069 = "Office15_O365HomePremR_PIN105"
	3070 = "Office15_O365HomePremR_PIN106"
	3071 = "Office15_O365HomePremR_PIN107"
	3072 = "Office15_O365HomePremR_PIN108"
	3073 = "Office15_O365HomePremR_PIN109"
	3074 = "Office15_O365HomePremR_PIN110"
	3075 = "Office15_O365HomePremR_PIN111"
	3076 = "Office15_O365HomePremR_PIN112"
	3077 = "Office15_O365HomePremR_PIN113"
	3078 = "Office15_O365HomePremR_PIN114"
	3079 = "Office15_O365HomePremR_PIN115"
	3080 = "Office15_O365HomePremR_PIN116"
	3081 = "Office15_O365HomePremR_PIN117"
	3082 = "PPIPro, Win Next Pre-Release PPIPro Retail"
	3083 = "PPIPro, Win Next Pre-Release PPIPro Volume:MAK"
	3084 = "Enterprise, Win Next Pre-Release Enterprise OEM:NONSLP"
	3085 = "Enterprise, Win Next Pre-Release Enterprise OEM:DM"
	3220 = "Visual Studio 2015 RTM Retail Visual Studio 2015 RTM Isolated Shell Retail"
	3221 = "Visual Studio 2015 RTM Retail Visual Studio 2015 RTM Integrated Shell Retail"
	3222 = "Visual Studio 2015 RTM Retail Visual Studio 2015 RTM Community Edition Retail"
	3223 = "Visual Studio 2015 RTM Retail Visual Studio 2015 RTM Community Edition Retail"
	3224 = "Visual Studio 2015 RTM Retail Visual Studio 2015 RTM Professional Retail Retail"
	3225 = "Visual Studio 2015 RTM Retail Visual Studio 2015 RTM Professional Retail"
	3226 = "Visual Studio 2015 RTM Retail Visual Studio 2015 RTM Premium Retail"
	3227 = "Visual Studio 2015 RTM Retail Visual Studio 2015 RTM Premium Retail"
	3228 = "Visual Studio 2015 RTM Retail Visual Studio 2015 RTM Ultimate Retail"
	3229 = "Visual Studio 2015 RTM Retail Visual Studio 2015 RTM Ultimate Retail"
	3230 = "Visual Studio 2015 RTM Retail Visual Studio 2015 RTM Test Professional Retail"
	3231 = "Visual Studio 2015 RTM Retail Visual Studio 2015 RTM Test Professional Retail"
	3232 = "Visual Studio 2015 RTM Retail Visual Studio 2015 RTM Team Foundation Server Retail"
	3233 = "Visual Studio 2015 RTM Retail Visual Studio 2015 RTM Team Foundation Server Retail"
	3234 = "Visual Studio 2015 RTM Retail Visual Studio 2015 RTM Team Foundation Server Retail"
	3235 = "Visual Studio 2015 RTM Retail Visual Studio 2015 RTM Team Foundation Server Express Retail"
	3236 = "Visual Studio 2015 RTM Retail Visual Studio 2015 RTM Release Management Server Retail"
	3237 = "Visual Studio 2015 RTM Retail Visual Studio 2015 RTM Release Management Server Retail"
	3238 = "Visual Studio 2015 RTM Retail Visual Studio 2015 RTM Visual Studio Agents Retail"
	3239 = "Visual Studio 2015 RTM Retail Visual Studio 2015 RTM Test Agent Retail"
	3240 = "Visual Studio 2015 RTM Retail Visual Studio 2015 RTM Test Controller Retail"
	3241 = "Visual Studio 2015 RTM Retail Visual Studio 2015 RTM Future Edition 1 Retail"
	3242 = "Visual Studio 2015 RTM Retail Visual Studio 2015 RTM Future Edition 1 Retail"
	3243 = "Visual Studio 2015 RTM Retail Visual Studio 2015 RTM Future Edition 1 Retail"
	3244 = "Visual Studio 2015 RTM Retail Visual Studio 2015 RTM Future Edition 2 Retail"
	3245 = "Visual Studio 2015 RTM Retail Visual Studio 2015 RTM Future Edition 2 Retail"
	3246 = "Visual Studio 2015 RTM Retail Visual Studio 2015 RTM Future Edition 2 Retail"
	3247 = "Visual Studio 2015 RTM Retail Visual Studio 2015 RTM Future Edition 3 Retail"
	3248 = "Visual Studio 2015 RTM Retail Visual Studio 2015 RTM Future Edition 3 Retail"
	3249 = "Visual Studio 2015 RTM Retail Visual Studio 2015 RTM Future Edition 3 Retail"
	3250 = "Visual Studio 2015 RTM Retail Visual Studio 2015 RTM Express for Windows Retail"
	3251 = "Visual Studio 2015 RTM Retail Visual Studio 2015 RTM Express for Windows Retail"
	3252 = "Visual Studio 2015 RTM Retail Visual Studio 2015 RTM Express for Desktop Retail"
	3253 = "Visual Studio 2015 RTM Retail Visual Studio 2015 RTM Express for Desktop Retail"
	3254 = "Visual Studio 2015 RTM Retail Visual Studio 2015 RTM Express for Web Retail"
	3255 = "Visual Studio 2015 RTM Retail Visual Studio 2015 RTM Express for Web Retail"
	3256 = "Visual Studio 2015 RTM Volume:MAK Visual Studio 2015 RTM Professional  Volume"
	3257 = "Visual Studio 2015 RTM Volume:MAK Visual Studio 2015 RTM Ultimate Volume"
	3541 = "Visual Studio 2015 Professional Visual Studio 2015 RTM Professional Volume"
	3542 = "Visual Studio 2015 Enterprise Visual Studio 2015 RTM Enterprise Volume"
	3543 = "Visual Studio 2015 Premium Visual Studio 2015 RTM Premium Volume"
	3544 = "Visual Studio 2015 Test Professional Visual Studio 2015 RTM Test Professional Volume"
	3545 = "Visual Studio 2015 Team Foundation Server Visual Studio 2015 RTM Team Foundation Server Volume"
	3546 = "Visual Studio 2015 Future Visual Studio SKU - 1 Visual Studio 2015 RTM Future Visual Studio SKU - 1 Volume"
	3547 = "Visual Studio 2015 Future Visual Studio SKU - 2 Visual Studio 2015 RTM Future Visual Studio SKU - 2 Volume"
	3548 = "Visual Studio 2015 Future Visual Studio SKU - 3 Visual Studio 2015 RTM Future Visual Studio SKU - 3 Volume"
	3675 = "Visual Studio 2015 PRERELEASE ALL Visual Studio 2015 PRERELEASE ALL Retail"
	3695 = "Visual Studio Dev15 RTM Prerelease All Retail"
	3696 = "Visual Studio Dev15 RTM Trial 30 All Retail"
	3697 = "Visual Studio Dev15 RTM Trial 90 All Retail"
	3698 = "Visual Studio Dev15 RTM Perpetual All Retail"
	3699 = "Visual Studio Dev15 RTM Enterprise Retail"
	3700 = "Visual Studio Dev15 RTM Enterprise Volume:MAK"
	3701 = "Visual Studio Dev15 RTM Professional Retail"
	3702 = "Visual Studio Dev15 RTM Professional Volume:MAK"
	3707 = "Visual Studio Dev15 RTM Test Professional Retail"
	3708 = "Visual Studio Dev15 RTM Test Professional Volume:MAK"
	3709 = "Visual Studio Dev15 RTM Test Professional Volume:GVLK"
	3710 = "Visual Studio Dev15 RTM Visual Studio Agents Retail"
	3711 = "Visual Studio Dev15 RTM Future Edition 1 Retail"
	3712 = "Visual Studio Dev15 RTM Future Edition 1 Retail"
	3713 = "Visual Studio Dev15 RTM Future Edition 1 Volume:GVLK"
	3714 = "Visual Studio Dev15 RTM Future Edition 2 Retail"
	3715 = "Visual Studio Dev15 RTM Future Edition 2 Retail"
	3716 = "Visual Studio Dev15 RTM Future Edition 2 Volume:GVLK"
	3717 = "Visual Studio Dev15 RTM Future Edition 3 Retail"
	3718 = "Visual Studio Dev15 RTM Future Edition 3 Volume:MAK"
	3719 = "Visual Studio Dev15 RTM Future Edition 3 Volume:GVLK"
	4339 = "Visual Studio 2019 RTM Enterprise Retail"
	4340 = "Visual Studio 2019 RTM Enterprise Volume:MAK"
	4341 = "Visual Studio 2019 RTM Future Edition 1 Volume:GVLK"
	4342 = "Visual Studio 2019 RTM Future Edition 2 Volume:GVLK"
	4343 = "Visual Studio 2019 RTM Future Edition 3 Volume:GVLK"
	4344 = "Visual Studio 2019 RTM Future Edition 1 Retail"
	4345 = "Visual Studio 2019 RTM Future Edition 2 Retail"
	4346 = "Visual Studio 2019 RTM Future Edition 3 Retail"
	4347 = "Visual Studio 2019 RTM Future Edition 1 Volume"
	4348 = "Visual Studio 2019 RTM Future Edition 2 Volume"
	4349 = "Visual Studio 2019 RTM Future Edition 3 Volume"
	4350 = "Visual Studio 2019 RTM Perpetual All Retail"
	4351 = "Visual Studio 2019 RTM Prerelease All Retail"
	4352 = "Visual Studio 2019 RTM Professional Retail"
	4353 = "Visual Studio 2019 RTM Professional Volume:MAK"
	4356 = "Visual Studio 2019 RTM Trial 30 All Retail"
	4357 = "Visual Studio 2019 RTM Trial 90 All Retail"
	4767 = "Visual Studio Dev17 RTM Prerelease All Retail"
	4768 = "Visual Studio Dev17 RTM Trial 30 All Retail"
	4821 = "Visual Studio 2022 RTM  Enterprise Retail"
	4822 = "Visual Studio 2022 RTM  Enterprise Volume:MAK"
	4823 = "Visual Studio 2022 RTM  Future Edition 1 Retail"
	4824 = "Visual Studio 2022 RTM  Future Edition 1 Volume:GVLK"
	4825 = "Visual Studio 2022 RTM  Future Edition 1 Volume:MAK"
	4826 = "Visual Studio 2022 RTM  Future Edition 2 Retail"
	4827 = "Visual Studio 2022 RTM  Future Edition 2 Volume:GVLK"
	4828 = "Visual Studio 2022 RTM  Future Edition 2 Volume:MAK"
	4829 = "Visual Studio 2022 RTM  Perpetual All Retail"
	4830 = "Visual Studio 2022 RTM  Professional Retail"
	4831 = "Visual Studio 2022 RTM  Professional Volume:MAK"
	3258 = "Core, Win 10 RTM Core OEM:DM"
	3259 = "Core, Win 10 RTM Core OEM:DM"
	3260 = "Core, Win 10 RTM Core OEM:NONSLP"
	3261 = "Core, Win 10 RTM Core Retail"
	3262 = "Core, Win 10 RTM Core Retail"
	3263 = "Core, Win 10 RTM Core Volume:GVLK"
	3264 = "CoreCountrySpecific, Win 10 RTM CoreCountrySpecific OEM:DM"
	3265 = "CoreCountrySpecific, Win 10 RTM CoreCountrySpecific OEM:NONSLP"
	3266 = "CoreCountrySpecific, Win 10 RTM CoreCountrySpecific Retail"
	3267 = "CoreCountrySpecific, Win 10 RTM CoreCountrySpecific Volume:GVLK"
	3268 = "CoreN, Win 10 RTM CoreN OEM:DM"
	3269 = "CoreN, Win 10 RTM CoreN OEM:NONSLP"
	3270 = "CoreN, Win 10 RTM CoreN Retail"
	3271 = "CoreN, Win 10 RTM CoreN Retail"
	3272 = "CoreN, Win 10 RTM CoreN Volume:GVLK"
	3273 = "CoreSingleLanguage, Win 10 RTM CoreSingleLanguage OEM:DM"
	3274 = "CoreSingleLanguage, Win 10 RTM CoreSingleLanguage OEM:DM"
	3275 = "CoreSingleLanguage, Win 10 RTM CoreSingleLanguage OEM:NONSLP"
	3276 = "CoreSingleLanguage, Win 10 RTM CoreSingleLanguage Retail"
	3277 = "CoreSingleLanguage, Win 10 RTM CoreSingleLanguage Volume:GVLK"
	3278 = "Education, Win 10 RTM Education OEM:DM"
	3279 = "Education, Win 10 RTM Education OEM:NONSLP"
	3280 = "Education, Win 10 RTM Education Retail"
	3281 = "Education, Win 10 RTM Education Volume:GVLK"
	3282 = "Education, Win 10 RTM Education Volume:MAK"
	3283 = "EducationN, Win 10 RTM EducationN OEM:DM"
	3284 = "EducationN, Win 10 RTM EducationN OEM:NONSLP"
	3285 = "EducationN, Win 10 RTM EducationN Retail"
	3286 = "EducationN, Win 10 RTM EducationN Volume:GVLK"
	3287 = "EducationN, Win 10 RTM EducationN Volume:MAK"
	3288 = "Enterprise, Win 10 RTM Enterprise OEM:DM"
	3289 = "Enterprise, Win 10 RTM Enterprise OEM:NONSLP"
	3290 = "Enterprise, Win 10 RTM Enterprise Volume:GVLK"
	3291 = "Enterprise, Win 10 RTM Enterprise Volume:MAK"
	3292 = "EnterpriseEval, Win 10 RTM EnterpriseEval Retail:TB:Eval"
	3293 = "EnterpriseS, Win 10 RTM EnterpriseS OEM:DM"
	3294 = "EnterpriseS, Win 10 RTM EnterpriseS OEM:NONSLP"
	3295 = "EnterpriseS, Win 10 RTM EnterpriseS Volume:GVLK"
	3296 = "EnterpriseS, Win 10 RTM EnterpriseS Volume:MAK"
	3297 = "EnterpriseSEval, Win 10 RTM EnterpriseSEval Retail:TB:Eval"
	3298 = "EnterpriseSNEval, Win 10 RTM EnterpriseSNEval Retail:TB:Eval"
	3299 = "EnterpriseN, Win 10 RTM EnterpriseN Volume:GVLK"
	3300 = "EnterpriseN, Win 10 RTM EnterpriseN Volume:MAK"
	3301 = "EnterpriseNEval, Win 10 RTM EnterpriseNEval Retail:TB:Eval"
	3302 = "EnterpriseSN, Win 10 RTM EnterpriseSN Volume:GVLK"
	3303 = "EnterpriseSN, Win 10 RTM EnterpriseSN Volume:MAK"
	3304 = "PPIPro, Win 10 RTM PPIPro OEM:NONSLP"
	3305 = "Professional, Win 10 RTM Professional OEM:DM"
	3306 = "Professional, Win 10 RTM Professional OEM:DM"
	3307 = "Professional, Win 10 RTM Professional OEM:NONSLP"
	3308 = "Professional, Win 10 RTM Professional Retail"
	3309 = "Professional, Win 10 RTM Professional Retail"
	3310 = "Professional, Win 10 RTM Professional Retail"
	3311 = "Professional, Win 10 RTM Professional Volume:GVLK"
	3312 = "Professional, Win 10 RTM Professional Volume:MAK"
	3313 = "Professional, Win 10 RTM Professional Volume:MAK"
	3314 = "ProfessionalN, Win 10 RTM ProfessionalN OEM:DM"
	3315 = "ProfessionalN, Win 10 RTM ProfessionalN OEM:NONSLP"
	3316 = "ProfessionalN, Win 10 RTM ProfessionalN Retail"
	3317 = "ProfessionalN, Win 10 RTM ProfessionalN Retail"
	3318 = "ProfessionalN, Win 10 RTM ProfessionalN Retail"
	3319 = "ProfessionalN, Win 10 RTM ProfessionalN Volume:GVLK"
	3320 = "ProfessionalN, Win 10 RTM ProfessionalN Volume:MAK"
	3321 = "ProfessionalN, Win 10 RTM ProfessionalN Volume:MAK"
	3322 = "Office16_AccessR_OEM_Perp"
	3323 = "Office16_AccessR_Retail"
	3324 = "Office16_AccessR_Trial"
	3325 = "Office16_AccessRuntimeR_PrepidBypass"
	3326 = "Office16_AccessVL_KMS_Client"
	3327 = "Office16_AccessVL_MAK"
	3328 = "Office16_ExcelR_OEM_Perp"
	3329 = "Office16_ExcelR_Retail"
	3330 = "Office16_ExcelR_Trial"
	3331 = "Office16_ExcelVL_KMS_Client"
	3332 = "Office16_ExcelVL_MAK"
	3333 = "Office16_HomeBusinessDemoR_BypassTrial365"
	3334 = "Office16_HomeBusinessR_OEM_Perp"
	3335 = "Office16_HomeBusinessR_Retail3"
	3336 = "Office16_HomeBusinessR_Trial2"
	3339 = "Office16_HomeStudentDemoR_BypassTrial180"
	3340 = "Office16_HomeStudentPlusARMPreInstallR_OEM_ARM"
	3341 = "Office16_HomeStudentARMPreInstallR_OEM_ARM"
	3342 = "Office16_HomeStudentR_OEM_Perp"
	3343 = "Office16_HomeStudentR_Retail"
	3344 = "Office16_HomeStudentR_Trial"
	3348 = "Office16_MondoR_OEM_Perp"
	3349 = "Office16_MondoR_Retail"
	3350 = "Office16_MondoR_Trial"
	3351 = "Office16_MondoR_Subscription2"
	3352 = "Office16_MondoR_SubTrial2"
	3353 = "Office16_MondoVL_KMS_Client"
	3354 = "Office16_MondoVL_MAK"
	3355 = "Office16_MOSS_Bypass"
	3356 = "Office16_MOSSFISEnt_Bypass"
	3357 = "Office16_MOSSFISStd_Bypass"
	3358 = "Office16_MOSSPremium_Bypass"
	3359 = "Office16_OfficeLPK_Bypass"
	3360 = "Office16_OneNoteFreeR_Bypass"
	3361 = "Office16_OneNoteR_OEM_Perp"
	3362 = "Office16_OneNoteR_Retail"
	3363 = "Office16_OneNoteR_Trial"
	3364 = "Office16_OneNoteVL_KMS_Client"
	3365 = "Office16_OneNoteVL_MAK"
	3366 = "Office16_OutlookR_OEM_Perp"
	3367 = "Office16_OutlookR_Retail"
	3368 = "Office16_OutlookVL_KMS_Client"
	3369 = "Office16_OutlookVL_MAK"
	3370 = "Office16_PowerPointR_OEM_Perp"
	3371 = "Office16_PowerPointR_Retail"
	3372 = "Office16_PowerPointVL_KMS_Client"
	3373 = "Office16_PowerPointVL_MAK"
	3374 = "Office16_ProfessionalR_OEM_Perp"
	3375 = "Office16_ProjectLPK_Bypass"
	3376 = "Office16_ProjectProDemoR_BypassTrial180"
	3377 = "Office16_ProjectProR_OEM_Perp"
	3378 = "Office16_ProjectProR_Retail"
	3379 = "Office16_ProjectProR_Trial"
	3380 = "Office16_ProjectProVL_KMS_Client"
	3381 = "Office16_ProjectProVL_MAK"
	3382 = "Office16_ProjectServer_BypassTrial180"
	3383 = "Office16_ProjectStdR_OEM_Perp"
	3384 = "Office16_ProjectStdR_Retail"
	3385 = "Office16_ProjectStdVL_KMS_Client"
	3386 = "Office16_ProjectStdVL_MAK"
	3387 = "Office16_ProPlusDemoR_BypassTrial180"
	3388 = "Office16_ProPlusR_OEM_Perp2"
	3389 = "Office16_ProPlusR_Retail"
	3390 = "Office16_ProPlusR_Trial"
	3391 = "Office16_ProPlusVL_KMS_Client"
	3392 = "Office16_ProPlusVL_MAK"
	3393 = "Office16_PTK_Bypass"
	3394 = "Office16_PublisherR_OEM_Perp"
	3395 = "Office16_PublisherR_Retail"
	3396 = "Office16_PublisherR_Trial"
	3397 = "Office16_PublisherVL_KMS_Client"
	3398 = "Office16_PublisherVL_MAK"
	3399 = "Office16_ServerLPK_Bypass"
	3400 = "Office16_SkypeforBusinessEntryR_PrepidBypass"
	3401 = "Office16_SkypeforBusinessR_Retail"
	3402 = "Office16_SkypeforBusinessR_Trial"
	3403 = "Office16_SkypeforBusinessVDI_Bypass"
	3404 = "Office16_SkypeforBusinessVL_KMS_Client"
	3405 = "Office16_SkypeforBusinessVL_MAK"
	3406 = "Office16_StandardR_Retail"
	3407 = "Office16_StandardR_Trial"
	3408 = "Office16_StandardVL_KMS_Client"
	3409 = "Office16_StandardVL_MAK"
	3410 = "Office16_VisioLPK_Bypass"
	3411 = "Office16_VisioProDemoR_BypassTrial180"
	3412 = "Office16_VisioProR_OEM_Perp"
	3413 = "Office16_VisioProR_Retail"
	3414 = "Office16_VisioProR_Trial"
	3415 = "Office16_VisioProVL_KMS_Client"
	3416 = "Office16_VisioProVL_MAK"
	3417 = "Office16_VisioStdR_OEM_Perp"
	3418 = "Office16_VisioStdR_Retail"
	3419 = "Office16_VisioStdVL_KMS_Client"
	3420 = "Office16_VisioStdVL_MAK"
	3421 = "Office16_WordR_OEM_Perp"
	3422 = "Core, Win 10 RTM Core OEM:DM"
	3423 = "CoreCountrySpecific, Win 10 RTM CoreCountrySpecific OEM:DM"
	3424 = "CoreSingleLanguage, Win 10 RTM CoreSingleLanguage OEM:DM"
	3425 = "Professional, Win 10 RTM Professional OEM:DM"
	3426 = "Office16_WordR_Retail"
	3427 = "Office16_WordR_Trial"
	3428 = "Office16_WordVL_KMS_Client"
	3429 = "Office16_WordVL_MAK"
	3432 = "Office16_WordR_Grace"
	3433 = "Office16_HomeBusinessR_Retail2"
	3434 = "Office16_HomeBusinessR_Retail"
	3435 = "Office16_HomeBusinessR_OEM_Perp4"
	3436 = "Office16_HomeBusinessR_OEM_Perp2"
	3437 = "Office16_HomeBusinessR_OEM_Perp3"
	3438 = "Office16_HomeBusinessR_Grace"
	3439 = "Office16_HomeBusinessR_Trial"
	3441 = "Office16_AccessR_Grace"
	3442 = "Office16_HomeStudentR_Grace"
	3443 = "Office16_HomeStudentR_Trial2"
	3445 = "Office16_MondoR_Grace"
	3446 = "Office16_MondoR_BypassTrial180"
	3447 = "Office16_MondoR_SubTest2"
	3448 = "Office16_MOSS_BypassTrial180"
	3449 = "Office16_MOSSFISEnt_BypassTrial180"
	3450 = "Office16_MOSSFISStd_BypassTrial180"
	3451 = "Office16_MOSSPremium_BypassTrial180"
	3452 = "Office16_OneNoteR_Grace"
	3453 = "Office16_OutlookR_Grace"
	3454 = "Office16_PowerPointR_Grace"
	3455 = "Office16_ProjectProR_Grace"
	3456 = "Office16_ProjectProR_Retail2"
	3457 = "Office16_ProjectServer_Bypass"
	3458 = "Office16_ProjectStdR_Grace"
	3459 = "Office16_ProPlusR_OEM_Perp6"
	3460 = "Office16_ProPlusR_OEM_Perp4"
	3461 = "Office16_ProPlusR_OEM_Perp"
	3462 = "Office16_ProPlusR_OEM_Perp3"
	3463 = "Office16_ProPlusR_OEM_Perp5"
	3464 = "Office16_ProPlusR_Grace"
	3465 = "Office16_PublisherR_Grace"
	3466 = "Office16_SkypeforBusinessR_Grace"
	3467 = "Office16_StandardR_Grace"
	3468 = "Office16_VisioProR_Grace"
	3469 = "Office16_VisioStdR_Grace"
	3470 = "Office16_ExcelR_Grace"
	3471 = "Office16_VisioProR_Retail2"
	3473 = "EducationN, Win Next Pre-Release EducationN OEM:DM"
	3474 = "EducationN, Win Next Pre-Release EducationN Retail"
	3475 = "EducationN, Win Next Pre-Release EducationN Volume:GVLK"
	3476 = "EducationN, Win Next Pre-Release EducationN Volume:MAK"
	3477 = "Core, Win Next Pre-Release Core Retail"
	3478 = "Core, Win Next Pre-Release Core Retail"
	3479 = "Professional, Win Next Pre-Release Professional Retail"
	3480 = "Professional, Win Next Pre-Release Professional Retail"
	3481 = "ProfessionalS, Win Next Pre-Release ProfessionalS Volume:GVLK"
	3482 = "ProfessionalS, Win Next Pre-Release ProfessionalS Volume:MAK"
	3483 = "ProfessionalSN, Win Next Pre-Release ProfessionalSN Volume:GVLK"
	3484 = "ProfessionalSN, Win Next Pre-Release ProfessionalSN Volume:MAK"
	3485 = "EnterpriseS, Win Next Pre-Release EnterpriseS OEM:DM"
	3486 = "EnterpriseS, Win Next Pre-Release EnterpriseS OEM:NONSLP"
	3487 = "EnterpriseS, Win Next Pre-Release EnterpriseS Volume:MAK"
	3488 = "EnterpriseS, Win Next Pre-Release EnterpriseS Volume:GVLK"
	3489 = "EnterpriseSN, Win Next Pre-Release EnterpriseSN OEM:DM"
	3490 = "EnterpriseSN, Win Next Pre-Release EnterpriseSN OEM:NONSLP"
	3491 = "EnterpriseSN, Win Next Pre-Release EnterpriseSN Volume:MAK"
	3492 = "EnterpriseSN, Win Next Pre-Release EnterpriseSN Volume:GVLK"
	3493 = "EnterpriseSEval, Win Next Pre-Release EnterpriseSEval Retail:TB:Eval"
	3494 = "EnterpriseSNEval, Win Next Pre-Release EnterpriseSNEval Retail:TB:Eval"
	3495 = "MobileCore, Win Next Pre-Release MobileCore Retail"
	3496 = "MobileEnterprise, Win Next Pre-Release MobileEnterprise Volume:MAK"
	3498 = "ServerHI, Windows Server Next Beta ServerHI Retail"
	3499 = "ServerHI, Windows Server Next Beta ServerHI Volume:MAK"
	3500 = "ServerHI, Windows Server Next Beta ServerHI Volume:GVLK"
	3501 = "ServerHI, Windows Server Next Beta ServerHI OEM:NONSLP"
	3502 = "ServerHI, Windows Server Next Beta ServerHI OEM:SLP"
	3503 = "ServerHI, Windows Server Next Beta ServerHI VT:IA"
	3504 = "Core, Win 10 RTM Core Retail"
	3505 = "Core, Win 10 RTM Core Retail"
	3506 = "Professional, Win 10 RTM Professional Retail"
	3507 = "Professional, Win 10 RTM Professional Retail"
	3510 = "ServerARM64, Windows Server Next Beta ServerARM64 Retail"
	3511 = "Office16_ProPlusR_Trial2"
	3513 = "Office16_ProPlusMSDNR_Retail"
	3514 = "Office16_ProfessionalR_Grace"
	3515 = "Office16_ProfessionalDemoR_BypassTrial180"
	3516 = "Office16_ProfessionalR_Trial"
	3517 = "Office16_ProfessionalR_Retail"
	3519 = "Office16_ProjectProMSDNR_Retail"
	3520 = "Office16_VisioProMSDNR_Retail"
	3521 = "Office16_StandardMSDNR_Retail"
	3522 = "Office16_PowerPointR_Trial"
	3523 = "Office16_PersonalR_Retail"
	3524 = "Office16_OutlookR_Trial"
	3525 = "Office16_WacServerLPK_Bypass"
	3526 = "Office16_WCServer_Bypass"
	3527 = "Office16_PersonalDemoR_BypassTrial180"
	3528 = "Office16_PersonalR_Grace"
	3529 = "Office16_PersonalR_OEM_Perp"
	3532 = "Office16_PersonalR_Trial"
	3534 = "Office16_O365ProPlusDemoR_BypassTrial365"
	3535 = "Office16_O365HomePremDemoR_BypassTrial365"
	3536 = "Office16_O365SmallBusPremDemoR_BypassTrial365"
	3537 = "Office16_O365BusinessDemoR_BypassTrial365"
	3538 = "Office16_PersonalPipcDemoR_BypassTrial365"
	3539 = "Office16_HomeBusinessPipcDemoR_BypassTrial365"
	3540 = "Office16_MondoR_KMS_Automation"
	3555 = "Professional, Win 10 RTM Professional OEM:DM"
	3556 = "Professional, Win 10 RTM Professional OEM:DM"
	3557 = "Professional, Win 10 RTM Professional OEM:DM"
	3558 = "ProfessionalN, Win 10 RTM ProfessionalN OEM:DM"
	3559 = "ProfessionalN, Win 10 RTM ProfessionalN OEM:DM"
	3560 = "Core, Win 10 RTM Core OEM:DM"
	3561 = "CoreCountrySpecific, Win 10 RTM CoreCountrySpecific OEM:DM"
	3562 = "CoreSingleLanguage, Win 10 RTM CoreSingleLanguage OEM:DM"
	3563 = "Professional, Win 10 RTM Professional OEM:DM"
	3568 = "Core, Win 10 Pre-Release Core OEM:DM"
	3569 = "Core, Win 10 Pre-Release Core OEM:NONSLP"
	3570 = "Core, Win 10 Pre-Release Core Retail"
	3571 = "Core, Win 10 Pre-Release Core Retail Qihoo"
	3572 = "Core, Win 10 Pre-Release Core Retail Tencent"
	3573 = "Core, Win 10 Pre-Release Core Volume:GVLK"
	3574 = "CoreCountrySpecific, Win 10 Pre-Release CoreCountrySpecific OEM:DM"
	3575 = "CoreCountrySpecific, Win 10 Pre-Release CoreCountrySpecific OEM:NONSLP"
	3576 = "CoreCountrySpecific, Win 10 Pre-Release CoreCountrySpecific Retail"
	3577 = "CoreCountrySpecific, Win 10 Pre-Release CoreCountrySpecific Volume:GVLK"
	3578 = "CoreN, Win 10 Pre-Release CoreN OEM:DM"
	3579 = "CoreN, Win 10 Pre-Release CoreN OEM:NONSLP"
	3580 = "CoreN, Win 10 Pre-Release CoreN Retail"
	3581 = "CoreN, Win 10 Pre-Release CoreN Volume:GVLK"
	3582 = "CoreSingleLanguage, Win 10 Pre-Release CoreSingleLanguage OEM:DM"
	3583 = "CoreSingleLanguage, Win 10 Pre-Release CoreSingleLanguage OEM:NONSLP"
	3584 = "CoreSingleLanguage, Win 10 Pre-Release CoreSingleLanguage Retail"
	3585 = "CoreSingleLanguage, Win 10 Pre-Release CoreSingleLanguage Volume:GVLK"
	3586 = "Education, Win 10 Pre-Release Education OEM:DM"
	3587 = "Education, Win 10 Pre-Release Education OEM:NONSLP"
	3588 = "Education, Win 10 Pre-Release Education Retail"
	3589 = "Education, Win 10 Pre-Release Education Volume:GVLK"
	3590 = "Education, Win 10 Pre-Release Education Volume:MAK"
	3591 = "EducationN, Win 10 Pre-Release EducationN OEM:DM"
	3592 = "EducationN, Win 10 Pre-Release EducationN OEM:NONSLP"
	3593 = "EducationN, Win 10 Pre-Release EducationN Retail"
	3594 = "EducationN, Win 10 Pre-Release EducationN Volume:GVLK"
	3595 = "EducationN, Win 10 Pre-Release EducationN Volume:MAK"
	3596 = "Enterprise, Win 10 Pre-Release Enterprise OEM:DM"
	3597 = "Enterprise, Win 10 Pre-Release Enterprise OEM:NONSLP"
	3598 = "Enterprise, Win 10 Pre-Release Enterprise Volume:GVLK"
	3599 = "Enterprise, Win 10 Pre-Release Enterprise Retail"
	3600 = "Enterprise, Win 10 Pre-Release Enterprise Volume:MAK"
	3601 = "EnterpriseEval, Win 10 Pre-Release EnterpriseEval Retail:TB:Eval"
	3602 = "EnterpriseS, Win 10 Pre-Release EnterpriseS Retail"
	3603 = "EnterpriseS, Win 10 Pre-Release EnterpriseS OEM:DM"
	3604 = "EnterpriseS, Win 10 Pre-Release EnterpriseS OEM:NONSLP"
	3605 = "EnterpriseS, Win 10 Pre-Release EnterpriseS Volume:GVLK"
	3606 = "EnterpriseS, Win 10 Pre-Release EnterpriseS Volume:MAK"
	3607 = "EnterpriseSEval, Win 10 Pre-Release EnterpriseSEval Retail:TB:Eval"
	3608 = "EnterpriseSNEval, Win 10 Pre-Release EnterpriseSNEval Retail:TB:Eval"
	3609 = "EnterpriseN, Win 10 Pre-Release EnterpriseN Volume:GVLK"
	3610 = "EnterpriseN, Win 10 Pre-Release EnterpriseN Retail"
	3611 = "EnterpriseN, Win 10 Pre-Release EnterpriseN Volume:MAK"
	3612 = "EnterpriseNEval, Win 10 Pre-Release EnterpriseNEval Retail:TB:Eval"
	3613 = "EnterpriseSN, Win 10 Pre-Release EnterpriseSN Volume:GVLK"
	3614 = "EnterpriseSN, Win 10 Pre-Release EnterpriseSN OEM:DM"
	3615 = "EnterpriseSN, Win 10 Pre-Release EnterpriseSN OEM:NONSLP"
	3616 = "EnterpriseSN, Win 10 Pre-Release EnterpriseSN Volume:MAK"
	3617 = "PPIPro, Win 10 Pre-Release PPIPro Volume:GVLK"
	3618 = "PPIPro, Win 10 Pre-Release PPIPro OEM:NONSLP"
	3619 = "Professional, Win 10 Pre-Release Professional OEM:DM"
	3620 = "Professional, Win 10 Pre-Release Professional OEM:NONSLP"
	3621 = "Professional, Win 10 Pre-Release Professional Retail"
	3622 = "Professional, Win 10 Pre-Release Professional Retail Qihoo"
	3623 = "Professional, Win 10 Pre-Release Professional Retail Tencent"
	3624 = "Professional, Win 10 Pre-Release Professional Volume:GVLK"
	3625 = "Professional, Win 10 Pre-Release Professional Volume:MAK"
	3626 = "ProfessionalN, Win 10 Pre-Release ProfessionalN OEM:DM"
	3627 = "ProfessionalN, Win 10 Pre-Release ProfessionalN OEM:NONSLP"
	3628 = "ProfessionalN, Win 10 Pre-Release ProfessionalN Retail"
	3629 = "ProfessionalN, Win 10 Pre-Release ProfessionalN Volume:GVLK"
	3630 = "ProfessionalN, Win 10 Pre-Release ProfessionalN Volume:MAK"
	3631 = "MobileCore, Win 10 Pre-Release MobileCore Retail"
	3632 = "MobileEnterprise, Win 10 Pre-Release MobileEnterprise Volume:MAK"
	3633 = "CoreARM, Win 10 Pre-Release CoreARM OEM:DM"
	3634 = "CoreARM, Win 10 Pre-Release CoreARM OEM:NONSLP"
	3635 = "CoreARM, Win 10 Pre-Release CoreARM Volume:GVLK"
	3672 = "ProfessionalWMC, Win 10 Pre-Release ProfessionalWMC Volume:GVLK"
	3673 = "ProfessionalWMC, Win 10 Pre-Release ProfessionalWMC Retail"
	3676 = "Professional, Win 10 Pre-Release Professional Retail"
	3677 = "ProfessionalN, Win 10 Pre-Release ProfessionalN Retail"
	3678 = "AnalogOneCore, Win 10 RTM AnalogOneCore Retail"
	3679 = "AnalogOneCoreEnterprise, Win 10 RTM AnalogOneCoreEnterprise Volume:MAK"
	3687 = "Office16_ProjectProXC2RVL_KMS_ClientC2R"
	3688 = "Office16_ProjectStdXC2RVL_KMS_ClientC2R"
	3689 = "Office16_VisioProXC2RVL_KMS_ClientC2R"
	3690 = "Office16_VisioStdXC2RVL_KMS_ClientC2R"
	3691 = "Office16_VisioProXC2RVL_MAKC2R"
	3692 = "Office16_VisioStdXC2RVL_MAKC2R"
	3693 = "Office16_ProjectProXC2RVL_MAKC2R"
	3694 = "Office16_ProjectStdXC2RVL_MAKC2R"
	3720 = "IoTUAP, Win 10 RTM IoTUAP Retail"
	3721 = "IoTUAPCommercial, Win 10 RTM IoTUAPCommercial Volume:MAK"
	3728 = "CoreSystemServer, Windows Server 12 R2 RTM CoreSystemServer Retail"
	3732 = "ServerDatacenterNano, Windows Server Next RTM ServerDatacenterNano Retail"
	3733 = "ServerStandardNano, Windows Server Next RTM ServerStandardNano Retail"
	3734 = "Office16_HomeStudentVNextR_Retail"
	3735 = "Office16_HomeStudentVNextR_Grace"
	3736 = "Office16_HomeStudentVNextR_Trial"
	3744 = "ServerCloudStorage, ServerCloudStorage 2016 RTM ServerCloudStorage OEM:NONSLP"
	3745 = "ServerCloudStorage, ServerCloudStorage 2016 RTM ServerCloudStorage OEM:SLP"
	3746 = "ServerCloudStorage, ServerCloudStorage 2016 RTM ServerCloudStorage Retail"
	3747 = "ServerCloudStorage, ServerCloudStorage 2016 RTM ServerCloudStorage Volume:GVLK"
	3748 = "ServerStorageStandard, Storage Server 2016 RTM ServerStorageStandard OEM:SLP"
	3749 = "ServerStorageStandard, Storage Server 2016 RTM ServerStorageStandard OEM:NONSLP"
	3750 = "ServerStorageStandard, Storage Server 2016 RTM ServerStorageStandard Retail"
	3751 = "ServerStorageWorkgroup, Storage Server 2016 RTM ServerStorageWorkgroup OEM:SLP"
	3752 = "ServerStorageWorkgroup, Storage Server 2016 RTM ServerStorageWorkgroup OEM:NONSLP"
	3753 = "ServerStorageWorkgroup, Storage Server 2016 RTM ServerStorageWorkgroup Retail"
	3754 = "ServerSolution, Windows Server Essentials 2016 RTM ServerSolution OEM:NONSLP"
	3755 = "ServerSolution, Windows Server Essentials 2016 RTM ServerSolution OEM:NONSLP (MUI locked to zh-CN)"
	3756 = "ServerSolution, Windows Server Essentials 2016 RTM ServerSolution OEM:SLP"
	3757 = "ServerSolution, Windows Server Essentials 2016 RTM ServerSolution OEM:SLP (MUI locked to zh-CN)"
	3758 = "ServerSolution, Windows Server Essentials 2016 RTM ServerSolution Retail"
	3759 = "ServerSolution, Windows Server Essentials 2016 RTM ServerSolution Retail:TB:Eval"
	3760 = "ServerSolution, Windows Server Essentials 2016 RTM ServerSolution Volume:GVLK"
	3761 = "ServerSolution, Windows Server Essentials 2016 RTM ServerSolution Volume:MAK"
	3762 = "ServerSolution, Windows Server Essentials 2016 RTM ServerSolution VT:IA"
	3763 = "ServerStandard, Windows Server 2016 RTM ServerStandard Retail"
	3764 = "ServerDatacenter, Windows Server 2016 RTM ServerDatacenter Volume:GVLK"
	3765 = "ServerDatacenter, Windows Server 2016 RTM ServerDatacenter Volume:MAK"
	3766 = "ServerDatacenter, Windows Server 2016 RTM ServerDatacenter VT:IA"
	3767 = "ServerDatacenter, Windows Server 2016 RTM ServerDatacenter OEM:NONSLP"
	3768 = "ServerDatacenter, Windows Server 2016 RTM ServerDatacenter OEM:NONSLP (MUI locked to zh-CN)"
	3769 = "ServerDatacenter, Windows Server 2016 RTM ServerDatacenter OEM:SLP"
	3770 = "ServerDatacenter, Windows Server 2016 RTM ServerDatacenter OEM:SLP (MUI locked to zh-CN)"
	3771 = "ServerDatacenterEval, Windows Server 2016 RTM ServerDatacenterEval Retail:TB:Eval"
	3772 = "ServerStandard, Windows Server 2016 RTM ServerStandard OEM:NONSLP"
	3773 = "ServerStandard, Windows Server 2016 RTM ServerStandard OEM:NONSLP (MUI locked to zh-CN)"
	3774 = "ServerStandard, Windows Server 2016 RTM ServerStandard OEM:SLP"
	3775 = "ServerStandard, Windows Server 2016 RTM ServerStandard OEM:SLP (MUI locked to zh-CN)"
	3776 = "ServerStandard, Windows Server 2016 RTM ServerStandard Volume:GVLK"
	3777 = "ServerStandard, Windows Server 2016 RTM ServerStandard Volume:MAK"
	3778 = "ServerStandard, Windows Server 2016 RTM ServerStandard VT:IA"
	3779 = "ServerDatacenter, Windows Server 2016 RTM ServerDatacenter Retail"
	3780 = "ServerStandardEval, Windows Server 2016 RTM ServerStandardEval Retail:TB:Eval"
	3782 = "EnterpriseS, Win 10 RTM EnterpriseS Volume:GVLK"
	3783 = "EnterpriseSN, Win 10 RTM EnterpriseSN Volume:GVLK"
	3784 = "ProfessionalEducation, Win 10 RTM ProfessionalEducation Volume:GVLK"
	3785 = "ProfessionalEducationN, Win 10 RTM ProfessionalEducationN Volume:GVLK"
	3786 = "ProfessionalEducation, Win 10 RTM ProfessionalEducation Volume:MAK"
	3787 = "ProfessionalEducationN, Win 10 RTM ProfessionalEducationN Volume:MAK"
	3788 = "ServerAzureNano, Windows Server 2016 RTM ServerAzureNano Retail"
	3789 = "ServerAzureCor, Windows Server 2016 RTM ServerAzureCor Retail"
	3790 = "EnterpriseSubscription, Win 10 RTM EnterpriseSubscription Volume:MAK"
	3791 = "EnterpriseSubscriptionN, Win 10 RTM EnterpriseSubscriptionN Volume:MAK"
	3792 = "ProfessionalEducation, Win 10 RTM ProfessionalEducation OEM:DM"
	3793 = "ProfessionalEducation, Win 10 RTM ProfessionalEducation OEM:NONSLP"
	3794 = "ProfessionalEducationN, Win 10 RTM ProfessionalEducationN OEM:DM"
	3795 = "ProfessionalEducationN, Win 10 RTM ProfessionalEducationN OEM:NONSLP"
	3798 = "ProfessionalWorkstation, Win 10 RTM ProfessionalWorkstation Retail"
	3799 = "ProfessionalWorkstationN, Win 10 RTM ProfessionalWorkstationN Retail"
	3800 = "ProfessionalEducation, Win 10 RTM ProfessionalEducation Retail"
	3801 = "ProfessionalEducationN, Win 10 RTM ProfessionalEducationN Retail"
	3802 = "EnterpriseS, Win 10 RTM EnterpriseS Volume:MAK"
	3803 = "EnterpriseSN, Win 10 RTM EnterpriseSN Volume:MAK"
	3804 = "EnterpriseSEval, Win 10 RTM EnterpriseSEval Retail:TB:Eval"
	3805 = "EnterpriseSNEval, Win 10 RTM EnterpriseSNEval Retail:TB:Eval"
	3806 = "EnterpriseS, Win 10 RTM EnterpriseS OEM:DM"
	3807 = "EnterpriseS, Win 10 RTM EnterpriseS OEM:NONSLP"
	3839 = "ServerAzureCor, Windows Server 2016 RTM ServerAzureCor Volume:GVLK"
	3840 = "ServerAzureCor, Windows Server 2016 RTM ServerAzureCor VT:IA"
	3841 = "ServerDatacenterCor, Windows Server 2016 RTM ServerDatacenterCor Retail"
	3842 = "ServerDatacenterEvalCor, Windows Server 2016 RTM ServerDatacenterEvalCor Retail:TB:Eval"
	3843 = "ServerStandardCor, Windows Server 2016 RTM ServerStandardCor Retail"
	3844 = "ServerStandardEvalCor, Windows Server 2016 RTM ServerStandardEvalCor Retail:TB:Eval"
	3846 = "Office16_O365ProPlusE5R_Subscription"
	3847 = "Office16_O365ProPlusE5R_SubTrial"
	3848 = "Office16_O365ProPlusEDUR_Subscription"
	3849 = "Office16_O365ProPlusEDUR_SubTrial"
	3854 = "EnterpriseG, Win 10 RTM EnterpriseG OEM:DM"
	3855 = "EnterpriseG, Win 10 RTM EnterpriseG OEM:NONSLP"
	3856 = "EnterpriseG, Win 10 RTM EnterpriseG Volume:GVLK"
	3857 = "EnterpriseG, Win 10 RTM EnterpriseG Volume:MAK"
	3858 = "EnterpriseG;EnterpriseGN, Win 10 RTM EnterpriseG;EnterpriseGN Volume:CSVLK"
	3859 = "EnterpriseGN, Win 10 RTM EnterpriseGN OEM:DM"
	3860 = "EnterpriseGN, Win 10 RTM EnterpriseGN OEM:NONSLP"
	3861 = "EnterpriseGN, Win 10 RTM EnterpriseGN Volume:GVLK"
	3862 = "EnterpriseGN, Win 10 RTM EnterpriseGN Volume:MAK"
	3863 = "Cloud, Win 10 RTM Cloud OEM:DM"
	3864 = "Cloud, Win 10 RTM Cloud OEM:NONSLP"
	3865 = "Cloud, Win 10 RTM Cloud Retail"
	3866 = "CloudN, Win 10 RTM CloudN OEM:DM"
	3867 = "CloudN, Win 10 RTM CloudN OEM:NONSLP"
	3868 = "CloudN, Win 10 RTM CloudN Retail"
	3876 = "Office16_O365EduCloudEDUR_Grace"
	3877 = "Office16_O365EduCloudEDUR_Subscription"
	3878 = "Office16_O365EduCloudEDUR_SubTrial"
	3892 = "ServerRdsh, Windows Server Next Beta ServerRdsh Retail"
	3893 = "ServerRdsh, Windows Server Next Beta ServerRdsh OEM:NONSLP"
	3894 = "ServerRdsh, Windows Server Next Beta ServerRdsh OEM:SLP"
	3895 = "ServerRdsh, Windows Server Next Beta ServerRdsh Volume:GVLK"
	3896 = "ServerRdsh, Windows Server Next Beta ServerRdsh Volume:MAK"
	3909 = "ServerDatacenter, Windows Server 2016 RTM ServerDatacenter OEM:DM"
	3910 = "ServerStandard, Windows Server 2016 RTM ServerStandard OEM:DM"
	3913 = "Cloud, Win 10 RTM Cloud Volume:MAK"
	3914 = "CloudN, Win 10 RTM CloudN Volume:MAK"
	3915 = "ProfessionalWorkstation, Win 10 RTM ProfessionalWorkstation OEM:DM"
	3916 = "ProfessionalWorkstation, Win 10 RTM ProfessionalWorkstation OEM:NONSLP"
	3917 = "ProfessionalWorkstation, Win 10 RTM ProfessionalWorkstation Retail"
	3918 = "ProfessionalWorkstation, Win 10 RTM ProfessionalWorkstation Volume:GVLK"
	3919 = "ProfessionalWorkstation, Win 10 RTM ProfessionalWorkstation Volume:MAK"
	3920 = "ProfessionalWorkstationN, Win 10 RTM ProfessionalWorkstationN OEM:DM"
	3921 = "ProfessionalWorkstationN, Win 10 RTM ProfessionalWorkstationN OEM:NONSLP"
	3922 = "ProfessionalWorkstationN, Win 10 RTM ProfessionalWorkstationN Retail"
	3923 = "ProfessionalWorkstationN, Win 10 RTM ProfessionalWorkstationN Volume:GVLK"
	3924 = "ProfessionalWorkstationN, Win 10 RTM ProfessionalWorkstationN Volume:MAK"
	3925 = "ServerStandardACor, Windows Server Next Beta ServerStandardACor Volume:MAK"
	3926 = "ServerDatacenterACor, Windows Server Next Beta ServerDatacenterACor Volume:MAK"
	3948 = "Office16_MondoR_O16ConsumerPerp_Bypass30"
	3949 = "Office16_MondoR_ConsumerSub_Bypass30"
	3950 = "Office16_MondoR_EnterpriseSub_Bypass30"
	3951 = "Office16_MondoR_O17EnterpriseVL_Bypass30"
	3952 = "Office16_MondoR_O16EnterpriseVL_Bypass30"
	3953 = "Office16_MondoR_ViewOnly_ZeroGrace"
	3954 = "ProfessionalWorkstation, Win 10 Pre-Release ProfessionalWorkstation Retail"
	3955 = "ServerStandardACor, Windows Server 2016 RTM ServerStandardACor Volume:GVLK"
	3956 = "ServerDatacenterACor, Windows Server 2016 RTM ServerDatacenterACor Volume:GVLK"
	3958 = "ServerStandardACor, Windows Server 2016 RTM ServerStandardACor Retail"
	3959 = "ServerDatacenterACor, Windows Server 2016 RTM ServerDatacenterACor Retail"
	3960 = "ServerStandardACor, Windows Server 2016 RTM ServerStandardACor Volume:MAK"
	3961 = "ServerDatacenterACor, Windows Server 2016 RTM ServerDatacenterACor Volume:MAK"
	3979 = "Andromeda, Win 10 RTM Andromeda Retail"
	3980 = "Office 2019 ProPlus2019XC2RVL KMS ClientC2R"
	3987 = "ServerARM64, Windows Server 2016 RTM ServerARM64 Volume:GVLK"
	3988 = "OneCoreUpdateOS, Win 10 RTM OneCoreUpdateOS Retail"
	4024 = "Office19_Access2019R_OEM_Perp"
	4025 = "Office19_Access2019R_Retail"
	4026 = "Office19_Access2019R_Trial"
	4027 = "Office19_AccessRuntime2019R_PrepidBypass"
	4028 = "Office19_Access2019VL_KMS_Client_AE"
	4029 = "Office19_Access2019VL_MAK_AE"
	4030 = "Office19_Excel2019R_OEM_Perp"
	4031 = "Office19_Excel2019R_Grace"
	4032 = "Office19_Excel2019R_Retail"
	4033 = "Office19_Excel2019R_Trial"
	4034 = "Office19_Excel2019VL_KMS_Client_AE"
	4035 = "Office19_Excel2019VL_MAK_AE"
	4036 = "Office19_HomeBusiness2019DemoR_BypassTrial180"
	4039 = "Office19_HomeBusiness2019R_OEM_Perp"
	4040 = "Office19_HomeBusiness2019R_OEM_Perp2"
	4041 = "Office19_HomeBusiness2019R_OEM_Perp4"
	4042 = "Office19_HomeBusiness2019R_OEM_Perp3"
	4043 = "Office19_HomeBusiness2019R_Grace"
	4044 = "Office19_HomeBusiness2019R_Retail"
	4045 = "Office19_HomeBusiness2019R_Trial"
	4050 = "Office19_HomeStudent2019DemoR_BypassTrial180"
	4051 = "Office19_HomeStudentPlusARM2019PreInstallR_OEM_ARM"
	4052 = "Office19_HomeStudentARM2019PreInstallR_OEM_ARM"
	4053 = "Office19_HomeStudent2019R_OEM_Perp"
	4054 = "Office19_HomeStudent2019R_Grace"
	4055 = "Office19_HomeStudent2019R_Retail"
	4056 = "Office19_HomeStudent2019R_Trial"
	4061 = "Office16_MOSS_Bypass"
	4062 = "Office16_MOSS_BypassTrial180"
	4063 = "Office16_MOSSFISEnt_Bypass"
	4064 = "Office16_MOSSFISEnt_BypassTrial180"
	4065 = "Office16_MOSSFISStd_Bypass"
	4066 = "Office16_MOSSFISStd_BypassTrial180"
	4067 = "Office16_MOSSPremium_Bypass"
	4068 = "Office16_MOSSPremium_BypassTrial180"
	4083 = "Office19_OfficeLPK2019_Bypass"
	4091 = "Office19_Outlook2019R_OEM_Perp"
	4092 = "Office19_Outlook2019R_Trial"
	4093 = "Office19_Outlook2019R_Retail"
	4094 = "Office19_Outlook2019R_Grace"
	4095 = "Office19_Outlook2019VL_KMS_Client_AE"
	4096 = "Office19_Outlook2019VL_MAK_AE"
	4097 = "Office19_Personal2019DemoR_BypassTrial180"
	4098 = "Office19_Personal2019R_OEM_Perp"
	4099 = "Office19_Personal2019R_Trial"
	4100 = "Office19_Personal2019R_Retail"
	4101 = "Office19_Personal2019R_Grace"
	4102 = "Office19_PowerPoint2019R_OEM_Perp"
	4103 = "Office19_PowerPoint2019R_Trial"
	4104 = "Office19_PowerPoint2019R_Retail"
	4105 = "Office19_PowerPoint2019R_Grace"
	4106 = "Office19_PowerPoint2019VL_KMS_Client_AE"
	4107 = "Office19_PowerPoint2019VL_MAK_AE"
	4108 = "Office19_Professional2019DemoR_BypassTrial180"
	4109 = "Office19_Professional2019R_OEM_Perp"
	4110 = "Office19_Professional2019R_Trial"
	4111 = "Office19_Professional2019R_Retail"
	4112 = "Office19_Professional2019R_Grace"
	4113 = "Office19_ProjectLPK2019_Bypass"
	4114 = "Office19_ProjectPro2019DemoR_BypassTrial180"
	4115 = "Office19_ProjectPro2019MSDNR_Retail"
	4116 = "Office19_ProjectPro2019R_OEM_Perp"
	4117 = "Office19_ProjectPro2019R_Trial"
	4118 = "Office19_ProjectPro2019R_Grace"
	4119 = "Office19_ProjectPro2019R_Retail"
	4120 = "Office19_ProjectPro2019VL_KMS_Client_AE"
	4121 = "Office19_ProjectPro2019VL_MAK_AE"
	4123 = "Office16_ProjectServer_Bypass"
	4124 = "Office16_ProjectServer_BypassTrial180"
	4125 = "Office19_ProjectStd2019R_OEM_Perp"
	4126 = "Office19_ProjectStd2019R_Grace"
	4127 = "Office19_ProjectStd2019R_Retail"
	4128 = "Office19_ProjectStd2019VL_KMS_Client_AE"
	4129 = "Office19_ProjectStd2019VL_MAK_AE"
	4131 = "Office19_ProPlus2019DemoR_BypassTrial180"
	4132 = "Office19_ProPlus2019MSDNR_Retail"
	4133 = "Office19_ProPlus2019R_Trial"
	4134 = "Office19_ProPlus2019R_Trial2"
	4135 = "Office19_ProPlus2019R_Grace"
	4136 = "Office19_ProPlus2019R_Retail"
	4137 = "Office19_Publisher2019R_Grace"
	4138 = "Office19_Publisher2019R_Retail"
	4139 = "Office19_ProPlus2019R_OEM_Perp6"
	4140 = "Office19_ProPlus2019R_OEM_Perp"
	4141 = "Office19_ProPlus2019R_OEM_Perp4"
	4142 = "Office19_ProPlus2019R_OEM_Perp2"
	4143 = "Office19_ProPlus2019R_OEM_Perp5"
	4144 = "Office19_ProPlus2019R_OEM_Perp3"
	4145 = "Office19_ProPlus2019VL_KMS_Client_AE"
	4146 = "Office19_ProPlus2019VL_MAK_AE"
	4147 = "Office19_Publisher2019R_OEM_Perp"
	4148 = "Office19_Publisher2019R_Trial"
	4149 = "Office19_Publisher2019VL_KMS_Client_AE"
	4150 = "Office19_Publisher2019VL_MAK_AE"
	4151 = "Office19_SkypeforBusiness2019VL_MAK_AE"
	4152 = "Office19_Standard2019VL_MAK_AE"
	4153 = "Office19_VisioPro2019VL_MAK_AE"
	4155 = "Office19_VisioStd2019VL_MAK_AE"
	4157 = "Office19_Word2019VL_MAK_AE"
	4158 = "Office19_SkypeforBusiness2019VL_KMS_Client_AE"
	4159 = "Office19_Standard2019VL_KMS_Client_AE"
	4160 = "Office19_VisioPro2019VL_KMS_Client_AE"
	4161 = "Office19_VisioStd2019VL_KMS_Client_AE"
	4162 = "Office19_Word2019VL_KMS_Client_AE"
	4163 = "Office19_VisioPro2019R_OEM_Perp"
	4164 = "Office19_VisioStd2019R_OEM_Perp"
	4165 = "Office19_Word2019R_OEM_Perp"
	4166 = "Office16_ServerLPK_Bypass"
	4167 = "Office19_SkypeforBusinessEntry2019R_PrepidBypass"
	4168 = "Office19_SkypeforBusiness2019R_Grace"
	4169 = "Office19_SkypeforBusiness2019R_Trial"
	4170 = "Office19_SkypeforBusiness2019R_Retail"
	4171 = "Office19_Standard2019R_Retail"
	4172 = "Office19_Standard2019R_Trial"
	4173 = "Office19_Standard2019R_Grace"
	4174 = "Office19_VisioPro2019R_Grace"
	4175 = "Office19_VisioPro2019R_Retail"
	4176 = "Office19_VisioPro2019DemoR_BypassTrial180"
	4177 = "Office19_VisioPro2019MSDNR_Retail"
	4178 = "Office19_VisioLPK2019_Bypass"
	4179 = "Office19_Standard2019MSDNR_Retail"
	4180 = "Office19_VisioPro2019R_Trial"
	4181 = "Office19_VisioStd2019R_Grace"
	4182 = "Office19_VisioStd2019R_Retail"
	4183 = "Office19_Word2019R_Trial"
	4184 = "Office19_SkypeforBusinessVDI2019_Bypass"
	4185 = "Office19_Word2019R_Retail"
	4186 = "Office19_Word2019R_Grace"
	4187 = "Office19_PTK2019_Bypass"
	4190 = "Office16_WCServer_Bypass"
	4191 = "Office19_WacServerLPK2019_Bypass"
	4214 = "Office19_Access2019R_Grace"
	4232 = "CloudE, Win 10 RTM CloudE OEM:DM"
	4234 = "CloudE, Win 10 RTM CloudE Retail"
	4244 = "CloudE, Win 10 RTM CloudE Volume:GVLK"
	4247 = "EnterpriseS, Win 10 RTM EnterpriseS OEM:DM"
	4248 = "EnterpriseS, Win 10 RTM EnterpriseS OEM:NONSLP"
	4249 = "EnterpriseS, Win 10 RTM EnterpriseS Volume:MAK"
	4250 = "EnterpriseS, Win 10 RTM EnterpriseS Volume:GVLK"
	4251 = "EnterpriseSEval, Win 10 RTM EnterpriseSEval Retail:TB:Eval"
	4252 = "EnterpriseSN, Win 10 RTM EnterpriseSN Volume:MAK"
	4253 = "EnterpriseSN, Win 10 RTM EnterpriseSN Volume:GVLK"
	4254 = "EnterpriseSNEval, Win 10 RTM EnterpriseSNEval Retail:TB:Eval"
	4256 = "Andromeda, Win 10 RTM Andromeda OEM:DM"
	4257 = "HubOS, Win 10 RTM HubOS OEM:DM"
	4258 = "Andromeda, Win 10 RTM Andromeda Retail"
	4259 = "HubOS, Win 10 RTM HubOS Retail"
	4290 = "ServerStandard, Windows Server 2019 RTM ServerStandard Retail"
	4291 = "ServerStandard, Windows Server 2019 RTM ServerStandard OEM:NONSLP"
	4292 = "ServerStandard, Windows Server 2019 RTM ServerStandard OEM:NONSLP (MUI locked to zh-CN)"
	4293 = "ServerStandard, Windows Server 2019 RTM ServerStandard OEM:SLP"
	4294 = "ServerStandard, Windows Server 2019 RTM ServerStandard OEM:SLP (MUI locked to zh-CN)"
	4295 = "ServerStandard, Windows Server 2019 RTM ServerStandard OEM:DM"
	4296 = "ServerStandard, Windows Server 2019 RTM ServerStandard OEM:DM (MUI locked to zh-CN)"
	4297 = "ServerStandard, Windows Server 2019 RTM ServerStandard Volume:GVLK"
	4298 = "ServerStandard;ServerStandardACor, Windows Server 2019 RTM ServerStandard;ServerStandardACor Volume:MAK"
	4299 = "ServerStandard;ServerStandardACor, Windows Server 2019 RTM ServerStandard VT:IA"
	4300 = "ServerDatacenter, Windows Server 2019 RTM ServerDatacenter Volume:GVLK"
	4301 = "AzureStackHCIAddOn, Windows Server 2019 RTM AzureStackHCIAddOn Volume:MAK"
	4302 = "ServerDatacenter;ServerDatacenterACor, Windows Server 2019 RTM ServerDatacenter VT:IA"
	4303 = "AzureStackHCIAddOn, Windows Server 2019 RTM AzureStackHCIAddOn OEM:NONSLP"
	4304 = "ServerDatacenter, Windows Server 2019 RTM ServerDatacenter OEM:NONSLP (MUI locked to zh-CN)"
	4305 = "AzureStackHCIAddOn, Windows Server 2019 RTM AzureStackHCIAddOn OEM:SLP"
	4306 = "ServerDatacenter, Windows Server 2019 RTM ServerDatacenter OEM:SLP (MUI locked to zh-CN)"
	4307 = "AzureStackHCIAddOn, Windows Server 2019 RTM AzureStackHCIAddOn Retail"
	4308 = "AzureStackHCIAddOn, Windows Server 2019 RTM AzureStackHCIAddOn OEM:DM"
	4309 = "AzureStackHCIAddOn, Windows Server 2019 RTM AzureStackHCIAddOn OEM:DM"
	4310 = "ServerDatacenter, Windows Server 2019 RTM ServerDatacenter OEM:DM (MUI locked to zh-CN)"
	4311 = "ServerStandardEval, Windows Server 2019 RTM ServerStandardEval Retail:TB:Eval"
	4312 = "ServerDatacenterEval, Windows Server 2019 RTM ServerDatacenterEval Retail:TB:Eval"
	4313 = "ServerStandardACor, Windows Server 2019 RTM ServerStandardACor Volume:GVLK"
	4314 = "ServerDatacenterACor, Windows Server 2019 RTM ServerDatacenterACor Volume:GVLK"
	4315 = "ServerStandardACor, Windows Server 2019 RTM ServerStandardACor Retail"
	4316 = "ServerDatacenterACor, Windows Server 2019 RTM ServerDatacenterACor Retail"
	4317 = "ServerStandardACor, Windows Server 2019 RTM ServerStandardACor Volume:MAK"
	4318 = "ServerDatacenterACor, Windows Server 2019 RTM ServerDatacenterACor Volume:MAK"
	4319 = "ServerAzureCor, Windows Server 2019 RTM ServerAzureCor Retail"
	4320 = "ServerAzureCor, Windows Server 2019 RTM ServerAzureCor Volume:GVLK"
	4321 = "ServerAzureCor, Windows Server 2019 RTM ServerAzureCor VT:IA"
	4322 = "ServerDatacenterCor, Windows Server 2021 RTM ServerDatacenterCor Retail"
	4323 = "ServerDatacenterEvalCor, Windows Server 2021 RTM ServerDatacenterEvalCor Retail:TB:Eval"
	4324 = "ServerStandardCor, Windows Server 2021 RTM ServerStandardCor Retail"
	4325 = "ServerStandardEvalCor, Windows Server 2021 RTM ServerStandardEvalCor Retail:TB:Eval"
	4326 = "ServerARM64, Windows Server 2019 RTM ServerARM64 Volume:GVLK"
	4327 = "ServerRdsh, Windows Server 2019 RTM ServerRdsh Volume:GVLK"
	4328 = "ServerSolution, Windows Server Essentials 2019 RTM ServerSolution OEM:NONSLP"
	4329 = "ServerSolution, Windows Server Essentials 2019 RTM ServerSolution OEM:SLP"
	4330 = "ServerSolution, Windows Server Essentials 2019 RTM ServerSolution Retail"
	4331 = "ServerSolution, Windows Server Essentials 2019 RTM ServerSolution Retail:TB:Eval"
	4332 = "ServerSolution, Windows Server Essentials 2019 RTM ServerSolution Volume:GVLK"
	4333 = "ServerSolution, Windows Server Essentials 2019 RTM ServerSolution Volume:MAK"
	4334 = "ServerSolution, Windows Server Essentials 2019 RTM ServerSolution VT:IA"
	4335 = "ServerSolution, Windows Server Essentials 2019 RTM ServerSolution OEM:DM"
	4361 = "Holographic, Win 10 RTM Holographic OEM:DM"
	4362 = "IoTEnterprise, Win 10 RTM IoTEnterprise OEM:DM"
	4363 = "IoTEnterprise, Win 10 RTM IoTEnterprise OEM:NONSLP"
	4364 = "IoTEnterpriseS, Win 10 RTM IoTEnterpriseS OEM:DM"
	4365 = "IoTEnterpriseS, Win 10 RTM IoTEnterpriseS OEM:NONSLP"
	4366 = "Lite, Win 10 RTM Lite Retail"
	4367 = "Lite, Win 10 RTM Lite OEM:DM"
	4368 = "Lite, Win 10 RTM Lite Retail"
	4456 = "ServerAzureStackHCICor, Windows Server 2019 RTM ServerAzureStackHCICor VT:IA"
	4458 = "ServerAzureStackHCICor, Windows Server 2019 RTM ServerAzureStackHCICor OEM:NONSLP"
	4459 = "ServerAzureStackHCICor, Windows Server 2019 RTM ServerAzureStackHCICor OEM:SLP"
	4460 = "ServerAzureStackHCICor, Windows Server 2019 RTM ServerAzureStackHCICor OEM:SLP"
	4462 = "ServerAzureStackHCICor, Windows Server 2019 RTM ServerAzureStackHCICor Retail"
	4463 = "ServerAzureStackHCICor, Windows Server 2019 RTM ServerAzureStackHCICor OEM:NONSLP"
	4464 = "ServerAzureStackHCICor, Windows Server 2019 RTM ServerAzureStackHCICor Retail"
	4468 = "ServerTurbine, Windows Server 2019 RTM ServerTurbine Retail"
	4469 = "ServerTurbine, Windows Server 2019 RTM ServerTurbine Volume:GVLK"
	4470 = "ServerTurbine, Windows Server 2019 RTM ServerTurbine VT:IA"
	4471 = "ServerTurbine, Windows Server 2019 RTM ServerTurbine Volume:MAK"
	4478 = "Office21_ProPlus2021PreviewVL_MAK_AE"
	4479 = "Office21_Visio2021PreviewVL_MAK_AE"
	4480 = "Office21_Project2021PreviewVL_MAK_AE"
	4536 = "ServerStandard, Windows Server 2021 RTM ServerStandard Retail"
	4537 = "ServerStandard, Windows Server 2021 RTM ServerStandard OEM:NONSLP"
	4538 = "ServerStandard, Windows Server 2021 RTM ServerStandard OEM:NONSLP (MUI locked to zh-CN)"
	4539 = "ServerStandard, Windows Server 2021 RTM ServerStandard OEM:SLP"
	4540 = "ServerStandard, Windows Server 2021 RTM ServerStandard OEM:SLP (MUI locked to zh-CN)"
	4541 = "ServerStandard, Windows Server 2021 RTM ServerStandard Volume:GVLK"
	4542 = "ServerStandard;ServerStandardACor, Windows Server 2021 RTM ServerStandard;ServerStandardACor Volume:MAK"
	4543 = "ServerStandard;ServerStandardACor, Windows Server 2021 RTM ServerStandard;ServerStandardACor VT:IA"
	4544 = "ServerStandardEval, Windows Server 2021 RTM ServerStandardEval Retail:TB:Eval"
	4545 = "ServerStandard, Windows Server 2021 RTM ServerStandard OEM:DM"
	4546 = "ServerDatacenter, Windows Server 2021 RTM ServerDatacenter Volume:GVLK"
	4547 = "ServerDatacenter;ServerDatacenterACor;AzureStackHCIAddOn2021, Windows Server 2021 RTM ServerDatacenter;ServerDatacenterACor;AzureStackHCIAddOn2021 Volume:MAK"
	4548 = "ServerDatacenter;ServerDatacenterACor, Windows Server 2021 RTM ServerDatacenter;ServerDatacenterACor VT:IA"
	4549 = "ServerDatacenter;AzureStackHCIAddOn2021, Windows Server 2021 RTM ServerDatacenter;AzureStackHCIAddOn2021 OEM:NONSLP"
	4550 = "ServerDatacenter, Windows Server 2021 RTM ServerDatacenter OEM:NONSLP (MUI locked to zh-CN)"
	4551 = "ServerDatacenter;AzureStackHCIAddOn2021, Windows Server 2021 RTM ServerDatacenter;AzureStackHCIAddOn2021 OEM:SLP"
	4552 = "ServerDatacenter, Windows Server 2021 RTM ServerDatacenter OEM:SLP (MUI locked to zh-CN)"
	4555 = "ServerDatacenterEval, Windows Server 2021 RTM ServerDatacenterEval Retail:TB:Eval"
	4556 = "ServerStandardACor, Windows Server 2021 RTM ServerStandardACor Volume:GVLK"
	4557 = "ServerDatacenterACor, Windows Server 2021 RTM ServerDatacenterACor Volume:GVLK"
	4560 = "ServerStandard, Windows Server 2021 RTM ServerStandard OEM:DM (MUI locked to zh-CN)"
	4561 = "ServerDatacenter, Windows Server 2021 RTM ServerDatacenter OEM:DM (MUI locked to zh-CN)"
	4562 = "ServerAzureCor, Windows Server 2021 RTM ServerAzureCor Volume:GVLK"
	4563 = "ServerAzureCor, Windows Server 2021 RTM ServerAzureCor VT:IA"
	4565 = "ServerDatacenter;AzureStackHCIAddOn2021, Windows Server 2021 RTM ServerDatacenter;AzureStackHCIAddOn2021 Retail"
	4572 = "ServerDatacenter;AzureStackHCIAddOn2021, Windows Server 2021 RTM ServerDatacenter;AzureStackHCIAddOn2021 OEM:DM"
	4573 = "ServerDatacenter;ServerStandard, Windows Server 2021 RTM ServerDatacenter;ServerStandard Volume:CSVLK"
	4574 = "ServerDatacenter;ServerStandard, Windows Server 2021 RTM ServerDatacenter;ServerStandard Volume:CSVLK Azure Only"
	4575 = "ServerDatacenter;ServerStandard, Windows Server 2021 RTM ServerDatacenter;ServerStandard Volume:CSVLK VL Additional Lab"
	4576 = "Office16_ServerLPK_Bypass"
	4580 = "Office16_MOSS_Bypass"
	4581 = "Office16_MOSS_BypassTrial180"
	4582 = "Office16_MOSSFISEnt_Bypass"
	4583 = "Office16_MOSSFISStd_Bypass"
	4584 = "Office16_MOSSFISEnt_BypassTrial180"
	4585 = "Office16_MOSSPremium_Bypass"
	4586 = "Office16_MOSSFISStd_BypassTrial180"
	4587 = "Office16_MOSSPremium_BypassTrial180"
	4588 = "Office16_ProjectServer_Bypass"
	4589 = "Office16_ProjectServer_BypassTrial180"
	4591 = "Office21_Access2021R_OEM_Perp"
	4592 = "Office21_Access2021R_Retail"
	4593 = "Office21_Access2021R_Trial"
	4594 = "Office21_AccessRuntime2021R_Bypass"
	4595 = "Office21_Access2021VL_KMS_Client_AE"
	4596 = "Office21_Access2021VL_MAK_AE"
	4597 = "Office21_Excel2021R_OEM_Perp"
	4598 = "Office21_Excel2021R_Grace"
	4599 = "Office21_Excel2021R_Retail"
	4600 = "Office21_Excel2021R_Trial"
	4601 = "Office21_Excel2021VL_KMS_Client_AE"
	4602 = "Office21_Excel2021VL_MAK_AE"
	4603 = "Office21_HomeBusiness2021DemoR_BypassTrial180"
	4604 = "Office21_HomeBusiness2021R_Retail1"
	4605 = "Office21_HomeBusiness2021R_Retail2"
	4606 = "Office21_HomeBusiness2021R_OEM_Perp1"
	4607 = "Office21_HomeBusiness2021R_OEM_Perp2"
	4608 = "Office21_HomeBusiness2021R_OEM_Perp3"
	4609 = "Office21_HomeBusiness2021R_OEM_Perp4"
	4610 = "Office21_HomeBusiness2021R_Grace"
	4611 = "Office21_HomeBusiness2021R_Retail3"
	4612 = "Office21_HomeBusiness2021R_Trial1"
	4613 = "Office21_HomeBusiness2021R_Trial2"
	4614 = "Office21_HomeBusiness2021R_SubTest"
	4615 = "Office21_HomeBusiness2021R_Subscription"
	4616 = "Office21_HomeBusiness2021R_SubTrial"
	4617 = "Office21_HomeStudent2021DemoR_BypassTrial180"
	4620 = "Office21_HomeStudent2021R_OEM_Perp"
	4621 = "Office21_HomeStudent2021R_Grace"
	4622 = "Office21_HomeStudent2021R_Retail"
	4623 = "Office21_HomeStudent2021R_Trial1"
	4624 = "Office21_HomeStudent2021R_Trial2"
	4625 = "Office21_HomeStudent2021R_Subscription"
	4626 = "Office21_HomeStudent2021R_SubTest"
	4627 = "Office21_HomeStudent2021R_SubTrial"
	4628 = "Office21_OfficeLPK2021_Bypass"
	4629 = "Office21_OneNoteFree2021R_Bypass"
	4630 = "Office21_OneNote2021R_OEM_Perp"
	4631 = "Office21_OneNote2021R_Trial"
	4632 = "Office21_OneNote2021R_Grace"
	4633 = "Office21_OneNote2021R_Retail"
	4634 = "Office21_OneNote2021VL_MAK_AE"
	4635 = "Office21_Outlook2021R_OEM_Perp"
	4636 = "Office21_Outlook2021R_Trial"
	4637 = "Office21_Outlook2021R_Retail"
	4638 = "Office21_Outlook2021R_Grace"
	4639 = "Office21_Outlook2021VL_KMS_Client_AE"
	4640 = "Office21_Outlook2021VL_MAK_AE"
	4641 = "Office21_Personal2021DemoR_BypassTrial180"
	4642 = "Office21_Personal2021R_OEM_Perp"
	4643 = "Office21_Personal2021R_Trial"
	4644 = "Office21_Personal2021R_Retail"
	4645 = "Office21_Personal2021R_Grace"
	4666 = "Office21_PowerPoint2021R_OEM_Perp"
	4667 = "Office21_PowerPoint2021R_Trial"
	4668 = "Office21_PowerPoint2021R_Retail1"
	4669 = "Office21_PowerPoint2021R_Retail2"
	4670 = "Office21_PowerPoint2021R_Grace"
	4671 = "Office21_PowerPoint2021VL_KMS_Client_AE"
	4672 = "Office21_PowerPoint2021VL_MAK_AE"
	4673 = "Office21_Professional2021DemoR_BypassTrial180"
	4674 = "Office21_Professional2021R_OEM_Perp"
	4675 = "Office21_Professional2021R_Trial"
	4676 = "Office21_Professional2021R_Retail"
	4677 = "Office21_Professional2021R_Grace"
	4678 = "Office21_ProjectLPK2021_Bypass"
	4679 = "Office21_ProjectPro2021DemoR_BypassTrial180"
	4680 = "Office21_ProjectPro2021MSDNR_Retail1"
	4681 = "Office21_ProjectPro2021MSDNR_Retail2"
	4682 = "Office21_ProjectPro2021R_OEM_Perp"
	4683 = "Office21_ProjectPro2021R_Trial"
	4684 = "Office21_ProjectPro2021R_Grace"
	4685 = "Office21_ProjectPro2021R_Retail"
	4686 = "Office21_ProjectPro2021VL_KMS_Client_AE"
	4687 = "Office21_ProjectPro2021VL_MAK_AE1"
	4688 = "Office21_ProjectPro2021VL_MAK_AE2"
	4689 = "Office21_ProjectStd2021R_OEM_Perp"
	4690 = "Office21_ProjectStd2021R_Grace"
	4691 = "Office21_ProjectStd2021R_Retail"
	4692 = "Office21_ProjectStd2021VL_KMS_Client_AE"
	4693 = "Office21_ProjectStd2021VL_MAK_AE"
	4694 = "Office21_ProPlus2021DemoR_BypassTrial180"
	4695 = "Office21_ProPlus2021MSDNR_Retail"
	4696 = "Office21_ProPlus2021R_Trial1"
	4697 = "Office21_ProPlus2021R_Trial2"
	4698 = "Office21_ProPlus2021R_Grace"
	4699 = "Office21_ProPlus2021R_Retail"
	4700 = "Office21_Publisher2021R_Grace"
	4701 = "Office21_Publisher2021R_Retail1"
	4702 = "Office21_Publisher2021R_Retail2"
	4703 = "Office21_ProPlus2021R_OEM_Perp1"
	4704 = "Office21_ProPlus2021R_OEM_Perp2"
	4705 = "Office21_ProPlus2021R_OEM_Perp3"
	4706 = "Office21_ProPlus2021R_OEM_Perp4"
	4707 = "Office21_ProPlus2021R_OEM_Perp5"
	4708 = "Office21_ProPlus2021R_OEM_Perp6"
	4709 = "Office21_ProPlus2021VL_KMS_Client_AE"
	4710 = "Office21_ProPlus2021VL_MAK_AE1"
	4711 = "Office21_ProPlus2021VL_MAK_AE2"
	4712 = "Office21_Publisher2021R_OEM_Perp"
	4713 = "Office21_Publisher2021R_Trial"
	4714 = "Office21_Publisher2021VL_KMS_Client_AE"
	4715 = "Office21_Publisher2021VL_MAK_AE"
	4716 = "Office21_SkypeforBusiness2021VL_MAK_AE"
	4717 = "Office21_Standard2021VL_MAK_AE"
	4718 = "Office21_VisioPro2021VL_MAK_AE"
	4719 = "Office21_VisioStd2021VL_MAK_AE"
	4720 = "Office21_Word2021VL_MAK_AE"
	4721 = "Office21_SkypeforBusiness2021VL_KMS_Client_AE"
	4722 = "Office21_Standard2021VL_KMS_Client_AE"
	4723 = "Office21_VisioPro2021VL_KMS_Client_AE"
	4724 = "Office21_VisioStd2021VL_KMS_Client_AE"
	4725 = "Office21_Word2021VL_KMS_Client_AE"
	4726 = "Office21_VisioPro2021R_OEM_Perp"
	4727 = "Office21_VisioStd2021R_OEM_Perp"
	4728 = "Office21_Word2021R_OEM_Perp"
	4730 = "Office21_SkypeforBusiness2021R_Grace"
	4731 = "Office21_SkypeforBusiness2021R_Trial"
	4732 = "Office21_SkypeforBusiness2021R_Retail"
	4733 = "Office21_Standard2021R_Retail"
	4734 = "Office21_Standard2021R_Trial"
	4735 = "Office21_Standard2021R_Grace"
	4736 = "Office21_VisioPro2021R_Grace"
	4737 = "Office21_VisioPro2021R_Retail"
	4738 = "Office21_VisioPro2021DemoR_BypassTrial180"
	4739 = "Office21_VisioPro2021MSDNR_Retail"
	4740 = "Office21_VisioLPK2021_Bypass"
	4741 = "Office21_Standard2021MSDNR_Retail"
	4742 = "Office21_VisioPro2021R_Trial"
	4743 = "Office21_VisioStd2021R_Grace"
	4744 = "Office21_VisioStd2021R_Retail"
	4745 = "Office21_Word2021R_Trial"
	4746 = "Office21_SkypeforBusinessVDI2021_Bypass"
	4747 = "Office21_Word2021R_Retail"
	4748 = "Office21_Word2021R_Grace"
	4749 = "Office21_PTK2021_Bypass"
	4751 = "Office21_Access2021R_Grace"
	4757 = "CloudEdition, Win 10 RTM CloudEdition OEM:DM"
	4758 = "CloudEdition, Win 10 RTM CloudEdition Retail"
	4759 = "CloudEdition, Win 10 RTM CloudEdition Volume:GVLK"
	4761 = "CloudEditionN, Win 10 RTM CloudEditionN OEM:DM"
	4762 = "CloudEditionN, Win 10 RTM CloudEditionN Retail"
	4763 = "CloudEditionN, Win 10 RTM CloudEditionN Volume:GVLK"
	4765 = "CloudEditionL, Win 10 RTM CloudEditionL Retail"
	4766 = "CloudEditionLN, Win 10 RTM CloudEditionLN Retail"
	4769 = "EnterpriseS, Win 2021 RTM EnterpriseS Volume:MAK"
	4771 = "EnterpriseSEval, Win 2021 RTM EnterpriseSEval Retail:TB:Eval"
	4772 = "EnterpriseSN, Win 2021 RTM EnterpriseSN Volume:MAK"
	4774 = "EnterpriseSNEval, Win 2021 RTM EnterpriseSNEval Retail:TB:Eval"
	4776 = "Office21_ProPlusSPLA2021VL_MAK_AE"
	4777 = "Office21_StandardSPLA2021VL_MAK_AE"
	4834 = "Server-ESU-Year1, Windows Server ESU 2012/2012 R2 RTM Extended Security Updates Year 1 Volume:MAK"
	4835 = "Server-ESU-Year2, Windows Server ESU 2012/2012 R2 RTM Extended Security Updates Year 2 Volume:MAK"
	4836 = "Server-ESU-Year3, Windows Server ESU 2012/2012 R2 RTM Extended Security Updates Year 3 Volume:MAK"
	4842 = "IoTEnterpriseS, Win 11 RTM IoTEnterpriseS OEM:NONSLP"
	4843 = "IoTEnterpriseS, Win 11 RTM IoTEnterpriseS OEM:DM"
	4844 = "IoTEnterpriseS, Win 11 RTM IoTEnterpriseS Volume:GVLK"
	4845 = "IoTEnterpriseS, Win 11 RTM IoTEnterpriseS Volume:MAK"
	4854 = "Client-FES-ESU-Year1, Windows 8.1 Embedded ESU RTM Extended Security Updates Year 1 Volume:MAK"
	4855 = "Client-FES-ESU-Year2, Windows 8.1 Embedded ESU RTM Extended Security Updates Year 2 Volume:MAK"
	4856 = "Client-FES-ESU-Year3, Windows 8.1 Embedded ESU RTM Extended Security Updates Year 3 Volume:MAK"
	4857 = "Client-ESU-Year1, Win 8.1 ESU RTM Extended Security Updates Year 1 Volume:MAK"
	4858 = "Client-ESU-Year2, Win 8.1 ESU RTM Extended Security Updates Year 2 Volume:MAK"
	4859 = "Client-ESU-Year3, Win 8.1 ESU RTM Extended Security Updates Year 3 Volume:MAK"
	4866 = "Server-FES-ESU-Year1, Windows Server ESU Emb 2012/2012 R2 RTM Extended Security Updates Year 1 Volume:MAK"
	4867 = "Server-FES-ESU-Year2, Windows Server ESU Emb 2012/2012 R2 RTM Extended Security Updates Year 2 Volume:MAK"
	4868 = "Server-FES-ESU-Year3, Windows Server ESU Emb 2012/2012 R2 RTM Extended Security Updates Year 3 Volume:MAK"
	4869 = "IoTEnterpriseSK, Win 11 RTM IoTEnterpriseSK OEM:DM"
	4870 = "IoTEnterpriseSK, Win 11 RTM IoTEnterpriseSK OEM:NONSLP"
	4871 = "IoTEnterpriseSK, Win11 RTM IoTEnterpriseSK Retail"
	4891 = "IoTEnterpriseS, Win 10 RTM IoTEnterpriseS Volume:MAK"
	4895 = "ProfessionalCountrySpecific, Win 11 RTM ProfessionalCountrySpecific Volume:MAK"
	4896 = "ProfessionalCountrySpecific, Win 11 RTM ProfessionalCountrySpecific Retail"
	4898 = "Server-ESU-Year1, Windows Server ESU 2012/2012 R2 RTM Extended Security Updates Year 1 TBA Volume:GVLK"
	4899 = "Server-ESU-Year2, Windows Server ESU 2012/2012 R2 RTM Extended Security Updates Year 2 TBA Volume:GVLK"
	4900 = "Server-ESU-Year3, Windows Server ESU 2012/2012 R2 RTM Extended Security Updates Year 3 TBA Volume:GVLK"
	4901 = "EnterpriseS, Win 2024 RTM EnterpriseS Volume:MAK"
	4902 = "EnterpriseSEval, Win 2024 RTM EnterpriseSEval Retail:TB:Eval"
	4903 = "EnterpriseSN, Win 2024 RTM EnterpriseSN Volume:MAK"
	4904 = "EnterpriseSNEval, Win 2024 RTM EnterpriseSNEval Retail:TB:Eval"
	4905 = "EnterpriseS, Win 2024 RTM EnterpriseS Retail"
	4906 = "EnterpriseSN, Win 2024 RTM EnterpriseSN Retail"
	4907 = "IoTEnterpriseS, Win 11 RTM IoTEnterpriseS Retail"
	4908 = "ServerDatacenter, Windows Server 2025 RTM ServerDatacenter OEM:DM (MUI locked to zh-CN)"
	4909 = "ServerDatacenter;AzureStackHCIAddOn2025, Windows Server 2025 RTM ServerDatacenter;AzureStackHCIAddOn2025 OEM:DM"
	4910 = "ServerDatacenter;AzureStackHCIAddOn2025, Windows Server 2025 RTM ServerDatacenter;AzureStackHCIAddOn2025 OEM:NONSLP"
	4911 = "ServerDatacenter, Windows Server 2025 RTM ServerDatacenter OEM:NONSLP (MUI locked to zh-CN)"
	4912 = "ServerDatacenter;AzureStackHCIAddOn2025, Windows Server 2025 RTM ServerDatacenter;AzureStackHCIAddOn2025 OEM:SLP"
	4913 = "ServerDatacenter, Windows Server 2025 RTM ServerDatacenter OEM:SLP (MUI locked to zh-CN)"
	4914 = "ServerDatacenter;AzureStackHCIAddOn2025, Windows Server 2025 RTM ServerDatacenter;AzureStackHCIAddOn2025 Retail"
	4915 = "ServerDatacenter, Windows Server 2025 RTM ServerDatacenter Volume:GVLK"
	4916 = "ServerDatacenter;AzureStackHCIAddOn2025, Windows Server 2025 RTM ServerDatacenter;AzureStackHCIAddOn2025 Volume:MAK"
	4917 = "ServerDatacenter, Windows Server 2025 RTM ServerDatacenter VT:IA"
	4918 = "ServerDatacenter;ServerStandard, Windows Server 2025 RTM ServerDatacenter;ServerStandard Volume:CSVLK Azure Only"
	4919 = "ServerDatacenter;ServerStandard, Windows Server 2025 RTM ServerDatacenter;ServerStandard Volume:CSVLK"
	4920 = "ServerDatacenter;ServerStandard, Windows Server 2025 RTM ServerDatacenter;ServerStandard Volume:CSVLK VL Additional Lab"
	4921 = "ServerDatacenterEval, Windows Server 2025 RTM ServerDatacenterEval Retail:TB:Eval"
	4922 = "ServerStandard, Windows Server 2025 RTM ServerStandard OEM:DM"
	4923 = "ServerStandard, Windows Server 2025 RTM ServerStandard OEM:DM (MUI locked to zh-CN)"
	4924 = "ServerStandard, Windows Server 2025 RTM ServerStandard OEM:NONSLP"
	4925 = "ServerStandard, Windows Server 2025 RTM ServerStandard OEM:NONSLP (MUI locked to zh-CN)"
	4926 = "ServerStandard, Windows Server 2025 RTM ServerStandard OEM:SLP"
	4927 = "ServerStandard, Windows Server 2025 RTM ServerStandard OEM:SLP (MUI locked to zh-CN)"
	4928 = "ServerStandard, Windows Server 2025 RTM ServerStandard Retail"
	4929 = "ServerStandard, Windows Server 2025 RTM ServerStandard Volume:GVLK"
	4930 = "ServerStandard, Windows Server 2025 RTM ServerStandard Volume:MAK"
	4931 = "ServerStandard, Windows Server 2025 RTM ServerStandard VT:IA"
	4932 = "ServerStandardEval, Windows Server 2025 RTM ServerStandardEval Retail:TB:Eval"
	4933 = "ServerDatacenterCor, Windows Server 2025 RTM ServerDatacenterCor Retail"
	4934 = "ServerDatacenterEvalCor, Windows Server 2025 RTM ServerDatacenterEvalCor Retail:TB:Eval"
	4935 = "ServerStandardCor, Windows Server 2025 RTM ServerStandardCor Retail"
	4936 = "ServerStandardEvalCor, Windows Server 2025 RTM ServerStandardEvalCor Retail:TB:Eval"
	4937 = "ServerTurbine, Windows Server 2025 RTM ServerTurbine Volume:GVLK"
	4938 = "ServerTurbine, Windows Server 2025 RTM ServerTurbine Volume:MAK"
	4939 = "ServerTurbine, Windows Server 2025 RTM ServerTurbine VT:IA"
	4940 = "ServerAzureCor, Windows Server 2025 RTM ServerAzureCor VT:IA"
	4941 = "ServerAzureCor, Windows Server 2025 RTM ServerAzureCor Volume:GVLK"
	4999 = "ServerTurbine, Windows Server 2025 RTM ServerTurbine Retail"
	5001 = "WNC, Win 11 RTM WNC Retail"
	5010 = "Office24_Access2024VL_KMS_Client_AE"
	5011 = "Office24_Access2024VL_MAK_AE"
	5012 = "Office24_Excel2024VL_KMS_Client_AE"
	5013 = "Office24_Excel2024VL_MAK_AE"
	5015 = "Office24_Outlook2024VL_KMS_Client_AE"
	5016 = "Office24_Outlook2024VL_MAK_AE"
	5017 = "Office24_PowerPoint2024VL_KMS_Client_AE"
	5018 = "Office24_PowerPoint2024VL_MAK_AE"
	5019 = "Office24_ProjectPro2024VL_KMS_Client_AE"
	5020 = "Office24_ProjectPro2024VL_MAK_AE1"
	5021 = "Office24_ProjectPro2024VL_MAK_AE2"
	5022 = "Office24_ProjectStd2024VL_KMS_Client_AE"
	5023 = "Office24_ProjectStd2024VL_MAK_AE"
	5024 = "Office24_ProPlus2024VL_KMS_Client_AE"
	5025 = "Office24_ProPlus2024VL_MAK_AE1"
	5026 = "Office24_ProPlus2024VL_MAK_AE2"
	5029 = "Office24_SkypeforBusiness2024VL_MAK_AE"
	5030 = "Office24_Standard2024VL_MAK_AE1"
	5031 = "Office24_VisioPro2024VL_MAK_AE"
	5032 = "Office24_VisioStd2024VL_MAK_AE"
	5033 = "Office24_Word2024VL_MAK_AE"
	5034 = "Office24_SkypeforBusiness2024VL_KMS_Client_AE"
	5035 = "Office24_Standard2024VL_KMS_Client_AE"
	5036 = "Office24_VisioPro2024VL_KMS_Client_AE"
	5037 = "Office24_VisioStd2024VL_KMS_Client_AE"
	5038 = "Office24_Word2024VL_KMS_Client_AE"
	5039 = "Office24_ProPlus2024VL_MAK_AE3"
	5040 = "Office24_Standard2024VL_MAK_AE2"
	5041 = "Office24_ProPlus2024PreviewVL_KMS_Client_AE"
	5042 = "Office24_VisioPro2024PreviewVL_KMS_Client_AE"
	5043 = "Office24_ProjectPro2024PreviewVL_KMS_Client_AE"
	5044 = "Office24_ProPlus2024PreviewVL_MAK_AE"
	5045 = "Office24_VisioPro2024PreviewVL_MAK_AE"
	5046 = "Office24_ProjectPro2024PreviewVL_MAK_AE"
	5047 = "IoTEnterpriseK, Win 11 RTM IoTEnterpriseK OEM:DM"
	5048 = "IoTEnterpriseK, Win 11 RTM IoTEnterpriseK OEM:NONSLP"
	5049 = "IoTEnterpriseK, Win 11 RTM IoTEnterpriseK Retail"
	5050 = "IoTEnterpriseSEval, Win 11 RTM IoTEnterpriseSEval Retail:TB:Eval"
	5051 = "Core;CoreCountrySpecific;CoreN;CoreSingleLanguage;Education;EducationN;Enterprise;EnterpriseG;EnterpriseGN;Professional;ProfessionalCountrySpecific;ProfessionalEducation;ProfessionalEducationN;ProfessionalN;ProfessionalWorkstation;ProfessionalWorkstationN;IoTEnterprise;IoTEnterpriseS;IoTEnterpriseSK;IoTEnterpriseK;CloudEdition;CloudEditionN, Win 11 RTM Professional OEM:DM"
	5052 = "Core;CoreCountrySpecific;CoreN;CoreSingleLanguage;Education;EducationN;Enterprise;EnterpriseG;EnterpriseGN;Professional;ProfessionalCountrySpecific;ProfessionalEducation;ProfessionalEducationN;ProfessionalN;ProfessionalWorkstation;ProfessionalWorkstationN;IoTEnterprise;IoTEnterpriseS;IoTEnterpriseSK;IoTEnterpriseK;CloudEdition;CloudEditionN, Win 11 RTM Professional OEM:DM"
	5053 = "ProfessionalCountrySpecific, Win 11 RTM ProfessionalCountrySpecific OEM:DM"
	5054 = "ProfessionalCountrySpecific, Win 11 RTM ProfessionalCountrySpecific OEM:NONSLP"
	5083 = "ServerStandard, Windows Server 2025 RTM ServerStandard PGS:TB"
	5084 = "ServerDatacenter, Windows Server 2025 RTM ServerDatacenter PGS:TB"
	5085 = "ServerStandardCor, Windows Server 2025 RTM ServerStandardCor PGS:TB"
	5086 = "ServerDatacenterCor, Windows Server 2025 RTM ServerDatacenterCor PGS:TB"
	5096 = "Office24_Access2024R_Retail"
	5097 = "Office24_Excel2024R_Retail"
	5098 = "Office24_HomeBusiness2024R_Retail"
	5099 = "Office24_Home2024R_Retail"
	5100 = "Office24_ProPlus2024R_Retail"
	5101 = "Office24_Outlook2024R_Retail"
	5102 = "Office24_PowerPoint2024R_Retail"
	5103 = "Office24_ProjectPro2024R_Retail"
	5104 = "Office24_ProjectStd2024R_Retail"
	5105 = "Office24_VisioPro2024R_Retail"
	5106 = "Office24_VisioStd2024R_Retail"
	5107 = "Office24_Word2024R_Retail"
	5108 = "Office24_Access2024R_Grace"
	5109 = "Office24_Excel2024R_Grace"
	5110 = "Office24_HomeBusiness2024R_Grace"
	5111 = "Office24_Home2024R_Grace"
	5113 = "Office24_Outlook2024R_Grace"
	5114 = "Office24_PowerPoint2024R_Grace"
	5115 = "Office24_ProjectPro2024R_Grace"
	5116 = "Office24_ProjectStd2024R_Grace"
	5117 = "Office24_ProPlus2024R_Grace"
	5123 = "Office24_VisioPro2024R_Grace"
	5124 = "Office24_VisioStd2024R_Grace"
	5125 = "Office24_Word2024R_Grace"
	5127 = "Office24_HomeBusiness2024DemoR_BypassTrial180"
	5128 = "Office24_HomeBusiness2024R_OEM_Perp"
	5129 = "Office24_Home2024R_OEM_Perp"
	5150 = "Client-ESU-Year1, Win ESU 10 RTM Extended Security Updates Year 1 Volume:MAK"
	5151 = "Client-ESU-Year2, Win ESU 10 RTM Extended Security Updates Year 2 Volume:MAK"
	5152 = "Client-ESU-Year3, Win ESU 10 RTM Extended Security Updates Year 3 Volume:MAK"
	5153 = "Client-IoT-ESU-Year1, Win IoT ESU 10 RTM Extended Security Updates Year 1 Volume:MAK"
	5154 = "Client-IoT-ESU-Year2, Win IoT ESU 10 RTM Extended Security Updates Year 2 Volume:MAK"
	5155 = "Client-IoT-ESU-Year3, Win IoT ESU 10 RTM Extended Security Updates Year 3 Volume:MAK"
	5186 = "Client-ESU-Year4, Win ESU 10 RTM Extended Security Updates Year 4 Volume:MAK"
	5187 = "Client-ESU-Year5, Win ESU 10 RTM Extended Security Updates Year 5 Volume:MAK"
	5188 = "Client-ESU-Year6, Win ESU 10 RTM Extended Security Updates Year 6 Volume:MAK"
	5189 = "Client-IoT-ESU-Year4, Win IoT ESU 10 RTM Extended Security Updates Year 4 Volume:MAK"
	5190 = "Client-IoT-ESU-Year5, Win IoT ESU 10 RTM Extended Security Updates Year 5 Volume:MAK"
	5191 = "Client-IoT-ESU-Year6, Win IoT ESU 10 RTM Extended Security Updates Year 6 Volume:MAK"
	5203 = "Client-ESU-Year1, Win ESU 10 RTM Extended Security Updates Year 1 Volume:GVLK"
	5204 = "Client-ESU-Year2, Win ESU 10 RTM Extended Security Updates Year 2 Volume:GVLK"
	5205 = "Client-ESU-Year3, Win ESU 10 RTM Extended Security Updates Year 3 Volume:GVLK"
	5206 = "Client-ESU-Year4, Win ESU 10 RTM Extended Security Updates Year 4 Volume:GVLK"
	5207 = "Client-ESU-Year5, Win ESU 10 RTM Extended Security Updates Year 5 Volume:GVLK"
	5208 = "Client-ESU-Year6, Win ESU 10 RTM Extended Security Updates Year 6 Volume:GVLK"
	5209 = "Client-IoT-ESU-Year1, Win IoT ESU 10 RTM Extended Security Updates Year 1 Volume:GVLK"
	5210 = "Client-IoT-ESU-Year2, Win IoT ESU 10 RTM Extended Security Updates Year 2 Volume:GVLK"
	5211 = "Client-IoT-ESU-Year3, Win IoT ESU 10 RTM Extended Security Updates Year 3 Volume:GVLK"
	5212 = "Client-IoT-ESU-Year4, Win IoT ESU 10 RTM Extended Security Updates Year 4 Volume:GVLK"
	5213 = "Client-IoT-ESU-Year5, Win IoT ESU 10 RTM Extended Security Updates Year 5 Volume:GVLK"
	5214 = "Client-IoT-ESU-Year6, Win IoT ESU 10 RTM Extended Security Updates Year 6 Volume:GVLK"
	5252 = "Office16 O365AppsBasicR Grace"
	5253 = "Office16 O365AppsBasicR Subscription"
	9976 = "ProdKey3 Win 9976 DLA NQR Test Retail:TB:Eval"
	9977 = "Win Next Ultimate OEM:DM"
	9980 = "ProdKey3 Win 9980 OEMAct NQR Test OEM:COA OEM OEM"
	9981 = "ProdKey3 Win 9981 DLA NQR Test OEM:NONSLP OEM OEM"
	9982 = "ProdKey3 Win 9982 OEMAct/Preinstall NQR Test OEM:SLP OEM OEM"
	9984 = "ProdKey3 Win 9984 DLA/Bypass NQR Test Volume:GVLK Vol Lic MLF"
	9985 = "ProdKey3 Win 9985 DLA CCP NQR Test Retail WAU"
	10001 = "ProdKey3 Win 10001 DLA NQR Test Retail:TB:Promo"
	10002 = "ProdKey3 Win 10002 DLA NQR Test Retail:TB:Sub"
	10003 = "ProdKey3 Win 10003 ProdAct 500 NQR Test Volume:MAK Vol Lic MLF"
	10005 = "ProdKey3 Win 10005 DLA NQR Test Retail"
	10006 = "ProdKey3 Win 10006 DLA NQR Test Retail:TB:Trial"
	100027 = "Win Next Enterprise Retail"
	100028 = "Win Next Enterprise Retail:TB:Eval"
	100029 = "Win Next Enterprise Volume:MAK"
	100030 = "Win Next Enterprise Volume:GVLK"
	100031 = "Win Next HomePremium Retail"
	100032 = "Win Next Professional Retail"
	100033 = "Win Next Professional Volume:MAK"
	100034 = "Win Next Professional Volume:GVLK"
	100051 = "Win Next Ultimate Retail"
	100054 = "Starter, Win Next Starter Retail"
	100055 = "StarterN, Win Next StarterN Retail"
	100056 = "Win Next HomeBasic Retail"
	100057 = "Win Next HomeBasicN Retail"
	100058 = "Win Next HomePremiumN Retail"
	100059 = "Win Next ProfessionalN Retail"
	100060 = "Win Next EnterpriseN Retail"
	100061 = "Win Next UltimateN Retail"
	100062 = "Win Next ProfessionalN Volume:GVLK"
	100063 = "Win Next EnterpriseN Volume:GVLK"
}

# Create a hash table for key-ref pairs with integer references
$OfficeOnlyKeys = @{
    1921 = "CN9FP-Q44Y9-C6BTG-KQJ2H-M4DQ2" # Office15_O365SmallBusPremR_PIN
    1922 = "FHNJQ-RKHJ2-9CD4V-V6FXQ-B96HQ" # Office15_O365HomePremR_PIN2
    1923 = "TWRKN-DY3YR-FG2HC-QR8BT-PDHD4" # Office15_O365HomePremR_PIN1
    1925 = "2NH3K-YG2FG-3RHM9-8KY37-8HRMH" # Office15_O365HomePremR_PIN4
    1934 = "89XN7-293MP-F4JD6-Y8FGC-KWX4J" # Office15_O365HomePremR_PIN13
    1939 = "FNJWH-H2FY6-TFK9J-K4BGK-M96JF" # Office15_O365HomePremR_PIN18
    1941 = "GXBC6-YN6CT-R4TQQ-RBWRX-Y7RM7" # Office15_AccessR_Grace
    1943 = "9JV64-8NJ39-X7XWQ-73RBJ-6MQRX" # Office15_AccessR_Retail
    1946 = "NG2JY-H4JBT-HQXYP-78QH9-4JM2D" # Office15_AccessVL_KMS_Client
    1947 = "7GFNH-JX9Q2-6J834-TDYRQ-VXJCF" # Office15_AccessVL_MAK
    1948 = "NP2JH-WVBYY-2C2XH-GQ6YM-88CWT" # Office15_ExcelR_Grace
    1952 = "VGPNG-Y7HQW-9RHP7-TKPV3-BG7GB" # Office15_ExcelVL_KMS_Client
    1953 = "3D39N-TW76P-PQKQT-G7PCJ-BWM2P" # Office15_ExcelVL_MAK
    1954 = "3V9N8-W93CC-FQPB8-Y9WVF-TVGJ3" # Office15_GrooveR_Grace
    1957 = "DJRB9-N8XJX-WGMWG-BKC2D-628CV" # Office15_GrooveVL_KMS_Client
    1960 = "KWW2T-GTN7J-FJXBX-FM3YD-DV3TM" # Office15_HomeBusinessR_Grace
    1961 = "DDN4F-M8KHW-BPMV9-BT8DB-RCW9C" # Office15_HomeBusinessR_OEM_Perp
    1962 = "3MYVJ-8GNCM-KPCCT-Q4JGY-6VGKD" # Office15_HomeBusinessR_Retail
    1969 = "CFD7N-PCTY4-HWFR7-9BFM3-QRPXP" # Office15_HomeStudentR_Grace
    1970 = "CN4JW-346KC-G4W9G-V7296-CGWDD" # Office15_HomeStudentR_OEM_Perp
    1971 = "2GP7G-HTNTH-3R9WF-TKVJB-RCW9R" # Office15_HomeStudentR_Retail
    1976 = "V8VNK-TBHG4-CH7PG-63HQQ-973VB" # Office15_InfoPathR_Grace
    1977 = "GH886-XNCT3-XQ9J3-GK4R8-F3HHC" # Office15_InfoPathR_Retail
    1979 = "DKT8B-N7VXH-D963P-Q4PHY-F8894" # Office15_InfoPathVL_KMS_Client
    1980 = "CRN4F-JFBBK-YD6TJ-MG6T7-G6J96" # Office15_InfoPathVL_MAK
    1982 = "TCN6R-MKJMV-6B989-FPGB6-BPW98" # Office15_LyncEntryR_PrepidBypass
    1983 = "VYFFM-RNTD9-GRQB4-F6J8D-QRPX9" # Office15_LyncR_Grace
    1987 = "2MG3G-3BNTT-3MFW9-KDQW3-TCK7R" # Office15_LyncVL_KMS_Client
    1988 = "N9QQ3-H23BK-KX6FM-V7PXV-6XVHT" # Office15_LyncVL_MAK
    1990 = "3N8KV-9BKXY-3Y83R-27XPY-VQTMJ" # Office15_MondoR_Grace
    1997 = "42QTK-RN8M7-J3C4G-BBGYM-88CYV" # Office15_MondoVL_KMS_Client
    1999 = "WB7H4-3N8DH-DBCT6-9MQWM-R6WFK" # Office15_MOSS_Bypass
    2005 = "N3MDM-DXR3H-JD7QH-QKKCR-BY2Y7" # Office15_MOSSPremium_Bypass
    2006 = "NQTMW-K63MQ-39G6H-B2CH9-FRDWJ" # Office15_MOSSPremium_BypassTrial180
    2007 = "9FNY8-PWWTY-8RY4F-GJMTV-KHGM9" # Office16_O365HomePremR_Grace
    2011 = "B2FJQ-DNK9X-QVYGV-4FG6K-H498R" # Office16_O365HomePremR_Subscription4
    2022 = "FYN74-QV8V2-CYJ4Q-G6XC3-8K6PW" # Office15_O365HomePremR_SubTrial5
    2023 = "DRNV7-VGMM2-B3G9T-4BF84-VMFTK" # Office16_O365ProPlusR_Grace
    2025 = "3J94C-NDRD9-23CT9-C2CM8-XWX9C" # Office16_O365ProPlusR_Subscription1
    2035 = "3FBRX-NFP7C-6JWVK-F2YGK-H499R" # Office16_O365SmallBusPremR_Grace
    2050 = "NM9DF-783W7-H6PVX-H4T86-68YBD" # Office15_OneNoteR_Grace
    2052 = "KKF4R-BJNTD-G84PK-8RXDQ-WQHMG" # Office15_OneNoteR_Retail
    2054 = "TGN6P-8MMBC-37P2F-XHXXK-P34VW" # Office15_OneNoteVL_KMS_Client
    2055 = "XMWN8-3MJ9W-88488-R72RP-XTKD9" # Office15_OneNoteVL_MAK
    2056 = "W2W44-NCX3H-7BK44-7TDVQ-7T7MM" # Office15_OutlookR_Grace
    2058 = "PGK3Y-DNM2F-HWGRP-FB22C-4RDYQ" # Office15_OutlookR_Retail
    2060 = "QPN8Q-BJBTJ-334K3-93TGY-2PMBT" # Office15_OutlookVL_KMS_Client
    2061 = "C942T-FNM6K-4RR2F-RFCKG-TJC4H" # Office15_OutlookVL_MAK
    2063 = "NJW68-4JMPF-RX4YK-XDP77-9BQYX" # Office15_PersonalR_Grace
    2065 = "7PNYR-RDK94-99G38-DQPYX-8QHM2" # Office15_PersonalR_Retail
    2070 = "CWH2Y-NPYJW-3C7HD-BJQWB-G28JJ" # Office15_MondoR_KMS_Automation
    2119 = "NVJDW-924X3-KYGYV-CFJMF-QGKHX" # Office15_PowerPointR_Grace
    2123 = "4NT99-8RJFH-Q2VDH-KYG2C-4RD4F" # Office15_PowerPointVL_KMS_Client
    2124 = "62DCQ-JNW4W-9RQ4W-J4684-KBQ4G" # Office15_PowerPointVL_MAK
    2126 = "XRNVH-YTPGM-CBMXB-HB2MR-WFD4J" # Office15_ProfessionalR_Grace
    2127 = "PJDX9-4N7CT-XVF23-P26PT-234YX" # Office15_ProfessionalR_OEM_Perp
    2128 = "4WNCP-34244-J93P6-68B2R-VMFYY" # Office15_ProfessionalR_Retail
    2135 = "8HD8N-J7HW4-FJXKR-88W98-QC8M9" # Office15_ProjectProMSDNR_Retail
    2139 = "7P9KT-N7M3V-KGDHF-GWXCG-GMQ44" # Office15_ProjectProR_Grace
    2141 = "JXVFJ-RHN9R-4GCMW-CB8B8-TQ42H" # Office15_ProjectProR_Retail
    2142 = "VNHRC-TC2YF-K9QD7-WW9PJ-QC8PJ" # Office15_ProjectProR_Trial
    2143 = "FN8TT-7WMH6-2D4X9-M337T-2342K" # Office15_ProjectProVL_KMS_Client
    2144 = "6PJTB-NCTVG-3T2GH-PCVM3-9D42M" # Office15_ProjectProVL_MAK
    2145 = "2P6G3-NPR4G-3XKF4-J7J4M-RCXJ2" # Office15_ProjectServer_Bypass
    2146 = "C84N9-P84Q7-CDCP8-HYQTY-WHR2Q" # Office15_ProjectServer_BypassTrial180
    2153 = "C4P97-NT3HG-XM9T7-K8QVB-MY29C" # Office15_ProjectStdR_Grace
    2156 = "6NTH3-CW976-3G3Y2-JK3TX-8QHTT" # Office15_ProjectStdVL_KMS_Client
    2157 = "DHJMN-HR49Y-HFQP4-64R8W-QC8P7" # Office15_ProjectStdVL_MAK
    2159 = "NQYCX-6VVC7-2FHDF-F86XD-YBF29" # Office15_ProPlusMSDNR_Retail
    2160 = "WTFN9-KRCBV-2VBBH-BC272-27GXM" # Office15_ProPlusR_Grace
    2162 = "32G6C-JNP3J-QXCFG-KYX8F-MWPDD" # Office15_ProPlusR_Retail
    2163 = "RNJB9-4H3HQ-HCPXQ-PYBB2-3YF3F" # Office15_ProPlusR_Trial
    2164 = "YC7DK-G2NP3-2QQC3-J6H88-GVGXT" # Office15_ProPlusVL_KMS_Client
    2165 = "3F3DN-CCQVQ-68R44-C4C3Q-RJPDH" # Office15_ProPlusVL_MAK
    2167 = "9HNFR-WWDDV-B7CK4-Q6Q92-P9VT9" # Office15_PublisherR_Grace
    2169 = "DFH8B-3WNCB-GT7K2-B3BG8-78PDP" # Office15_PublisherR_Retail
    2171 = "PN2WF-29XG2-T9HJ7-JQPJR-FCXK4" # Office15_PublisherVL_KMS_Client
    2172 = "6F4NT-4G82X-7WRY9-RK3HM-TXVVG" # Office15_PublisherVL_MAK
    2174 = "GYJRG-NMYMF-VGBM4-T3QD4-842DW" # Office15_SPDFreeR_PrepidBypass
    2176 = "NKHJ9-QY8MJ-YGMQM-C7XXK-P343Y" # Office15_StandardR_Grace
    2179 = "KBKQT-2NMXY-JJWGP-M62JB-92CD4" # Office15_StandardVL_KMS_Client
    2180 = "2VVNP-76WYK-QWWYY-B2T9R-W8DBG" # Office15_StandardVL_MAK
    2186 = "FJ2N7-W8TXC-JB8KB-DCQ7Q-7T7V3" # Office15_VisioProMSDNR_Retail
    2190 = "2NYF6-QG2CY-9F8XC-GWMBW-29VV8" # Office15_VisioProR_Grace
    2192 = "XN4WT-T6Y38-HTFPG-DKVMG-WW9MY" # Office15_VisioProR_Retail
    2193 = "J7G2X-WNGK4-VTHJX-G4DTX-YDTY2" # Office15_VisioProR_Trial
    2194 = "C2FG9-N6J68-H8BTJ-BW3QX-RM3B3" # Office15_VisioProVL_KMS_Client
    2195 = "N7YGD-CKMWV-PY326-KTXGJ-K2CFR" # Office15_VisioProVL_MAK
    2202 = "43CRB-3NWW3-WYP9B-V69WQ-MDT2D" # Office15_VisioStdR_Grace
    2204 = "994N4-MPQRJ-DT2X9-MB42M-BBF46" # Office15_VisioStdR_Retail
    2205 = "J484Y-4NKBF-W2HMG-DBMJC-PGWR7" # Office15_VisioStdVL_KMS_Client
    2206 = "JWPNH-RJ9C2-FQJQ2-CCBW9-M962J" # Office15_VisioStdVL_MAK
    2208 = "4N6BG-CC9Q8-J7QKG-G33T7-CYQ8Y" # Office15_WCServer_Bypass
    2209 = "VBN27-Y67WB-XTMP3-CW3MT-72XPP" # Office15_WordR_Grace
    2211 = "DFNQ7-MFPDD-HPBKD-YPMMK-H6BJ4" # Office15_WordR_Retail
    2213 = "6Q7VD-NX8JD-WJ2VH-88V73-4GBJ7" # Office15_WordVL_KMS_Client
    2214 = "HP9KN-3KTGD-DHCR7-V2XGW-7FQCW" # Office15_WordVL_MAK
    2331 = "H8DDN-BMX39-XMMXY-HWKHX-XKV44" # Office15_OneNoteFreeR_Bypass
    2656 = "MCPBN-CPY7X-3PK9R-P6GTT-H8P8Y" # Office16_O365BusinessR_Grace
    2658 = "TNC22-WJMM4-96XWQ-CXVDC-PGXJ3" # Office16_O365BusinessR_Subscription
    2661 = "RWQ6N-GCJ3F-RGXY7-B2G2Y-VQVTH" # Office16_PersonalPipcR_Grace
    2663 = "GNRM4-RTQ6P-WTGM2-X2FQD-B97TK" # Office16_HomeBusinessPipcR_Grace
    2665 = "2BKFN-BHY2G-WV47X-PHK2Y-KD6XC" # Office16_ProfessionalPipcR_Grace
    2832 = "VXPTB-NDRMB-B6TWG-8827K-HCDJB" # Office16_SkypeServiceBypassR_PrepidBypass
    2970 = "C24XN-XFFFQ-8P47P-MBFFT-YG88Q" # Office15_O365HomePremR_PIN28
    2971 = "KXJC3-NKPJJ-J4YMV-HQWDH-MBHF4" # Office15_O365HomePremR_PIN29
    2972 = "KM2T4-NJ6BM-RXKDF-GDC8Q-2WFPG" # Office15_O365HomePremR_PIN30
    2973 = "HNRDK-DYTMX-7RRM3-VPXJD-B98CH" # Office15_O365HomePremR_PIN31
    2974 = "2QGR4-PNHK8-39MTV-87KR4-TVJCJ" # Office15_O365HomePremR_PIN32
    2975 = "VTKQN-KMGTR-F2Y7Q-9P8CJ-YPY2K" # Office15_O365HomePremR_PIN33
    3323 = "3J2NT-T2D36-VDDC9-DRQWQ-MDWX4" # Office16_AccessR_Retail
    3325 = "TTB3B-NT2JQ-YBBFK-76BX4-JHV3V" # Office16_AccessRuntimeR_PrepidBypass
    3326 = "GNH9Y-D2J4T-FJHGG-QRVH7-QPFDW" # Office16_AccessVL_KMS_Client
    3327 = "NYWTD-7YJQG-2PYB7-DYHD7-8HV3X" # Office16_AccessVL_MAK
    3329 = "T2NR8-D9XBG-YWMH4-7JK7B-XBT7P" # Office16_ExcelR_Retail
    3331 = "9C2PK-NWTVB-JMPW8-BFT28-7FTBF" # Office16_ExcelVL_KMS_Client
    3332 = "Q897C-QN7KP-DJV92-G6B8Y-PR4D6" # Office16_ExcelVL_MAK
    3334 = "XMKN9-YWGW8-K7HGB-CCTKM-6VJYJ" # Office16_HomeBusinessR_OEM_Perp
    3335 = "NT983-3KVDJ-TGQ3Q-J72GW-DGPMK" # Office16_HomeBusinessR_Retail3
    3343 = "NCY66-9RXGC-8KJW7-V7B4W-33WYX" # Office16_HomeStudentR_Retail
    3353 = "HFTND-W9MK4-8B7MJ-B6C4G-XQBR2" # Office16_MondoVL_KMS_Client
    3354 = "MF2W2-JNTTM-6YHG8-TC2V3-FM6CD" # Office16_MondoVL_MAK
    3355 = "NWFM7-QVBRH-C4DR7-844BB-JK82F" # Office16_MOSS_Bypass
    3358 = "TY6N4-K9WD3-JD2J2-VYKTJ-GVJ2J" # Office16_MOSSPremium_Bypass
    3360 = "XN9Q3-RDV2X-Y4BRC-Q8MP2-7CFGB" # Office16_OneNoteFreeR_Bypass
    3364 = "DR92N-9HTF2-97XKM-XW2WJ-XW3J6" # Office16_OneNoteVL_KMS_Client
    3367 = "9B78W-NKXP3-WMH2K-VXQVP-6JGCX" # Office16_OutlookR_Retail
    3368 = "R69KK-NTPKF-7M3Q4-QYBHW-6MT9B" # Office16_OutlookVL_KMS_Client
    3369 = "NWCTY-Y7HC9-V6VCW-MC9B9-Y7V6P" # Office16_OutlookVL_MAK
    3371 = "W3MNG-CCWVT-2F6JH-WHHR7-R9CP4" # Office16_PowerPointR_Retail
    3372 = "J7MQP-HNJ4Y-WJ7YM-PFYGF-BY6C6" # Office16_PowerPointVL_KMS_Client
    3373 = "N7HM9-JDX2K-WRJK4-H82XQ-VXMTV" # Office16_PowerPointVL_MAK
    3374 = "DHBNG-9VD8F-VPKXT-KMVVH-HXMTW" # Office16_ProfessionalR_OEM_Perp
    3378 = "6FPP4-8NWJC-22KBB-9XPHB-HT9XQ" # Office16_ProjectProR_Retail
    3379 = "N46MP-733KG-T8MR9-VV9JX-HCFG4" # Office16_ProjectProR_Trial
    3380 = "NW9FH-7K972-W3KCH-23CT8-33W3G" # Office16_ProjectProVL_KMS_Client
    3381 = "24BVB-NQ49W-2W9CV-GDMMB-TXXXV" # Office16_ProjectProVL_MAK
    3384 = "4FCG8-NWQRK-K77DH-JC76Q-8K83M" # Office16_ProjectStdR_Retail
    3385 = "GNFHQ-F6YQM-KQDGJ-327XX-KQBVC" # Office16_ProjectStdVL_KMS_Client
    3386 = "7PGN3-X3MFT-PWJVJ-YJXBM-QJ3K3" # Office16_ProjectStdVL_MAK
    3389 = "H38PG-29NB6-3WPYC-R2JRD-PYT97" # Office16_ProPlusR_Retail
    3391 = "7FN7W-JF8VP-VHJJK-4GKJQ-MDW3X" # Office16_ProPlusVL_KMS_Client
    3392 = "2XHTJ-NXVXJ-3PRRF-W8BQF-7H7BB" # Office16_ProPlusVL_MAK
    3395 = "DYQ2H-NP789-TV9KF-XXG9C-RVV7R" # Office16_PublisherR_Retail
    3397 = "F47MM-N3XJP-TQXJ9-BP99D-8K837" # Office16_PublisherVL_KMS_Client
    3398 = "9XVN7-V8F3M-7WQRH-C6PDD-QRTD8" # Office16_PublisherVL_MAK
    3400 = "JXN88-22KXV-YR73M-JCT8M-HT9YM" # Office16_SkypeforBusinessEntryR_PrepidBypass
    3404 = "869NQ-FJ69K-466HW-QYCP2-DDBV6" # Office16_SkypeforBusinessVL_KMS_Client
    3405 = "G8J4F-9JNK8-3FC6R-4TFYK-DYH77" # Office16_SkypeforBusinessVL_MAK
    3408 = "JNRGM-WHDWX-FJJG3-K47QV-DRTFM" # Office16_StandardVL_KMS_Client
    3409 = "2BNWF-HQ3XJ-QHXQD-639QJ-XW3M2" # Office16_StandardVL_MAK
    3413 = "2WN3J-2H696-RYW7F-YWJB3-49CRV" # Office16_VisioProR_Retail
    3414 = "W9WC2-JN9W2-H4CBV-24QR7-M4HB8" # Office16_VisioProR_Trial
    3415 = "PD3PC-RHNGV-FXJ29-8JK7D-RJRJK" # Office16_VisioProVL_KMS_Client
    3416 = "NJV43-DWV73-H42VP-3JBCW-6MVCB" # Office16_VisioProVL_MAK
    3418 = "RXHX3-NQC4Q-MCD8B-T8TDM-HT92D" # Office16_VisioStdR_Retail
    3419 = "7WHWN-4T7MP-G96JF-G33KR-W8GF4" # Office16_VisioStdVL_KMS_Client
    3420 = "NP2J6-RWCVH-BMTDR-VYJK4-X2FJT" # Office16_VisioStdVL_MAK
    3426 = "D6KGQ-HNXTC-8WHPF-7MHTQ-PYVCQ" # Office16_WordR_Retail
    3428 = "WXY84-JN2Q9-RBCCQ-3Q3J3-3PFJ6" # Office16_WordVL_KMS_Client
    3429 = "P4H2J-3N26Q-4699G-99Q2V-BDW6H" # Office16_WordVL_MAK
    3432 = "YVD87-NXWK4-8PYQP-GT8KT-YG92Y" # Office16_WordR_Grace
    3434 = "RN4VY-4B8QX-JXPHR-VH4VQ-H22TQ" # Office16_HomeBusinessR_Retail
    3438 = "NKVRG-XP9FX-FKFRD-2HXY2-D6928" # Office16_HomeBusinessR_Grace
    3441 = "HFVHN-X2X8D-67VCH-HF69K-P379P" # Office16_AccessR_Grace
    3442 = "RGNMP-V32H3-QBWXM-BF7XR-DJ3QD" # Office16_HomeStudentR_Grace
    3445 = "2N6B3-BXW6B-W2XBT-VVQ64-7H7DH" # Office16_MondoR_Grace
    3452 = "NX3MW-3T26X-HJDRX-R39KV-94THG" # Office16_OneNoteR_Grace
    3453 = "DR7HN-K76WM-TQC9V-34PRK-BKMX7" # Office16_OutlookR_Grace
    3454 = "23GNX-8FTCJ-THJBB-DVGMH-BDW7J" # Office16_PowerPointR_Grace
    3455 = "GJN26-8DV6F-76VJT-PMF6Y-92FK9" # Office16_ProjectProR_Grace
    3457 = "23CB6-N4X8Q-WWD7M-6FHCW-9TPVP" # Office16_ProjectServer_Bypass
    3458 = "CXTPN-YWF37-D3TPH-6DHJH-6XX33" # Office16_ProjectStdR_Grace
    3464 = "CYC3N-BHX8G-QJVJV-H2WWP-BTDRB" # Office16_ProPlusR_Grace
    3465 = "9RN37-FCBGH-T36YR-TTJF6-GMVFC" # Office16_PublisherR_Grace
    3466 = "DNCD4-JDKR3-WQQCY-47GYX-JXCV3" # Office16_SkypeforBusinessR_Grace
    3467 = "PCCXN-7MKB3-F986V-V6HV4-CR4MR" # Office16_StandardR_Grace
    3468 = "BB6YN-3W2C6-R82H2-PTBMF-F6YYT" # Office16_VisioProR_Grace
    3469 = "NJFDP-X46PK-M7DBR-VMHW6-MKMYV" # Office16_VisioStdR_Grace
    3470 = "YY6CN-WVPG8-T72BH-QB6QH-RGDRJ" # Office16_ExcelR_Grace
    3513 = "8VRRN-PD9RM-YQ98X-C9XBC-9QB3P" # Office16_ProPlusMSDNR_Retail
    3514 = "J2VPX-NMM9V-TPYKJ-P7VT2-3YJDQ" # Office16_ProfessionalR_Grace
    3516 = "NKGG6-WBPCC-HXWMY-6DQGJ-CPQVG" # Office16_ProfessionalR_Trial
    3517 = "NTGF6-Q4QRC-M7Q9R-KBYJV-XD8DV" # Office16_ProfessionalR_Retail
    3519 = "XT88V-9PNWJ-GXHP3-J88QP-4RHHK" # Office16_ProjectProMSDNR_Retail
    3520 = "TF74N-XPD7W-9C2XJ-M37BR-2KCYB" # Office16_VisioProMSDNR_Retail
    3526 = "P7NC4-K3X6B-D9VP7-YJKPM-X4TMJ" # Office16_WCServer_Bypass
    3528 = "CJKFJ-WNWBK-29CW7-P9786-C9X7Y" # Office16_PersonalR_Grace
    3529 = "CKJYK-BNQDD-YB36J-RVTKX-9HKBP" # Office16_PersonalR_OEM_Perp
    3535 = "NG3HB-Y326P-PHCH3-9F96F-KBVH9" # Office16_O365HomePremDemoR_BypassTrial365
    3540 = "DMTCJ-KNRKX-26982-JYCKT-P7KB6" # Office16_MondoR_KMS_Automation
    3687 = "WGT24-HCNMF-FQ7XH-6M8K7-DRTW9" # Office16_ProjectProXC2RVL_KMS_ClientC2R
    3688 = "D8NRQ-JTYM3-7J2DX-646CT-6836M" # Office16_ProjectStdXC2RVL_KMS_ClientC2R
    3689 = "69WXN-MBYV6-22PQG-3WGHK-RM6XC" # Office16_VisioProXC2RVL_KMS_ClientC2R
    3690 = "NY48V-PPYYH-3F4PX-XJRKJ-W4423" # Office16_VisioStdXC2RVL_KMS_ClientC2R
    3691 = "JFWJN-79K3G-GWF8H-92T2Y-QJ36R" # Office16_VisioProXC2RVL_MAKC2R
    3692 = "VNXG9-7RQRQ-Y934T-3CH7X-H6D6T" # Office16_VisioStdXC2RVL_MAKC2R
    3693 = "MXMBD-BN69V-FKTCT-B9M4F-Q9PC7" # Office16_ProjectProXC2RVL_MAKC2R
    3694 = "MC6NX-2DR2Q-FD3MG-3FKQF-DJ36W" # Office16_ProjectStdXC2RVL_MAKC2R
    3735 = "T2NP2-GM3V4-VYBYW-HT963-B99M9" # Office16_HomeStudentVNextR_Grace
    3876 = "8843N-BCXXD-Q84H8-R4Q37-T3CPT" # Office16_O365EduCloudEDUR_Grace
    3951 = "9QQJF-NR4RF-XC46H-3XGMD-7VBXK" # Office16_MondoR_O17EnterpriseVL_Bypass30
    3952 = "D2P2N-743KT-VB6X2-K8DD4-846GY" # Office16_MondoR_O16EnterpriseVL_Bypass30
    3980 = "6FPNC-PRYD3-X9HBB-4HMR8-YP3RG" # Office21_ProPlus2019Volume
    4025 = "CFM4C-NYGHX-GJXRK-Q449H-B7W92" # Office19_Access2019R_Retail
    4027 = "JQ36N-4J2GD-M7WP7-WV2DQ-G84QR" # Office19_AccessRuntime2019R_PrepidBypass
    4028 = "9N9PT-27V4Y-VJ2PD-YXFMF-YTFQT" # Office19_Access2019VL_KMS_Client_AE
    4029 = "NCRGC-2PYYC-VTRMT-RJFT7-WK97H" # Office19_Access2019VL_MAK_AE
    4031 = "R9Q2B-N7FCB-66HFM-6WJ6T-TJHHK" # Office19_Excel2019R_Grace
    4034 = "TMJWT-YYNMB-3BKTF-644FC-RVXBD" # Office19_Excel2019VL_KMS_Client_AE
    4035 = "D6DBB-GNGD9-XR3YD-XY47T-C9Y34" # Office19_Excel2019VL_MAK_AE
    4039 = "KP2TY-V7NX7-RMY62-W8XC2-W2RQ9" # Office19_HomeBusiness2019R_OEM_Perp
    4043 = "3F4GT-DN2RR-B89CP-8KVPC-J46MR" # Office19_HomeBusiness2019R_Grace
    4044 = "6NCJX-49YFK-W7HRW-8D73T-V6FRG" # Office19_HomeBusiness2019R_Retail
    4053 = "3NT9T-3KHWF-XF7H7-3PDDR-TVK8H" # Office19_HomeStudent2019R_OEM_Perp
    4054 = "NTMYR-DM4C3-MHK32-7QBRC-RVXB8" # Office19_HomeStudent2019R_Grace
    4055 = "Y7QVG-N62RY-9BWQ2-D99GD-7VB4X" # Office19_HomeStudent2019R_Retail
    4061 = "XNPCY-7K9B8-Y63P8-82MVM-39P2H" # Office16_MOSS_Bypass
    4062 = "F2DPD-HPNPV-WHKMK-G7C38-2G22J" # Office16_MOSS_BypassTrial180
    4067 = "7G7R6-N6QJC-JFPJX-CK8WX-66QW4" # Office16_MOSSPremium_Bypass
    4068 = "M692G-8N2JP-GG8B2-2W2P7-YY7J6" # Office16_MOSSPremium_BypassTrial180
    4093 = "2X3NT-BTKCM-2RW9D-JRGV6-D3X97" # Office19_Outlook2019R_Retail
    4094 = "Q2KN3-2QH4F-CXJM6-KVF7Y-F9DX8" # Office19_Outlook2019R_Grace
    4095 = "7HD7K-N4PVK-BHBCQ-YWQRW-XW4VK" # Office19_Outlook2019VL_KMS_Client_AE
    4096 = "6NRRQ-9PXQQ-82R73-2CTHF-PPRVM" # Office19_Outlook2019VL_MAK_AE
    4098 = "4RNW6-CRY8K-HCMK9-C3FHK-WT233" # Office19_Personal2019R_OEM_Perp
    4101 = "VQFTQ-GNRXK-HCVHQ-DWJDJ-JFJHV" # Office19_Personal2019R_Grace
    4105 = "7FJ6Q-QNFB8-BGXGQ-FFWMV-9BWH2" # Office19_PowerPoint2019R_Grace
    4106 = "RRNCX-C64HY-W2MM7-MCH9G-TJHMQ" # Office19_PowerPoint2019VL_KMS_Client_AE
    4107 = "6VBNW-2G99K-VDDDR-G73GJ-K2GRF" # Office19_PowerPoint2019VL_MAK_AE
    4109 = "W7CFC-KTNPX-RFPH9-9JRRD-YBKFH" # Office19_Professional2019R_OEM_Perp
    4111 = "MJBFF-YNXYP-MHV89-VBF3W-VH8H9" # Office19_Professional2019R_Retail
    4112 = "7PND3-J7G8B-9M7V3-8VXHR-QGQYY" # Office19_Professional2019R_Grace
    4115 = "7NWXR-PQMJ3-FYW77-WTTMX-BKP4R" # Office19_ProjectPro2019MSDNR_Retail
    4118 = "GP2G7-N7P9M-MGVJB-PK9GM-B4JJJ" # Office19_ProjectPro2019R_Grace
    4119 = "93TN7-HPG68-G2TF8-TPYDW-F3M8K" # Office19_ProjectPro2019R_Retail
    4120 = "B4NPR-3FKK7-T2MBV-FRQ4W-PKD2B" # Office19_ProjectPro2019VL_KMS_Client_AE
    4121 = "N4PVQ-DFFG4-HFD6B-73M4F-Q9P42" # Office19_ProjectPro2019VL_MAK_AE
    4123 = "94D77-N9KP7-62G8M-PCX6H-8HXF4" # Office16_ProjectServer_Bypass
    4124 = "R9946-QXNHR-62JPQ-3H3QC-TMWJT" # Office16_ProjectServer_BypassTrial180
    4126 = "RMCNH-6MH3J-VD843-Y4THK-RM7PJ" # Office19_ProjectStd2019R_Grace
    4127 = "6Q64R-FN9VH-TWXD2-4CJD4-4YBCK" # Office19_ProjectStd2019R_Retail
    4128 = "C4F7P-NCP8C-6CQPT-MQHV9-JXD2M" # Office19_ProjectStd2019VL_KMS_Client_AE
    4129 = "477K6-KNRXH-WBFDH-DYYB6-FVXGC" # Office19_ProjectStd2019VL_MAK_AE
    4132 = "2GH6N-VV7JM-JCH67-2VMHW-GVMCT" # Office19_ProPlus2019MSDNR_Retail
    4135 = "Y64MN-DK448-Q3VK7-YBTP3-8MBCX" # Office19_ProPlus2019R_Grace
    4136 = "2HMWB-QNJD9-HGQ43-B4JJQ-MDYCY" # Office19_ProPlus2019R_Retail
    4137 = "JPGNM-X3K7H-KHGQC-JHWDD-CBBC2" # Office19_Publisher2019R_Grace
    4145 = "NMMKJ-6RK4F-KMJVX-8D9MJ-6MWKP" # Office19_ProPlus2019VL_KMS_Client_AE
    4146 = "2B2NQ-Q7QRH-79DJ2-Q493T-GMWKQ" # Office19_ProPlus2019VL_MAK_AE
    4149 = "G2KWX-3NW6P-PY93R-JXK2T-C9Y9V" # Office19_Publisher2019VL_KMS_Client_AE
    4150 = "NYGYJ-9HYG2-Y833K-YK27H-M4JKW" # Office19_Publisher2019VL_MAK_AE
    4151 = "9J3NQ-DRKTQ-KGMP9-F29T6-P7MDK" # Office19_SkypeforBusiness2019VL_MAK_AE
    4152 = "96GNB-87TH4-KK7HX-Q62V2-7CGVB" # Office19_Standard2019VL_MAK_AE
    4153 = "228N2-6HCP8-KDCQ8-JTBBK-XKY92" # Office19_VisioPro2019VL_MAK_AE
    4155 = "8BVG2-NHMBP-7R6Y2-RV76Y-RC33R" # Office19_VisioStd2019VL_MAK_AE
    4157 = "BNM3Y-M9W3P-QF76K-Y6M3D-VXP7H" # Office19_Word2019VL_MAK_AE
    4158 = "NCJ33-JHBBY-HTK98-MYCV8-HMKHJ" # Office19_SkypeforBusiness2019VL_KMS_Client_AE
    4159 = "6NWWJ-YQWMR-QKGCB-6TMB3-9D9HK" # Office19_Standard2019VL_KMS_Client_AE
    4160 = "9BGNQ-K37YR-RQHF2-38RQ3-7VCBB" # Office19_VisioPro2019VL_KMS_Client_AE
    4161 = "7TQNQ-K3YQQ-3PFH7-CCPPM-X4VQ2" # Office19_VisioStd2019VL_KMS_Client_AE
    4162 = "PBX3G-NWMT6-Q7XBW-PYJGG-WXD33" # Office19_Word2019VL_KMS_Client_AE
    4167 = "CGRNC-VC826-JJJX8-Y7MHW-6MWMK" # Office19_SkypeforBusinessEntry2019R_PrepidBypass
    4168 = "38N83-G89F7-8F67C-TH2KM-G3C7Y" # Office19_SkypeforBusiness2019R_Grace
    4173 = "MKFY8-QNW8D-YKV28-H2CJD-Y4JMV" # Office19_Standard2019R_Grace
    4174 = "GFNR9-GJ3T6-2GHCR-QF6CT-684YW" # Office19_VisioPro2019R_Grace
    4175 = "4T7YN-CKDXC-V8YVV-8KJXV-RGFYX" # Office19_VisioPro2019R_Retail
    4177 = "NFK24-KVVP3-DGH4W-9MW7F-X2GWC" # Office19_VisioPro2019MSDNR_Retail
    4181 = "79NH8-K7F3C-YBF8P-3WMYC-V8TWH" # Office19_VisioStd2019R_Grace
    4182 = "N39QQ-DMDBB-W8VVH-GGR44-TVMFW" # Office19_VisioStd2019R_Retail
    4185 = "VTTBH-NYYFR-KHC3B-DV98B-2PR2C" # Office19_Word2019R_Retail
    4186 = "6NR9R-48TXM-KDFFX-RHHYT-PDPCD" # Office19_Word2019R_Grace
    4214 = "NR2B6-YBFTG-JFMKK-FGDKF-GX2DJ" # Office19_Access2019R_Grace
    4478 = "T3N47-WVHW9-VCT2V-QKP29-P393W" # Office21_ProPlus2021PreviewVL_MAK_AE
    4479 = "M9N3Y-CCB6D-J66FD-KKGF4-8B799" # Office21_Visio2021PreviewVL_MAK_AE
    4480 = "2NYG6-3BBBX-M97JW-B7DFV-G6RMB" # Office21_Project2021PreviewVL_MAK_AE
    4592 = "22FND-GDW8Y-CYCPG-82YHP-Q3Y6Y" # Office21_Access2021R_Retail
    4595 = "WM8YG-YNGDD-4JHDC-PG3F4-FC4T4" # Office21_Access2021VL_KMS_Client_AE
    4598 = "J2B4N-TKGVF-9GKM3-86QGC-Q3Y68" # Office21_Excel2021R_Grace
    4601 = "NWG3X-87C9K-TC7YY-BC2G7-G6RVC" # Office21_Excel2021VL_KMS_Client_AE
    4603 = "CRK4N-8KW4R-JF9YP-RD2J8-6MXDR" # Office21_HomeBusiness2021DemoR_BypassTrial180
    4604 = "BR8CN-BWPG3-8J4JD-TM49Y-XBXDT" # Office21_HomeBusiness2021R_Retail1
    4610 = "QGTQ3-RNVPB-6YJ23-Y32R4-X2HMD" # Office21_HomeBusiness2021R_Grace
    4621 = "PB2D6-G4NJR-4CD7B-DF7RH-9BXFH" # Office21_HomeStudent2021R_Grace
    4632 = "2Q3PN-37DFW-R7HGQ-6JPHP-6JJJM" # Office21_OneNote2021R_Grace
    4638 = "C4N44-RP6HX-YK9DY-Y6VB7-MBMCJ" # Office21_Outlook2021R_Grace
    4639 = "C9FM6-3N72F-HFJXB-TM3V9-T86R9" # Office21_Outlook2021VL_KMS_Client_AE
    4645 = "WN2B7-QJPXV-93VY2-6WTH3-BHC6H" # Office21_Personal2021R_Grace
    4670 = "3Y77Q-NB84W-94BJJ-X2BPC-BTGVJ" # Office21_PowerPoint2021R_Grace
    4671 = "TY7XF-NFRBR-KJ44C-G83KF-GX27K" # Office21_PowerPoint2021VL_KMS_Client_AE
    4676 = "HQNWX-BC3KQ-RMVTX-7THM7-CYXHT" # Office21_Professional2021R_Retail
    4677 = "G7R2D-6NQ7C-CX62B-9YR9J-DGRYH" # Office21_Professional2021R_Grace
    4680 = "RGNB4-Y92P2-7G3KV-KJ66V-9BXHY" # Office21_ProjectPro2021MSDNR_Retail1
    4684 = "BN7TR-MVXBP-VVR8B-G6WDG-FVYFG" # Office21_ProjectPro2021R_Grace
    4685 = "8NPHP-F294M-7GVWF-XK38K-9HPBV" # Office21_ProjectPro2021R_Retail
    4686 = "FTNWT-C6WBT-8HMGF-K9PRX-QV9H8" # Office21_ProjectPro2021VL_KMS_Client_AE
    4688 = "YN8Q9-7K77C-9763R-VCY7C-FYCBY" # Office21_ProjectPro2021VL_MAK_AE2
    4690 = "NM67Q-YGTRY-898DB-67RF6-QYMFQ" # Office21_ProjectStd2021R_Grace
    4691 = "YNKK9-M9T4G-QTMGC-3XX2K-2YXJF" # Office21_ProjectStd2021R_Retail
    4692 = "J2JDC-NJCYY-9RGQ4-YXWMH-T3D4T" # Office21_ProjectStd2021VL_KMS_Client_AE
    4695 = "38BGN-49Q8H-8RK9K-9M9CJ-J8JM9" # Office21_ProPlus2021MSDNR_Retail
    4698 = "YNYDT-B8RMY-G8WJX-RPTY2-PG343" # Office21_ProPlus2021R_Grace
    4699 = "YB9WX-NP9D4-J8HKT-YJXWD-49F2F" # Office21_ProPlus2021R_Retail
    4700 = "JK2N9-C82GT-YJRTK-TT8C7-46346" # Office21_Publisher2021R_Grace
    4709 = "FXYTK-NJJ8C-GB6DW-3DYQT-6F7TH" # Office21_ProPlus2021VL_KMS_Client_AE
    4711 = "BNDYJ-7TXK6-VVQM3-XY6YV-YY8PX" # Office21_ProPlus2021VL_MAK_AE2
    4714 = "2MW9D-N4BXM-9VBPG-Q7W6M-KFBGQ" # Office21_Publisher2021VL_KMS_Client_AE
    4717 = "NM6DV-GPBPQ-M4R8C-G7C3G-4M8P7" # Office21_Standard2021VL_MAK_AE
    4721 = "HWCXN-K3WBT-WJBKY-R8BD9-XK29P" # Office21_SkypeforBusiness2021VL_KMS_Client_AE
    4722 = "KDX7X-BNVR8-TXXGX-4Q7Y8-78VT3" # Office21_Standard2021VL_KMS_Client_AE
    4723 = "KNH8D-FGHT4-T8RK3-CTDYJ-K2HT4" # Office21_VisioPro2021VL_KMS_Client_AE
    4724 = "MJVNY-BYWPY-CWV6J-2RKRT-4M8QG" # Office21_VisioStd2021VL_KMS_Client_AE
    4725 = "TN8H9-M34D3-Y64V9-TR72V-X79KV" # Office21_Word2021VL_KMS_Client_AE
    4730 = "H4TN4-FQXYB-B74CH-WF7D4-YTGX3" # Office21_SkypeforBusiness2021R_Grace
    4735 = "RXK2W-N42KP-FT9W3-Q7DG8-TRBHK" # Office21_Standard2021R_Grace
    4736 = "6PKRH-BNYBM-JWY82-4PBJ8-Q7DBB" # Office21_VisioPro2021R_Grace
    4737 = "NRPTR-CV767-2W8PJ-2HMJ6-24BHP" # Office21_VisioPro2021R_Retail
    4739 = "32TWN-BQKG6-BWFK6-BYJG2-JB8Q4" # Office21_VisioPro2021MSDNR_Retail
    4743 = "QFNR2-YGMTQ-7PYYT-667D2-V8VVX" # Office21_VisioStd2021R_Grace
    4748 = "4KCVN-HRKJM-H3QRP-3HY3Y-39Q76" # Office21_Word2021R_Grace
    4751 = "P7GPV-TNCRV-YQRDY-VXFFH-YY8RK" # Office21_Access2021R_Grace
    4776 = "HNQ22-HGCKV-RK4TT-47RH9-BKQ9B" # Office21_ProPlusSPLA2021VL_MAK_AE
    4777 = "TM6RK-NFD7H-9YFHK-7M82B-HVDC2" # Office21_StandardSPLA2021VL_MAK_AE
    5010 = "82FTR-NCHR7-W3944-MGRHM-JMCWD" # Office24_Access2024VL_KMS_Client_AE
    5012 = "F4DYN-89BP2-WQTWJ-GR8YC-CKGJG" # Office24_Excel2024VL_KMS_Client_AE
    5015 = "D2F8D-N3Q3B-J28PV-X27HD-RJWB9" # Office24_Outlook2024VL_KMS_Client_AE
    5017 = "CW94N-K6GJH-9CTXY-MG2VC-FYCWP" # Office24_PowerPoint2024VL_KMS_Client_AE
    5019 = "FQQ23-N4YCY-73HQ3-FM9WC-76HF4" # Office24_ProjectPro2024VL_KMS_Client_AE
    5022 = "PD3TT-NTHQQ-VC7CY-MFXK3-G87F8" # Office24_ProjectStd2024VL_KMS_Client_AE
    5024 = "4H6NF-QDPG8-832B2-9VYK4-TVPWY" # Office24_ProPlus2024VL_KMS_Client_AE
    5034 = "4NKHF-9HBQF-Q3B6C-7YV34-F64P3" # Office24_SkypeforBusiness2024VL_KMS_Client_AE
    5035 = "V28N4-JG22K-W66P8-VTMGK-H6HGR" # Office24_Standard2024VL_KMS_Client_AE
    5036 = "B7TN8-FJ8V3-7QYCP-HQPMV-YY89G" # Office24_VisioPro2024VL_KMS_Client_AE
    5037 = "JMMVY-XFNQC-KK4HK-9H7R3-WQQTV" # Office24_VisioStd2024VL_KMS_Client_AE
    5038 = "MQ84N-7VYDM-FXV7C-6K7CC-VFW9J" # Office24_Word2024VL_KMS_Client_AE
    5041 = "2TDPW-NDQ7G-FMG99-DXQ7M-TX3T2" # Office24_ProPlus2024PreviewVL_KMS_Client_AE
    5042 = "YW66X-NH62M-G6YFP-B7KCT-WXGKQ" # Office24_VisioPro2024PreviewVL_KMS_Client_AE
    5043 = "D9GTG-NP7DV-T6JP3-B6B62-JB89R" # Office24_ProjectPro2024PreviewVL_KMS_Client_AE
    5044 = "Y63J7-9RNDJ-GD3BV-BDKBP-HH966" # Office24_ProPlus2024PreviewVL_MAK_AE
    5045 = "3HYNG-BB9J3-MVPP7-2W3D8-CPVG7" # Office24_VisioPro2024PreviewVL_MAK_AE
    5046 = "GQRNR-KHGMM-TCMK6-M2R3H-94W9W" # Office24_ProjectPro2024PreviewVL_MAK_AE
    5098 = "X3CPN-B38QB-QWBQQ-CFM78-293XD" # Office24_HomeBusiness2024R_Retail
    5108 = "GHNTC-PQW8F-99799-9HJTG-MKRT6" # Office24_Access2024R_Grace
    5109 = "VRX3N-2MP22-D88TR-B23KV-2R8G7" # Office24_Excel2024R_Grace
    5110 = "T426N-Y4VXF-PGJBK-YXH79-BKRT8" # Office24_HomeBusiness2024R_Grace
    5111 = "NHM39-W2C2G-6FXWB-KT7MM-QJ7KX" # Office24_Home2024R_Grace
    5113 = "TK263-N63DD-PDBV3-MFFW4-4YC3P" # Office24_Outlook2024R_Grace
    5114 = "D3NRX-6VC6F-P32K7-4H8KQ-VXRVD" # Office24_PowerPoint2024R_Grace
    5115 = "CBNBW-Y38B2-926G3-FDJTQ-YBM7F" # Office24_ProjectPro2024R_Grace
    5116 = "WJQ8V-92NF9-TWJ4T-DH4MT-D323T" # Office24_ProjectStd2024R_Grace
    5117 = "HD4NY-QVXPH-VPXH8-YY4WV-R9GQV" # Office24_ProPlus2024R_Grace
    5123 = "WW24K-7QNGC-GF4B3-P2F2D-WQQYF" # Office24_VisioPro2024R_Grace
    5124 = "NBH3G-RGRDT-8TMGJ-CTW6Q-PYYBG" # Office24_VisioStd2024R_Grace
    5125 = "N4YDW-X8GRP-XF27W-2CBJH-WMC37" # Office24_Word2024R_Grace
    5127 = "6F78Y-N9KRQ-CKRBF-PR798-VJBBK" # Office24_HomeBusiness2024DemoR_BypassTrial180
	5252 = "BDFXN-B36X4-B9MFF-FQC9C-W2VVT" # Office16_O365AppsBasicR_Grace
}

# Define the keyPair string and split it into lines, processing each line directly
$VSOnlyKeys = @()  # Initialize here to avoid errors

@'
    3225 = "HMGNV-WCYXV-X7G9W-YCX63-B98R2" # Visual Studio 2015 RTM Retail Visual Studio 2015 RTM Professional Retail
    3226 = "PTBNK-HVGCM-HB2GW-MXWMH-T3BJQ" # Visual Studio 2015 RTM Retail Visual Studio 2015 RTM Premium Retail
    3228 = "N3QMM-GKDT3-JQJKD-CRXQ4-8438T" # Visual Studio 2015 RTM Retail Visual Studio 2015 RTM Ultimate Retail
    3229 = "2XNFG-KFHR8-QV3CP-3W6HT-683CH" # Visual Studio 2015 RTM Retail Visual Studio 2015 RTM Ultimate Retail
    3229 = "HM6NR-QXX7C-DFW2Y-8B82K-WTYJV" # Visual Studio 2015 RTM Retail Visual Studio 2015 RTM Ultimate Retail
    3256 = "DVN46-CT3MD-HKMMH-KDJWG-YG9QM" # Visual Studio 2015 RTM Volume:MAK Visual Studio 2015 RTM Professional  Volume
    3257 = "2TNKK-Q3FCT-CQP8T-WJ6TT-TJF7C" # Visual Studio 2015 RTM Volume:MAK Visual Studio 2015 RTM Ultimate Volume
    3542 = "XHMG7-NCTPT-D8V9K-FTHDD-49CY8" # Visual Studio 2015 Enterprise Visual Studio 2015 RTM Enterprise Volume
    3544 = "Y9GTX-N3QJV-JK2HR-7MWJ2-6JGPB" # Visual Studio 2015 Test Professional Visual Studio 2015 RTM Test Professional Volume
    3545 = "XDWN8-D7HDP-J7QKT-TVMFT-P7KCC" # Visual Studio 2015 Team Foundation Server Visual Studio 2015 RTM Team Foundation Server Volume
    3699 = "N2VYX-9VR2K-T733M-MWD9X-KQCDF" # Visual Studio Dev15 RTM Enterprise Retail
    3699 = "NJVYC-BMHX2-G77MM-4XJMR-6Q8QF" # Visual Studio Dev15 RTM Enterprise Retail
    3700 = "YBHFK-NRD8P-3T7XT-4QQ3G-8T2DG" # Visual Studio Dev15 RTM Enterprise Volume:MAK
    3701 = "4F3PR-NFKDB-8HFP7-9WXGY-K77T7" # Visual Studio Dev15 RTM Professional Retail
    3701 = "KBJFW-NXHK6-W4WJM-CRMQB-G3CDH" # Visual Studio Dev15 RTM Professional Retail
    3702 = "X2NTK-FP9XV-6HP3T-DP8WG-4M6XW" # Visual Studio Dev15 RTM Professional Volume:MAK
    3707 = "VG622-NKFP4-GTWPH-XB2JJ-JFHVF" # Visual Studio Dev15 RTM Test Professional Retail
    3708 = "RQ4VN-VVM9M-Y6C3Q-7M74K-BKPDT" # Visual Studio Dev15 RTM Test Professional Volume:MAK
    4339 = "3N979-9MQC2-PPMY7-7YJGH-4C4DF" # Visual Studio 2019 RTM Enterprise Retail
    4339 = "8NW97-4C66B-946FG-W7RH3-T6RDF" # Visual Studio 2019 RTM Enterprise Retail
    4339 = "BF8Y8-GN2QH-T84XB-QVY3B-RC4DF" # Visual Studio 2019 RTM Enterprise Retail
    4339 = "C83MN-VVD2Q-93T9P-DWTWY-FGF9R" # Visual Studio 2019 RTM Enterprise Retail
    4339 = "GFM62-NPX8Q-22HRX-D6CD8-CPR9R" # Visual Studio 2019 RTM Enterprise Retail
    4339 = "KMRG3-7NMBG-6973T-DRKCQ-TCR9R" # Visual Studio 2019 RTM Enterprise Retail
    4339 = "MBN4X-RGMX3-C9BCG-K78T3-GF664" # Visual Studio 2019 RTM Enterprise Retail
    4339 = "N9V4J-PW9X6-4YKD2-T4G47-R9FDF" # Visual Studio 2019 RTM Enterprise Retail
    4339 = "NXG4K-X726V-VFV7X-7TW2R-BY73F" # Visual Studio 2019 RTM Enterprise Retail
    4339 = "Q7NKQ-W62KR-JY2FP-BTH2X-3RV3F" # Visual Studio 2019 RTM Enterprise Retail
    4339 = "RMN6R-3BCW9-27V6W-Q8Q8V-HXQG4" # Visual Studio 2019 RTM Enterprise Retail
    4339 = "V6KKH-C4N2Y-KJPW7-2JB24-K4V3F" # Visual Studio 2019 RTM Enterprise Retail
    4339 = "VR6X8-8JNDC-9DFB3-DRDP4-CR664" # Visual Studio 2019 RTM Enterprise Retail
    4340 = "89N29-VC43C-4MXKJ-F86KF-GX2KT" # Visual Studio 2019 RTM Enterprise Volume:MAK
    4352 = "7BV49-NJ6T7-B3Q8C-Q9QQ2-GQ9VM" # Visual Studio 2019 RTM Professional Retail
    4352 = "7NPFP-GPJM9-K8XGH-X3RBG-686BB" # Visual Studio 2019 RTM Professional Retail
    4352 = "7VV43-NF8PR-WYQRM-QWW4D-PYWYB" # Visual Studio 2019 RTM Professional Retail
    4352 = "7WNDX-28JW9-JR89W-RB3HM-TX2MB" # Visual Studio 2019 RTM Professional Retail
    4352 = "8GNRJ-BV3P7-2CX36-MXH4H-9BWYB" # Visual Studio 2019 RTM Professional Retail
    4352 = "B9QP3-TNWWF-8QMPR-MD47V-T3DHM" # Visual Studio 2019 RTM Professional Retail
    4352 = "NYWVH-HT4XC-R2WYW-9Y3CM-X4V3Y" # Visual Studio 2019 RTM Professional Retail
    4353 = "XDG8C-NTCG3-VJG3T-79GP7-B7XVP" # Visual Studio 2019 RTM Professional Volume:MAK
    4821 = "VHF9H-NXBBB-638P6-6JHCY-88JWH" # Visual Studio 2022 RTM  Enterprise Retail
    4821 = "F4YQN-C7FJF-P6RQH-9RFQY-39RB7" # Visual Studio 2022 RTM  Enterprise Retail
    4822 = "MTTW7-NQCJ6-2VWRK-66VP4-6RBM8" # Visual Studio 2022 RTM  Enterprise Volume:MAK
    4830 = "TD244-P4NB7-YQ6XK-Y8MMM-YWV2J" # Visual Studio 2022 RTM  Professional Retail
    4831 = "47VGN-R6RDH-FFCQB-3F2CD-63FCK" # Visual Studio 2022 RTM  Professional Volume:MAK
'@ -split "`n" | ForEach-Object {
    # Trim any leading or trailing whitespace
    $line = $_.Trim()
    
    # Split the line into key and value
    if ($line -match '(\d+)\s*=\s*"([^"]+)"\s*#\s*(.*)') {
        $VSOnlyKeys += [PSCustomObject]@{
            Key         = $matches[1]
            Value       = $matches[2]
            Description = $matches[3]
        }
    }
}

# Initialize an array to hold PSObjects
$KeysRef = @()

# Create a hash table for key-ref pairs with integer references
@'
    1042 = "GBBXB-8DNVD-2X4G6-T863T-9KRWD" # WinServer Next ServerDatacenter OEM:DM
    1043 = "6HPQN-F6WKY-2JM6P-7DV28-W4XFR" # WinServer Next ServerDatacenter OEM:SLP
    1043 = "Y74D9-QN2XB-TPRT8-KK6JR-PPJJF" # WinServer Next ServerDatacenter OEM:SLP
    1044 = "KJ6VV-CNFYK-FDHQV-PTJDQ-97Y8G" # WinServer Next ServerDatacenter OEM:NONSLP
    1044 = "NJ23M-WDVR7-72XT7-T8FCG-9KRWG" # WinServer Next ServerDatacenter OEM:NONSLP
    1045 = "DM3GN-V7TRY-XD7Q8-JGR32-CJ7M7" # WinServer Next ServerDatacenter OEM:COA
    1045 = "GNJPJ-Q6Y46-6PDVF-FYKT8-PJ7M7" # WinServer Next ServerDatacenter OEM:COA
    1052 = "TYN7K-PXBJB-WKTYR-9KTBT-3VY8T" # WinServer Next ServerWinFoundation OEM:NONSLP
    1054 = "Y84VV-NBK6Q-TYTM7-F9PTC-Q3Q2J" # WinServer Next ServerStandard OEM:DM
    1055 = "6PDNC-RCFJJ-H6K7C-MWRWY-FF8JX" # WinServer Next ServerStandard OEM:SLP
    1055 = "B38N7-QYJB6-HQRBK-KTVKH-VT4WX" # WinServer Next ServerStandard OEM:SLP
    1056 = "KVKHN-XQMH9-6JR6T-JJ36Q-4F8JY" # WinServer Next ServerStandard OEM:NONSLP
    1056 = "Q83WX-NV3J2-GVVHJ-HT9C4-Q9GTB" # WinServer Next ServerStandard OEM:NONSLP
    1057 = "FDBNB-3GM37-BXTD6-3TKP3-JTTTC" # WinServer Next ServerStandard OEM:COA
    1057 = "WKFQV-KNKRQ-8XR3J-F2MFG-PDFW2" # WinServer Next ServerStandard OEM:COA
    1058 = "8HQ9M-QNCX9-FV4G2-88VDT-6FXGD" # ServerWeb, WinServer Next ServerWeb OEM:DM
    1059 = "H7RN9-XDBFP-824HQ-J98D3-DVY84" # ServerWeb, WinServer Next ServerWeb OEM:SLP
    1059 = "N8VTY-4RTQK-FWXJJ-VXYPF-PPJJ4" # ServerWeb, WinServer Next ServerWeb OEM:SLP
    1060 = "MR7Y6-N3FX9-M269R-BK6WH-6XRW6" # ServerWeb, WinServer Next ServerWeb OEM:NONSLP
    1061 = "PNJ93-PJK47-B7TKH-HJPB7-2RXGH" # ServerWeb, WinServer Next ServerWeb OEM:COA
    1068 = "FN4FW-WJQ8V-X8VXM-RP3HH-M4B9G" # WinServer Next ServerStorageWorkgroup OEM:DM
    1068 = "T2B3W-RJN32-32HFV-82TKM-K7Y9G" # WinServer Next ServerStorageWorkgroup OEM:DM
    1069 = "9JFKN-MWC8F-X8PVJ-RG34X-9HD27" # WinServer Next ServerStorageStandard OEM:DM
    1069 = "VRJVT-NXGPT-WYHR9-JVV2P-CJ7P7" # WinServer Next ServerStorageStandard OEM:DM
    1073 = "FV4NT-QMCWC-DFXT2-83GKB-QJWKP" # WinServerSolutions Next ServerSolution OEM:DM
    1073 = "VNKR4-K34FT-CDBCJ-FK8TF-KBM9P" # WinServerSolutions Next ServerSolution OEM:DM
    1278 = "DNJXJ-7XBW8-2378T-X22TX-BKG7J" # WinNext Beta Prerelease Retail
    1278 = "H9VCT-63NFW-FWHDR-F4J43-972K8" # WinNext Beta Prerelease Retail
    1279 = "NHKTD-YYMG6-H77XH-BWBC8-MR8X9" # WinNext Beta Prerelease Volume:GVLK
    1280 = "T87VG-N82DX-9Q7G4-67CHR-KBPMB" # WinNext Beta PrereleaseN Retail
    1282 = "D9HNY-JTJDK-BQM84-K3VTB-JK4D3" # WinNext Beta PrereleaseARM Retail
    1283 = "NTJQR-RKW42-DMDHB-D8F6T-3V2MF" # WinNext Beta PrereleaseARM Volume:GVLK
    1284 = "BNMMY-9D8F2-TKGQ6-BT8DJ-JFCMG" # WinNext Beta EnterpriseEval Retail:TB:Eval
    1285 = "KJC88-XWNCH-C4F7V-8X4DM-XBPMH" # WinNext Beta EnterpriseNEval Retail:TB:Eval
    1289 = "K239N-DKBKY-BPJ7K-8V44P-PGT72" # WinServer Next ServerStandardEval Retail:TB:Eval
    1289 = "N2VCT-KTCCY-CFC8F-DGR7J-J8BRC" # WinServer Next ServerStandardEval Retail:TB:Eval
    1289 = "NJBCW-WXK3P-BH2HC-HV2DQ-2WBRC" # WinServer Next ServerStandardEval Retail:TB:Eval
    1290 = "7RQHC-MNTBD-2CK49-B4JCF-PPJYQ" # WinServer Next ServerDatacenterEval Retail:TB:Eval
    1290 = "RNVXQ-7KVPJ-HG3HW-FXB68-D9G73" # WinServer Next ServerDatacenterEval Retail:TB:Eval
    1290 = "WK3NH-YPQH4-7WQ9D-YGT3H-G6H4D" # WinServer Next ServerDatacenterEval Retail:TB:Eval
    1291 = "GHMG6-NT2FH-BJ7VY-QW4F8-QC674" # WinServer Next ServerStorageWorkgroup Retail:TB:Eval
    1291 = "HK386-DNXKY-J8WX8-DY78C-XTH4F" # WinServer Next ServerStorageWorkgroup Retail:TB:Eval
    1292 = "PQ6NX-BHK88-86J9G-7FWM9-6CJYT" # WinServer Next ServerStorageWorkgroup OEM:SLP
    1292 = "RQ7PN-WDGCC-VTD2Y-FRC6B-FF8YT" # WinServer Next ServerStorageWorkgroup OEM:SLP
    1293 = "47TNM-XW3Y6-FVFVX-BTXMJ-GVFFH" # WinServer Next ServerStorageWorkgroup OEM:NONSLP
    1293 = "4CBNB-73RKJ-VD7YH-H4J6C-9P677" # WinServer Next ServerStorageWorkgroup OEM:NONSLP
    1293 = "KJTGN-JD69D-FYQDK-WRD9B-VQRFH" # WinServer Next ServerStorageWorkgroup OEM:NONSLP
    1294 = "49BWB-KND26-48W74-4626D-H2V4J" # WinServer Next ServerStorageWorkgroup OEM:COA
    1294 = "WTMK2-FNFHY-78XKW-GVYBG-233H8" # WinServer Next ServerStorageWorkgroup OEM:COA
    1295 = "JF4ND-8K7CW-96P84-DT2RX-9HFFK" # WinServer Next ServerStorageStandard Retail:TB:Eval
    1295 = "XRW2Y-N9949-GXYBH-KFDJH-94MRK" # WinServer Next ServerStorageStandard Retail:TB:Eval
    1296 = "QRDJF-N7QCC-CCJH4-GBJXD-T6H4M" # WinServer Next ServerStorageStandard OEM:SLP
    1296 = "W8VRN-D6776-749GR-V66H2-DC68B" # WinServer Next ServerStorageStandard OEM:SLP
    1297 = "4XGR7-PNCKM-XYHV8-CH4W2-GQ3JC" # WinServer Next ServerStorageStandard OEM:NONSLP
    1297 = "J6QRN-JRMRY-398JP-R393D-GFXWC" # WinServer Next ServerStorageStandard OEM:NONSLP
    1297 = "XM9N3-TV9DQ-HTXBK-M7M6B-X4MRP" # WinServer Next ServerStorageStandard OEM:NONSLP
    1298 = "DBN7V-4R3HT-7P6Y3-TBJDT-GMPM3" # WinServer Next ServerStorageStandard OEM:COA
    1298 = "N4PR4-9WYHD-J3GJ2-28RYQ-JTT8D" # WinServer Next ServerStorageStandard OEM:COA
    1307 = "83MRD-NQGP3-FJBJD-9X8TT-72V44" # WinServer Next ServerMultiPointStandard OEM:NONSLP
    1310 = "3CK7G-VRNKC-8QBFR-9G8HC-YKG8W" # WinServer Next ServerMultiPointStandard Volume:GVLK
    1313 = "N2MW6-VPYJ7-W9H3D-6GWJ2-6JBTC" # WinServer Next ServerMultiPointPremium OEM:NONSLP
    1316 = "GRMDJ-JNF7H-W9WTC-WKQRG-H8KW6" # WinServer Next ServerMultiPointPremium Volume:GVLK
    1318 = "BGT2Y-9NFW4-FRTJ6-7YQ7V-8HQJ8" # WinServerSolutions Next ServerSolution Retail
    1318 = "NGH86-TGPJY-J836V-RXQ8R-JHQJ8" # WinServerSolutions Next ServerSolution Retail
    1318 = "WNWGR-CJQHV-QDTKX-9TQJ6-68W2W" # WinServerSolutions Next ServerSolution Retail
    1319 = "NPTDJ-TDWGG-QQK2H-X83P9-FRCPX" # WinServerSolutions Next ServerSolution Retail:TB:Eval
    1319 = "WPN2V-T7CXK-XKK33-G7MW4-F6T89" # WinServerSolutions Next ServerSolution Retail:TB:Eval
    1320 = "792C8-N4TPB-JTPKW-BFT8W-J8BTM" # WinServerSolutions Next ServerSolution OEM:SLP
    1320 = "8QNHV-HJWXP-XP79V-G8Q87-T269B" # WinServerSolutions Next ServerSolution OEM:SLP
    1321 = "M7FP8-NKP48-B29K3-4YYWJ-XWW22" # WinServerSolutions Next ServerSolution OEM:NONSLP
    1321 = "NDHK4-38D89-FJHP7-G338J-D9G9C" # WinServerSolutions Next ServerSolution OEM:NONSLP
    1322 = "F692N-K7JD2-KTW3F-CV46P-RVQKD" # WinServerSolutions Next ServerSolution OEM:COA
    1322 = "NTHVR-CXRP6-RPHCC-JXW7W-KY9XD" # WinServerSolutions Next ServerSolution OEM:COA
    1323 = "2NJR4-TQ688-4X24Y-KRPQ7-8HQKF" # WinServerSolutions Next ServerSolution Volume:MAK
    1323 = "XPNYG-6MVR2-RYPPM-J6CKC-DC69F" # WinServerSolutions Next ServerSolution Volume:MAK
    1333 = "4JJNK-MPBT8-FW8FR-693WD-KKTDH" # WinServer Next ServerDatacenter Retail
    1333 = "4Y8N3-H7MMW-C76VJ-YD3XV-MBDKV" # WinServer Next ServerDatacenter Retail
    1333 = "6XBNX-4JQGW-QX6QG-74P76-72V67" # WinServer Next ServerDatacenter Retail
    1333 = "8RQCG-NRXBX-PJX2K-XGTH7-QM9XV" # WinServer Next ServerDatacenter Retail
    1333 = "PTKM3-DN93H-8WPY6-G7V7T-HFMT7" # WinServer Next ServerDatacenter Retail
    1334 = "NP93H-BJDMF-PQRVW-D7G8J-XWW3J" # WinServer Next ServerDatacenter Retail:TB:Eval
    1334 = "YJNWD-DQKWB-HBPMK-B6RDY-FF83J" # WinServer Next ServerDatacenter Retail:TB:Eval
    1335 = "3Y7R6-NFMM6-WW38M-DQJ2Y-KD3KX" # WinServer Next ServerDatacenter Volume:MAK
    1335 = "W6X2Q-NDHPF-F9PTD-496HM-8FCQK" # WinServer Next ServerDatacenter Volume:MAK
    1336 = "9PWPK-NWF68-K33W2-MVD4B-F877B" # WinServer Next ServerDatacenter Volume:GVLK
    1336 = "DJTP2-NR4TF-4J2G8-9CWD8-KY9XY" # WinServer Next ServerDatacenter Volume:GVLK
    1336 = "VRDD2-NVGDP-K7QG8-69BR4-TVFHB" # WinServer Next ServerDatacenter Volume:GVLK
    1341 = "9NBF6-WDTP2-7HH99-R9X3M-3GH7H" # WinServer Next ServerStandard Retail
    1341 = "DTYHP-NF3K3-FCBTF-HF4K6-CGT97" # WinServer Next ServerStandard Retail
    1341 = "MFY9F-XBN2F-TYFMP-CCV49-RMYVH" # WinServer Next ServerStandard Retail
    1341 = "QGNVK-7K3YK-QV24P-4XRMD-3M9X7" # WinServer Next ServerStandard Retail
    1342 = "HBRTJ-XDN4Q-FFV29-JH8GM-88BVJ" # WinServer Next ServerStandard Retail:TB:Eval
    1342 = "PG6ND-KQJY7-HQT2R-XP3DY-JK4HJ" # WinServer Next ServerStandard Retail:TB:Eval
    1343 = "T8RCT-KJNR2-WGPR4-HC3JX-66H7K" # WinServer Next ServerStandard Volume:GVLK
    1343 = "YNBF9-GPVTG-FFHQC-MJR4B-B4CQX" # WinServer Next ServerStandard Volume:GVLK
    1343 = "YT83R-NYG6V-QMHXV-Q6GDY-39G99" # WinServer Next ServerStandard Volume:GVLK
    1344 = "64Q9N-WR2KJ-8XXP6-HQGWP-YKHBB" # WinServer Next ServerStandard;ServerEnterprise Volume:MAK
    1344 = "Q9N3Y-9RMD7-7BF4J-TY7RG-XP7BB" # WinServer Next ServerStandard;ServerEnterprise Volume:MAK
    1345 = "3WN48-GVPXF-VHWK4-29Y8D-KKTD2" # ServerWeb, WinServer Next ServerWeb Retail
    1345 = "KN7PC-CJ492-TRM7Q-YY4R4-JHQMC" # ServerWeb, WinServer Next ServerWeb Retail
    1345 = "PCPHN-JH4DV-KW84V-JTWT3-VXHBC" # ServerWeb, WinServer Next ServerWeb Retail
    1346 = "7Y4KV-TNR3P-XRTY7-HVRRK-YDRHQ" # ServerWeb, WinServer Next ServerWeb Retail:TB:Eval
    1347 = "GJHFP-N4CCY-9MV9W-D4H6J-GVFHR" # ServerWeb, WinServer Next ServerWeb Volume:MAK
    1348 = "TRCKN-QV3YJ-HT7RW-JVQHD-627BG" # ServerWeb, WinServer Next ServerWeb Volume:GVLK
    1353 = "H4VC8-NC6CM-T3Y4C-CYJKM-RCV72" # Embedded, Cassini Platform 8 Pre-Beta Embedded Retail
    1368 = "2H7NK-3VJJY-HHY3Y-WM3T8-JFCRY" # Core, Win 8 RC Core Retail
    1368 = "CKP7K-WNDQ2-Q466C-TXGXY-MYYWM" # Core, Win 8 RC Core Retail
    1369 = "MQTN4-BDXR6-23B7J-J9XVP-CJ78P" # CoreN, Win 8 RC CoreN Retail
    1371 = "GCNRF-BHBCM-W9YWM-VWQP6-TJBWR" # Professional, Win 8 RC Professional Retail
    1371 = "NKJFK-GPHP7-G8C3J-P6JXR-HQRJR" # Professional, Win 8 RC Professional Retail
    1371 = "NTTX3-RV7VB-T7X7F-WQYYY-9Y92F" # Professional, Win 8 RC Professional Retail
    1371 = "TK8TP-9JN6P-7X7WW-RFFTV-B7QPF" # Professional, Win 8 RC Professional Retail
    1372 = "6N44J-D7VQ2-W4BFY-B4J2W-9TH8T" # ProfessionalN, Win 8 RC ProfessionalN Retail
    1373 = "JGN88-JG6P9-XWD9R-3VX46-9KTF7" # ProfessionalWMC, Win 8 RC ProfessionalWMC Retail
    1373 = "MBFBV-W3DP2-2MVKN-PJCQD-KKTF7" # ProfessionalWMC, Win 8 RC ProfessionalWMC Retail
    1374 = "NFV72-RG2HG-7FTTP-8FJTB-FF848" # CoreARM, Win 8 RC CoreARM Retail
    1375 = "CVWV3-RKNBX-3J7X3-H8PYK-DYDPK" # Enterprise, Win 8 RC Enterprise Retail
    1375 = "PBHCJ-Q2NYD-2PX34-T2TD6-233PK" # Enterprise, Win 8 RC Enterprise Retail
    1376 = "3NKKQ-B6BX6-TBPXM-779PC-4RCTB" # EnterpriseN, Win 8 RC EnterpriseN Retail
    1377 = "CDD92-JBN3V-X4YQJ-PDKCQ-TCJ6C" # CoreCountrySpecific, Win 8 RC CoreCountrySpecific Retail
    1378 = "JNMH9-BGBF6-RM6JP-DCRKM-2PJ6D" # CoreSingleLanguage, Win 8 RC CoreSingleLanguage Retail
    1381 = "YNB3T-VHW8P-72P6K-BQHCB-DM92V" # Professional;ProfessionalN;Enterprise;EnterpriseN, Win 8 RC Professional;ProfessionalN;Enterprise;EnterpriseN Volume:MAK
    1777 = "434N6-CFK68-X2WWF-2HTF7-3JXT2" # Win 8 RTM CoreN Retail
    1777 = "7HP28-FMBTG-DP64N-GYVBB-JK49P" # Win 8 RTM CoreN Retail
    1777 = "9CWN6-C77H4-TB4GX-FY9YB-JK49P" # Win 8 RTM CoreN Retail
    1777 = "9QRQK-G9DQH-D8N6D-KWPQ8-WB2KP" # Win 8 RTM CoreN Retail
    1777 = "C8H92-NGY2M-KD9QF-GFT4B-88CKP" # Win 8 RTM CoreN Retail
    1777 = "DRMVW-KXNTT-6V7DJ-DGKTK-3RPKP" # Win 8 RTM CoreN Retail
    1777 = "N2RKQ-JH9WX-TVDC8-JX866-8TV3C" # Win 8 RTM CoreN Retail
    1777 = "R4JDB-NVV8C-RHTB9-V8F8J-78MQC" # Win 8 RTM CoreN Retail
    1777 = "VDKYM-JNKJ7-DC4X9-BT3QR-JHRDC" # Win 8 RTM CoreN Retail
    1778 = "24VQY-G6NBH-4XRFG-8H3YP-RVRDD" # Win 8 RTM Core Retail
    1778 = "6JTN9-8VMYH-47MPR-6MQJH-WK49Q" # Win 8 RTM Core Retail
    1778 = "BBDDN-7C6DK-GVXYW-RWQ8F-R3G63" # Win 8 RTM Core Retail
    1778 = "BVTDY-N2CRP-V4CC7-TQ3D9-XKT63" # Win 8 RTM Core Retail
    1778 = "C4N9K-QB826-4BXFH-H43BY-6VF9Q" # Win 8 RTM Core Retail
    1778 = "C98N4-FJFMC-6CV2C-MYQ9M-RCWXQ" # Win 8 RTM Core Retail
    1778 = "FB4WR-32NVD-4RW79-XQFWH-CYQG3" # Win 8 RTM Core Retail
    1778 = "TMW34-C3QC6-R6MY8-NF66H-FJMQD" # Win 8 RTM Core Retail
    1778 = "XFMW4-4HH43-4PQFN-Q7F3F-MWMQD" # Win 8 RTM Core Retail
    1780 = "42QYB-NRYJC-QB3XH-66PGG-MKH3G" # Win 8 RTM ProfessionalN Retail
    1780 = "8N2BK-QQ6V3-RV6C4-KFR2M-8FDG6" # Win 8 RTM ProfessionalN Retail
    1780 = "96HND-PQY6Y-XD9P8-GYH4P-749T6" # Win 8 RTM ProfessionalN Retail
    1780 = "BHHD4-FKNK8-89X83-HTGM4-3C73G" # Win 8 RTM ProfessionalN Retail
    1780 = "FYK73-HNMTM-8JBFY-7G7B9-QV3G6" # Win 8 RTM ProfessionalN Retail
    1780 = "J8M24-BVNQ9-XH6KY-94H8H-MBFDG" # Win 8 RTM ProfessionalN Retail
    1780 = "JN4VG-67BW2-XF6HR-QRDKG-H8MQG" # Win 8 RTM ProfessionalN Retail
    1780 = "KMXPP-WNPX4-BTT82-8PQK6-CGV3G" # Win 8 RTM ProfessionalN Retail
    1780 = "NJP7G-HCF67-J3424-J7YRK-4JMQG" # Win 8 RTM ProfessionalN Retail
    1780 = "PRNVF-98463-HPYJC-CT8YX-4JMQG" # Win 8 RTM ProfessionalN Retail
    1780 = "PWHBN-XW97W-H444P-YMF3H-94PKT" # Win 8 RTM ProfessionalN Retail
    1780 = "VG7PG-T8V7G-YXPN8-9VWCB-3GJXT" # Win 8 RTM ProfessionalN Retail
    1780 = "XFKQN-Q99CV-3YBWG-GTQKX-6CKT6" # Win 8 RTM ProfessionalN Retail
    1780 = "XKC89-QGQD9-7HH2N-R6YFM-CWCKT" # Win 8 RTM ProfessionalN Retail
    1781 = "29G2J-HQ2QY-PXPVN-9V2KJ-7FPKV" # Win 8 RTM Professional Retail
    1781 = "BFBRW-FN924-6R4FF-9H82F-8B2KV" # Win 8 RTM Professional Retail
    1781 = "CBNRK-W3JXF-6GR2C-Q4V7Y-YWMQH" # Win 8 RTM Professional Retail
    1781 = "D2RJ2-GVNRD-Y2P9Y-P6PFB-QJXT7" # Win 8 RTM Professional Retail
    1781 = "GC4BF-RTNTP-4C2KQ-3BMCK-C7F9V" # Win 8 RTM Professional Retail
    1781 = "GH47G-3PC6X-4TTNH-GR38X-WTV3H" # Win 8 RTM Professional Retail
    1781 = "GNQRY-7228K-X9KDG-866JX-2YQG7" # Win 8 RTM Professional Retail
    1781 = "GQTMX-N8DRK-XQTV8-CH73Y-TXT67" # Win 8 RTM Professional Retail
    1781 = "GYJ98-3KFWC-NVPGM-K43WX-66JXV" # Win 8 RTM Professional Retail
    1781 = "JQFNF-JF2R3-PV7PH-3XJDP-8W8XV" # Win 8 RTM Professional Retail
    1781 = "NPQWY-4C33F-KMFKR-K6X9Y-R6V3H" # Win 8 RTM Professional Retail
    1781 = "PMPN6-QP967-XCFVK-RCPMV-GCKT7" # Win 8 RTM Professional Retail
    1781 = "PRX3B-NCFPP-79893-V3F2B-R6V3H" # Win 8 RTM Professional Retail
    1781 = "TBNYR-KTBHX-Y89Q2-H79HB-MY2KV" # Win 8 RTM Professional Retail
    1781 = "TNDCD-2CHXB-V3BQ3-38YGD-TCKT7" # Win 8 RTM Professional Retail
    1781 = "V2JN9-QHB86-QQ8K4-GHHG2-TMQG7" # Win 8 RTM Professional Retail
    1781 = "WYVVM-3NWVC-GFJ76-2YKQ4-QGJXV" # Win 8 RTM Professional Retail
    1781 = "XKY4K-2NRWR-8F6P2-448RF-CRYQH" # Win 8 RTM Professional Retail
    1781 = "XWCHQ-CDMYC-9WN2C-BWWTV-YY2KV" # Win 8 RTM Professional Retail
    1781 = "YXPWT-CYC49-NRFQ9-PGF36-WW8XV" # Win 8 RTM Professional Retail
    1782 = "P3DNP-JYJRP-B8MQR-HHXMR-CRYQJ" # Win 8 RTM ProfessionalWMC Retail
    1782 = "RR3BN-3YY9P-9D7FC-7J4YF-QGJXW" # Win 8 RTM ProfessionalWMC Retail
    1784 = "MJ8TN-42JH8-886MT-8THCF-3667B" # EnterpriseEval, Win 8 RTM EnterpriseEval Retail:TB:Eval
    1785 = "2NQCM-M68DQ-JQJY7-WPTDG-FVRDP" # Win 8 RTM Professional;ProfessionalN;Enterprise;EnterpriseN Volume:MAK
    1785 = "3GNDH-PX63H-77742-9PQY6-VCBQP" # Win 8 RTM Professional;ProfessionalN;Enterprise;EnterpriseN Volume:MAK
    1785 = "3QRP8-VQN6J-MQPBM-2KW3X-2YQHC" # Win 8 RTM Professional;ProfessionalN;Enterprise;EnterpriseN Volume:MAK
    1785 = "3WNQ9-X97BJ-337Y3-8BTM8-PJ8X2" # Win 8 RTM Professional;ProfessionalN;Enterprise;EnterpriseN Volume:MAK
    1785 = "9XT33-NW22T-4PKWK-HXHH4-6Q4DP" # Win 8 RTM Professional;ProfessionalN;Enterprise;EnterpriseN Volume:MAK
    1785 = "BFJNP-9WMDH-2M77K-RJ4WJ-XWXVC" # Win 8 RTM Professional;ProfessionalN;Enterprise;EnterpriseN Volume:MAK
    1785 = "CBNRF-QG7V6-QMJQ7-QPY43-G8XVC" # Win 8 RTM Professional;ProfessionalN;Enterprise;EnterpriseN Volume:MAK
    1785 = "CCN9F-HKKF8-X3PPY-HYJ9B-B4DHC" # Win 8 RTM Professional;ProfessionalN;Enterprise;EnterpriseN Volume:MAK
    1785 = "CJ29F-9MNQ9-RQ7DV-X42BY-WHRDP" # Win 8 RTM Professional;ProfessionalN;Enterprise;EnterpriseN Volume:MAK
    1785 = "CNDRJ-CDW8C-HXYC9-HFVDH-RF9VC" # Win 8 RTM Professional;ProfessionalN;Enterprise;EnterpriseN Volume:MAK
    1785 = "F4JTH-XYNTF-PFV7F-9HMQF-W8CK2" # Win 8 RTM Professional;ProfessionalN;Enterprise;EnterpriseN Volume:MAK
    1785 = "GQ3B9-8N6XQ-7JR3X-62TVP-6JCK2" # Win 8 RTM Professional;ProfessionalN;Enterprise;EnterpriseN Volume:MAK
    1785 = "JG6TJ-DNHYQ-3VKM2-MJFYK-XKT7C" # Win 8 RTM Professional;ProfessionalN;Enterprise;EnterpriseN Volume:MAK
    1785 = "JKN7Y-RHFVG-4P4KJ-RPX4M-6VF92" # Win 8 RTM Professional;ProfessionalN;Enterprise;EnterpriseN Volume:MAK
    1785 = "JQR2V-M7NMK-DXKXF-K7HW8-9TJX2" # Win 8 RTM Professional;ProfessionalN;Enterprise;EnterpriseN Volume:MAK
    1785 = "JTQFN-43VHP-3WD7F-66BGC-Q3R92" # Win 8 RTM Professional;ProfessionalN;Enterprise;EnterpriseN Volume:MAK
    1785 = "KV6KF-4XNXF-Q828W-69MGF-F6V3P" # Win 8 RTM Professional;ProfessionalN;Enterprise;EnterpriseN Volume:MAK
    1785 = "MCF4N-H48TK-J7K7H-2GC4C-RVRDP" # Win 8 RTM Professional;ProfessionalN;Enterprise;EnterpriseN Volume:MAK
    1785 = "MK4NP-XF7PW-VGHRW-3JXFK-P34DP" # Win 8 RTM Professional;ProfessionalN;Enterprise;EnterpriseN Volume:MAK
    1785 = "MRMBD-NTDHR-VFCWB-2Y2V8-29T7C" # Win 8 RTM Professional;ProfessionalN;Enterprise;EnterpriseN Volume:MAK
    1785 = "N7VDG-M6QFG-V2HGB-VX9G7-94PK2" # Win 8 RTM Professional;ProfessionalN;Enterprise;EnterpriseN Volume:MAK
    1785 = "N9R2X-H79VM-6KM2V-J6B4F-6Q4DP" # Win 8 RTM Professional;ProfessionalN;Enterprise;EnterpriseN Volume:MAK
    1785 = "NPHWT-89JKJ-WRPYW-FF8H8-DGJX2" # Win 8 RTM Professional;ProfessionalN;Enterprise;EnterpriseN Volume:MAK
    1785 = "NXVHB-YRRQJ-VJMR4-WWHQ4-84YQP" # Win 8 RTM Professional;ProfessionalN;Enterprise;EnterpriseN Volume:MAK
    1785 = "QHXV2-3FNM6-QKHDF-JFQTP-7CBQP" # Win 8 RTM Professional;ProfessionalN;Enterprise;EnterpriseN Volume:MAK
    1785 = "R4JXN-7WB4G-VT3BF-FFRJ6-WW8X2" # Win 8 RTM Professional;ProfessionalN;Enterprise;EnterpriseN Volume:MAK
    1785 = "VXQFY-7PN97-G6XBC-HKHBP-HH3HC" # Win 8 RTM Professional;ProfessionalN;Enterprise;EnterpriseN Volume:MAK
    1785 = "XJN3Y-JQCYF-Y9M9X-CPG2M-X4PK2" # Win 8 RTM Professional;ProfessionalN;Enterprise;EnterpriseN Volume:MAK
    1785 = "XT3N3-BXJT3-P87V9-FY7Q4-QGJX2" # Win 8 RTM Professional;ProfessionalN;Enterprise;EnterpriseN Volume:MAK
    1785 = "YPGT4-NTGWP-P44M2-4WMTH-JQG7C" # Win 8 RTM Professional;ProfessionalN;Enterprise;EnterpriseN Volume:MAK
    1786 = "XCVCF-2NXM9-723PB-MHCB7-2RYQQ" # ProfessionalN, Win 8 RTM ProfessionalN Volume:GVLK
    1787 = "NG4HW-VH26C-733KW-K6F98-J8CK4" # Professional, Win 8 RTM Professional Volume:GVLK
    1788 = "JMNMF-RHW7P-DMY6X-RF3DR-X2BQT" # EnterpriseN, Win 8 RTM EnterpriseN Volume:GVLK
    1789 = "32JNW-9KQ84-P47T8-D8GGY-CWCK7" # Enterprise, Win 8 RTM Enterprise Volume:GVLK
    1789 = "8M9BN-YB7W9-YV3VJ-7WMGG-MKH3V" # Enterprise, Win 8 RTM Enterprise Volume:GVLK
    1790 = "8QHNV-97MDX-WHCYG-9PC3P-YKH3W" # CoreN, Win 8 RTM CoreN OEM:DM
    1790 = "CWYYD-N7MDC-TG26D-FC4J2-9P73W" # CoreN, Win 8 RTM CoreN OEM:DM
    1790 = "MKWHN-783W8-GCGD4-9RTGW-W4YQW" # CoreN, Win 8 RTM CoreN OEM:DM
    1790 = "T3NBF-XCC34-9CJQM-Y483Y-JK498" # CoreN, Win 8 RTM CoreN OEM:DM
    1791 = "7QNT4-HJDDR-T672J-FBFP4-2J8X9" # CoreN, Win 8 RTM CoreN OEM:NONSLP
    1791 = "CRDQ7-NHGFY-3FFDW-D82KJ-DGJX9" # CoreN, Win 8 RTM CoreN OEM:NONSLP
    1791 = "F9V4Y-RTNXY-KCGYQ-YFXMD-XHF99" # CoreN, Win 8 RTM CoreN OEM:NONSLP
    1791 = "K29Y8-TNKWQ-PJYW3-M9CMC-CJ8X9" # CoreN, Win 8 RTM CoreN OEM:NONSLP
    1791 = "MNFVY-T9YWQ-Y9TRK-HRPMR-WFDHK" # CoreN, Win 8 RTM CoreN OEM:NONSLP
    1791 = "THX9X-YN6XW-3QJQ3-BXG4Q-Y4DHK" # CoreN, Win 8 RTM CoreN OEM:NONSLP
    1792 = "6R4WW-NTFXB-XR3FG-MMY3D-B96BB" # CoreCountrySpecific, Win 8 RTM CoreCountrySpecific OEM:DM
    1792 = "99VYV-6NJRH-K8XVQ-TMVFY-3GJYB" # CoreCountrySpecific, Win 8 RTM CoreCountrySpecific OEM:DM
    1792 = "HN6XF-6BYM9-WFJX6-QF448-BWMQY" # CoreCountrySpecific, Win 8 RTM CoreCountrySpecific OEM:DM
    1792 = "JDGN9-KW3GC-JVJ68-6K28J-33TBB" # CoreCountrySpecific, Win 8 RTM CoreCountrySpecific OEM:DM
    1792 = "KRCDN-4V4F2-T7JJH-DT77Y-YWMQY" # CoreCountrySpecific, Win 8 RTM CoreCountrySpecific OEM:DM
    1792 = "V2YWH-DFNBW-B8VGX-Y8M7M-BBFDY" # CoreCountrySpecific, Win 8 RTM CoreCountrySpecific OEM:DM
    1793 = "3VGNG-C8F9X-48V22-RYQ7Q-XHGBC" # Win 8 RTM CoreCountrySpecific OEM:NONSLP
    1793 = "4MYY3-NMPHY-R7KYH-7V4MY-K73HP" # Win 8 RTM CoreCountrySpecific OEM:NONSLP
    1793 = "8CCGP-NJK6W-WWHY4-322H3-JTV32" # Win 8 RTM CoreCountrySpecific OEM:NONSLP
    1793 = "94D3N-TKJGH-TRKMM-V3GGJ-GVGBC" # Win 8 RTM CoreCountrySpecific OEM:NONSLP
    1793 = "CY6W6-NJJCR-6J6W3-P679X-CDG7P" # Win 8 RTM CoreCountrySpecific OEM:NONSLP
    1793 = "N2FRB-RMFCM-38VFH-FCJPJ-4VRD2" # Win 8 RTM CoreCountrySpecific OEM:NONSLP
    1793 = "NB7F4-JVR66-9VG8Q-688XM-G2732" # Win 8 RTM CoreCountrySpecific OEM:NONSLP
    1794 = "24RGN-K2YXT-Y4QB2-4Y29V-94PMD" # CoreSingleLanguage, Win 8 RTM CoreSingleLanguage OEM:DM
    1794 = "FQ4VH-N9FJ3-VP7YY-GMYCV-8HRD3" # CoreSingleLanguage, Win 8 RTM CoreSingleLanguage OEM:DM
    1794 = "H96WY-N3JK9-X4GJ9-WR4BY-WHRD3" # CoreSingleLanguage, Win 8 RTM CoreSingleLanguage OEM:DM
    1794 = "R3C2N-HT63Q-F4RKH-KPP3R-3667Q" # CoreSingleLanguage, Win 8 RTM CoreSingleLanguage OEM:DM
    1794 = "RQF8V-8FN83-84KXJ-272BK-XKT7Q" # CoreSingleLanguage, Win 8 RTM CoreSingleLanguage OEM:DM
    1795 = "CGJ2M-N82GK-HC63T-8M6H8-HMFD4" # CoreSingleLanguage, Win 8 RTM CoreSingleLanguage OEM:NONSLP
    1795 = "DRNDY-7YPRG-JKYMX-73VFM-K73HR" # CoreSingleLanguage, Win 8 RTM CoreSingleLanguage OEM:NONSLP
    1795 = "K78MF-48NJG-DBY9D-TJRFK-4JMQ4" # CoreSingleLanguage, Win 8 RTM CoreSingleLanguage OEM:NONSLP
    1795 = "N69YV-VP9D7-773G4-H3J2G-QYFD4" # CoreSingleLanguage, Win 8 RTM CoreSingleLanguage OEM:NONSLP
    1795 = "NH7GX-2BPDT-FDPBD-WD893-RJMQ4" # CoreSingleLanguage, Win 8 RTM CoreSingleLanguage OEM:NONSLP
    1795 = "XVYN9-KF3JV-WKDFF-CP84G-72WYF" # CoreSingleLanguage, Win 8 RTM CoreSingleLanguage OEM:NONSLP
    1795 = "YR6G6-GNV6V-6FWXG-WPD6B-8FDHR" # CoreSingleLanguage, Win 8 RTM CoreSingleLanguage OEM:NONSLP
    1796 = "4BNHD-F8W3B-XBTW3-VQJXJ-DGJYG" # Win 8 RTM Core OEM:DM
    1796 = "DQQ2P-YNF4V-CMQHJ-RPXK8-QC736" # Win 8 RTM Core OEM:DM
    1796 = "MWYMN-WHPHB-JFWVW-GDDYQ-T6JYG" # Win 8 RTM Core OEM:DM
    1796 = "QNF6T-VM8KW-3MVJJ-FVYRJ-DGJYG" # Win 8 RTM Core OEM:DM
    1796 = "XDPYK-6N2TB-MG7TR-6JK6P-W2KVT" # Win 8 RTM Core OEM:DM
    1797 = "46V6N-VCBYR-KT9KT-6Y4YF-QGJYH" # Core, Win 8 RTM Core OEM:NONSLP
    1797 = "69HF2-NMFC6-2YVVB-MMFD4-F6V37" # Core, Win 8 RTM Core OEM:NONSLP
    1797 = "9JCNT-GYDY2-BYKCD-YMBWH-MBFD7" # Core, Win 8 RTM Core OEM:NONSLP
    1797 = "BB2P3-NCX67-HK8K3-3DBC3-FM2MH" # Core, Win 8 RTM Core OEM:NONSLP
    1797 = "NGW6G-Y9974-VCFJF-FVQDV-XD4D7" # Core, Win 8 RTM Core OEM:NONSLP
    1797 = "PCGPN-BJQCC-2FTK9-JR2W2-GQ4D7" # Core, Win 8 RTM Core OEM:NONSLP
    1797 = "YMYJ3-H9N6J-RQP7T-MJRB8-78MQ7" # Core, Win 8 RTM Core OEM:NONSLP
    1798 = "2DQ8Q-RYNR3-XGHV9-KMRRX-9HGBJ" # ProfessionalN, Win 8 RTM ProfessionalN OEM:DM
    1798 = "N7HY3-YHFHM-P6F86-M98CR-KBQHW" # ProfessionalN, Win 8 RTM ProfessionalN OEM:DM
    1798 = "NKT66-W2HP9-C9MTR-4XBB3-9D4D8" # ProfessionalN, Win 8 RTM ProfessionalN OEM:DM
    1798 = "TQ6KJ-Y7N8V-R4X6F-D8XCG-GMQHW" # ProfessionalN, Win 8 RTM ProfessionalN OEM:DM
    1799 = "4NX4X-C98R3-KBR22-MGBWC-D667X" # ProfessionalN, Win 8 RTM ProfessionalN OEM:NONSLP
    1799 = "84WDN-68HGY-GR3K3-Q3BJY-FF9VX" # ProfessionalN, Win 8 RTM ProfessionalN OEM:NONSLP
    1799 = "CF67M-ND92C-4VXWV-KD23F-MWMQ9" # ProfessionalN, Win 8 RTM ProfessionalN OEM:NONSLP
    1799 = "NRJ9D-WBF33-B2QYF-RQ22Q-TCKVX" # ProfessionalN, Win 8 RTM ProfessionalN OEM:NONSLP
    1799 = "T39RN-Q96TM-RR2TD-4JRB8-78MQ9" # ProfessionalN, Win 8 RTM ProfessionalN OEM:NONSLP
    1799 = "YP9TN-QYMKH-C83Y3-78YR3-MDTBK" # ProfessionalN, Win 8 RTM ProfessionalN OEM:NONSLP
    1801 = "6MYNW-JX38H-H7QHC-CK6G9-CDG72" # Win 8 RTM Professional OEM:DM
    1801 = "6YFVN-64X8P-J9WHQ-HBGG4-W8CMP" # Win 8 RTM Professional OEM:DM
    1801 = "DR38Q-GTNFD-WR3TR-VBXBV-QPBRC" # Win 8 RTM Professional OEM:DM
    1801 = "FJT8C-2WNKT-DKPQG-JYHXD-YBFFC" # Win 8 RTM Professional OEM:DM
    1801 = "KCXCB-FJNHT-W4FDW-D97VR-KBQH2" # Win 8 RTM Professional OEM:DM
    1801 = "Q4NYJ-3KM62-KYGK2-W63WK-9HGBP" # Win 8 RTM Professional OEM:DM
    1801 = "VW6N8-3HTBY-PP2KC-8RRGJ-CPKV2" # Win 8 RTM Professional OEM:DM
    1802 = "8BDBM-NPMHQ-VMFCV-78G68-TQ4FD" # Professional, Win 8 RTM Professional OEM:NONSLP
    1802 = "9T74N-982RM-RJH96-YMP4J-29T73" # Professional, Win 8 RTM Professional OEM:NONSLP
    1802 = "BXTN6-MCRYY-D4PGF-JMQC3-YBFFD" # Professional, Win 8 RTM Professional OEM:NONSLP
    1802 = "CNG2C-8PT9T-QCMRQ-32MTD-3PBRD" # Professional, Win 8 RTM Professional OEM:NONSLP
    1802 = "NDFC9-CWPQ3-HK47B-PTD9D-YBFFD" # Professional, Win 8 RTM Professional OEM:NONSLP
    1802 = "NTQ46-3JK8G-V23M8-6MWHY-QJXV3" # Professional, Win 8 RTM Professional OEM:NONSLP
    1802 = "P2X2R-2VN23-4KFJX-MWW8G-VCBRD" # Professional, Win 8 RTM Professional OEM:NONSLP
    1802 = "V7C3N-3W6CM-PDKR2-KW8DQ-RJMRD" # Professional, Win 8 RTM Professional OEM:NONSLP
    1805 = "F4DTG-PNFQW-WWWGY-CQ43T-V49V7" # APPXLOB-Client, Win 8 RTM APPXLOB-Client Volume:MAK
    1807 = "8PC8Q-TQ8CN-6RXHD-Q99TC-Q3TBX" # Win 8 RTM ProfessionalN Retail
    1807 = "BT436-V6DRH-NFTK7-26Y6V-B7RFK" # Win 8 RTM ProfessionalN Retail
    1807 = "HBKJH-KBHND-W9X47-2WQ3J-33TBX" # Win 8 RTM ProfessionalN Retail
    1807 = "Q7V6W-M2Y44-NJ33K-244XY-7MFFK" # Win 8 RTM ProfessionalN Retail
    1808 = "C22TP-JGM4N-FRY46-B4PP7-KHGBY" # Win 8 RTM Professional Retail
    1809 = "8JYH4-6KC2H-RN84B-B3GTM-B4DJC" # Win 8 RTM ProfessionalWMC Retail
    1809 = "BPBPC-BTKNG-24XW8-734K2-FX6B2" # Win 8 RTM ProfessionalWMC Retail
    1809 = "G67KP-DVJX6-QT86G-N7863-488Y2" # Win 8 RTM ProfessionalWMC Retail
    1809 = "MBQW7-4MRXJ-N7MCJ-4BJP4-Q9H4P" # Win 8 RTM ProfessionalWMC Retail
    1809 = "RKWGR-VTD8J-XYNY9-RWVYX-YDTB2" # Win 8 RTM ProfessionalWMC Retail
    1810 = "6XQX6-9CNW6-FX443-66JWP-BR9WD" # Win 8 RTM ProfessionalWMC Retail
    1810 = "CHPQX-VD3NT-67W83-QWPJR-FCWY3" # Win 8 RTM ProfessionalWMC Retail
    1810 = "RXQWC-D7K86-NPWD6-C74MF-KBQJD" # Win 8 RTM ProfessionalWMC Retail
    1812 = "NDQGD-9X68R-RRFYH-8GB8W-82KWG" # ServerMultiPointStandard, MultiPoint Server 2012 RTM ServerMultiPointStandard OEM:SLP
    1814 = "HM7DN-YVMH3-46JC3-XYTG7-CYQJJ" # ServerMultiPointStandard, MultiPoint Server 2012 RTM ServerMultiPointStandard Volume:GVLK
    1815 = "32TNQ-HMFWQ-8R933-X6VYY-WHRFX" # ServerMultiPointStandard, MultiPoint Server 2012 RTM ServerMultiPointStandard Retail
    1815 = "N2D92-MG7YF-Y88TC-2R846-V49WK" # ServerMultiPointStandard, MultiPoint Server 2012 RTM ServerMultiPointStandard Retail
    1817 = "VNM7D-2DPGK-9QHWW-7HK27-KHGCC" # ServerMultiPointStandard, MultiPoint Server 2012 RTM ServerMultiPointStandard Volume:MAK
    1818 = "RTDKG-7K8HQ-3QVVW-W8NKF-Q9H43" # ServerMultiPointPremium, MultiPoint Server 2012 RTM ServerMultiPointPremium OEM:SLP
    1818 = "VNKYM-JBKJ7-DC4X9-BT3QR-JHRF3" # ServerMultiPointPremium, MultiPoint Server 2012 RTM ServerMultiPointPremium OEM:SLP
    1820 = "XNH6W-2V9GX-RGJ4K-Y8X6F-QGJ2G" # ServerMultiPointPremium, MultiPoint Server 2012 RTM ServerMultiPointPremium Volume:GVLK
    1821 = "CBR2N-2HG39-2TGGT-GQB27-46V47" # ServerMultiPointPremium, MultiPoint Server 2012 RTM ServerMultiPointPremium Retail
    1821 = "K3YWR-NG788-M462K-M7MWF-7H3JV" # ServerMultiPointPremium, MultiPoint Server 2012 RTM ServerMultiPointPremium Retail
    1821 = "N6GYW-8VDC9-D28R9-8HYCG-9KT8V" # ServerMultiPointPremium, MultiPoint Server 2012 RTM ServerMultiPointPremium Retail
    1823 = "2J8PF-B2N2X-HVR27-9VFDH-CYQJX" # ServerMultiPointPremium, MultiPoint Server 2012 RTM ServerMultiPointPremium Volume:MAK
    1824 = "KXHGK-GRJQN-K7WVV-MTXP3-YBFGB" # ServerMultiPointStandard, MultiPoint Server 2012 RTM ServerMultiPointStandard OEM:SLP (MUI locked to zh-CN)
    1826 = "QXHGN-GRJQH-K7WVV-MTXP3-YBFGD" # ServerMultiPointPremium, MultiPoint Server 2012 RTM ServerMultiPointPremium OEM:SLP (MUI locked to zh-CN)
    1827 = "KN7FD-2WHWX-FMH2Y-43KXF-CRYTF" # ServerMultiPointPremium, MultiPoint Server 2012 RTM ServerMultiPointPremium OEM:NONSLP (MUI locked to zh-CN)
    1828 = "2CT2D-3JNPB-WJDP7-4JFH4-9WXW6" # ServerStorageStandard, Storage Server 2012 RTM ServerStorageStandard OEM:SLP
    1828 = "DXHGK-GRJQH-K7WVV-NTXP3-YBFGG" # ServerStorageStandard, Storage Server 2012 RTM ServerStorageStandard OEM:SLP
    1828 = "N67T9-R7KXM-CJKJB-BHGCW-CPKW6" # ServerStorageStandard, Storage Server 2012 RTM ServerStorageStandard OEM:SLP
    1830 = "RD9XF-6N3MC-2P2R3-MK2WX-C7GCW" # ServerStorageStandard, Storage Server 2012 RTM ServerStorageStandard Retail
    1833 = "CDNBD-9X68R-RRFYH-8G28W-82KXC" # ServerStorageWorkgroup, Storage Server 2012 RTM ServerStorageWorkgroup OEM:SLP
    1833 = "QNF7Y-QYYF3-FTQ76-WTWPV-JQG9C" # ServerStorageWorkgroup, Storage Server 2012 RTM ServerStorageWorkgroup OEM:SLP
    1835 = "NYGPD-KK4W6-QC3XH-HX4P4-2J824" # ServerStorageWorkgroup, Storage Server 2012 RTM ServerStorageWorkgroup Retail
    1838 = "CN74W-QCXGQ-YTH26-Q8WWT-CGV6W" # ServerStandard, Windows Server 2012 RTM ServerStandard Retail
    1838 = "VN93G-8PVT3-W2X3H-F3X87-FJMTW" # ServerStandard, Windows Server 2012 RTM ServerStandard Retail
    1840 = "4BNJM-QFX2Y-GW6TT-2WDPD-6276Y" # ServerStandard, Windows Server 2012 RTM ServerStandard OEM:SLP
    1840 = "P6M2J-7NY4W-JTR2C-VB874-K4PQB" # ServerStandard, Windows Server 2012 RTM ServerStandard OEM:SLP
    1840 = "VDNYM-JBKJ7-DC4X9-BT3QR-JHRGY" # ServerStandard, Windows Server 2012 RTM ServerStandard OEM:SLP
    1841 = "CPPXR-NPKCM-Y4K32-P93DX-WTV62" # ServerStandard, Windows Server 2012 RTM ServerStandard OEM:NONSLP
    1842 = "CMBBN-J9VY8-W48GV-P69M8-JFDKQ" # ServerStandard, Windows Server 2012 RTM ServerStandard Volume:MAK
    1842 = "MKXRT-27NB2-3W3VP-23D9B-B4DKQ" # ServerStandard, Windows Server 2012 RTM ServerStandard Volume:MAK
    1843 = "KM7FD-2WNWX-FMH2Y-43KXF-CRYT4" # ServerStandard, Windows Server 2012 RTM ServerStandard Volume:GVLK
    1843 = "XC9B7-NBPP2-83J2H-RHMBY-92BT4" # ServerStandard, Windows Server 2012 RTM ServerStandard Volume:GVLK
    1845 = "2BVGY-TNRWK-6927W-866R9-66J3H" # ServerDatacenter, Windows Server 2012 RTM ServerDatacenter OEM:SLP
    1845 = "B7RRX-RVN4P-PCPBM-89D8Y-X4PQH" # ServerDatacenter, Windows Server 2012 RTM ServerDatacenter OEM:SLP
    1845 = "N67Y4-R7KXM-CJKJB-BHGCW-CPKXV" # ServerDatacenter, Windows Server 2012 RTM ServerDatacenter OEM:SLP
    1846 = "RNRTP-RBMK6-JVGX9-GTGQR-FCW3J" # ServerDatacenter, Windows Server 2012 RTM ServerDatacenter OEM:NONSLP
    1847 = "2GMNX-8K7D2-X968C-7P62F-8B2QK" # ServerDatacenter, Windows Server 2012 RTM ServerDatacenter Retail
    1847 = "V82WN-CG864-BGW2P-YJGW7-X73KX" # ServerDatacenter, Windows Server 2012 RTM ServerDatacenter Retail
    1848 = "PCCDY-NCHKF-GD23R-FVW2B-R6V7B" # ServerDatacenter, Windows Server 2012 RTM ServerDatacenter Volume:MAK
    1849 = "48HP8-DN98B-MYWDG-T2DCC-8W83P" # ServerDatacenter, Windows Server 2012 RTM ServerDatacenter Volume:GVLK
    1850 = "2GDTN-RWTYX-TDK7V-4Q6K3-G8XX3" # ServerWinFoundation, Windows Server 2012 RTM ServerWinFoundation OEM:SLP
    1850 = "3BWNY-T7M4F-KMJDV-VMHG4-R3G93" # ServerWinFoundation, Windows Server 2012 RTM ServerWinFoundation OEM:SLP
    1850 = "8MBNB-YB7W9-YV3VJ-7WMGG-MKH7D" # ServerWinFoundation, Windows Server 2012 RTM ServerWinFoundation OEM:SLP
    1850 = "96764-R7KXM-CJKJB-BNGCW-CPKX3" # ServerWinFoundation, Windows Server 2012 RTM ServerWinFoundation OEM:SLP
    1850 = "RTMNG-7K8HQ-3QVVW-W8QKF-Q9H7D" # ServerWinFoundation, Windows Server 2012 RTM ServerWinFoundation OEM:SLP
    1851 = "D2FNQ-TDHT7-K32GB-2GMVM-TXT94" # ServerWinFoundation, Windows Server 2012 RTM ServerWinFoundation OEM:NONSLP
    1852 = "PN24B-X6THG-274MF-YHM9G-H8MVG" # ServerWinFoundation, Windows Server 2012 RTM ServerWinFoundation Retail
    1854 = "2G9DG-XKFR6-VG8D3-DN9T9-CDG98" # ServerStandard, Windows Server 2012 RTM ServerStandard OEM:SLP (MUI locked to zh-CN)
    1854 = "BNHD9-KT7MY-4BX83-HTGM4-3C77J" # ServerStandard, Windows Server 2012 RTM ServerStandard OEM:SLP (MUI locked to zh-CN)
    1856 = "BDCBV-BQ27P-9PNJJ-BQJ96-KTJ3Y" # ServerWinFoundation, Windows Server 2012 RTM ServerWinFoundation OEM:SLP (MUI locked to zh-CN)
    1856 = "VXHGK-GRJQH-K7WVN-MTXP3-YBFHM" # ServerWinFoundation, Windows Server 2012 RTM ServerWinFoundation OEM:SLP (MUI locked to zh-CN)
    1860 = "JXHGK-GRJQH-N7WVV-MTXP3-YBFHT" # ServerSolution, Windows Server Essentials 2012 RTM ServerSolution OEM:SLP
    1860 = "MXHGN-GRJQH-K7WVV-MTXP3-YBFHT" # ServerSolution, Windows Server Essentials 2012 RTM ServerSolution OEM:SLP
    1861 = "CRDBN-CG29Q-T8F6H-72YP6-PDHBH" # ServerSolution, Windows Server Essentials 2012 RTM ServerSolution OEM:NONSLP
    1862 = "4N2KH-M2B2G-KY47X-XBGWT-V49YJ" # ServerSolution, Windows Server Essentials 2012 RTM ServerSolution Retail
    1863 = "JK4BD-THNKK-FTHVY-YBDY9-Y7RHX" # ServerSolution, Windows Server Essentials 2012 RTM ServerSolution Volume:MAK
    1863 = "VDF73-NP4G3-BKTDP-KR7P9-T8XYK" # ServerSolution, Windows Server Essentials 2012 RTM ServerSolution Volume:MAK
    1864 = "HHRHF-YMNJW-RPGCC-VV68W-BWMVY" # ServerSolution, Windows Server Essentials 2012 RTM ServerSolution Retail:TB:Eval
    1865 = "3R2HN-VRWDD-J6CRQ-JRM22-W2KYP" # CoreARM, Win 8 RTM CoreARM OEM:DM
    1865 = "8X3NC-R2TDK-Q6WXC-M9TKY-MY2RC" # CoreARM, Win 8 RTM CoreARM OEM:DM
    1865 = "PBNWQ-QJB43-68H4X-R7B6J-2GV72" # CoreARM, Win 8 RTM CoreARM OEM:DM
    1866 = "MRPNR-JMHVH-DJYWH-TV7BT-72W4D" # Embedded, Windows Embedded Standard 8 RC Embedded Retail:TB:Eval
    1867 = "6Q7P9-NFD2F-7JGQR-3X277-9BQMR" # Embedded, Windows Embedded Standard 8 RC Embedded Retail
    1873 = "W3B2Q-MN6MQ-BCYF3-VGDWF-3C78C" # Embedded, Windows Embedded Standard 8 RC Embedded Retail:TB:Eval
    1875 = "4GMNG-VFM4J-88839-4F4JV-3JXY4" # Embedded, Windows Embedded Standard 8 RC Embedded Retail
    1876 = "9N28G-7WY7K-RMMD4-9J4BY-WHRJG" # EmbeddedA, Windows Embedded Standard 8 RC EmbeddedA Retail:TB:Eval
    1884 = "JBYN8-BT6X6-4XB2G-P33V4-K4PR6" # EmbeddedE, Windows Embedded Standard 8 RC EmbeddedE Retail:TB:Eval
    1885 = "29QNM-D667Q-9Q86B-Q93MQ-4F92H" # EmbeddedE, Windows Embedded Standard 8 RC EmbeddedE Retail
    1889 = "9T6RK-NWJ9B-Q7HT4-H6CFC-DC782" # CoreN, Win 8 RC CoreN Volume:GVLK
    1890 = "NDTWC-J28B6-RTR3C-CPRHW-2GV83" # CoreCountrySpecific, Win 8 RC CoreCountrySpecific Volume:GVLK
    1891 = "WRR6N-3JB78-MB9TD-WQW7K-WTV84" # CoreSingleLanguage, Win 8 RC CoreSingleLanguage Volume:GVLK
    1892 = "MPWP3-DXNP9-BRD79-W8WFP-3YFJ6" # Core, Win 8 RC Core Volume:GVLK
    1893 = "MY4N9-TGH34-4X4VY-8FG2T-RRDPV" # ProfessionalWMC, Win 8 RC ProfessionalWMC Volume:GVLK
    1899 = "3D47B-3N3K9-YR887-B6F73-JTV9F" # ServerStorageStandardEval, Windows Server 2012 RC ServerStorageStandardEval Retail:TB:Eval
    1900 = "DKRJV-NFHWK-27PM8-Y72WM-3GJ6T" # ServerStorageWorkgroupEval, Windows Server 2012 RC ServerStorageWorkgroupEval Retail:TB:Eval
    1901 = "K4H27-NB9DX-93BYG-K7QQK-GJCTV" # CoreARM, Win 8 RC CoreARM Volume:GVLK
    1904 = "8N2M2-HWPGY-7PGT9-HGDD8-GVGGY" # CoreN, Win 8 RTM CoreN Volume:GVLK
    1905 = "4K36P-JN4VD-GDC6V-KDT89-DYFKP" # CoreCountrySpecific, Win 8 RTM CoreCountrySpecific Volume:GVLK
    1906 = "2WN2H-YGCQR-KFX6K-CD6TF-84YXQ" # CoreSingleLanguage, Win 8 RTM CoreSingleLanguage Volume:GVLK
    1907 = "BN3D2-R7TKB-3YPBD-8DRP2-27GG4" # Core, Win 8 RTM Core Volume:GVLK
    1908 = "GNBB8-YVD74-QJHX6-27H4K-8QHDG" # ProfessionalWMC, Win 8 RTM ProfessionalWMC Volume:GVLK
    1908 = "NQ3PX-BBY8Y-RRHMM-TBHFW-PJ866" # ProfessionalWMC, Win 8 RTM ProfessionalWMC Volume:GVLK
    1909 = "DXHJF-N9KQX-MFPVR-GHGQK-Y7RKV" # CoreARM, Win 8 RTM CoreARM Volume:GVLK
    1911 = "XYNVP-TW798-F8893-7B89K-8QHDK" # Win 8 RTM CoreCountrySpecific Retail
    1912 = "XBRND-QDJTG-CQJDB-7DRBW-RX6HB" # Win 8 RTM CoreSingleLanguage Retail
    1913 = "32X2X-4CN6X-3JVJT-FR6VD-973QP" # CoreSingleLanguage, Win 8 RTM CoreSingleLanguage OEM:DM
    1913 = "J83JM-NHK27-JMWGK-3RWRB-88CVC" # CoreSingleLanguage, Win 8 RTM CoreSingleLanguage OEM:DM
    1913 = "MP8HH-3RNF8-8VCCH-DFQ8P-4RDQP" # CoreSingleLanguage, Win 8 RTM CoreSingleLanguage OEM:DM
    1914 = "GTNG9-VX9HD-F694X-YFJW9-H493Q" # Win 8 RTM Core OEM:DM
    1914 = "JCKHY-NKYK4-36PGH-WJKGH-8HRK3" # Win 8 RTM Core OEM:DM
    1915 = "BYGG2-N278G-PTQ4D-P373B-G2794" # Win 8 RTM Professional OEM:DM
    1915 = "CX8M8-PN8P3-33999-YDV86-C9VDR" # Win 8 RTM Professional OEM:DM
    1915 = "J7TWN-BQBR4-46XGH-B9VV4-CRYX4" # Win 8 RTM Professional OEM:DM
    1915 = "KKFJD-NV6R9-3DT9Q-8J2RR-HQTHF" # Win 8 RTM Professional OEM:DM
    1915 = "PJNHC-V9GJT-FRHT9-B9V6J-9TJ7F" # Win 8 RTM Professional OEM:DM
    1915 = "PQ7J3-C4N4X-YP9V4-THJHM-BBFK4" # Win 8 RTM Professional OEM:DM
    1918 = "9VKDN-FDY34-HGK3H-TCC66-8TV98" # EmbeddedIndustryE, Windows Embedded Industry 8 TAP-CTP
    2263 = "96V7J-DN9T2-CVKXX-27VYJ-6MRB9" # Embedded, Windows Embedded Standard 8 RTM Embedded Retail:TB:Eval
    2264 = "NDDRT-KKVGM-D33R2-KR372-27G4Y" # Embedded, Windows Embedded Standard 8 RTM Embedded Retail:TB:Eval
    2265 = "TCX42-TJNM9-448DV-26H7M-39JWP" # Embedded, Windows Embedded Standard 8 RTM Embedded Retail:TB:Eval
    2270 = "FN943-6TMB7-K8QJM-3WCTB-JK648" # APPXLOB-Embedded, Windows Embedded Standard 8 RTM APPXLOB-Embedded Volume:MAK
    2273 = "WHN7Y-Y62DP-P4PPH-MTJ34-KBRCP" # Embedded, Windows Embedded Standard 8 RTM Embedded OEM:NONSLP
    2274 = "42NYC-2F6VF-T4M8V-DWCXT-FVR83" # Embedded, Windows Embedded Standard 8 RTM Embedded OEM:DM
    2276 = "HG2QW-PNJWQ-PHD6P-F4T8Q-RJPJ6" # Embedded, Windows Embedded Standard 8 RTM Embedded Retail
    2277 = "HTDQM-NBMMG-KGYDT-2DTKT-J2MPV" # ServerSolution, Windows Server Essentials 2012 RTM ServerSolution Volume:GVLK
    2281 = "N9VXB-H6WXT-HBMGX-K3WKJ-MTBP2" # ServerStandard, Windows vNext Test ServerStandard VT:IA
    2282 = "HKYFJ-MN6FF-FPTBG-WWTCT-68YP3" # ServerDatacenter, Windows vNext Test ServerDatacenter VT:IA
    2285 = "7XKNG-JD7W3-TKFJX-VFMVY-KD49H" # EmbeddedIndustry, Windows Embedded Industry 8 RTM EmbeddedIndustry Retail:TB:Eval
    2296 = "JVPDN-TBWJW-PD94V-QYKJ2-KWYQM" # EmbeddedIndustry, Windows Embedded Industry 8 RTM EmbeddedIndustry Volume:GVLK
    2296 = "RYXVT-BNQG7-VD29F-DBMRY-HT73M" # EmbeddedIndustry, Windows Embedded Industry 8 RTM EmbeddedIndustry Volume:GVLK
    2304 = "67MJY-NHRQF-BCPB3-6PGBT-XP8YB" # APPXLOB-Embedded, Windows Embedded Industry 8 RTM APPXLOB-Embedded Volume:MAK
    2305 = "NKB3R-R2F8T-3XCDP-7Q2KW-XWYQ2" # EmbeddedIndustryE, Windows Embedded Industry 8 RTM EmbeddedIndustryE Volume:GVLK
    2316 = "2VN9R-T2TFP-2HPVG-D43WQ-C36BT" # ServerCloudStorage, ServerCloudStorage Next Beta ServerCloudStorage OEM:SLP
    2317 = "2FKXD-NHTPX-DC8CF-4HGCG-QYGBV" # ServerCloudStorage, ServerCloudStorage Next Beta ServerCloudStorage OEM:NONSLP
    2500 = "3K92D-PNKHR-WTFHP-27JXM-K74Q6" # EmbeddedIndustryEval, Windows Embedded Industry Next Beta EmbeddedIndustryEval Retail:TB:Eval
    2501 = "7CNDP-3R3J2-VM48R-Y4DW8-6MRQ7" # EmbeddedIndustry, Windows Embedded Industry Next Beta EmbeddedIndustry OEM:NONSLP
    2502 = "4NMRQ-YGR3G-TCV68-T6B27-9BRQ8" # EmbeddedIndustry, Windows Embedded Industry Next Beta EmbeddedIndustry OEM:DM
    2503 = "Q7DK8-HYNWH-GR42J-P9WHQ-H2X7X" # EmbeddedIndustry, Windows Embedded Industry Next Beta EmbeddedIndustry Volume:GVLK
    2503 = "XY4TQ-CXNVJ-YCT73-HH6R7-R897X" # EmbeddedIndustry, Windows Embedded Industry Next Beta EmbeddedIndustry Volume:GVLK
    2504 = "GNB4Q-WDMV8-BP6WG-D9J7F-PPM4B" # EmbeddedIndustry, Windows Embedded Industry Next Beta EmbeddedIndustry Volume:MAK
    2505 = "4TDK2-N89GW-CCCV7-633QX-RM3V2" # EmbeddedIndustryEEval, Windows Embedded Industry Next Beta EmbeddedIndustryEEval Retail:TB:Eval
    2507 = "23N3K-29JDQ-JBQHC-48TKF-2J974" # EmbeddedIndustryE, Windows Embedded Industry Next Beta EmbeddedIndustryE OEM:NONSLP
    2508 = "WN3XP-M9YFD-JRJ84-4J9FB-QJY4G" # EmbeddedIndustryE, Windows Embedded Industry Next Beta EmbeddedIndustryE Volume:GVLK
    2508 = "XCNC9-BPK3C-KCCMD-FTDTC-KWY4G" # EmbeddedIndustryE, Windows Embedded Industry Next Beta EmbeddedIndustryE Volume:GVLK
    2509 = "7NRDD-QYXMG-XMDJT-8TYJ6-MKKBV" # EmbeddedIndustryE, Windows Embedded Industry Next Beta EmbeddedIndustryE Volume:MAK
    2511 = "NJJ9T-Q7C3Y-QGYG2-HMMX7-M4FRK" # EmbeddedIndustryA, Windows Embedded Industry Next Beta EmbeddedIndustryA OEM:NONSLP
    2512 = "4NC6W-TR8KB-R4YVK-MCKM7-WK7JB" # EmbeddedIndustryA, Windows Embedded Industry Next Beta EmbeddedIndustryA OEM:DM
    2513 = "434XB-NH62H-JG7RG-P3KMD-XHHJC" # EmbeddedIndustryA, Windows Embedded Industry Next Beta EmbeddedIndustryA Volume:GVLK
    2513 = "GN2X2-KXTK6-P92FR-VBB9G-PDJFP" # EmbeddedIndustryA, Windows Embedded Industry Next Beta EmbeddedIndustryA Volume:GVLK
    2514 = "42RNK-VX3D6-WD7Y8-MWV97-R898D" # EmbeddedIndustryA, Windows Embedded Industry Next Beta EmbeddedIndustryA Volume:MAK
    2515 = "HXFNP-8HYQ3-4FMC3-2DHJ9-M97JF" # ServerStandard, Windows Server Next Beta ServerStandard VT:IA
    2516 = "XVNRV-9HTX4-TH2JD-HVJQD-QRQWG" # ServerDatacenter, Windows Server Next Beta ServerDatacenter VT:IA
    2517 = "GYFHM-NDGDD-YFTWR-XPPT6-8TXB7" # ServerStandard, Windows Server Next Beta ServerStandard OEM:SLP
    2518 = "2FPB9-CRNYB-QQK3C-82PMX-4JPY8" # ServerDatacenter, Windows Server Next Beta ServerDatacenter OEM:SLP
    2518 = "CNK8H-Y6GFY-HCDPX-RVG2M-JK7JJ" # ServerDatacenter, Windows Server Next Beta ServerDatacenter OEM:SLP
    2519 = "7VW9N-8C48X-J6442-J3KM6-FVTM9" # ServerSolution, Windows Server Essentials Next Beta ServerSolution VT:IA
    2520 = "27M8F-M2NGD-4H7D6-BJW2X-DYGPB" # ServerStandard, Windows Server 12 R2 RTM ServerStandard Retail
    2520 = "6FRN8-B7KJD-DC9YW-HCCBT-XP9CB" # ServerStandard, Windows Server 12 R2 RTM ServerStandard Retail
    2520 = "74PBX-DNVWB-TF4B6-7DM8D-9D6PB" # ServerStandard, Windows Server 12 R2 RTM ServerStandard Retail
    2520 = "7BNT2-BY3VJ-3TBDW-TKB92-P9WFY" # ServerStandard, Windows Server 12 R2 RTM ServerStandard Retail
    2520 = "7FN7G-6HKK8-PP38Q-8Q6CG-9KWFY" # ServerStandard, Windows Server 12 R2 RTM ServerStandard Retail
    2520 = "7NTCF-CXMKK-6MKFP-RBCKW-TQ6PB" # ServerStandard, Windows Server 12 R2 RTM ServerStandard Retail
    2520 = "7PVN9-64K2F-M64B6-WBG3H-WK7JM" # ServerStandard, Windows Server 12 R2 RTM ServerStandard Retail
    2520 = "7T2RN-VMJ9V-MBGC2-PJFQB-CWDWM" # ServerStandard, Windows Server 12 R2 RTM ServerStandard Retail
    2520 = "CXXXC-QCN23-K2RRQ-CFPFP-TMRRY" # ServerStandard, Windows Server 12 R2 RTM ServerStandard Retail
    2520 = "N3JX3-KYCDJ-T4M3Y-3TWDY-8FFRY" # ServerStandard, Windows Server 12 R2 RTM ServerStandard Retail
    2520 = "N6F7X-BFXB3-VF7HH-VH7W8-WB3WM" # ServerStandard, Windows Server 12 R2 RTM ServerStandard Retail
    2520 = "NB4WH-BBBYV-3MPPC-9RCMV-46XCB" # ServerStandard, Windows Server 12 R2 RTM ServerStandard Retail
    2520 = "NRJ3T-RC2GB-6XQWD-8BB2B-7MGPB" # ServerStandard, Windows Server 12 R2 RTM ServerStandard Retail
    2520 = "Q3K83-G2NRH-PR328-M7CPT-236PB" # ServerStandard, Windows Server 12 R2 RTM ServerStandard Retail
    2520 = "WM7JT-7NBVH-2Y7R9-KQBJ6-RRFRY" # ServerStandard, Windows Server 12 R2 RTM ServerStandard Retail
    2520 = "YDC6G-RNGYV-JP82W-WMT3P-VFQWM" # ServerStandard, Windows Server 12 R2 RTM ServerStandard Retail
    2521 = "CG9N3-WKB9P-FMQG6-J3D8C-TMRR2" # ServerStandardEval, Windows Server 12 R2 RTM ServerStandardEval Retail:TB:Eval
    2522 = "2FND4-FCR66-RK9Q3-F82H3-4GB43" # ServerStandard, Windows Server 12 R2 RTM ServerStandard OEM:SLP
    2522 = "3BG82-9KN3X-HXXT3-TTJP2-RVTPD" # ServerStandard, Windows Server 12 R2 RTM ServerStandard OEM:SLP
    2522 = "Q23MN-G8YFT-7W6M2-DPYX2-J422D" # ServerStandard, Windows Server 12 R2 RTM ServerStandard OEM:SLP
    2522 = "XWVH8-NHGHR-RBMCY-QMY7J-BWP2D" # ServerStandard, Windows Server 12 R2 RTM ServerStandard OEM:SLP
    2523 = "QNM3H-8XYHQ-VFTTG-77DD8-GVHJR" # ServerStandard, Windows Server 12 R2 RTM ServerStandard OEM:SLP (MUI locked to zh-CN)
    2523 = "XJ43W-2NQXX-9KT9P-4QDTH-T29CF" # ServerStandard, Windows Server 12 R2 RTM ServerStandard OEM:SLP (MUI locked to zh-CN)
    2524 = "CG9N8-9MKPB-87MGK-MT3YQ-YBGPG" # ServerStandard, Windows Server 12 R2 RTM ServerStandard OEM:NONSLP
    2524 = "G3WN4-Q67MJ-297FT-R4X3K-GJDWT" # ServerStandard, Windows Server 12 R2 RTM ServerStandard OEM:NONSLP
    2524 = "G3WN4-Q67MJ-297FT-R4X3K-GJDWT" # ServerStandard, Windows Server 12 R2 RTM ServerStandard OEM:NONSLP    
    2524 = "HXGNC-BGV6B-G2D93-2BPTD-DV4R6" # ServerStandard, Windows Server 12 R2 RTM ServerStandard OEM:NONSLP
    2524 = "KCWGM-GNGWH-V68YX-VJBV7-B7TPG" # ServerStandard, Windows Server 12 R2 RTM ServerStandard OEM:NONSLP
    2524 = "WYBRW-4NJJ9-G2GKJ-96XPC-8W98T" # ServerStandard, Windows Server 12 R2 RTM ServerStandard OEM:NONSLP
    2525 = "6NH4C-4GJT7-7FB7B-2GJWB-2PM47" # ServerStandard, Windows Server 12 R2 RTM ServerStandard OEM:NONSLP (MUI locked to zh-CN)
    2525 = "XGRNT-JXGG3-YHKV7-8YTDC-XTK8V" # ServerStandard, Windows Server 12 R2 RTM ServerStandard OEM:NONSLP (MUI locked to zh-CN)
    2525 = "Y33QK-N7TDF-8KKCH-W7MXQ-9D6PH" # ServerStandard, Windows Server 12 R2 RTM ServerStandard OEM:NONSLP (MUI locked to zh-CN)
    2526 = "4WN6D-RT7JY-VQDJ4-YTWR6-CGXCJ" # ServerStandard, Windows Server 12 R2 RTM ServerStandard Volume:MAK
    2526 = "7XBW3-NDM6Q-VQDHB-VYBM9-CDJF8" # ServerStandard, Windows Server 12 R2 RTM ServerStandard Volume:MAK
    2526 = "8BCNH-3HXD2-THBQ4-F6QYB-FGB48" # ServerStandard, Windows Server 12 R2 RTM ServerStandard Volume:MAK
    2526 = "9W2CK-WNW2B-2VC64-CDT4X-CDJF8" # ServerStandard, Windows Server 12 R2 RTM ServerStandard Volume:MAK
    2526 = "C3RN8-CYYXH-3JCBV-FB6C9-T8Y48" # ServerStandard, Windows Server 12 R2 RTM ServerStandard Volume:MAK
    2526 = "HGQ2F-NFHFQ-BKJ4F-DKP9H-YY3WW" # ServerStandard, Windows Server 12 R2 RTM ServerStandard Volume:MAK
    2526 = "HQN24-873X7-PWDJ4-3Y6YB-X4QWW" # ServerStandard, Windows Server 12 R2 RTM ServerStandard Volume:MAK
    2526 = "KBP8N-QC246-HC72K-TYYCP-6JDWW" # ServerStandard, Windows Server 12 R2 RTM ServerStandard Volume:MAK
    2526 = "KNVKM-GY4KG-FG7MQ-VJTC2-HH4R8" # ServerStandard, Windows Server 12 R2 RTM ServerStandard Volume:MAK
    2526 = "MN8M2-Y8CKY-GHHTC-9XYT2-XTK8W" # ServerStandard, Windows Server 12 R2 RTM ServerStandard Volume:MAK
    2526 = "MPXBC-B9N2H-VV8RF-YMDQD-9D6PJ" # ServerStandard, Windows Server 12 R2 RTM ServerStandard Volume:MAK
    2526 = "N4CM4-V7WVF-BB26H-QHBYP-DC9CJ" # ServerStandard, Windows Server 12 R2 RTM ServerStandard Volume:MAK
    2526 = "N7H93-3PGW8-C64QC-YQRK9-WTXCJ" # ServerStandard, Windows Server 12 R2 RTM ServerStandard Volume:MAK
    2526 = "N7WGH-BGRB9-YB7XD-RCHXX-QV4R8" # ServerStandard, Windows Server 12 R2 RTM ServerStandard Volume:MAK
    2526 = "NW4VF-DWT3M-CKH6T-9JDHY-YWP2J" # ServerStandard, Windows Server 12 R2 RTM ServerStandard Volume:MAK
    2526 = "YB7B7-7N82C-M9B7G-QXPJ2-V8P2J" # ServerStandard, Windows Server 12 R2 RTM ServerStandard Volume:MAK
    2527 = "D2N9P-3P6X9-2R39C-7RTCD-MDVJX" # ServerStandard, Windows Server 12 R2 RTM ServerStandard Volume:GVLK
    2527 = "MGFQN-2DP2B-DV6H4-VH2YR-Q9KCK" # ServerStandard, Windows Server 12 R2 RTM ServerStandard Volume:GVLK
    2528 = "2NFBX-J6H6Q-XYT2Q-4YDRY-7MGPM" # ServerDatacenter, Windows Server 12 R2 RTM ServerDatacenter Retail
    2528 = "2NFBX-J6H6Q-XYT2Q-4YDRY-7MGPM" # ServerDatacenter, Windows Server 12 R2 RTM ServerDatacenter Retail    
    2528 = "BH9T4-4N7CW-67J3M-64J36-WW98Y" # ServerDatacenter, Windows Server 12 R2 RTM ServerDatacenter Retail
    2528 = "CNGV3-G29JH-MMT6Y-9DDXW-D9KCM" # ServerDatacenter, Windows Server 12 R2 RTM ServerDatacenter Retail
    2528 = "DCMPN-7DW4T-G782T-2GMVW-2GXCM" # ServerDatacenter, Windows Server 12 R2 RTM ServerDatacenter Retail
    2528 = "MKN3W-WVPXT-WRKGW-6PHBG-WW98Y" # ServerDatacenter, Windows Server 12 R2 RTM ServerDatacenter Retail
    2528 = "N7J3B-3W8C4-VKJB4-2B2YB-8FFTB" # ServerDatacenter, Windows Server 12 R2 RTM ServerDatacenter Retail
    2528 = "NMFMT-R39FQ-RTQ7F-WV3YG-MKKCM" # ServerDatacenter, Windows Server 12 R2 RTM ServerDatacenter Retail
    2528 = "NRQ8V-HKJP6-W9VKG-B3GR4-TVHJY" # ServerDatacenter, Windows Server 12 R2 RTM ServerDatacenter Retail
    2528 = "QXGNQ-HDQKG-7M7F2-HJJJX-2YRTB" # ServerDatacenter, Windows Server 12 R2 RTM ServerDatacenter Retail
    2528 = "V32YN-P73GQ-HGPYV-CV9JD-KKWGB" # ServerDatacenter, Windows Server 12 R2 RTM ServerDatacenter Retail
    2529 = "VVWKN-DRYGT-GBG6F-YQ79J-29WGC" # ServerDatacenterEval, Windows Server 12 R2 RTM ServerDatacenterEval Retail:TB:Eval
    2530 = "2N9T6-Y284D-T68G9-QGV6X-FRFTD" # ServerDatacenter, Windows Server 12 R2 RTM ServerDatacenter OEM:SLP
    2530 = "3RNXG-QDPCH-T6M7Y-R6GBG-C9WGD" # ServerDatacenter, Windows Server 12 R2 RTM ServerDatacenter OEM:SLP
    2530 = "8GGNP-JJVFP-CYFG9-QJQ4M-G29CQ" # ServerDatacenter, Windows Server 12 R2 RTM ServerDatacenter OEM:SLP
    2530 = "G26XT-NRXQY-6XGTK-KTW8B-RCX83" # ServerDatacenter, Windows Server 12 R2 RTM ServerDatacenter OEM:SLP
    2530 = "J4MNY-F8B7F-CQ68B-BJRHT-WW983" # ServerDatacenter, Windows Server 12 R2 RTM ServerDatacenter OEM:SLP
    2530 = "NPVCG-TVVPF-2V7PD-QR4MX-T8Y6D" # ServerDatacenter, Windows Server 12 R2 RTM ServerDatacenter OEM:SLP
    2530 = "XN7YB-9K8J8-8RD73-HDYKV-MBGPQ" # ServerDatacenter, Windows Server 12 R2 RTM ServerDatacenter OEM:SLP
    2531 = "4TTRN-P42G7-8F7TP-9WCYH-FJP2R" # ServerDatacenter, Windows Server 12 R2 RTM ServerDatacenter OEM:SLP (MUI locked to zh-CN)
    2531 = "NCXWX-TGFRV-83KV6-RFWBM-B4FTF" # ServerDatacenter, Windows Server 12 R2 RTM ServerDatacenter OEM:SLP (MUI locked to zh-CN)
    2532 = "2BF6X-KKNMX-96TCX-J4R6G-RRFTG" # ServerDatacenter, Windows Server 12 R2 RTM ServerDatacenter OEM:NONSLP
    2532 = "9N6HD-XM9QQ-6WXKY-XR2BR-9WY6G" # ServerDatacenter, Windows Server 12 R2 RTM ServerDatacenter OEM:NONSLP
    2532 = "JTN89-MGY46-QXBG4-RF6WG-P7HJ6" # ServerDatacenter, Windows Server 12 R2 RTM ServerDatacenter OEM:NONSLP
    2532 = "WHD68-XKNFP-PHXY9-3YP49-2YRTG" # ServerDatacenter, Windows Server 12 R2 RTM ServerDatacenter OEM:NONSLP
    2532 = "XTQKF-JNBM7-BK8TR-R66WD-KKWGG" # ServerDatacenter, Windows Server 12 R2 RTM ServerDatacenter OEM:NONSLP
    2532 = "YFM48-TNC92-7FXWQ-7RRRC-MPX86" # ServerDatacenter, Windows Server 12 R2 RTM ServerDatacenter OEM:NONSLP
    2532 = "YN99C-3RVXB-QBRGH-8FVYQ-PYRTG" # ServerDatacenter, Windows Server 12 R2 RTM ServerDatacenter OEM:NONSLP
    2533 = "G3MC3-N8Q7M-MKRQP-6R4TM-88DW7" # ServerDatacenter, Windows Server 12 R2 RTM ServerDatacenter OEM:NONSLP (MUI locked to zh-CN)
    2533 = "QN6KV-9HWTJ-T4398-BJQCC-8W987" # ServerDatacenter, Windows Server 12 R2 RTM ServerDatacenter OEM:NONSLP (MUI locked to zh-CN)
    2534 = "2FDNP-MRGCV-CRR8B-JDVJY-TXWGJ" # ServerDatacenter, Windows Server 12 R2 RTM ServerDatacenter Volume:MAK
    2534 = "48MCB-8N4YT-TDCV8-9GT38-GVHJ8" # ServerDatacenter, Windows Server 12 R2 RTM ServerDatacenter Volume:MAK
    2534 = "4F2VH-NMY88-QK7VD-Q2943-974TJ" # ServerDatacenter, Windows Server 12 R2 RTM ServerDatacenter Volume:MAK
    2534 = "4J62P-N6GJ7-68BXC-VD878-MTB6J" # ServerDatacenter, Windows Server 12 R2 RTM ServerDatacenter Volume:MAK
    2534 = "7MNQT-F39B3-J86VD-8KW7P-2DJGJ" # ServerDatacenter, Windows Server 12 R2 RTM ServerDatacenter Volume:MAK
    2534 = "7W4PJ-NGGQF-6BMKC-2HYBJ-Q68GJ" # ServerDatacenter, Windows Server 12 R2 RTM ServerDatacenter Volume:MAK
    2534 = "9VVDM-N2DW8-6FMVB-YQV4Y-MY3W8" # ServerDatacenter, Windows Server 12 R2 RTM ServerDatacenter Volume:MAK
    2534 = "BKR49-4FN7G-H9FXM-X97XD-4GB6J" # ServerDatacenter, Windows Server 12 R2 RTM ServerDatacenter Volume:MAK
    2534 = "FH77K-QN8JR-CGCXR-Q734M-G29CW" # ServerDatacenter, Windows Server 12 R2 RTM ServerDatacenter Volume:MAK
    2534 = "FV87V-4XNBT-JKRFX-2RRM8-33VJ8" # ServerDatacenter, Windows Server 12 R2 RTM ServerDatacenter Volume:MAK
    2534 = "KNBRD-WMK9M-WW4KM-XJ2K9-C7HJ8" # ServerDatacenter, Windows Server 12 R2 RTM ServerDatacenter Volume:MAK
    2534 = "KYG89-GXNDY-8Q7MX-XBVY6-8TXCW" # ServerDatacenter, Windows Server 12 R2 RTM ServerDatacenter Volume:MAK
    2534 = "MGHD9-N4JDW-X9GTT-MR6RM-92C2W" # ServerDatacenter, Windows Server 12 R2 RTM ServerDatacenter Volume:MAK
    2534 = "MNYJF-HBKXB-KHKK4-RYWVC-VFQW8" # ServerDatacenter, Windows Server 12 R2 RTM ServerDatacenter Volume:MAK
    2534 = "NQMCW-6BF7D-7R63X-T4CMC-GQ6PW" # ServerDatacenter, Windows Server 12 R2 RTM ServerDatacenter Volume:MAK
    2534 = "NVF2J-96XM2-TPPXB-TK3RW-33VJ8" # ServerDatacenter, Windows Server 12 R2 RTM ServerDatacenter Volume:MAK
    2534 = "NXQ32-6JP86-8K8JF-XXMWW-BWP2W" # ServerDatacenter, Windows Server 12 R2 RTM ServerDatacenter Volume:MAK
    2534 = "QN4BW-KTFX3-9QK4V-B84JY-BBGPW" # ServerDatacenter, Windows Server 12 R2 RTM ServerDatacenter Volume:MAK
    2534 = "QRYJN-MWWG2-RBVYT-QYQ3J-78P2W" # ServerDatacenter, Windows Server 12 R2 RTM ServerDatacenter Volume:MAK
    2534 = "QTD8P-HVNGH-FYWJB-6RFDT-9KWGJ" # ServerDatacenter, Windows Server 12 R2 RTM ServerDatacenter Volume:MAK
    2534 = "QTMMY-6N763-H4DQ2-PK7G8-PJ988" # ServerDatacenter, Windows Server 12 R2 RTM ServerDatacenter Volume:MAK
    2534 = "R9WHB-PKNG6-V9KH7-MJCTG-HFQW8" # ServerDatacenter, Windows Server 12 R2 RTM ServerDatacenter Volume:MAK
    2534 = "RXC98-NV48Y-PTRT2-6JTTW-RX7J8" # ServerDatacenter, Windows Server 12 R2 RTM ServerDatacenter Volume:MAK
    2534 = "TN3G3-YV9GP-VV8Y9-TT9BB-8FFTJ" # ServerDatacenter, Windows Server 12 R2 RTM ServerDatacenter Volume:MAK
    2534 = "VG7NH-2DRF8-2DJDK-DBDVX-H6B6J" # ServerDatacenter, Windows Server 12 R2 RTM ServerDatacenter Volume:MAK
    2534 = "W4R6N-72GH2-JHDPR-T83TD-DV4TJ" # ServerDatacenter, Windows Server 12 R2 RTM ServerDatacenter Volume:MAK
    2534 = "XKXN9-G8VMM-B727K-JQ8GG-236PW" # ServerDatacenter, Windows Server 12 R2 RTM ServerDatacenter Volume:MAK
    2534 = "Y62VN-H7YJB-RDPVY-BQG3X-66K88" # ServerDatacenter, Windows Server 12 R2 RTM ServerDatacenter Volume:MAK
    2535 = "4XN2G-KDTJX-DYGXT-9Q8CV-JQJGK" # ServerDatacenter, Windows Server 12 R2 RTM ServerDatacenter Volume:GVLK
    2535 = "8NK82-6VX8B-26782-4H7M9-KP9CX" # ServerDatacenter, Windows Server 12 R2 RTM ServerDatacenter Volume:GVLK
    2535 = "W3GGN-FT8W3-Y4M27-J84CP-Q3VJ9" # ServerDatacenter, Windows Server 12 R2 RTM ServerDatacenter Volume:GVLK
    2536 = "37N7F-BQBXY-R66QV-G343D-9D6PY" # ServerWinFoundation, Windows Server 12 R2 RTM ServerWinFoundation OEM:SLP
    2536 = "MQ6N8-WKJGD-8BKFW-JPTQP-4RFTM" # ServerWinFoundation, Windows Server 12 R2 RTM ServerWinFoundation OEM:SLP
    2537 = "7FRFG-NPKGM-YVMPW-TDGJQ-974TP" # ServerWinFoundation, Windows Server 12 R2 RTM ServerWinFoundation OEM:SLP (MUI locked to zh-CN)
    2537 = "FR29P-DJNFH-M7HT9-JPQK6-GMRTP" # ServerWinFoundation, Windows Server 12 R2 RTM ServerWinFoundation OEM:SLP (MUI locked to zh-CN)
    2538 = "FW989-NXFT3-R8698-4C4MF-4X7KD" # ServerWinFoundation, Windows Server 12 R2 RTM ServerWinFoundation OEM:NONSLP
    2538 = "MRYNY-QKTRR-KHMFF-92XW9-DYGP3" # ServerWinFoundation, Windows Server 12 R2 RTM ServerWinFoundation OEM:NONSLP
    2538 = "N6P7P-3WQMQ-82JFJ-Q8HMY-92C23" # ServerWinFoundation, Windows Server 12 R2 RTM ServerWinFoundation OEM:NONSLP
    2539 = "939H8-N4FM8-G8KDG-484HJ-J8DXF" # ServerWinFoundation, Windows Server 12 R2 RTM ServerWinFoundation OEM:NONSLP (MUI locked to zh-CN)
    2539 = "QTKQV-NF2XY-X6CQ6-PGBWP-YKKC4" # ServerWinFoundation, Windows Server 12 R2 RTM ServerWinFoundation OEM:NONSLP (MUI locked to zh-CN)
    2539 = "Y6NJ2-2X9QC-69YBT-7PHQG-4M3XF" # ServerWinFoundation, Windows Server 12 R2 RTM ServerWinFoundation OEM:NONSLP (MUI locked to zh-CN)
    2540 = "3N4R6-CWT8R-K94FC-Q4RRP-3YGP6" # ServerWinFoundation, Windows Server 12 R2 RTM ServerWinFoundation Retail
    2540 = "7JGXN-BW8X3-DTJCK-WG7XB-YWP26" # ServerWinFoundation, Windows Server 12 R2 RTM ServerWinFoundation Retail
    2540 = "CT8M3-NVPPJ-4HBXB-82WX3-629C6" # ServerWinFoundation, Windows Server 12 R2 RTM ServerWinFoundation Retail
    2540 = "NB7Q7-W4RH7-BY4RT-7H2P4-K4QXG" # ServerWinFoundation, Windows Server 12 R2 RTM ServerWinFoundation Retail
    2540 = "VFNBQ-RGVMJ-9RY7K-47TGC-CJ99G" # ServerWinFoundation, Windows Server 12 R2 RTM ServerWinFoundation Retail
    2540 = "WHK8R-27NQT-HQYJ6-GVHDR-PPM6T" # ServerWinFoundation, Windows Server 12 R2 RTM ServerWinFoundation Retail
    2540 = "YGG36-NQK86-FPDWD-G86B8-JFFTT" # ServerWinFoundation, Windows Server 12 R2 RTM ServerWinFoundation Retail
    2541 = "DBGBW-NPF86-BJVTX-K3WKJ-MTB6V" # ServerStandard, Windows Server 12 R2 RTM ServerStandard VT:IA
    2541 = "DBKRN-WXVG7-GXBG9-MCPH6-TJDXH" # ServerStandard, Windows Server 12 R2 RTM ServerStandard VT:IA
    2542 = "NFBMK-2PGPF-CJFB3-9H38F-MWP28" # ServerDatacenter, Windows Server 12 R2 RTM ServerDatacenter VT:IA
    2542 = "NV62G-YCDJV-7YR8Y-MVC8W-82M6W" # ServerDatacenter, Windows Server 12 R2 RTM ServerDatacenter VT:IA
    2542 = "Y4TGP-NPTV9-HTC2H-7MGQ3-DV4TW" # ServerDatacenter, Windows Server 12 R2 RTM ServerDatacenter VT:IA
    2543 = "BFBN8-X8K7C-347CH-JG6KC-W2M6X" # ServerCloudStorage, ServerCloudStorage 12 R2 RTM ServerCloudStorage Retail
    2543 = "FDG7N-JMWVW-9XMVW-4W9RD-JTXC9" # ServerCloudStorage, ServerCloudStorage 12 R2 RTM ServerCloudStorage Retail
    2544 = "82P6N-DVK24-BPRKR-WRKTH-X74TY" # ServerCloudStorage, ServerCloudStorage 12 R2 RTM ServerCloudStorage OEM:SLP
    2544 = "H2JQG-N4JWY-R3RC3-THRYM-YWP3B" # ServerCloudStorage, ServerCloudStorage 12 R2 RTM ServerCloudStorage OEM:SLP
    2545 = "49HHW-FNXGR-3PY3C-Y68GB-PR23C" # ServerCloudStorage, ServerCloudStorage 12 R2 RTM ServerCloudStorage OEM:NONSLP
    2545 = "B3T82-NCJ3D-V7XCT-9FD7W-6MRT2" # ServerCloudStorage, ServerCloudStorage 12 R2 RTM ServerCloudStorage OEM:NONSLP
    2546 = "3NPTF-33KPT-GGBPR-YX76B-39KDD" # ServerCloudStorage, ServerCloudStorage 12 R2 RTM ServerCloudStorage Volume:GVLK
    2546 = "XM9XH-6NB8H-C6XT2-QC9V9-4JP3D" # ServerCloudStorage, ServerCloudStorage 12 R2 RTM ServerCloudStorage Volume:GVLK
    2570 = "2DND8-VMDWJ-9KTH7-2RK24-WFFV3" # ServerStorageStandard, Storage Server 2012 R2 RTM ServerStorageStandard OEM:SLP
    2570 = "2MNJB-4TKDY-M68W6-DQXTF-BY3YQ" # ServerStorageStandard, Storage Server 2012 R2 RTM ServerStorageStandard OEM:SLP
    2570 = "6CBNV-3FFJG-MY83V-VGTPR-VMGRD" # ServerStorageStandard, Storage Server 2012 R2 RTM ServerStorageStandard OEM:SLP
    2570 = "F9277-N79MJ-Y7T2D-F32Y2-XTMBQ" # ServerStorageStandard, Storage Server 2012 R2 RTM ServerStorageStandard OEM:SLP
    2571 = "JKF9D-NWM2W-9GB3W-YPRVM-BBGRF" # ServerStorageStandard, Storage Server 2012 R2 RTM ServerStorageStandard OEM:NONSLP
    2571 = "RCYY8-N6QF8-D3MYB-PYQYQ-T6MBR" # ServerStorageStandard, Storage Server 2012 R2 RTM ServerStorageStandard OEM:NONSLP
    2572 = "BB9DV-NG9QW-9YTHF-CQ3CH-M4FV6" # ServerStorageStandard, Storage Server 2012 R2 RTM ServerStorageStandard Retail
    2572 = "H2K4M-QNKQ2-64699-FYQHD-2WDYT" # ServerStorageStandard, Storage Server 2012 R2 RTM ServerStorageStandard Retail
    2572 = "JJR4N-MX8R8-FRBYJ-8CMXQ-49BBT" # ServerStorageStandard, Storage Server 2012 R2 RTM ServerStorageStandard Retail
    2572 = "KCXQ8-Q4N7W-8WD88-DFTGY-2PM76" # ServerStorageStandard, Storage Server 2012 R2 RTM ServerStorageStandard Retail
    2572 = "VNCWX-WTG96-K6KBM-BC887-PWDYT" # ServerStorageStandard, Storage Server 2012 R2 RTM ServerStorageStandard Retail
    2573 = "27FBJ-8NMFM-PK3H8-4D7B4-HQVMV" # ServerStorageStandardEval, Storage Server 2012 R2 RTM ServerStorageStandardEval Retail:TB:Eval
    2574 = "NDBQF-2F4M6-WG6VH-HPGK6-V6B78" # ServerStorageWorkgroupEval, Storage Server 2012 R2 RTM ServerStorageWorkgroupEval Retail:TB:Eval
    2575 = "FG8MJ-MXN9Q-QH9RV-9X44V-WK7MX" # ServerStorageWorkgroup, Storage Server 2012 R2 RTM ServerStorageWorkgroup OEM:SLP
    2575 = "GYX3B-N7R6G-3W2WC-Q284C-27HMX" # ServerStorageWorkgroup, Storage Server 2012 R2 RTM ServerStorageWorkgroup OEM:SLP
    2576 = "P2TMB-2YNC6-2GDYK-YHRF8-VH4WB" # ServerStorageWorkgroup, Storage Server 2012 R2 RTM ServerStorageWorkgroup OEM:NONSLP
    2576 = "TT63N-8R3K7-3MPBV-YFRV6-XP9FM" # ServerStorageWorkgroup, Storage Server 2012 R2 RTM ServerStorageWorkgroup OEM:NONSLP
    2577 = "29N6K-PCPFC-Y3F9J-HJYCF-PPM8C" # ServerStorageWorkgroup, Storage Server 2012 R2 RTM ServerStorageWorkgroup Retail
    2577 = "2HBPX-CNW29-228HH-2QDFQ-Y4FWC" # ServerStorageWorkgroup, Storage Server 2012 R2 RTM ServerStorageWorkgroup Retail
    2577 = "8N7PM-D3C64-RQVYF-MX8T7-G6MB2" # ServerStorageWorkgroup, Storage Server 2012 R2 RTM ServerStorageWorkgroup Retail
    2577 = "BK46P-NF693-C2GYC-X7G8W-VH4WC" # ServerStorageWorkgroup, Storage Server 2012 R2 RTM ServerStorageWorkgroup Retail
    2577 = "JFB4H-N32FM-KGYMM-XBCD3-XHHM2" # ServerStorageWorkgroup, Storage Server 2012 R2 RTM ServerStorageWorkgroup Retail
    2577 = "NCQH4-QFRPB-GPRYD-M3DFM-RCYB2" # ServerStorageWorkgroup, Storage Server 2012 R2 RTM ServerStorageWorkgroup Retail
    2578 = "2DKDG-V4NWC-XYW9F-8CYRY-3GMB3" # ServerSolution, Windows Server Essentials 2012 R2 RTM ServerSolution OEM:SLP
    2578 = "FNKYT-4B4GK-YVWMX-6PCWT-9KWJD" # ServerSolution, Windows Server Essentials 2012 R2 RTM ServerSolution OEM:SLP
    2578 = "NTFD9-FC3BR-V4XMR-G4RGQ-T6MB3" # ServerSolution, Windows Server Essentials 2012 R2 RTM ServerSolution OEM:SLP
    2579 = "BXJ63-NH4KR-GM82F-C37PH-R9BB4" # ServerSolution, Windows Server Essentials 2012 R2 RTM ServerSolution OEM:SLP (MUI locked to zh-CN)
    2580 = "NQ34G-9DQF3-VYDDT-XQCCD-WQJJG" # ServerSolution, Windows Server Essentials 2012 R2 RTM ServerSolution OEM:NONSLP
    2580 = "WNHDP-VPKBB-BQF7P-4K728-DGMB6" # ServerSolution, Windows Server Essentials 2012 R2 RTM ServerSolution OEM:NONSLP
    2580 = "XW82H-N7PKG-M4KH7-JM28T-Y97M6" # ServerSolution, Windows Server Essentials 2012 R2 RTM ServerSolution OEM:NONSLP
    2581 = "9JNTD-B3VXT-H8JPM-G6QMJ-WB3Y7" # ServerSolution, Windows Server Essentials 2012 R2 RTM ServerSolution OEM:NONSLP (MUI locked to zh-CN)
    2582 = "326N4-6GMBX-PD2QT-M7HX4-TVHM8" # ServerSolution, Windows Server Essentials 2012 R2 RTM ServerSolution Retail
    2582 = "6G7KB-NXYQT-6MHTT-PHCC7-VT8JJ" # ServerSolution, Windows Server Essentials 2012 R2 RTM ServerSolution Retail
    2582 = "8N8CF-3672K-J3DDK-M3FVY-QJY8J" # ServerSolution, Windows Server Essentials 2012 R2 RTM ServerSolution Retail
    2582 = "DYD8N-C83PF-B3MMY-PP7WP-4RFWJ" # ServerSolution, Windows Server Essentials 2012 R2 RTM ServerSolution Retail
    2582 = "FDN4P-K3X44-6MRDB-9FPV8-HMGRW" # ServerSolution, Windows Server Essentials 2012 R2 RTM ServerSolution Retail
    2582 = "GTK2N-C37WQ-XWK6G-7D78P-VFQY8" # ServerSolution, Windows Server Essentials 2012 R2 RTM ServerSolution Retail
    2582 = "JGNHG-978F8-HV8JK-9M88Q-629FW" # ServerSolution, Windows Server Essentials 2012 R2 RTM ServerSolution Retail
    2582 = "KNFX7-XP8R8-KP7MF-4QX2M-X4QY8" # ServerSolution, Windows Server Essentials 2012 R2 RTM ServerSolution Retail
    2582 = "RH8WN-B9WW8-VWQ8B-CKPF8-BWP4W" # ServerSolution, Windows Server Essentials 2012 R2 RTM ServerSolution Retail
    2582 = "XYVNP-XHKY3-3CKVF-WPPMF-F6XFW" # ServerSolution, Windows Server Essentials 2012 R2 RTM ServerSolution Retail
    2583 = "4YV7N-D4CK4-74PKH-3WB7W-K2C4X" # ServerSolution, Windows Server Essentials 2012 R2 RTM ServerSolution Volume:MAK
    2583 = "DNM7K-YPGB4-KD88X-V2F3T-KTMB9" # ServerSolution, Windows Server Essentials 2012 R2 RTM ServerSolution Volume:MAK
    2583 = "J2JGN-FPG86-DTKCP-TK469-KP9FX" # ServerSolution, Windows Server Essentials 2012 R2 RTM ServerSolution Volume:MAK
    2583 = "VDW8N-MRT6J-G4HRY-JC3CK-HCC4X" # ServerSolution, Windows Server Essentials 2012 R2 RTM ServerSolution Volume:MAK
    2583 = "WQMND-QHMQD-QKDDF-DCQJ3-3PC4X" # ServerSolution, Windows Server Essentials 2012 R2 RTM ServerSolution Volume:MAK
    2583 = "X2T83-N7BTT-KDXR7-PGPGG-MKKFX" # ServerSolution, Windows Server Essentials 2012 R2 RTM ServerSolution Volume:MAK
    2584 = "DGNRX-VV6CG-R4FDC-QJ9Q2-6JD2B" # ServerSolution, Windows Server Essentials 2012 R2 RTM ServerSolution Volume:GVLK
    2584 = "KNC87-3J2TX-XB4WP-VCPJV-M4FWM" # ServerSolution, Windows Server Essentials 2012 R2 RTM ServerSolution Volume:GVLK
    2585 = "K2XGM-NMBT3-2R6Q8-WF2FK-P36R2" # ServerSolution, Windows Server Essentials 2012 R2 RTM ServerSolution VT:IA
    2585 = "YKKMX-HN27X-MHCD8-3YMGX-YDVPC" # ServerSolution, Windows Server Essentials 2012 R2 RTM ServerSolution VT:IA
    2586 = "2QQBD-KNBY3-348P9-DTGG3-9D6R3" # Win 8.1 RTM Core OEM:DM
    2586 = "46N6Y-RXPT9-DFRPY-DWYTK-XKWJQ" # Win 8.1 RTM Core OEM:DM
    2586 = "7NG76-7YCJY-YRCHF-B8FWF-R3JJQ" # Win 8.1 RTM Core OEM:DM
    2586 = "7QJXN-XFH3J-XMXP2-Y8QVJ-F3JJQ" # Win 8.1 RTM Core OEM:DM
    2586 = "HKGPG-N8TDQ-P3FJX-YKXDF-R3JJQ" # Win 8.1 RTM Core OEM:DM
    2586 = "M77BP-NTPV6-JFRVC-MWWWX-RM32D" # Win 8.1 RTM Core OEM:DM
    2586 = "PGQNM-RYJBY-YRCW9-VDHFD-FM32D" # Win 8.1 RTM Core OEM:DM
    2586 = "Q37NV-YH8QQ-VTHM8-6VDRJ-MTB8Q" # Win 8.1 RTM Core OEM:DM
    2586 = "V329N-XV6F9-D9RJQ-R6T8D-B97PD" # Win 8.1 RTM Core OEM:DM
    2586 = "WC7TN-PDF9H-TPTT7-KG3PC-YKKF3" # Win 8.1 RTM Core OEM:DM
    2586 = "XPQPN-PHJ4H-WJP7V-CDDH7-46XF3" # Win 8.1 RTM Core OEM:DM
    2587 = "BGQGN-3TGWY-FTB8D-F9KY9-V2YCF" # Win 8.1 RTM Professional OEM:DM
    2587 = "C2NM4-CGMGY-GHDT6-GWYFF-9WY8R" # Win 8.1 RTM Professional OEM:DM
    2587 = "FFVM8-ND779-HXPXD-YCQDC-D68JR" # Win 8.1 RTM Professional OEM:DM
    2587 = "NFCYH-29WDW-6K8TC-F2GRM-92C44" # Win 8.1 RTM Professional OEM:DM
    2587 = "QWNGM-B4JFD-8F78W-9HXDW-J8D2F" # Win 8.1 RTM Professional OEM:DM
    2587 = "YJT2B-NTTY4-69DJ3-Y43BG-68Y8R" # Win 8.1 RTM Professional OEM:DM
    2588 = "2YRNV-XT7XM-8G9TY-THV4C-W2M8T" # Win 8.1 RTM ProfessionalN OEM:DM
    2588 = "9W7XQ-9NKJB-J632G-92224-CR246" # Win 8.1 RTM ProfessionalN OEM:DM
    2588 = "F264N-792YF-XDFPM-C4HPW-CPM8T" # Win 8.1 RTM ProfessionalN OEM:DM
    2588 = "MNKR8-XJDYR-6XPQD-3P8P2-RVTR6" # Win 8.1 RTM ProfessionalN OEM:DM
    2588 = "MPC9R-N4P8V-YG7T6-9K9R9-MG8JT" # Win 8.1 RTM ProfessionalN OEM:DM
    2588 = "NVM9T-2G9GQ-MY42X-RVHG6-J2M8T" # Win 8.1 RTM ProfessionalN OEM:DM
    2588 = "XWHJH-N7YQJ-PM73X-QCVRM-G29F6" # Win 8.1 RTM ProfessionalN OEM:DM
    2589 = "3FJN8-CHKQW-B43TQ-XRC4R-DJY8V" # Win 8.1 RTM Core OEM:NONSLP
    2589 = "7DBNF-29426-2JTDB-7MTJJ-33VPH" # Win 8.1 RTM Core OEM:NONSLP
    2589 = "8DW9N-X6644-QFD4C-8G9C4-CR247" # Win 8.1 RTM Core OEM:NONSLP
    2589 = "F6B26-CNQYX-VTP3V-4FHPY-F9BCH" # Win 8.1 RTM Core OEM:NONSLP
    2589 = "FJWTM-42NKR-9DPD2-8FR9Y-3GMCH" # Win 8.1 RTM Core OEM:NONSLP
    2589 = "HN9RH-3T984-CRHGV-KVTMF-BY32H" # Win 8.1 RTM Core OEM:NONSLP
    2589 = "NCX3D-QVJJT-WGFQC-WG2F8-F3JJV" # Win 8.1 RTM Core OEM:NONSLP
    2590 = "NK2V7-9DWXG-KMTWQ-K9H9M-6VHPJ" # CoreARM, Win 8.1 RTM CoreARM OEM:NONSLP
    2591 = "4JQVW-NMBCW-BXT4X-6T6C4-K4Q2K" # Win 8.1 RTM CoreCountrySpecific OEM:NONSLP
    2591 = "CJG9D-YN98M-3V9R6-X44PD-974WX" # Win 8.1 RTM CoreCountrySpecific OEM:NONSLP
    2591 = "F3MR2-NPTY6-8DB3K-84VCM-BBGR9" # Win 8.1 RTM CoreCountrySpecific OEM:NONSLP
    2591 = "TNH8J-KG84C-TRMG4-FFD7J-VH4WX" # Win 8.1 RTM CoreCountrySpecific OEM:NONSLP
    2592 = "3J3CN-X2BVV-TPFMF-MDYT9-9HHPM" # Win 8.1 RTM CoreN OEM:NONSLP
    2592 = "8FDVG-YN4DJ-42B98-FBMY3-VXKGB" # Win 8.1 RTM CoreN OEM:NONSLP
    2592 = "GKKHG-NDHPG-VVYQP-FY86T-XP9GB" # Win 8.1 RTM CoreN OEM:NONSLP
    2592 = "HJ924-JPN9Y-3FC9H-GCYMG-C9WJY" # Win 8.1 RTM CoreN OEM:NONSLP
    2592 = "MTP76-3DN3V-Y32QY-TDPMC-GQ6TB" # Win 8.1 RTM CoreN OEM:NONSLP
    2592 = "N88QW-FPY4X-VT24D-FY3KX-9HHPM" # Win 8.1 RTM CoreN OEM:NONSLP
    2593 = "34VJD-KNVTQ-PGK7C-GY8YC-GQ6TC" # Win 8.1 RTM CoreSingleLanguage OEM:NONSLP
    2593 = "C4Y9V-N9M82-42Q67-62TWB-G29GC" # Win 8.1 RTM CoreSingleLanguage OEM:NONSLP
    2593 = "F87GJ-9JNT8-HMXTP-9MMCV-X74W2" # Win 8.1 RTM CoreSingleLanguage OEM:NONSLP
    2593 = "F9W7Y-NRK78-9W2DQ-JBV4T-FVTTC" # Win 8.1 RTM CoreSingleLanguage OEM:NONSLP
    2593 = "TCRVV-NCRM2-DD7J3-CJBTD-7T8J2" # Win 8.1 RTM CoreSingleLanguage OEM:NONSLP
    2593 = "Y9NXP-XT8MV-PT9TG-97CT3-9D6TC" # Win 8.1 RTM CoreSingleLanguage OEM:NONSLP
    2594 = "6D4NC-J8XV3-TW8CG-KC6MB-8FFW3" # Win 8.1 RTM Professional OEM:NONSLP
    2594 = "8BCV3-NPTR9-GBVRY-HFRHW-2GXGD" # Win 8.1 RTM Professional OEM:NONSLP
    2594 = "B478Q-FNMXX-FKYT6-D6FC8-HMGTD" # Win 8.1 RTM Professional OEM:NONSLP
    2594 = "HBM47-YNYGF-FKWDM-JYQJY-39KGD" # Win 8.1 RTM Professional OEM:NONSLP
    2594 = "NBVT8-4JCBX-W622J-CCGPD-G8Y83" # Win 8.1 RTM Professional OEM:NONSLP
    2594 = "QQPW3-N272X-JCK7Y-K6TXW-D9KGD" # Win 8.1 RTM Professional OEM:NONSLP
    2594 = "TQ9QM-8N83K-8JWY4-374WX-2YRW3" # Win 8.1 RTM Professional OEM:NONSLP
    2595 = "2TXRD-CCNWC-CT2X8-KGDXP-PGXGF" # Win 8.1 RTM ProfessionalN OEM:NONSLP
    2595 = "8WKN2-JM322-BKXHG-TTGGQ-T6MCR" # Win 8.1 RTM ProfessionalN OEM:NONSLP
    2595 = "9RVNT-TQTQF-QMJ32-H6CWJ-33VPR" # Win 8.1 RTM ProfessionalN OEM:NONSLP
    2595 = "YBPJQ-NVMT3-38WQ6-X6K7X-H6B84" # Win 8.1 RTM ProfessionalN OEM:NONSLP
    2595 = "YDVVC-2NTQF-MWYGQ-6XVRM-G29GF" # Win 8.1 RTM ProfessionalN OEM:NONSLP
    2596 = "2NJFF-29FR9-X9JRW-7HQTP-27HPT" # Win 8.1 RTM Core Retail
    2596 = "334NH-RXG76-64THK-C7CKG-D3VPT" # Win 8.1 RTM Core Retail
    2596 = "3R3GV-N7M49-9CTV7-CPV82-GQ6TG" # Win 8.1 RTM Core Retail
    2596 = "BHWHH-N6QK4-BHRCF-PGQVV-FJP6G" # Win 8.1 RTM Core Retail
    2596 = "DWJRN-MKBYD-B99DQ-YJVTX-4JP6G" # Win 8.1 RTM Core Retail
    2596 = "HTN3H-XT77W-YYVMG-2JR7Y-KD6TG" # Win 8.1 RTM Core Retail
    2596 = "HX6BB-NK47H-XYD74-DGBF6-6F26G" # Win 8.1 RTM Core Retail
    2596 = "KN8GT-Y6RH3-PJ9P7-8Q69P-XTMCT" # Win 8.1 RTM Core Retail
    2596 = "M7G46-RTN98-8KX34-3QXJQ-2WD2T" # Win 8.1 RTM Core Retail
    2596 = "NCXH7-C46BG-JRWYW-VGTY4-W8D2T" # Win 8.1 RTM Core Retail
    2596 = "NGDJR-92Q8V-83F6T-HK4PW-Q68J6" # Win 8.1 RTM Core Retail
    2596 = "VF2BG-FN96F-CD99K-RBTM2-3YGTG" # Win 8.1 RTM Core Retail
    2597 = "VC723-XNVYP-WJWF8-JR8R6-CGXGH" # Win 8.1 RTM Core OEM:DM
    2599 = "436P9-MN6X7-HX6M2-DP9GJ-CPM89" # Win 8.1 RTM CoreN Retail
    2599 = "6NPQ8-PK64X-W4WMM-MF84V-RGB89" # Win 8.1 RTM CoreN Retail
    2599 = "6QXPX-HN84D-42D2Q-66XKC-RVTTK" # Win 8.1 RTM CoreN Retail
    2599 = "M4V3Y-XVN6B-H7W2P-C42MK-H6B89" # Win 8.1 RTM CoreN Retail
    2599 = "M6887-DNB6W-F3HWC-HC8YK-TF26K" # Win 8.1 RTM CoreN Retail
    2599 = "MXBFD-MNKG4-FW7P3-H6CR4-368J9" # Win 8.1 RTM CoreN Retail
    2599 = "MXPNK-VY38M-98B2J-7C4GP-HH4W9" # Win 8.1 RTM CoreN Retail
    2599 = "N48TD-HTH2H-V4KV6-93KCG-KTMCX" # Win 8.1 RTM CoreN Retail
    2599 = "WJN6W-K2GFG-4RVHF-2KJJF-DJY89" # Win 8.1 RTM CoreN Retail
    2600 = "2NHD9-KTTHG-XF36B-VDJ6V-9BRXB" # Win 8.1 RTM Professional Retail
    2600 = "4BRRN-YDYBW-Q4RGG-H7XM3-49BCY" # Win 8.1 RTM Professional Retail
    2600 = "4NFMM-FYXCQ-H8FKT-9RXR3-2WD2Y" # Win 8.1 RTM Professional Retail
    2600 = "6NJXY-W6694-MMDRK-43VVC-8XBCY" # Win 8.1 RTM Professional Retail
    2600 = "6NPH4-PTPK9-XKKR2-XY4M8-33VPY" # Win 8.1 RTM Professional Retail
    2600 = "6RNR9-HRY9X-P4B2W-MT9FX-KP9GM" # Win 8.1 RTM Professional Retail
    2600 = "8XNPH-PBPTH-BXDXB-VX6J7-PWD2Y" # Win 8.1 RTM Professional Retail
    2600 = "9NXP6-9BRHF-V6P3V-3VJYR-2KBCY" # Win 8.1 RTM Professional Retail
    2600 = "9VV8M-N89YG-2TMJG-XH4BG-C9WKB" # Win 8.1 RTM Professional Retail
    2600 = "B4K9M-2NBXC-H96DF-HVFT9-QV4XB" # Win 8.1 RTM Professional Retail
    2600 = "BBNRV-P22TW-6KFR8-2WXGX-P36TM" # Win 8.1 RTM Professional Retail
    2600 = "BGH2N-MT2M9-WH9XW-8K9P7-QPC6M" # Win 8.1 RTM Professional Retail
    2600 = "BHNB4-WF6WB-KVW7M-43FG2-XTMCY" # Win 8.1 RTM Professional Retail
    2600 = "C3BP6-GGNVB-PPXVD-HMCDM-HT8KB" # Win 8.1 RTM Professional Retail
    2600 = "DHC4V-KNCKX-F7XDM-B7348-QC9GM" # Win 8.1 RTM Professional Retail
    2600 = "DM986-DWNVR-QMM2B-KYVJC-D68KB" # Win 8.1 RTM Professional Retail
    2600 = "FJ9TK-WN88X-VQF6D-D49T3-QRQ2Y" # Win 8.1 RTM Professional Retail
    2600 = "G4CBM-NBBRX-K2FX6-K66FH-B7TTM" # Win 8.1 RTM Professional Retail
    2600 = "HNGFG-VJ7X2-PVK6X-M4WFP-3YGTM" # Win 8.1 RTM Professional Retail
    2600 = "K3HFJ-XQN3P-MHMY6-4XGM2-3YGTM" # Win 8.1 RTM Professional Retail
    2600 = "KYQXW-YNMCD-39Q28-CVDGK-7XKGM" # Win 8.1 RTM Professional Retail
    2600 = "MPC9C-T8NPB-KM7KB-C233V-HXKGM" # Win 8.1 RTM Professional Retail
    2600 = "N9YVD-HGXYX-KRX44-433HR-QGMCY" # Win 8.1 RTM Professional Retail
    2600 = "NCJY3-4YP8X-VF6DJ-66MW6-HFQ2Y" # Win 8.1 RTM Professional Retail
    2600 = "NHQJ9-PYTX6-FKQJ7-PKG7R-YTB9B" # Win 8.1 RTM Professional Retail
    2600 = "PCWHM-QBNVT-W427D-69XX3-C36TM" # Win 8.1 RTM Professional Retail
    2600 = "QNB2M-Q4C3T-W93YJ-CRJ7F-PPM9B" # Win 8.1 RTM Professional Retail
    2600 = "RFT6N-3J6DP-QJW6T-VFHXV-MBGTM" # Win 8.1 RTM Professional Retail
    2600 = "TJNBD-PWR4K-Y4H7T-RMCCJ-F3JKB" # Win 8.1 RTM Professional Retail
    2600 = "TNM26-PC2HM-7JWW7-TWFB3-49BCY" # Win 8.1 RTM Professional Retail
    2600 = "XFQN6-XHVKT-D996D-TK3Q4-4X7PY" # Win 8.1 RTM Professional Retail
    2600 = "XGWM7-4NXCK-MHF48-HYT4Q-QRQ2Y" # Win 8.1 RTM Professional Retail
    2600 = "XHQ8N-C3MCJ-RQXB6-WCHYG-C9WKB" # Win 8.1 RTM Professional Retail
    2600 = "XRD3N-KP74G-3VVHV-F42B8-TQ6TM" # Win 8.1 RTM Professional Retail
    2600 = "YJGGN-TWH3K-BM9J7-DFKJQ-974XB" # Win 8.1 RTM Professional Retail
    2600 = "YM4CN-HCB9K-T9FD7-JM2P4-K4Q2Y" # Win 8.1 RTM Professional Retail
    2600 = "YWNF3-B8XKD-Y3797-R97PY-QJY9B" # Win 8.1 RTM Professional Retail
    2601 = "4QBN7-YWDH8-44FV8-G89GV-9BRXC" # Win 8.1 RTM ProfessionalN Retail
    2601 = "7JQHV-N29JY-876PT-CG4PB-7MGTP" # Win 8.1 RTM ProfessionalN Retail
    2601 = "8N7HM-MW7V7-7WMXD-Y8KQH-MBGTP" # Win 8.1 RTM ProfessionalN Retail
    2601 = "B6TJK-BWNR6-XXFHB-78T9P-XTMC2" # Win 8.1 RTM ProfessionalN Retail
    2601 = "CFHJT-NB9BG-JB3RC-GFJQM-HT8KC" # Win 8.1 RTM ProfessionalN Retail
    2601 = "H3HFD-WWNCG-229XX-9V2K3-629GP" # Win 8.1 RTM ProfessionalN Retail
    2601 = "J9C3V-WNQ4F-QJKFP-G6R89-7XKGP" # Win 8.1 RTM ProfessionalN Retail
    2601 = "JRBBN-4Q997-H4RM2-H3B7W-Q68KC" # Win 8.1 RTM ProfessionalN Retail
    2601 = "KDRFN-FHH76-3JG2V-7MTM4-7H4XC" # Win 8.1 RTM ProfessionalN Retail
    2601 = "N2736-WKGV6-FBGFR-4TVCM-BBGTP" # Win 8.1 RTM ProfessionalN Retail
    2601 = "TBKJN-M8Q4T-PWPDP-3HK7X-H6B9C" # Win 8.1 RTM ProfessionalN Retail
    2601 = "V28JN-HJWYB-63TYC-QHJRH-KHHP2" # Win 8.1 RTM ProfessionalN Retail
    2601 = "V9KRV-7NP49-6WHBB-J8HPC-P9WKC" # Win 8.1 RTM ProfessionalN Retail
    2601 = "VNMDP-DH9B3-QHX2F-GQHD4-4X7P2" # Win 8.1 RTM ProfessionalN Retail
    2601 = "YKJGV-CYN6X-DXT3F-DMHJF-7H4XC" # Win 8.1 RTM ProfessionalN Retail
    2602 = "3K2MD-PT6CY-3NCW6-DVKJ4-F6XGQ" # Win 8.1 RTM ProfessionalN Retail
    2602 = "6D8MG-F8CT4-7DH2N-MPR4X-6CM9D" # Win 8.1 RTM ProfessionalN Retail
    2602 = "DFXYT-3YJ9H-4CDN2-72TJG-YG8KD" # Win 8.1 RTM ProfessionalN Retail
    2603 = "6XDVT-YCDFM-N3JFK-JYHPW-CPM9F" # Win 8.1 RTM ProfessionalWMC Retail
    2603 = "BJXPF-GVB62-C2R9W-NKH63-KKWKF" # Win 8.1 RTM ProfessionalWMC Retail
    2603 = "M9GB4-JYCF4-QNBY9-YM6MF-BY324" # Win 8.1 RTM ProfessionalWMC Retail
    2603 = "XXDP4-4J8QR-FH8NP-G7Y64-R3JKF" # Win 8.1 RTM ProfessionalWMC Retail
    2604 = "4PBQW-GKMVH-X8JN8-4B3RG-H8P6T" # Win 8.1 RTM ProfessionalWMC Retail
    2604 = "H42X9-6YP8G-FM3NB-3WDJ4-KBRXG" # Win 8.1 RTM ProfessionalWMC Retail
    2604 = "MFC3J-F628F-JK9VT-NPMTX-T8Y9G" # Win 8.1 RTM ProfessionalWMC Retail
    2605 = "MNDGV-M6PKV-DV4DR-CYY8X-2YRXH" # EnterpriseNEval, Win 8.1 RTM EnterpriseNEval Retail:TB:Eval
    2606 = "7VY4Y-6N6R2-DGYC7-TTPQT-GMRXJ" # EnterpriseEval, Win 8.1 RTM EnterpriseEval Retail:TB:Eval
    2607 = "M9Q9P-WNJJT-6PXPY-DWX8H-6XWKK" # Core, Win 8.1 RTM Core Volume:GVLK
    2608 = "NYPGX-X7JRW-BFQ9Q-K3X4Q-VXKGY" # CoreARM, Win 8.1 RTM CoreARM OEM:DM
    2608 = "WGPRN-MPR7D-CFDJF-FJQWC-JB33B" # CoreARM, Win 8.1 RTM CoreARM OEM:DM
    2609 = "XYTND-K6QKT-K2MRH-66RTM-43JKP" # CoreARM, Win 8.1 RTM CoreARM Volume:GVLK
    2610 = "NCTT7-2RGK8-WMHRF-RY7YQ-JTXG3" # CoreCountrySpecific, Win 8.1 RTM CoreCountrySpecific Volume:GVLK
    2611 = "7B9N3-D94CG-YTVHR-QBPX3-RJP64" # CoreN, Win 8.1 RTM CoreN Volume:GVLK
    2612 = "4NX46-6DHCG-MR3PH-9FMCX-3RQ3G" # CoreSingleLanguage, Win 8.1 RTM CoreSingleLanguage Volume:GVLK
    2612 = "BB6NG-PQ82V-VRDPW-8XVD2-V8P66" # CoreSingleLanguage, Win 8.1 RTM CoreSingleLanguage Volume:GVLK
    2613 = "FHQNR-XYXYC-8PMHT-TV4PH-DRQ3H" # Enterprise, Win 8.1 RTM Enterprise Volume:GVLK
    2613 = "MHF9N-XY6XB-WVXMC-BTDCT-MKKG7" # Enterprise, Win 8.1 RTM Enterprise Volume:GVLK
    2613 = "TN6CM-KCVXP-VVP8X-YVCF7-R9BDH" # Enterprise, Win 8.1 RTM Enterprise Volume:GVLK
    2614 = "NDRDJ-3YBP2-8WTKD-CK7VB-HT8KW" # EnterpriseN, Win 8.1 RTM EnterpriseN Volume:GVLK
    2614 = "TT4HM-HN7YT-62K67-RGRQJ-JFFXW" # EnterpriseN, Win 8.1 RTM EnterpriseN Volume:GVLK
    2615 = "GCRJD-8NW9H-F2CDX-CCM8D-9D6T9" # Professional, Win 8.1 RTM Professional Volume:GVLK
    2616 = "HMCNV-VVBFX-7HMBH-CTY9B-B4FXY" # ProfessionalN, Win 8.1 RTM ProfessionalN Volume:GVLK
    2617 = "789NJ-TQK6T-6XTH8-J39CJ-J8D3P" # ProfessionalWMC, Win 8.1 RTM ProfessionalWMC Volume:GVLK
    2618 = "2CBPG-FRN23-9DCC2-P2JQ9-TF27D" # Professional;ProfessionalN;Enterprise;EnterpriseN, Win 8.1 RTM Professional;ProfessionalN;Enterprise;EnterpriseN Volume:MAK
    2618 = "2QHNW-MQD84-689DH-HJWHB-DPC7D" # Professional;ProfessionalN;Enterprise;EnterpriseN, Win 8.1 RTM Professional;ProfessionalN;Enterprise;EnterpriseN Volume:MAK
    2618 = "3NRTH-6XMW8-83GRJ-DX2V4-2KBDQ" # Professional;ProfessionalN;Enterprise;EnterpriseN, Win 8.1 RTM Professional;ProfessionalN;Enterprise;EnterpriseN Volume:MAK
    2618 = "3QH62-N2FPH-JKYM3-7G8DG-8TXHD" # Professional;ProfessionalN;Enterprise;EnterpriseN, Win 8.1 RTM Professional;ProfessionalN;Enterprise;EnterpriseN Volume:MAK
    2618 = "3W6JH-N6PWP-JPJ42-PK3JH-WK7QQ" # Professional;ProfessionalN;Enterprise;EnterpriseN, Win 8.1 RTM Professional;ProfessionalN;Enterprise;EnterpriseN Volume:MAK
    2618 = "3W7K9-3NPB2-YYPH8-VM388-GVHQQ" # Professional;ProfessionalN;Enterprise;EnterpriseN, Win 8.1 RTM Professional;ProfessionalN;Enterprise;EnterpriseN Volume:MAK
    2618 = "48RN4-HJDGX-RG7JM-D48CX-H6B93" # Professional;ProfessionalN;Enterprise;EnterpriseN, Win 8.1 RTM Professional;ProfessionalN;Enterprise;EnterpriseN Volume:MAK
    2618 = "4M8HN-DWJXK-3GX3Q-KY4FH-9BRX3" # Professional;ProfessionalN;Enterprise;EnterpriseN, Win 8.1 RTM Professional;ProfessionalN;Enterprise;EnterpriseN Volume:MAK
    2618 = "4MBYK-N96WK-J4QDD-W8X8G-4M33Q" # Professional;ProfessionalN;Enterprise;EnterpriseN, Win 8.1 RTM Professional;ProfessionalN;Enterprise;EnterpriseN Volume:MAK
    2618 = "4YKJN-6BHQX-GRP4R-D4PTJ-2GXHD" # Professional;ProfessionalN;Enterprise;EnterpriseN, Win 8.1 RTM Professional;ProfessionalN;Enterprise;EnterpriseN Volume:MAK
    2618 = "7M36B-NK3MM-FVM93-86JCB-MY33Q" # Professional;ProfessionalN;Enterprise;EnterpriseN, Win 8.1 RTM Professional;ProfessionalN;Enterprise;EnterpriseN Volume:MAK
    2618 = "86GQN-C4GWT-79FP2-XG2CY-B4FX3" # Professional;ProfessionalN;Enterprise;EnterpriseN, Win 8.1 RTM Professional;ProfessionalN;Enterprise;EnterpriseN Volume:MAK
    2618 = "8NDDK-GJGW4-2W6JK-FQJTQ-4GB93" # Professional;ProfessionalN;Enterprise;EnterpriseN, Win 8.1 RTM Professional;ProfessionalN;Enterprise;EnterpriseN Volume:MAK
    2618 = "8PYVD-PN96M-C22WH-XG2Y2-TMRX3" # Professional;ProfessionalN;Enterprise;EnterpriseN, Win 8.1 RTM Professional;ProfessionalN;Enterprise;EnterpriseN Volume:MAK
    2618 = "8QNBB-2V9D3-2KVGX-YJJ4X-V2YDQ" # Professional;ProfessionalN;Enterprise;EnterpriseN, Win 8.1 RTM Professional;ProfessionalN;Enterprise;EnterpriseN Volume:MAK
    2618 = "93NXV-R4BJF-678PF-68VFC-W2M93" # Professional;ProfessionalN;Enterprise;EnterpriseN, Win 8.1 RTM Professional;ProfessionalN;Enterprise;EnterpriseN Volume:MAK
    2618 = "97RNP-VTWR6-VJB8R-894JQ-C36VD" # Professional;ProfessionalN;Enterprise;EnterpriseN, Win 8.1 RTM Professional;ProfessionalN;Enterprise;EnterpriseN Volume:MAK
    2618 = "BGDNJ-4J4CG-MW2K3-7YH7M-39KHD" # Professional;ProfessionalN;Enterprise;EnterpriseN, Win 8.1 RTM Professional;ProfessionalN;Enterprise;EnterpriseN Volume:MAK
    2618 = "BHDM4-KN69P-BKFK3-R76VR-VMGVD" # Professional;ProfessionalN;Enterprise;EnterpriseN, Win 8.1 RTM Professional;ProfessionalN;Enterprise;EnterpriseN Volume:MAK
    2618 = "BRXGR-FNW72-326XH-P9MJM-HT8K3" # Professional;ProfessionalN;Enterprise;EnterpriseN, Win 8.1 RTM Professional;ProfessionalN;Enterprise;EnterpriseN Volume:MAK
    2618 = "BT4KB-MNHJR-3C9Q7-Q7622-HH4X3" # Professional;ProfessionalN;Enterprise;EnterpriseN, Win 8.1 RTM Professional;ProfessionalN;Enterprise;EnterpriseN Volume:MAK
    2618 = "CTW3N-DJFPT-26GFG-HQKXR-HQVQQ" # Professional;ProfessionalN;Enterprise;EnterpriseN, Win 8.1 RTM Professional;ProfessionalN;Enterprise;EnterpriseN Volume:MAK
    2618 = "CXP6N-R73RB-TWBJW-Q92XV-WK7QQ" # Professional;ProfessionalN;Enterprise;EnterpriseN, Win 8.1 RTM Professional;ProfessionalN;Enterprise;EnterpriseN Volume:MAK
    2618 = "DTCWN-RDBTB-FB2P2-2VQR7-R9BDQ" # Professional;ProfessionalN;Enterprise;EnterpriseN, Win 8.1 RTM Professional;ProfessionalN;Enterprise;EnterpriseN Volume:MAK
    2618 = "FMNB4-8944B-MXD9J-XBFWM-HT8K3" # Professional;ProfessionalN;Enterprise;EnterpriseN, Win 8.1 RTM Professional;ProfessionalN;Enterprise;EnterpriseN Volume:MAK
    2618 = "FVNJG-9BCJ2-TQBVR-KK2DR-X2C7D" # Professional;ProfessionalN;Enterprise;EnterpriseN, Win 8.1 RTM Professional;ProfessionalN;Enterprise;EnterpriseN Volume:MAK
    2618 = "GFD9N-82DC7-JQYYH-39KYQ-PYRX3" # Professional;ProfessionalN;Enterprise;EnterpriseN, Win 8.1 RTM Professional;ProfessionalN;Enterprise;EnterpriseN Volume:MAK
    2618 = "GNRF7-VGGDB-C6DRV-D47P8-7FQ3Q" # Professional;ProfessionalN;Enterprise;EnterpriseN, Win 8.1 RTM Professional;ProfessionalN;Enterprise;EnterpriseN Volume:MAK
    2618 = "GXXJD-HNKWK-RJWHD-7WCJ4-F6XHD" # Professional;ProfessionalN;Enterprise;EnterpriseN, Win 8.1 RTM Professional;ProfessionalN;Enterprise;EnterpriseN Volume:MAK
    2618 = "H2BBP-N8VYQ-T4RD9-7VDGQ-PYRX3" # Professional;ProfessionalN;Enterprise;EnterpriseN, Win 8.1 RTM Professional;ProfessionalN;Enterprise;EnterpriseN Volume:MAK
    2618 = "HN44R-GR2JT-HQRKB-J4GKG-H8P7D" # Professional;ProfessionalN;Enterprise;EnterpriseN, Win 8.1 RTM Professional;ProfessionalN;Enterprise;EnterpriseN Volume:MAK
    2618 = "K43J7-CNJH2-K469T-VYX2H-M4FX3" # Professional;ProfessionalN;Enterprise;EnterpriseN, Win 8.1 RTM Professional;ProfessionalN;Enterprise;EnterpriseN Volume:MAK
    2618 = "K4F6Q-88NDM-GTJMT-KTQHC-BTB93" # Professional;ProfessionalN;Enterprise;EnterpriseN, Win 8.1 RTM Professional;ProfessionalN;Enterprise;EnterpriseN Volume:MAK
    2618 = "KBG3Q-44NP7-CFTTF-GFWHP-2DJK3" # Professional;ProfessionalN;Enterprise;EnterpriseN, Win 8.1 RTM Professional;ProfessionalN;Enterprise;EnterpriseN Volume:MAK
    2618 = "M6BT2-NX86H-8GGT2-7WXQ7-X74X3" # Professional;ProfessionalN;Enterprise;EnterpriseN, Win 8.1 RTM Professional;ProfessionalN;Enterprise;EnterpriseN Volume:MAK
    2618 = "MWN7C-WY8HG-3HQR8-486QW-QC9HD" # Professional;ProfessionalN;Enterprise;EnterpriseN, Win 8.1 RTM Professional;ProfessionalN;Enterprise;EnterpriseN Volume:MAK
    2618 = "NK7KH-D8BG6-MCRM8-Y6DPB-3GMDQ" # Professional;ProfessionalN;Enterprise;EnterpriseN, Win 8.1 RTM Professional;ProfessionalN;Enterprise;EnterpriseN Volume:MAK
    2618 = "NPDM8-C82D2-MTC7J-JRXPC-YKKHD" # Professional;ProfessionalN;Enterprise;EnterpriseN, Win 8.1 RTM Professional;ProfessionalN;Enterprise;EnterpriseN Volume:MAK
    2618 = "NRM98-DBHVR-YJV8D-K4BGT-D3VQQ" # Professional;ProfessionalN;Enterprise;EnterpriseN, Win 8.1 RTM Professional;ProfessionalN;Enterprise;EnterpriseN Volume:MAK
    2618 = "NXQXX-Q3PJV-RHGRW-8JQT8-TQ6VD" # Professional;ProfessionalN;Enterprise;EnterpriseN, Win 8.1 RTM Professional;ProfessionalN;Enterprise;EnterpriseN Volume:MAK
    2618 = "P9RYY-CNP87-JDT28-6FWMJ-9TMDQ" # Professional;ProfessionalN;Enterprise;EnterpriseN, Win 8.1 RTM Professional;ProfessionalN;Enterprise;EnterpriseN Volume:MAK
    2618 = "PXNRW-2R3QG-72V7B-VK666-BPYDQ" # Professional;ProfessionalN;Enterprise;EnterpriseN, Win 8.1 RTM Professional;ProfessionalN;Enterprise;EnterpriseN Volume:MAK
    2618 = "Q6R2N-FG74Y-38TFK-2DXVV-X74X3" # Professional;ProfessionalN;Enterprise;EnterpriseN, Win 8.1 RTM Professional;ProfessionalN;Enterprise;EnterpriseN Volume:MAK
    2618 = "Q9TRQ-NQFMG-46TR3-FWMPH-3JY93" # Professional;ProfessionalN;Enterprise;EnterpriseN, Win 8.1 RTM Professional;ProfessionalN;Enterprise;EnterpriseN Volume:MAK
    2618 = "QJMVD-9JNDG-G8Q2J-2FC6C-KWY93" # Professional;ProfessionalN;Enterprise;EnterpriseN, Win 8.1 RTM Professional;ProfessionalN;Enterprise;EnterpriseN Volume:MAK
    2618 = "R7V6Y-NKM66-HYGXD-MFHBC-CKBDQ" # Professional;ProfessionalN;Enterprise;EnterpriseN, Win 8.1 RTM Professional;ProfessionalN;Enterprise;EnterpriseN Volume:MAK
    2618 = "RDHTN-YFFKY-8YVR7-Q996Y-K74X3" # Professional;ProfessionalN;Enterprise;EnterpriseN, Win 8.1 RTM Professional;ProfessionalN;Enterprise;EnterpriseN Volume:MAK
    2618 = "RGN8C-YHCFJ-YYKH6-XWFVF-8B33Q" # Professional;ProfessionalN;Enterprise;EnterpriseN, Win 8.1 RTM Professional;ProfessionalN;Enterprise;EnterpriseN Volume:MAK
    2618 = "VDF9B-NMVKK-2DKBW-4RPFX-6CM93" # Professional;ProfessionalN;Enterprise;EnterpriseN, Win 8.1 RTM Professional;ProfessionalN;Enterprise;EnterpriseN Volume:MAK
    2618 = "VKNR6-6QYT4-BKTJW-KX4PM-39KHD" # Professional;ProfessionalN;Enterprise;EnterpriseN, Win 8.1 RTM Professional;ProfessionalN;Enterprise;EnterpriseN Volume:MAK
    2618 = "XP6PN-GWT2W-JVTJP-WWXYK-M97QQ" # Professional;ProfessionalN;Enterprise;EnterpriseN, Win 8.1 RTM Professional;ProfessionalN;Enterprise;EnterpriseN Volume:MAK
    2620 = "GBFNG-2X3TC-8R27F-RMKYB-JK7QT" # Win 8.1 RTM ProfessionalWMC Retail
    2621 = "3GRWN-HKVMG-3MYDQ-3Q6QC-JB33V" # Win 8.1 RTM CoreCountrySpecific OEM:DM
    2621 = "668NB-886B7-26QTQ-Y2BQD-KKWK7" # Win 8.1 RTM CoreCountrySpecific OEM:DM
    2621 = "8HTNX-D66B6-4FRWG-9MQPY-KD6VH" # Win 8.1 RTM CoreCountrySpecific OEM:DM
    2621 = "9YCJQ-MNVHG-D287Q-9BYXJ-W427H" # Win 8.1 RTM CoreCountrySpecific OEM:DM
    2621 = "DR7DN-GT9BD-9JY9M-8KGH8-HMGVH" # Win 8.1 RTM CoreCountrySpecific OEM:DM
    2621 = "DTKMN-GHYJ2-BQCMR-Y6BR4-X2C7H" # Win 8.1 RTM CoreCountrySpecific OEM:DM
    2621 = "MQNWP-82JBX-D2M4X-GHC9Y-DPC7H" # Win 8.1 RTM CoreCountrySpecific OEM:DM
    2621 = "NQC88-W7X88-VVDJQ-XK36B-8FFX7" # Win 8.1 RTM CoreCountrySpecific OEM:DM
    2621 = "RXTQJ-36NR3-X38PX-73DTH-PWD3V" # Win 8.1 RTM CoreCountrySpecific OEM:DM
    2621 = "WQYVW-DN2WV-CMFK2-XHT8Q-RJP7H" # Win 8.1 RTM CoreCountrySpecific OEM:DM
    2622 = "28YH8-NFT2Y-FTRGX-3R9HB-7MGVJ" # Win 8.1 RTM CoreN OEM:DM
    2622 = "84NG2-H7DYR-8XJ4J-PFWBK-7XKHJ" # Win 8.1 RTM CoreN OEM:DM
    2622 = "8PYDW-RNGJ3-DPVKY-T9RC8-DGMDW" # Win 8.1 RTM CoreN OEM:DM
    2622 = "CM8XG-KN7WR-PWJRH-KTWTY-92C7J" # Win 8.1 RTM CoreN OEM:DM
    2622 = "G84NX-K9YXX-VXJDM-MPXXK-P36VJ" # Win 8.1 RTM CoreN OEM:DM
    2622 = "H3RXD-CJNCC-7MDD4-KRJM6-J2M98" # Win 8.1 RTM CoreN OEM:DM
    2622 = "KNWMG-BGWF8-K2K66-6QY84-4X7QW" # Win 8.1 RTM CoreN OEM:DM
    2622 = "PNQK9-KJJFB-QCCC8-K6H64-W8D3W" # Win 8.1 RTM CoreN OEM:DM
    2623 = "29GVY-2QN3G-J8CJG-FBJFR-3C9HK" # Win 8.1 RTM CoreSingleLanguage OEM:DM
    2623 = "2NKP8-RKJ2B-2HWT2-YD9T6-P7HQX" # Win 8.1 RTM CoreSingleLanguage OEM:DM
    2623 = "3VQRQ-N2XBR-BBPFG-JDRFC-RVTVK" # Win 8.1 RTM CoreSingleLanguage OEM:DM
    2623 = "D8TNK-T2329-6P442-DKPW4-KBRX9" # Win 8.1 RTM CoreSingleLanguage OEM:DM
    2623 = "JWFFX-PTNJT-J2J3M-MCBGF-BY33X" # Win 8.1 RTM CoreSingleLanguage OEM:DM
    2623 = "NB9C7-RBW3V-JF3PV-D82T6-8TXHK" # Win 8.1 RTM CoreSingleLanguage OEM:DM
    2623 = "PRN2R-9J3M9-VHVKK-YVTJ7-PWD3X" # Win 8.1 RTM CoreSingleLanguage OEM:DM
    2624 = "HCTC3-NM9GC-CBJ6P-RP7WH-WK7QY" # Win 8.1 RTM CoreSingleLanguage OEM:DM
    2625 = "27NXJ-JH9WY-KYF3K-J8DPP-9P9HP" # Win 8.1 RTM Professional OEM:DM
    2625 = "BX3NK-GDVFY-W3XGM-R794G-D3VQ2" # Win 8.1 RTM Professional OEM:DM
    2625 = "CXF77-DNDP7-6YXM2-JWKPQ-H2YD2" # Win 8.1 RTM Professional OEM:DM
    2625 = "JB43W-BN37D-WG9FH-HG43M-DPC7P" # Win 8.1 RTM Professional OEM:DM
    2625 = "NW4YQ-F2QH7-GQG8J-3FY37-BDVQ2" # Win 8.1 RTM Professional OEM:DM
    2625 = "VN677-DW8QV-6WXQR-GQ3M4-HQVQ2" # Win 8.1 RTM Professional OEM:DM
    2625 = "VNJQT-9GBJC-KHM6T-RRTHX-7XKHP" # Win 8.1 RTM Professional OEM:DM
    2625 = "WG9NY-XW9B2-M7THG-KT7YY-WHTVP" # Win 8.1 RTM Professional OEM:DM
    2625 = "XNF34-K7R9K-2PKG4-7QFDB-6VHQ2" # Win 8.1 RTM Professional OEM:DM
    2627 = "XDJ76-KNBM8-BB9BK-B4CHH-XD6VR" # EmbeddedIndustryEval, Windows Embedded Industry 8.1 RTM EmbeddedIndustryEval Retail:TB:Eval
    2629 = "2KNW6-7QG99-XFXFF-6KWYB-39KHV" # EmbeddedIndustry, Windows Embedded Industry 8.1 RTM EmbeddedIndustry Retail
    2629 = "3JH6V-NMW4K-FQTRP-WFYBJ-9TMD7" # EmbeddedIndustry, Windows Embedded Industry 8.1 RTM EmbeddedIndustry Retail
    2629 = "49YNJ-TFPJM-FFTXJ-6X442-BTCBH" # EmbeddedIndustry, Windows Embedded Industry 8.1 RTM EmbeddedIndustry Retail
    2629 = "4D4YN-2W7QG-BQY69-WP729-T82BH" # EmbeddedIndustry, Windows Embedded Industry 8.1 RTM EmbeddedIndustry Retail
    2629 = "6F6NG-QY77X-D6F7K-B7G9V-WK7Q7" # EmbeddedIndustry, Windows Embedded Industry 8.1 RTM EmbeddedIndustry Retail
    2629 = "7JQDT-9NKQ7-YY4FT-4GM8G-BPYD7" # EmbeddedIndustry, Windows Embedded Industry 8.1 RTM EmbeddedIndustry Retail
    2629 = "7NJ8M-XCKBG-47266-R7QKH-9BRYH" # EmbeddedIndustry, Windows Embedded Industry 8.1 RTM EmbeddedIndustry Retail
    2629 = "B4NT6-K4PJT-JTWD2-VBJFB-KD6VV" # EmbeddedIndustry, Windows Embedded Industry 8.1 RTM EmbeddedIndustry Retail
    2629 = "BBR2Y-NTHKH-4T77G-YXMHB-HT8MH" # EmbeddedIndustry, Windows Embedded Industry 8.1 RTM EmbeddedIndustry Retail
    2629 = "CXHRY-YXNGM-R838Y-2V6W9-7XKHV" # EmbeddedIndustry, Windows Embedded Industry 8.1 RTM EmbeddedIndustry Retail
    2629 = "DY2P4-NVFFG-7CX87-D2TPR-VMGVV" # EmbeddedIndustry, Windows Embedded Industry 8.1 RTM EmbeddedIndustry Retail
    2629 = "GN7VX-YKPC2-XY98J-9RYKX-KP9HV" # EmbeddedIndustry, Windows Embedded Industry 8.1 RTM EmbeddedIndustry Retail
    2629 = "GW434-KNF9B-R3P4W-7HTYY-G29HV" # EmbeddedIndustry, Windows Embedded Industry 8.1 RTM EmbeddedIndustry Retail
    2629 = "H338C-X4N9V-KMCDP-D4JJM-R6XHV" # EmbeddedIndustry, Windows Embedded Industry 8.1 RTM EmbeddedIndustry Retail
    2629 = "HPNF6-RVV63-CK6CY-GGG38-WB337" # EmbeddedIndustry, Windows Embedded Industry 8.1 RTM EmbeddedIndustry Retail
    2629 = "HQGWN-YPWQ6-84JT9-G3JH2-27HQ7" # EmbeddedIndustry, Windows Embedded Industry 8.1 RTM EmbeddedIndustry Retail
    2629 = "HRVXT-FNQD4-M9DGY-KK9HV-4CYD7" # EmbeddedIndustry, Windows Embedded Industry 8.1 RTM EmbeddedIndustry Retail
    2629 = "KVRDN-XMTG2-DTJQ9-4DDHV-PWD37" # EmbeddedIndustry, Windows Embedded Industry 8.1 RTM EmbeddedIndustry Retail
    2629 = "N3QXW-32CJR-94GJY-HXHHM-BBGVV" # EmbeddedIndustry, Windows Embedded Industry 8.1 RTM EmbeddedIndustry Retail
    2629 = "NHFY3-VD8C3-4X4VP-2CKH8-W427V" # EmbeddedIndustry, Windows Embedded Industry 8.1 RTM EmbeddedIndustry Retail
    2629 = "NQV27-2D6C9-3XBB6-Y6WRV-94Q37" # EmbeddedIndustry, Windows Embedded Industry 8.1 RTM EmbeddedIndustry Retail
    2629 = "NWF2Q-F82BG-WPQ3B-HKCGR-GXWMH" # EmbeddedIndustry, Windows Embedded Industry 8.1 RTM EmbeddedIndustry Retail
    2629 = "NWTCY-DX2PP-PHBPX-C4X9D-BG8MH" # EmbeddedIndustry, Windows Embedded Industry 8.1 RTM EmbeddedIndustry Retail
    2629 = "PDXVN-4B6CH-6FXRT-8T9HD-RJP7V" # EmbeddedIndustry, Windows Embedded Industry 8.1 RTM EmbeddedIndustry Retail
    2629 = "PPCN3-MGHRK-4FRCG-7M2T7-2R27V" # EmbeddedIndustry, Windows Embedded Industry 8.1 RTM EmbeddedIndustry Retail
    2629 = "Q2V4X-NJQ6C-WRFQY-9PJ2G-Y97Q7" # EmbeddedIndustry, Windows Embedded Industry 8.1 RTM EmbeddedIndustry Retail
    2629 = "R9JVN-34T24-PRRTT-GMMPP-V8P7V" # EmbeddedIndustry, Windows Embedded Industry 8.1 RTM EmbeddedIndustry Retail
    2629 = "RQNW3-94CXV-7Q9QP-HB864-DJ2BH" # EmbeddedIndustry, Windows Embedded Industry 8.1 RTM EmbeddedIndustry Retail
    2629 = "RVTN7-PT7RF-FCJFR-WP766-VCC7V" # EmbeddedIndustry, Windows Embedded Industry 8.1 RTM EmbeddedIndustry Retail
    2629 = "VNWCH-GVPJT-8WM7K-JV376-3V4YH" # EmbeddedIndustry, Windows Embedded Industry 8.1 RTM EmbeddedIndustry Retail
    2629 = "W7V4N-G7YBQ-PCYHC-VPG6B-JK7Q7" # EmbeddedIndustry, Windows Embedded Industry 8.1 RTM EmbeddedIndustry Retail
    2629 = "WYNK7-R9GG3-XDXJ4-3XXW8-6MRYH" # EmbeddedIndustry, Windows Embedded Industry 8.1 RTM EmbeddedIndustry Retail
    2629 = "XMH84-2GNF8-YR984-RQDPH-M4FYH" # EmbeddedIndustry, Windows Embedded Industry 8.1 RTM EmbeddedIndustry Retail
    2629 = "XN2BF-PHVJ8-P72F6-6FT96-V6CBH" # EmbeddedIndustry, Windows Embedded Industry 8.1 RTM EmbeddedIndustry Retail
    2629 = "XNY7H-CTF8W-VCP2D-8HX3M-R6XHV" # EmbeddedIndustry, Windows Embedded Industry 8.1 RTM EmbeddedIndustry Retail
    2629 = "Y2TNX-CTFGW-B68W4-VGKX3-RJP7V" # EmbeddedIndustry, Windows Embedded Industry 8.1 RTM EmbeddedIndustry Retail
    2629 = "YC3VN-CH33H-M8FB6-6JBHK-66MD7" # EmbeddedIndustry, Windows Embedded Industry 8.1 RTM EmbeddedIndustry Retail
    2629 = "YT87P-NF4PW-WC6B4-4RF76-D3VQ7" # EmbeddedIndustry, Windows Embedded Industry 8.1 RTM EmbeddedIndustry Retail
    2639 = "4MQVN-QB8TB-Q6B4C-B3267-RGCBX" # EmbeddedIndustry, Windows Embedded Industry 8.1 RTM EmbeddedIndustry Volume:MAK
    2640 = "NMMPB-38DD4-R2823-62W8D-VXKJB" # EmbeddedIndustry, Windows Embedded Industry 8.1 RTM EmbeddedIndustry Volume:GVLK
    2643 = "PPBKC-NQYJM-JJ8X6-26W42-VFQ4R" # EmbeddedIndustryEEval, Windows Embedded Industry 8.1 RTM EmbeddedIndustryEEval Retail:TB:Eval
    2645 = "48NBY-H2JQK-Q8GW7-BF47Y-YWP8H" # EmbeddedIndustryE, Windows Embedded Industry 8.1 RTM EmbeddedIndustryE Retail
    2645 = "NDXXJ-YX29Q-JDY6B-C93G8-TQ6WH" # EmbeddedIndustryE, Windows Embedded Industry 8.1 RTM EmbeddedIndustryE Retail
    2646 = "C9NJJ-6TCJX-G3M2K-MJHQC-JB34W" # EmbeddedIndustryE, Windows Embedded Industry 8.1 RTM EmbeddedIndustryE Volume:MAK
    2647 = "FNFKF-PWTVT-9RC8H-32HB2-JB34X" # EmbeddedIndustryE, Windows Embedded Industry 8.1 RTM EmbeddedIndustryE Volume:GVLK
    2648 = "TP7MN-9H7FK-P4PJM-K6KJT-Y97RY" # EmbeddedIndustryA, Windows Embedded Industry 8.1 RTM EmbeddedIndustryA OEM:NONSLP
    2654 = "VHXM3-NR6FT-RY6RT-CK882-KW2CJ" # EmbeddedIndustryA, Windows Embedded Industry 8.1 RTM EmbeddedIndustryA Volume:GVLK
    2655 = "R9N79-23MWD-MBP9B-KHF8Q-C36WX" # ServerSolution, Windows Server Essentials 2012 R2 RTM ServerSolution Retail:TB:Eval
    2655 = "VD4NY-447WT-WFRT9-FK3K2-8XBF9" # ServerSolution, Windows Server Essentials 2012 R2 RTM ServerSolution Retail:TB:Eval
    2667 = "3J9Q2-2QN23-PFPTV-MG3K8-F3JP4" # Win 8.1 RTM CoreConnected OEM:DM
    2667 = "6NDQM-BTXH9-VWHD4-7Y2CR-BY36R" # Win 8.1 RTM CoreConnected OEM:DM
    2667 = "CVQPN-CH77Q-XX7KT-YH47F-TVHTR" # Win 8.1 RTM CoreConnected OEM:DM
    2667 = "KNT2X-49VKF-9CH7Q-VKFPG-9KWP4" # Win 8.1 RTM CoreConnected OEM:DM
    2667 = "TW28N-Y48CX-R79BQ-2DCF8-BWP9F" # Win 8.1 RTM CoreConnected OEM:DM
    2667 = "TXHPN-K7XCP-PVJ98-BK3CQ-H2YGR" # Win 8.1 RTM CoreConnected OEM:DM
    2667 = "WK6N4-GVJFP-YTYQR-Q2KVR-F6XKF" # Win 8.1 RTM CoreConnected OEM:DM
    2667 = "XBYQ7-39NFH-FM4GX-RG4FY-HT8P4" # Win 8.1 RTM CoreConnected OEM:DM
    2667 = "XNKT2-FMFQ8-MJVR3-G7MTX-P36XF" # Win 8.1 RTM CoreConnected OEM:DM
    2668 = "4NQCH-DW7FQ-4HVCR-HPW8F-HQVTT" # Win 8.1 RTM CoreConnected OEM:DM
    2668 = "DQNH3-V4QXM-76PWD-7R9CG-GMR26" # Win 8.1 RTM CoreConnected OEM:DM
    2669 = "8N4XP-DKKDM-F464W-7THWR-8B36V" # Win 8.1 RTM CoreConnected OEM:NONSLP
    2670 = "KC7XT-NXR27-3JTCQ-MW9WM-HT8P8" # Win 8.1 RTM CoreConnected Retail
    2670 = "TNPYB-DX84C-26HCV-33KJB-CWD6W" # Win 8.1 RTM CoreConnected Retail
    2670 = "V8THN-J3FBH-79DT8-Y9B7F-368P8" # Win 8.1 RTM CoreConnected Retail
    2670 = "W8TFT-MPNHR-7YVVD-4TWCV-PWD6W" # Win 8.1 RTM CoreConnected Retail
    2671 = "3PY8R-QHNP9-W7XQD-G6DPH-3J2C9" # CoreConnected, Win 8.1 RTM CoreConnected Volume:GVLK
    2672 = "2Y267-7NTHQ-CH3DX-9C424-Q9KKM" # Win 8.1 RTM CoreConnectedN OEM:DM
    2672 = "3X8VQ-N496W-R79R3-4HD9M-92C9M" # Win 8.1 RTM CoreConnectedN OEM:DM
    2672 = "8CXNW-BPMRK-64QD8-DD6M9-9HHTY" # Win 8.1 RTM CoreConnectedN OEM:DM
    2672 = "CYGRN-T6BVY-HC844-9PYK4-TVHTY" # Win 8.1 RTM CoreConnectedN OEM:DM
    2672 = "FYQNK-VRPGF-RFWYQ-4PWVF-TVHTY" # Win 8.1 RTM CoreConnectedN OEM:DM
    2672 = "MVQ2T-N4776-FJCR9-B47WH-WK7TY" # Win 8.1 RTM CoreConnectedN OEM:DM
    2672 = "N2TGY-823PB-6GF2C-9WHK4-368QB" # Win 8.1 RTM CoreConnectedN OEM:DM
    2672 = "WTN9G-XBYRM-92CXW-GFRH9-BKKKM" # Win 8.1 RTM CoreConnectedN OEM:DM
    2673 = "GMKGK-NK9JF-K9VQ2-KPTV7-9BR3C" # Win 8.1 RTM CoreConnectedN OEM:NONSLP
    2674 = "4NQR6-7GV3Y-RH3KC-W9QJW-VH43D" # Win 8.1 RTM CoreConnectedN Retail
    2674 = "DCGXF-7WN4R-H23J3-BHDC6-3V43D" # Win 8.1 RTM CoreConnectedN Retail
    2674 = "NF2TF-W7WDY-RV9BP-YX6VR-QGMG3" # Win 8.1 RTM CoreConnectedN Retail
    2674 = "WRKNW-4BQCT-QHCH9-MQ3T6-FVTXQ" # Win 8.1 RTM CoreConnectedN Retail
    2675 = "Q6HTR-N24GM-PMJFP-69CD8-2GXKR" # CoreConnectedN, Win 8.1 RTM CoreConnectedN Volume:GVLK
    2676 = "42F88-XN62F-DQDT7-CMQ34-QGMG6" # Win 8.1 RTM ProfessionalStudent OEM:DM
    2676 = "48W2D-NVWMQ-T7B2F-4KBDV-DRQ66" # Win 8.1 RTM ProfessionalStudent OEM:DM
    2676 = "4K96Q-BN344-JK8TP-HHHP6-H8P9T" # Win 8.1 RTM ProfessionalStudent OEM:DM
    2676 = "CGXWM-HNHW9-3JTWK-B83MT-72YG6" # Win 8.1 RTM ProfessionalStudent OEM:DM
    2676 = "DH3JX-HPNMX-DPFRV-R2VQX-HCC9T" # Win 8.1 RTM ProfessionalStudent OEM:DM
    2676 = "JN3KY-Q4H4K-CQXCB-P4M4R-3C9KT" # Win 8.1 RTM ProfessionalStudent OEM:DM
    2676 = "JR9YN-M3HM4-XWPJR-THHWP-4RF3G" # Win 8.1 RTM ProfessionalStudent OEM:DM
    2676 = "NW9D7-GDP9W-BJ96W-4YDPW-GVHT6" # Win 8.1 RTM ProfessionalStudent OEM:DM
    2676 = "VDRTF-M9NQX-4F8QC-V2F3T-KTMG6" # Win 8.1 RTM ProfessionalStudent OEM:DM
    2676 = "XNW7V-BC8Y6-3VG76-BF4RF-K4Q66" # Win 8.1 RTM ProfessionalStudent OEM:DM
    2677 = "PNF34-KJC7H-6FBGV-DTB84-4X7T7" # Win 8.1 RTM ProfessionalStudent OEM:DM
    2678 = "BMNWP-7K493-GR7JR-KD679-4JP9W" # Win 8.1 RTM ProfessionalStudent OEM:NONSLP
    2679 = "NQHYK-WGWJH-DQJT7-XB68G-BPYG9" # Win 8.1 RTM ProfessionalStudent Retail
    2679 = "RMV43-CN33Q-VRYRW-TFHTR-Q9KKX" # Win 8.1 RTM ProfessionalStudent Retail
    2680 = "MX3RK-9HNGX-K3QKC-6PJ3F-W8D7B" # ProfessionalStudent, Win 8.1 RTM ProfessionalStudent Volume:GVLK
    2681 = "6XNQK-GPXR4-TV9XP-M8FPB-3GMHC" # Win 8.1 RTM ProfessionalStudentN OEM:DM
    2681 = "BPNQJ-2HJY4-3CJGM-K89YX-BKKK2" # Win 8.1 RTM ProfessionalStudentN OEM:DM
    2681 = "D6V2N-3DVXY-MDYVM-HC4K7-M4F3P" # Win 8.1 RTM ProfessionalStudentN OEM:DM
    2681 = "G39FY-MDNGV-W24PJ-B33V2-HH43P" # Win 8.1 RTM ProfessionalStudentN OEM:DM
    2681 = "HH82T-NQDBV-77BY2-CD9QX-2YR3P" # Win 8.1 RTM ProfessionalStudentN OEM:DM
    2681 = "MBHPX-NBMXY-DXB6Q-2K6FK-BKKK2" # Win 8.1 RTM ProfessionalStudentN OEM:DM
    2681 = "PWJJN-7MTBQ-93QFT-BKXDC-JB37C" # Win 8.1 RTM ProfessionalStudentN OEM:DM
    2681 = "QHNGY-GJ8TG-842GH-6FJRV-WK7VC" # Win 8.1 RTM ProfessionalStudentN OEM:DM
    2681 = "RCQ6X-XNF48-8CJ6D-8W49T-P7HVC" # Win 8.1 RTM ProfessionalStudentN OEM:DM
    2681 = "YNQB8-M4WWW-QJYJB-MYWT9-KP9K2" # Win 8.1 RTM ProfessionalStudentN OEM:DM
    2682 = "FN7HH-XKYQF-TV8CR-D6P4X-GJD7D" # Win 8.1 RTM ProfessionalStudentN OEM:NONSLP
    2683 = "8NX43-BY7VT-86WPJ-8X362-3YGX4" # Win 8.1 RTM ProfessionalStudentN Retail
    2683 = "N4WVP-J464Q-246KM-8FQMM-YWP94" # Win 8.1 RTM ProfessionalStudentN Retail
    2684 = "TNFGH-2R6PB-8XM3K-QYHX2-J4296" # ProfessionalStudentN, Win 8.1 RTM ProfessionalStudentN Volume:GVLK
    2685 = "4RN33-YF4D4-V7D6T-DJHMB-BBGX7" # Win 8.1 RTM CoreConnectedSingleLanguage OEM:DM
    2685 = "6JQMK-3NDM8-FB77W-D73DK-KP9K7" # Win 8.1 RTM CoreConnectedSingleLanguage OEM:DM
    2685 = "8B78F-NWFHJ-K27XC-X6J73-BG8QV" # Win 8.1 RTM CoreConnectedSingleLanguage OEM:DM
    2685 = "98HCN-RMDDY-4HJRM-M2B93-9743V" # Win 8.1 RTM CoreConnectedSingleLanguage OEM:DM
    2685 = "B9FNC-6F87Q-797TH-GWTCT-682DV" # Win 8.1 RTM CoreConnectedSingleLanguage OEM:DM
    2685 = "K836B-P8NKB-YHQVT-JJK3X-RM37H" # Win 8.1 RTM CoreConnectedSingleLanguage OEM:DM
    2685 = "KB3CR-VVNX6-2JTWQ-R3GCQ-3PC97" # Win 8.1 RTM CoreConnectedSingleLanguage OEM:DM
    2685 = "Q6XT2-NBJRB-TWGWP-YJC2J-J8D7H" # Win 8.1 RTM CoreConnectedSingleLanguage OEM:DM
    2685 = "W3HN9-76FMD-PH42F-P3PPW-9TMHH" # Win 8.1 RTM CoreConnectedSingleLanguage OEM:DM
    2685 = "WJTVR-7XN4X-MPTM2-B2VF9-C7HVH" # Win 8.1 RTM CoreConnectedSingleLanguage OEM:DM
    2686 = "6FM44-NB3F9-CHJ9V-37JQC-3YGX8" # Win 8.1 RTM CoreConnectedSingleLanguage OEM:DM
    2687 = "GQNT2-MVGTG-8M6PQ-PPQKP-TMR3X" # Win 8.1 RTM CoreConnectedSingleLanguage OEM:NONSLP
    2687 = "R8X6M-RN3T6-H6B29-FTYFM-CWD7K" # Win 8.1 RTM CoreConnectedSingleLanguage OEM:NONSLP
    2687 = "TCWNP-WJDF3-XV347-YKC2T-WXBHK" # Win 8.1 RTM CoreConnectedSingleLanguage OEM:NONSLP
    2687 = "XDK8H-3XNP8-7P63Y-YPHPF-PPPDX" # Win 8.1 RTM CoreConnectedSingleLanguage OEM:NONSLP
    2688 = "KF37N-VDV38-GRRTV-XH8X6-6F3BB" # CoreConnectedSingleLanguage, Win 8.1 RTM CoreConnectedSingleLanguage Volume:GVLK
    2689 = "7W8NB-FGPWQ-J3BDF-67VPV-8HTYC" # Win 8.1 RTM CoreConnectedCountrySpecific OEM:DM
    2689 = "8M97H-MNWVQ-JCPBH-464GP-DC9MC" # Win 8.1 RTM CoreConnectedCountrySpecific OEM:DM
    2689 = "C8J32-N724R-J2J2D-7G8RB-88D7P" # Win 8.1 RTM CoreConnectedCountrySpecific OEM:DM
    2689 = "KT46F-XNH7M-B4V76-WYB9T-YG8Q2" # Win 8.1 RTM CoreConnectedCountrySpecific OEM:DM
    2689 = "MNTVG-M6P7M-TXWHQ-QTH7T-RRF32" # Win 8.1 RTM CoreConnectedCountrySpecific OEM:DM
    2689 = "NQ4C6-WBGKK-KBCHJ-CKPM6-BPYHP" # Win 8.1 RTM CoreConnectedCountrySpecific OEM:DM
    2689 = "RMK6M-NFWTK-83TFQ-VYVKV-RGCD2" # Win 8.1 RTM CoreConnectedCountrySpecific OEM:DM
    2689 = "VQPQP-NVDTQ-8MWV7-9XQDB-92DBC" # Win 8.1 RTM CoreConnectedCountrySpecific OEM:DM
    2689 = "XC8NF-DKBK9-FV2FM-YRQJW-VH432" # Win 8.1 RTM CoreConnectedCountrySpecific OEM:DM
    2689 = "YN3D6-9TDG4-R2XHK-RX34Y-R6XMC" # Win 8.1 RTM CoreConnectedCountrySpecific OEM:DM
    2690 = "B67NP-9HDCF-DCKX2-8VCCG-Y97VQ" # Win 8.1 RTM CoreConnectedCountrySpecific OEM:NONSLP
    2690 = "JBQ2N-R8RJP-8WF62-PWKKP-3YGYD" # Win 8.1 RTM CoreConnectedCountrySpecific OEM:NONSLP
    2690 = "WCVYB-GCNJB-99YMW-6WRCX-3RQ7Q" # Win 8.1 RTM CoreConnectedCountrySpecific OEM:NONSLP
    2691 = "R962J-37N87-9VVK2-WJ74P-XTMHR" # CoreConnectedCountrySpecific, Win 8.1 RTM CoreConnectedCountrySpecific Volume:GVLK
    2787 = "7T3T3-VN3HH-42GF4-83Y2V-T29TF" # CoreConnected, Win Next Pre-Release CoreConnected OEM:DM
    2789 = "GVYN6-BGJDK-RVPMY-YCX4G-D3V2V" # CoreConnected, Win Next Pre-Release CoreConnected Retail
    2790 = "DJMYQ-WN6HG-YJ2YX-82JDB-CWFCW" # CoreConnected, Win Next Pre-Release CoreConnected Volume:GVLK
    2790 = "QBWKP-NFVG3-CYGTT-724CF-FCYPW" # CoreConnected, Win Next Pre-Release CoreConnected Volume:GVLK
    2792 = "FBKM7-NBQ86-RKQTM-4F2GB-JK72Y" # CoreConnectedCountrySpecific, Win Next Pre-Release CoreConnectedCountrySpecific OEM:DM
    2794 = "97N7Q-YMY7Q-8MV3C-T97YT-PDJXD" # CoreConnectedCountrySpecific, Win Next Pre-Release CoreConnectedCountrySpecific Retail
    2795 = "TNPJK-GCKPR-4WX4C-HCJHT-HFRC4" # CoreConnectedCountrySpecific, Win Next Pre-Release CoreConnectedCountrySpecific Volume:GVLK
    2797 = "4GNFB-JDQ7J-HXCFR-3P7Q2-Q3V27" # CoreConnectedN, Win Next Pre-Release CoreConnectedN OEM:DM
    2799 = "23TYN-4T6M8-J86QW-7F2RB-YWQGX" # CoreConnectedN, Win Next Pre-Release CoreConnectedN Retail
    2800 = "JQNT7-W63G4-WX4QX-RD9M9-6CPKM" # CoreConnectedN, Win Next Pre-Release CoreConnectedN Volume:GVLK
    2800 = "TKDDW-N77V2-WXKMG-QY6WQ-WQJXM" # CoreConnectedN, Win Next Pre-Release CoreConnectedN Volume:GVLK
    2802 = "N9GW8-4FKY2-CRF4K-3CTDY-PR3G3" # CoreConnectedSingleLanguage, Win Next Pre-Release CoreConnectedSingleLanguage OEM:DM
    2804 = "Q6MYN-Y8D89-GHVBR-KXTK3-RJQG6" # CoreConnectedSingleLanguage, Win Next Pre-Release CoreConnectedSingleLanguage Retail
    2805 = "QQMNF-GPVQ6-BFXGG-GWRCX-7XKT7" # CoreConnectedSingleLanguage, Win Next Pre-Release CoreConnectedSingleLanguage Volume:GVLK
    2805 = "RQ2MN-RKR94-P86YQ-TM76X-P3667" # CoreConnectedSingleLanguage, Win Next Pre-Release CoreConnectedSingleLanguage Volume:GVLK
    2807 = "F2YMP-VTN7Q-CYK64-W6YJF-W8FDK" # ProfessionalStudent, Win Next Pre-Release ProfessionalStudent OEM:DM
    2809 = "V3NH2-P462J-VT4G4-XD8DD-B973P" # ProfessionalStudent, Win Next Pre-Release ProfessionalStudent Retail
    2810 = "N6X24-448X6-HYV8Y-8XQ3V-DRRDQ" # ProfessionalStudent, Win Next Pre-Release ProfessionalStudent Volume:GVLK
    2810 = "YNXW3-HV3VB-Y83VG-KPBXM-6VH3Q" # ProfessionalStudent, Win Next Pre-Release ProfessionalStudent Volume:GVLK
    2812 = "7T8BN-B2WH3-FHMX2-VQQTY-CWFDT" # ProfessionalStudentN, Win Next Pre-Release ProfessionalStudentN OEM:DM
    2814 = "QJFNY-8Q8BQ-6WQH8-9J3K6-CGXVJ" # ProfessionalStudentN, Win Next Pre-Release ProfessionalStudentN Retail
    2815 = "8G9XJ-GN6PJ-GW787-MVV7G-GMR99" # ProfessionalStudentN, Win Next Pre-Release ProfessionalStudentN Volume:GVLK
    2815 = "XHGFB-WNK7Q-BG8VG-BG2KQ-KKWX9" # ProfessionalStudentN, Win Next Pre-Release ProfessionalStudentN Volume:GVLK
    2994 = "4NDBG-T6JFX-FXTF7-TQYHW-9TM3D" # Education, Win Next Pre-Release Education OEM:DM
    2995 = "RHH87-J7N99-X8M4Q-CC7K8-BWQT4" # Education, Win Next Pre-Release Education Retail
    2996 = "GH3ND-9J7VH-F9WJK-CMBD4-VMHG6" # Education, Win Next Pre-Release Education Volume:GVLK
    2997 = "THNY2-6P3JB-C34WF-X9HB7-RGCXV" # Education, Win Next Pre-Release Education Volume:MAK
    3085 = "9GMBN-J4XXY-QQ34T-T3BTR-K4RV7" # Enterprise, Win Next Pre-Release Enterprise OEM:DM
    3258 = "37GNV-YCQVD-38XP9-T848R-FC2HD" # Core, Win 10 RTM Core OEM:DM
    3258 = "6HCN4-DHPFG-XMVQJ-KJ3FW-78Q93" # Core, Win 10 RTM Core OEM:DM
    3258 = "7CYBN-WP2MW-43367-GTG79-4JQ93" # Core, Win 10 RTM Core OEM:DM
    3258 = "BNYY9-422WC-Y3K9J-B6DB4-R3KQQ" # Core, Win 10 RTM Core OEM:DM
    3258 = "BRNYR-YVPWR-3RBHH-VD9VD-C37X3" # Core, Win 10 RTM Core OEM:DM
    3258 = "D3X3Y-FMNFB-6MGG9-PH8TH-FJQ93" # Core, Win 10 RTM Core OEM:DM
    3258 = "DFH8H-N8XVT-628PV-2849B-VQWVD" # Core, Win 10 RTM Core OEM:DM
    3258 = "F4X8N-CQ8GX-MYG9C-J79M2-PGYK3" # Core, Win 10 RTM Core OEM:DM
    3258 = "F9NJ2-VQ9GB-YFWMD-QHGB6-P7JVD" # Core, Win 10 RTM Core OEM:DM
    3258 = "FHBBN-6FB96-6XKFW-XJQY7-G6PHD" # Core, Win 10 RTM Core OEM:DM
    3258 = "FQN4Y-FTB43-3KPPD-6VQ6T-PDKQQ" # Core, Win 10 RTM Core OEM:DM
    3258 = "GNCPC-B6RGQ-7XTX3-JJFQW-J8F7D" # Core, Win 10 RTM Core OEM:DM
    3258 = "HYNC4-8VY3W-8MTV6-DBJD3-7T9QQ" # Core, Win 10 RTM Core OEM:DM
    3258 = "J9P3N-4PQF4-9XW8M-2HGTQ-FM47D" # Core, Win 10 RTM Core OEM:DM
    3258 = "JRNV4-WCFVJ-4DTR6-GFT9H-KHJVD" # Core, Win 10 RTM Core OEM:DM
    3258 = "NY6FW-B8G2Y-Y9JR8-CM2Y8-XW3DQ" # Core, Win 10 RTM Core OEM:DM
    3258 = "RJTXN-VFQQG-G3X77-DK7TX-YDWVD" # Core, Win 10 RTM Core OEM:DM
    3258 = "VX38R-JFNW9-PJY8H-X9H9M-2PQDQ" # Core, Win 10 RTM Core OEM:DM
    3258 = "W7RNC-HPTRX-DCQ9T-GBGW9-H6DDQ" # Core, Win 10 RTM Core OEM:DM
    3258 = "Y24GV-NQ97Y-VP3KD-7CMYT-D3WVD" # Core, Win 10 RTM Core OEM:DM
    3258 = "YHG84-GCN2Y-38QPD-87PWJ-XW3DQ" # Core, Win 10 RTM Core OEM:DM
    3259 = "2863Y-N3JTD-R2644-R44YP-27JVF" # Core, Win 10 RTM Core OEM:DM
    3259 = "33RR8-NYH78-T8DJ4-PCQK6-CGYK4" # Core, Win 10 RTM Core OEM:DM
    3259 = "38NQ9-CYXDQ-24VFP-DR7G8-JFG3R" # Core, Win 10 RTM Core OEM:DM
    3259 = "6D8CG-BNHCR-2QKC6-GTKW8-9TPHF" # Core, Win 10 RTM Core OEM:DM
    3259 = "8CNY3-CWY7D-F8MFX-8QKHK-HCD94" # Core, Win 10 RTM Core OEM:DM
    3259 = "9NVFH-WH7MD-27WPF-KQQMQ-4GDDR" # Core, Win 10 RTM Core OEM:DM
    3259 = "BRNJ2-P6JVD-QK6RK-CV77Q-XHJVF" # Core, Win 10 RTM Core OEM:DM
    3259 = "CN38Q-DDMD9-YD84K-2TMM6-4M47F" # Core, Win 10 RTM Core OEM:DM
    3259 = "D9NBX-PFVBF-BH7KB-3MDXC-RVVX4" # Core, Win 10 RTM Core OEM:DM
    3259 = "DF78H-2WN3R-C9KWW-4C69D-BG9QR" # Core, Win 10 RTM Core OEM:DM
    3259 = "DFM6V-NHGGD-6497K-8MT9X-QV63R" # Core, Win 10 RTM Core OEM:DM
    3259 = "FQTR4-XRNQK-8R4YQ-6KDM2-3YHX4" # Core, Win 10 RTM Core OEM:DM
    3259 = "FQV4G-RPN73-24V8D-J846J-K2D94" # Core, Win 10 RTM Core OEM:DM
    3259 = "GNY6G-JQPBM-HJDY7-B4KDP-YKMK4" # Core, Win 10 RTM Core OEM:DM
    3259 = "J3DVD-NVHDM-PH9B8-HCTYB-TXXQR" # Core, Win 10 RTM Core OEM:DM
    3259 = "JQ6CR-JNV8R-J6VFC-YR39V-G6PHF" # Core, Win 10 RTM Core OEM:DM
    3259 = "JT7NC-QMYWP-KDDYR-QRVRT-J2QDR" # Core, Win 10 RTM Core OEM:DM
    3259 = "KN4CG-TRBP6-GHJ2P-736MT-D3WVF" # Core, Win 10 RTM Core OEM:DM
    3259 = "KN64C-DTXW9-HH9H6-FTHGC-GQ7X4" # Core, Win 10 RTM Core OEM:DM
    3259 = "KN6BX-GHCJ4-79GXD-GF4B8-PKCHF" # Core, Win 10 RTM Core OEM:DM
    3259 = "MK6DN-DMTMR-J7TF7-XHHF6-9KXQR" # Core, Win 10 RTM Core OEM:DM
    3259 = "MM286-PNW8H-36MC4-CVC4D-T6PHF" # Core, Win 10 RTM Core OEM:DM
    3259 = "NBP9G-GWMQC-BFHRV-267X3-C37X4" # Core, Win 10 RTM Core OEM:DM
    3259 = "NCK4T-DT88R-T8MVB-KDYQB-WHVX4" # Core, Win 10 RTM Core OEM:DM
    3259 = "NH9MT-6368J-TT4XY-4BGCW-9TPHF" # Core, Win 10 RTM Core OEM:DM
    3259 = "P4N8K-HMWMH-TD94J-DCJFP-XTPHF" # Core, Win 10 RTM Core OEM:DM
    3259 = "VRVD4-J8NQT-D73PB-B8HQD-VXMK4" # Core, Win 10 RTM Core OEM:DM
    3259 = "WFDJK-W9NH6-YYRMD-T3JX8-82QDR" # Core, Win 10 RTM Core OEM:DM
    3259 = "YGBPV-JGNC7-MG9VH-YK637-BDWVF" # Core, Win 10 RTM Core OEM:DM
    3259 = "YGCG4-3FNT6-6D82T-K6JWJ-XW3DR" # Core, Win 10 RTM Core OEM:DM
    3259 = "YGKVB-JNB2T-P6VRW-XKW8T-KTPHF" # Core, Win 10 RTM Core OEM:DM
    3259 = "YR229-NB77P-JFKKK-JV8VC-P9XQR" # Core, Win 10 RTM Core OEM:DM
    3260 = "46J3N-RY6B3-BJFDY-VBFT9-V22HG" # Core, Win 10 RTM Core OEM:NONSLP
    3260 = "673JN-2Y3HJ-HW9TK-488TJ-Q69QT" # Core, Win 10 RTM Core OEM:NONSLP
    3260 = "82TGN-T7VPQ-RBFRF-WGCP2-RVVX6" # Core, Win 10 RTM Core OEM:NONSLP
    3260 = "8RNJ7-PPRTG-2MJQW-YHK6T-D3WVG" # Core, Win 10 RTM Core OEM:NONSLP
    3260 = "9FNXQ-YVWD9-GPQB4-XJ3TC-GQ7X6" # Core, Win 10 RTM Core OEM:NONSLP
    3260 = "CK3FT-W7NBK-CK3JX-WY39X-Y7VX6" # Core, Win 10 RTM Core OEM:NONSLP
    3260 = "G4J8V-NC892-P2HCW-GQF9M-WHVX6" # Core, Win 10 RTM Core OEM:NONSLP
    3260 = "GNKHT-YC997-R8DK2-Q9X27-KHJVG" # Core, Win 10 RTM Core OEM:NONSLP
    3260 = "GPT63-N66BP-FDGH6-CKFTV-B7VX6" # Core, Win 10 RTM Core OEM:NONSLP
    3260 = "HNF2K-WCWQ3-DXGFM-JGYBF-YTDDT" # Core, Win 10 RTM Core OEM:NONSLP
    3260 = "K8QVR-GMN3V-HJ3CR-22CW2-GQ7X6" # Core, Win 10 RTM Core OEM:NONSLP
    3260 = "KGHH9-MN28T-JYJYT-2CYBW-HMHX6" # Core, Win 10 RTM Core OEM:NONSLP
    3260 = "N28QG-TCHPF-7B6BJ-84HJM-MY47G" # Core, Win 10 RTM Core OEM:NONSLP
    3260 = "NK7CQ-JFK8D-DXBW4-XPW3J-JFG3T" # Core, Win 10 RTM Core OEM:NONSLP
    3260 = "Q9QFR-8GN4F-7BFFB-VH9TH-X763T" # Core, Win 10 RTM Core OEM:NONSLP
    3260 = "RGHTN-4RFYY-WRP4D-8RPJH-94R7G" # Core, Win 10 RTM Core OEM:NONSLP
    3260 = "TH4GN-T267P-HW64M-R934Y-7MHX6" # Core, Win 10 RTM Core OEM:NONSLP
    3260 = "VBJPB-NVV3Y-3XGWX-79GDQ-MDWVG" # Core, Win 10 RTM Core OEM:NONSLP
    3260 = "WKCWW-NJ6F4-QY687-Q697X-H6DDT" # Core, Win 10 RTM Core OEM:NONSLP
    3260 = "WWV8W-G3NHT-DBH8Y-W89DW-BWQ96" # Core, Win 10 RTM Core OEM:NONSLP
    3260 = "XFJNR-BJP8F-CXTDY-CKXVB-XBT3T" # Core, Win 10 RTM Core OEM:NONSLP
    3260 = "XMMFN-TD6HD-TBXTY-67X9K-BKMK6" # Core, Win 10 RTM Core OEM:NONSLP
    3261 = "2WYPR-GMN23-BYCHW-6P6WD-QRR7H" # Core, Win 10 RTM Core Retail
    3261 = "3FRD4-PN4FD-PHYHF-KGHHB-HT9QV" # Core, Win 10 RTM Core Retail
    3261 = "3GPKB-3NFTF-V2J24-3G379-P37X7" # Core, Win 10 RTM Core Retail
    3261 = "63NVD-Y7XX3-642J2-63X97-XD7X7" # Core, Win 10 RTM Core Retail
    3261 = "6YBN7-DRWHP-9DGM8-9QGYX-JXCHH" # Core, Win 10 RTM Core Retail
    3261 = "73YR4-2NMVX-C36BW-FFT8W-4VVX7" # Core, Win 10 RTM Core Retail
    3261 = "7NKR2-TRXHY-Y49MV-T6K67-RGDDV" # Core, Win 10 RTM Core Retail
    3261 = "7NTYY-D9WFT-CFQ7M-TQ7BG-RRG3V" # Core, Win 10 RTM Core Retail
    3261 = "8B37D-RNHVM-WVCYD-DQYMY-WHVX7" # Core, Win 10 RTM Core Retail
    3261 = "BFB6N-Y7G4Y-26XDY-HF8M7-RGDDV" # Core, Win 10 RTM Core Retail
    3261 = "CN9G3-XTMBM-MRB7W-7B7RT-J2QDV" # Core, Win 10 RTM Core Retail
    3261 = "DFGNR-8GY3W-H9CMC-XC2XP-TMT3V" # Core, Win 10 RTM Core Retail
    3261 = "DFHNB-3XWWQ-CQM4R-TMYDY-X4R7H" # Core, Win 10 RTM Core Retail
    3261 = "DFMNP-T7H4J-CVQM9-YGVHC-P9XQV" # Core, Win 10 RTM Core Retail
    3261 = "DNJ2Y-6X8M2-427WB-BYV3T-6F397" # Core, Win 10 RTM Core Retail
    3261 = "FPT94-RYN7F-FDPHR-7BJFY-7MHX7" # Core, Win 10 RTM Core Retail
    3261 = "FQPCY-WKN6F-F4GY4-YKWXY-3GPHH" # Core, Win 10 RTM Core Retail
    3261 = "GNMCG-KPDQT-Q7Q8P-H8XJR-X2D97" # Core, Win 10 RTM Core Retail
    3261 = "GNPD8-RRDHT-DXVFW-BQX4M-CWF7H" # Core, Win 10 RTM Core Retail
    3261 = "GNVCR-FJMMK-HT2MG-4GX6D-XHJVH" # Core, Win 10 RTM Core Retail
    3261 = "GTG6N-FD6KX-D3JH6-76FFR-3DBK7" # Core, Win 10 RTM Core Retail
    3261 = "HC9QN-HRPCH-JPHFW-B86FF-CR397" # Core, Win 10 RTM Core Retail
    3261 = "HXQDV-NR47Q-98XPH-TGBKD-8K8VH" # Core, Win 10 RTM Core Retail
    3261 = "KCXVN-QMP3X-7QXWF-GCV8M-3GPHH" # Core, Win 10 RTM Core Retail
    3261 = "KN3X6-K4RRD-YCP6Q-GFM9R-3DBK7" # Core, Win 10 RTM Core Retail
    3261 = "KN3XY-CC4P3-RQ7C4-C3M6Q-PYT3V" # Core, Win 10 RTM Core Retail
    3261 = "KN429-7YH9J-D3267-HYGJ9-H6DDV" # Core, Win 10 RTM Core Retail
    3261 = "KN434-GGD7R-CRVRT-T8V42-VFR7H" # Core, Win 10 RTM Core Retail
    3261 = "KN7CY-DXHPX-J8FHF-JXTFF-CR397" # Core, Win 10 RTM Core Retail
    3261 = "N94GW-JYR9B-8HRVC-3MQMG-237X7" # Core, Win 10 RTM Core Retail
    3261 = "NCCR6-2Y7BJ-X3CDD-B3RXQ-VXMK7" # Core, Win 10 RTM Core Retail
    3261 = "NH8F4-J7V3Y-FQD3Q-62W9T-FVVX7" # Core, Win 10 RTM Core Retail
    3261 = "NK2FB-XR23F-JJTTJ-62QWW-J8F7H" # Core, Win 10 RTM Core Retail
    3261 = "NTMHQ-4CJCX-7DT2P-BQY2C-FX8VH" # Core, Win 10 RTM Core Retail
    3261 = "PNX2M-CCXYM-7XD4Q-Y64GX-BKMK7" # Core, Win 10 RTM Core Retail
    3261 = "PWXYG-PN3HF-MMRRM-C889H-B7VX7" # Core, Win 10 RTM Core Retail
    3261 = "Q3NGT-DKTD4-TYMGV-WH8WG-4M47H" # Core, Win 10 RTM Core Retail
    3261 = "R6BTJ-8GNTW-D2M9P-9FD7H-3J3DV" # Core, Win 10 RTM Core Retail
    3261 = "RN9X7-BPRXD-WVJ64-PH4BB-FGDDV" # Core, Win 10 RTM Core Retail
    3261 = "RNG48-KX3KD-9FPHQ-KX9W9-H6DDV" # Core, Win 10 RTM Core Retail
    3261 = "TPRN8-XBWGX-TK6QT-GKKMD-7T9QV" # Core, Win 10 RTM Core Retail
    3261 = "TWQ83-XNWTG-6VBQM-CCG6V-46YK7" # Core, Win 10 RTM Core Retail
    3261 = "TYHBN-6WH2C-FVDFX-HGQJ3-TCQDV" # Core, Win 10 RTM Core Retail
    3261 = "V2NM3-WC8RQ-2DHKF-MCYMK-H6DDV" # Core, Win 10 RTM Core Retail
    3261 = "VGNQJ-CTWDV-9BVFK-44M7Q-XHJVH" # Core, Win 10 RTM Core Retail
    3261 = "VGXTQ-WNTR4-KXCPV-8CM4M-6VJVH" # Core, Win 10 RTM Core Retail
    3261 = "VHYBV-NH32R-QJ4W6-223GK-7XMK7" # Core, Win 10 RTM Core Retail
    3261 = "VYGFN-CVBRX-X9YQP-HPJ3C-JB47H" # Core, Win 10 RTM Core Retail
    3261 = "W4PNH-3YKQF-HGFCP-XF9G2-TMT3V" # Core, Win 10 RTM Core Retail
    3261 = "W6FHY-QTNMM-X4T3P-JJGRB-KD7X7" # Core, Win 10 RTM Core Retail
    3261 = "W6HNM-KR2HH-W6K2W-3TDGP-7CD97" # Core, Win 10 RTM Core Retail
    3261 = "WFVYR-D2NQG-723TB-D9C96-9KXQV" # Core, Win 10 RTM Core Retail
    3261 = "WT7Q7-HNQXJ-8F3V2-T2P6M-B4G3V" # Core, Win 10 RTM Core Retail
    3261 = "Y328N-PHM76-GWPXF-47KG3-49CHH" # Core, Win 10 RTM Core Retail
    3261 = "Y8HCN-JG3JQ-X7XQX-W7RYR-K4R7H" # Core, Win 10 RTM Core Retail
    3261 = "YBNGR-CBV9T-76QTC-F8T8D-B98VH" # Core, Win 10 RTM Core Retail
    3261 = "YFF6N-MPKKJ-WXQ8H-2WWG7-RGDDV" # Core, Win 10 RTM Core Retail
    3261 = "YG62W-VBNPP-VTW9Q-Q3WRW-JFG3V" # Core, Win 10 RTM Core Retail
    3261 = "YG9VN-2WDKG-WF8J4-7RTXW-78Q97" # Core, Win 10 RTM Core Retail
    3261 = "YGDJJ-FNX9T-WMCPC-YC8MD-H22HH" # Core, Win 10 RTM Core Retail
    3261 = "YQBYC-6JN6W-22GXB-KH43W-BWQ97" # Core, Win 10 RTM Core Retail
    3261 = "YTMG3-N6DKC-DKB77-7M9GH-8HVX7" # Core, Win 10 RTM Core Retail
    3262 = "9TMNP-6GTTJ-DQF6X-RR68K-GJF7J" # Core, Win 10 RTM Core Retail
    3262 = "HNM8K-CK43C-JR9D9-PTGV3-JTYK8" # Core, Win 10 RTM Core Retail
    3262 = "M4Y2N-3G47M-HQ7GH-BHGPF-X2D98" # Core, Win 10 RTM Core Retail
    3262 = "VTRMB-NMG7J-4QKPT-VJ9TH-X763W" # Core, Win 10 RTM Core Retail
    3262 = "WJCTN-YMDWK-BDVBM-G8T77-YY47J" # Core, Win 10 RTM Core Retail
    3262 = "WKPKN-YBMB2-KVQ9F-H2XCW-9TPHJ" # Core, Win 10 RTM Core Retail
    3263 = "33QT6-RCNYF-DXB4F-DGP7B-7MHX9" # Core, Win 10 RTM Core Volume:GVLK
    3263 = "TX9XD-98N7V-6WMQ6-BX7FG-H8Q99" # Core, Win 10 RTM Core Volume:GVLK
    3264 = "29WPG-VNTBP-293DQ-DVR2V-FJRBB" # CoreCountrySpecific, Win 10 RTM CoreCountrySpecific OEM:DM
    3264 = "2G7KY-NC34D-KV27M-T4GWM-R6YMB" # CoreCountrySpecific, Win 10 RTM CoreCountrySpecific OEM:DM
    3264 = "4NMT4-HB48K-RFR8K-TVTRQ-9D7YB" # CoreCountrySpecific, Win 10 RTM CoreCountrySpecific OEM:DM
    3264 = "7B6NC-V3438-TRQG7-8TCCX-H6DDY" # CoreCountrySpecific, Win 10 RTM CoreCountrySpecific OEM:DM
    3264 = "7Q2BN-4JVQ4-76M8H-D3QF7-XD7YB" # CoreCountrySpecific, Win 10 RTM CoreCountrySpecific OEM:DM
    3264 = "82DMY-NGKV6-YYJ98-8HPY2-XTPHM" # CoreCountrySpecific, Win 10 RTM CoreCountrySpecific OEM:DM
    3264 = "CJT62-7TNTH-6JCHF-CHM2V-PWF7M" # CoreCountrySpecific, Win 10 RTM CoreCountrySpecific OEM:DM
    3264 = "GC2HC-XWNXB-9QVTY-XV8C4-2KCHM" # CoreCountrySpecific, Win 10 RTM CoreCountrySpecific OEM:DM
    3264 = "GKY2V-BN9DX-436PD-FK3PF-X2FBB" # CoreCountrySpecific, Win 10 RTM CoreCountrySpecific OEM:DM
    3264 = "HB6YC-3NYTP-3RRW4-HXPPT-683DY" # CoreCountrySpecific, Win 10 RTM CoreCountrySpecific OEM:DM
    3264 = "HMN4B-X8XB6-HG4PD-MKMYY-K763Y" # CoreCountrySpecific, Win 10 RTM CoreCountrySpecific OEM:DM
    3264 = "HYNWR-MVXJX-6PJHM-BQRHT-RRG3Y" # CoreCountrySpecific, Win 10 RTM CoreCountrySpecific OEM:DM
    3264 = "MNHR4-M463D-M8943-J783K-6CQDY" # CoreCountrySpecific, Win 10 RTM CoreCountrySpecific OEM:DM
    3264 = "N6M3Y-HWT69-B886F-TMPFR-R3KQY" # CoreCountrySpecific, Win 10 RTM CoreCountrySpecific OEM:DM
    3264 = "TMYNM-76HXQ-6BJBF-78X8H-6XXQY" # CoreCountrySpecific, Win 10 RTM CoreCountrySpecific OEM:DM
    3264 = "WT33N-7KFCT-6PJ3M-4VGM7-6XXQY" # CoreCountrySpecific, Win 10 RTM CoreCountrySpecific OEM:DM
    3264 = "Y9D2N-8G4P4-7BCRG-MK77Q-M7VYB" # CoreCountrySpecific, Win 10 RTM CoreCountrySpecific OEM:DM
    3264 = "YN79T-WVGKW-B83DY-7V74T-BP2HM" # CoreCountrySpecific, Win 10 RTM CoreCountrySpecific OEM:DM
    3265 = "4T6DD-KNB6K-9QV69-MB8GK-DYHYC" # CoreCountrySpecific, Win 10 RTM CoreCountrySpecific OEM:NONSLP
    3265 = "68WP7-N2JMW-B676K-WR24Q-9D7YC" # CoreCountrySpecific, Win 10 RTM CoreCountrySpecific OEM:NONSLP
    3265 = "6ND8M-JX7KK-K29VW-H6D88-Q69Q2" # CoreCountrySpecific, Win 10 RTM CoreCountrySpecific OEM:NONSLP
    3265 = "92FN7-DMCHB-GQXFP-PR3H4-9W3D2" # CoreCountrySpecific, Win 10 RTM CoreCountrySpecific OEM:NONSLP
    3265 = "9GNJJ-DMCCH-J66PX-WCGMF-KBT32" # CoreCountrySpecific, Win 10 RTM CoreCountrySpecific OEM:NONSLP
    3265 = "9NFRD-HQQ7R-X3C7M-68B6G-WXCHP" # CoreCountrySpecific, Win 10 RTM CoreCountrySpecific OEM:NONSLP
    3265 = "M2N96-46V9F-8P3PP-V9MT7-2R4BC" # CoreCountrySpecific, Win 10 RTM CoreCountrySpecific OEM:NONSLP
    3265 = "MGY4W-DXN7K-838GJ-44M6D-7T9Q2" # CoreCountrySpecific, Win 10 RTM CoreCountrySpecific OEM:NONSLP
    3265 = "MNM8Y-C332H-8QKD7-HCQXF-K4R7P" # CoreCountrySpecific, Win 10 RTM CoreCountrySpecific OEM:NONSLP
    3265 = "RBPVT-NJ672-TCHWV-Y798M-MY47P" # CoreCountrySpecific, Win 10 RTM CoreCountrySpecific OEM:NONSLP
    3265 = "WGKWM-HXNRK-YFMP8-BFHBX-YDWVP" # CoreCountrySpecific, Win 10 RTM CoreCountrySpecific OEM:NONSLP
    3265 = "XRTMN-66H4W-GD3K8-V93BK-XKXQ2" # CoreCountrySpecific, Win 10 RTM CoreCountrySpecific OEM:NONSLP
    3266 = "7KXMW-8N7GT-TVJQX-F9KD6-HFR7Q" # CoreCountrySpecific, Win 10 RTM CoreCountrySpecific Retail
    3266 = "8FF7X-7NV38-8YXYT-23WH4-CR4BD" # CoreCountrySpecific, Win 10 RTM CoreCountrySpecific Retail
    3266 = "GX7WN-2W37Y-W3R6F-RJYRM-6VJVQ" # CoreCountrySpecific, Win 10 RTM CoreCountrySpecific Retail
    3266 = "J43QF-MNFC2-8YX8Q-H8VKV-94R7Q" # CoreCountrySpecific, Win 10 RTM CoreCountrySpecific Retail
    3266 = "JNMYF-GG4M9-X9BFY-87FT8-TQ7YD" # CoreCountrySpecific, Win 10 RTM CoreCountrySpecific Retail
    3266 = "N2434-X9D7W-8PF6X-8DV9T-8TYMD" # CoreCountrySpecific, Win 10 RTM CoreCountrySpecific Retail
    3266 = "Q2YFK-8FNJ3-WTPRD-7Q4BV-9BT33" # CoreCountrySpecific, Win 10 RTM CoreCountrySpecific Retail
    3266 = "X6J7D-TN6P6-BRPVD-DFDQM-XBT33" # CoreCountrySpecific, Win 10 RTM CoreCountrySpecific Retail
    3266 = "XYX6H-8NGPP-9DMC2-R3BM9-KQBMD" # CoreCountrySpecific, Win 10 RTM CoreCountrySpecific Retail
    3267 = "JN9HR-MH7K4-DBPDD-TFTXF-Q9MMF" # CoreCountrySpecific, Win 10 RTM CoreCountrySpecific Volume:GVLK
    3267 = "PVMJN-6DFY6-9CCP6-7BKTT-D3WVR" # CoreCountrySpecific, Win 10 RTM CoreCountrySpecific Volume:GVLK
    3268 = "22324-FN7V3-8V6VT-XF87K-RM47T" # CoreN, Win 10 RTM CoreN OEM:DM
    3268 = "2BJKM-PKNR6-QJKDB-773F7-HXMMG" # CoreN, Win 10 RTM CoreN OEM:DM
    3268 = "33CY4-NPKCC-V98JP-42G8W-VH636" # CoreN, Win 10 RTM CoreN OEM:DM
    3268 = "34WMX-7NV29-GCXJX-TPHXB-VQWVT" # CoreN, Win 10 RTM CoreN OEM:DM
    3268 = "39BN2-FR8MB-CTFK3-V7B7F-369Q6" # CoreN, Win 10 RTM CoreN OEM:DM
    3268 = "39JVP-BN72R-V7YQK-3PD2C-VFR7T" # CoreN, Win 10 RTM CoreN OEM:DM
    3268 = "3HPMV-69NWF-3DRFG-BGBHD-RJRBG" # CoreN, Win 10 RTM CoreN OEM:DM
    3268 = "3HT3D-MN7HX-8K27D-QMM37-JQKQ6" # CoreN, Win 10 RTM CoreN OEM:DM
    3268 = "4XKB3-CN8G6-M9HBH-R3GYB-39MMG" # CoreN, Win 10 RTM CoreN OEM:DM
    3268 = "6BN8P-W446Y-G7BK6-Q34X9-HCFBG" # CoreN, Win 10 RTM CoreN OEM:DM
    3268 = "6N3KD-DD7PR-FKKBH-JG3YX-BKMMG" # CoreN, Win 10 RTM CoreN OEM:DM
    3268 = "6PWN4-9D86H-G47W8-J9VFJ-HMHYG" # CoreN, Win 10 RTM CoreN OEM:DM
    3268 = "76N4H-7M4D3-QKDMR-4KKH3-BG9Q6" # CoreN, Win 10 RTM CoreN OEM:DM
    3268 = "7KWY4-2NQW6-CQ6M2-2RQ9X-9HJVT" # CoreN, Win 10 RTM CoreN OEM:DM
    3268 = "9MT66-DNGWQ-48FPD-TQHJC-XTPHT" # CoreN, Win 10 RTM CoreN OEM:DM
    3268 = "B9H4N-38JYF-3XY33-QPVD4-YTDD6" # CoreN, Win 10 RTM CoreN OEM:DM
    3268 = "BNKG6-96G3C-4HWG8-468M3-GF4BG" # CoreN, Win 10 RTM CoreN OEM:DM
    3268 = "C2FCN-9YQPG-QJP3R-MF4XT-8TYMG" # CoreN, Win 10 RTM CoreN OEM:DM
    3268 = "CKWNM-DJK49-QYCWT-VP2R2-4RG36" # CoreN, Win 10 RTM CoreN OEM:DM
    3268 = "DP982-GN4MH-D8PCP-6RJBH-4C2HT" # CoreN, Win 10 RTM CoreN OEM:DM
    3268 = "F2NFY-D4KMV-TQR7Y-V3K3R-JHVYG" # CoreN, Win 10 RTM CoreN OEM:DM
    3268 = "F8PXD-G9NM6-YR8FR-6TMYQ-BG9Q6" # CoreN, Win 10 RTM CoreN OEM:DM
    3268 = "FHN6M-B7FTV-DGC97-K7F98-82QD6" # CoreN, Win 10 RTM CoreN OEM:DM
    3268 = "FTXYN-HFX89-BD3GK-VBYY6-VCFBG" # CoreN, Win 10 RTM CoreN OEM:DM
    3268 = "FVHHX-GFNGX-PJJHM-H6KTM-B4G36" # CoreN, Win 10 RTM CoreN OEM:DM
    3268 = "GJW76-WNM7Q-P6RK9-RQJXD-FM47T" # CoreN, Win 10 RTM CoreN OEM:DM
    3268 = "H79JQ-87NDB-D3Y3T-GDJGV-B7VYG" # CoreN, Win 10 RTM CoreN OEM:DM
    3268 = "H9TTN-VGX68-6WX86-KJT7B-7MHYG" # CoreN, Win 10 RTM CoreN OEM:DM
    3268 = "HJWRN-H7DPH-CJDQ9-R487F-JHVYG" # CoreN, Win 10 RTM CoreN OEM:DM
    3268 = "HN8HJ-PCTFX-K4X3W-YM8D9-TF4BG" # CoreN, Win 10 RTM CoreN OEM:DM
    3268 = "HNB99-KKKXK-Y69TM-8782Q-3PFBG" # CoreN, Win 10 RTM CoreN OEM:DM
    3268 = "HWHWG-NTQXK-6PPB7-VKXMM-88F7T" # CoreN, Win 10 RTM CoreN OEM:DM
    3268 = "KHNKF-J6BBY-YK8BC-HMQ86-WXCHT" # CoreN, Win 10 RTM CoreN OEM:DM
    3268 = "KN7J6-3BQFW-29TFD-2TG98-F3KQ6" # CoreN, Win 10 RTM CoreN OEM:DM
    3268 = "KN8B8-8BG9P-XCXDJ-HWGFB-YWRBG" # CoreN, Win 10 RTM CoreN OEM:DM
    3268 = "KRNTD-QJ66K-W9GTD-TMY9G-TJF7T" # CoreN, Win 10 RTM CoreN OEM:DM
    3268 = "KW9QN-PQXBX-C24PY-23YXX-KQBMG" # CoreN, Win 10 RTM CoreN OEM:DM
    3268 = "MCWRC-6QNM6-GJYWP-JMR8V-HXMMG" # CoreN, Win 10 RTM CoreN OEM:DM
    3268 = "MH7XR-N4T8K-2F6CQ-D4GMV-QPFBG" # CoreN, Win 10 RTM CoreN OEM:DM
    3268 = "N4W9V-KBQWC-XQM46-MJYDJ-33WVT" # CoreN, Win 10 RTM CoreN OEM:DM
    3268 = "N8DVK-WHQR7-WFRBG-82XQ8-K2FBG" # CoreN, Win 10 RTM CoreN OEM:DM
    3268 = "NCTJJ-RVFR8-DK2M6-4MDR6-9KXQ6" # CoreN, Win 10 RTM CoreN OEM:DM
    3268 = "NFCDV-7XHPJ-9J2V2-4J8W7-X7636" # CoreN, Win 10 RTM CoreN OEM:DM
    3268 = "NHBGK-XPJP2-4TKJ6-RRR2V-PWF7T" # CoreN, Win 10 RTM CoreN OEM:DM
    3268 = "NJ84D-FDTW2-4GWYC-J4G2Y-VQWVT" # CoreN, Win 10 RTM CoreN OEM:DM
    3268 = "NMX7M-7233W-6962R-K6GX6-V6DD6" # CoreN, Win 10 RTM CoreN OEM:DM
    3268 = "NPW4D-8DK99-VT9WM-9K2CM-8FG36" # CoreN, Win 10 RTM CoreN OEM:DM
    3268 = "NQTH4-KK96T-T4W27-KYP3C-JB47T" # CoreN, Win 10 RTM CoreN OEM:DM
    3268 = "NWQBX-QDCCJ-GWWXV-H8J9T-FVVYG" # CoreN, Win 10 RTM CoreN OEM:DM
    3268 = "PCPB6-8N2D2-YCKBQ-RBHTV-VT9Q6" # CoreN, Win 10 RTM CoreN OEM:DM
    3268 = "PGCJN-V6CCD-KDFPM-HGTC7-VT9Q6" # CoreN, Win 10 RTM CoreN OEM:DM
    3268 = "PRC3N-RPM29-FF7JV-9V3HK-HCFBG" # CoreN, Win 10 RTM CoreN OEM:DM
    3268 = "PVNPJ-T4WWX-6WK66-DKP3R-369Q6" # CoreN, Win 10 RTM CoreN OEM:DM
    3268 = "Q2GQD-G3N76-KWQMV-KFQRQ-QRR7T" # CoreN, Win 10 RTM CoreN OEM:DM
    3268 = "QNVKK-4TW4H-VGPHW-7MPTQ-PYT36" # CoreN, Win 10 RTM CoreN OEM:DM
    3268 = "RTKX8-KN2HT-MKRKG-3BK3X-RM47T" # CoreN, Win 10 RTM CoreN OEM:DM
    3268 = "T3M8N-WBQ3R-G8WP7-MMCHR-844BG" # CoreN, Win 10 RTM CoreN OEM:DM
    3268 = "T3QCY-BND4M-CXJFF-6QBG7-94R7T" # CoreN, Win 10 RTM CoreN OEM:DM
    3268 = "TJ6TN-FHXJG-YGKX9-3TQ7D-G83D6" # CoreN, Win 10 RTM CoreN OEM:DM
    3268 = "TNCQH-C7P33-VG3FM-882K3-97636" # CoreN, Win 10 RTM CoreN OEM:DM
    3268 = "TR8V6-X3N8K-X6263-KWD88-Q69Q6" # CoreN, Win 10 RTM CoreN OEM:DM
    3268 = "VHJVF-HYNDP-F99W3-V7M4F-K4R7T" # CoreN, Win 10 RTM CoreN OEM:DM
    3268 = "VJ9TN-XPWV7-HPC8T-92YQ4-F6YMG" # CoreN, Win 10 RTM CoreN OEM:DM
    3268 = "VXW7P-QKN37-XTGGH-4DRTM-43KQ6" # CoreN, Win 10 RTM CoreN OEM:DM
    3268 = "XCKHW-NTX8X-JM9DB-FP6HC-FX8VT" # CoreN, Win 10 RTM CoreN OEM:DM
    3268 = "XF3MQ-NQQ6R-9RBJ3-VFFBJ-CPQD6" # CoreN, Win 10 RTM CoreN OEM:DM
    3268 = "XHH47-38NK7-4G3VV-Q3YRP-76DD6" # CoreN, Win 10 RTM CoreN OEM:DM
    3268 = "XV48N-GJ8VM-3QFDV-Q6WDQ-RJRBG" # CoreN, Win 10 RTM CoreN OEM:DM
    3268 = "Y7FPN-7XMB9-MHP4H-X64GB-X4R7T" # CoreN, Win 10 RTM CoreN OEM:DM
    3269 = "6QGCQ-NDBF6-QVG9Q-4B799-RM47V" # CoreN, Win 10 RTM CoreN OEM:NONSLP
    3269 = "FNYQ6-7MJJH-MHBWT-HWTQG-8TYMH" # CoreN, Win 10 RTM CoreN OEM:NONSLP
    3269 = "HNPWH-7Q7P8-GFH79-GKKD3-DV637" # CoreN, Win 10 RTM CoreN OEM:NONSLP
    3269 = "JQTWJ-NCQQD-XDD7P-F278F-HQWVV" # CoreN, Win 10 RTM CoreN OEM:NONSLP
    3269 = "M3WYN-36MC4-FP8M4-PC73X-MG9Q7" # CoreN, Win 10 RTM CoreN OEM:NONSLP
    3269 = "MHNVF-QFCDJ-HBR7Y-RJ6TB-BBHYH" # CoreN, Win 10 RTM CoreN OEM:NONSLP
    3269 = "NPYGM-T4JGM-RBDJC-KVRBM-F9CHV" # CoreN, Win 10 RTM CoreN OEM:NONSLP
    3269 = "PGGM7-N77TC-KVR98-D82KJ-DGPHV" # CoreN, Win 10 RTM CoreN OEM:NONSLP
    3269 = "PGXBY-RHNHX-P2BBF-8QHKT-4M47V" # CoreN, Win 10 RTM CoreN OEM:NONSLP
    3269 = "Q7R6P-FNW74-H4FP9-V8GG4-HQWVV" # CoreN, Win 10 RTM CoreN OEM:NONSLP
    3269 = "T8RV8-G9NDF-P3KYY-6QQB7-94R7V" # CoreN, Win 10 RTM CoreN OEM:NONSLP
    3269 = "TJ4JT-NPRW3-RKQXD-MY3F4-FC2HV" # CoreN, Win 10 RTM CoreN OEM:NONSLP
    3269 = "VRBNY-WGYMJ-V32HB-96J7W-GVJVV" # CoreN, Win 10 RTM CoreN OEM:NONSLP
    3270 = "22CW3-WXNPV-F7DYJ-BGXDF-MWRBJ" # CoreN, Win 10 RTM CoreN Retail
    3270 = "4CPRK-NM3K3-X6XXQ-RXX86-WXCHW" # CoreN, Win 10 RTM CoreN Retail
    3270 = "6NJ93-4YVHJ-C884K-38X3F-DJ3D8" # CoreN, Win 10 RTM CoreN Retail
    3270 = "7C2NP-7MHC9-DD62H-JJQDH-2R4BJ" # CoreN, Win 10 RTM CoreN Retail
    3270 = "8J8RJ-NCJGX-YDVVC-QPXYD-M7VYJ" # CoreN, Win 10 RTM CoreN Retail
    3270 = "9NJHV-KTFQX-WH62R-8JGCG-Y98VW" # CoreN, Win 10 RTM CoreN Retail
    3270 = "HDCHQ-FNTQ6-XRP3B-RM84V-MBHYJ" # CoreN, Win 10 RTM CoreN Retail
    3270 = "K2NTV-4XTJY-7FC94-7C9HH-DRR7W" # CoreN, Win 10 RTM CoreN Retail
    3270 = "KFTH7-Q7N7H-PBG89-DVKPM-FGDD8" # CoreN, Win 10 RTM CoreN Retail
    3270 = "KN6V4-GPDQY-HYMV2-M38RK-T83D8" # CoreN, Win 10 RTM CoreN Retail
    3270 = "NMDXC-PVJBP-QPKKJ-T7R8G-4M47W" # CoreN, Win 10 RTM CoreN Retail
    3270 = "PYT28-42NKJ-X68MD-2RBRC-27JVW" # CoreN, Win 10 RTM CoreN Retail
    3270 = "TGWNR-T88HF-DKKP7-Y8Y88-GVJVW" # CoreN, Win 10 RTM CoreN Retail
    3270 = "WN9JT-82JJM-F72Y8-FTKGY-WHVYJ" # CoreN, Win 10 RTM CoreN Retail
    3270 = "WQYK8-KNT22-VGQK3-GQQY2-76DD8" # CoreN, Win 10 RTM CoreN Retail
    3271 = "6RDKC-FNJ4G-FV3F9-WXVYF-844BK" # CoreN, Win 10 RTM CoreN Retail
    3271 = "DVBWF-NFKRB-H98XB-JD8YT-XQBMK" # CoreN, Win 10 RTM CoreN Retail
    3271 = "GGNMY-7PCGW-CRFM9-Y36CW-9TPHX" # CoreN, Win 10 RTM CoreN Retail
    3271 = "N7VJK-VHCXC-9CDCH-7YKHR-YTDD9" # CoreN, Win 10 RTM CoreN Retail
    3271 = "QDTCN-F22MP-3FPD9-XY3VD-97639" # CoreN, Win 10 RTM CoreN Retail
    3271 = "XR8RN-MGCR7-R4QXC-9HK9T-8TYMK" # CoreN, Win 10 RTM CoreN Retail
    3272 = "3KHY7-WNT83-DGQKR-F7HPR-844BM" # CoreN, Win 10 RTM CoreN Volume:GVLK
    3272 = "CP4KF-NG6TC-9K6QF-P6GTT-H8RBM" # CoreN, Win 10 RTM CoreN Volume:GVLK
    3273 = "3NFM9-8HB7J-79VHX-2KXMD-XHJV2" # CoreSingleLanguage, Win 10 RTM CoreSingleLanguage OEM:DM
    3273 = "3NQ62-T2KDP-GBGWJ-VC3B7-WK8V2" # CoreSingleLanguage, Win 10 RTM CoreSingleLanguage OEM:DM
    3273 = "4BWNY-YRQYR-VX24J-HRTWR-X2FBP" # CoreSingleLanguage, Win 10 RTM CoreSingleLanguage OEM:DM
    3273 = "4WVW8-N6FCK-KRYHQ-M367X-DYHYP" # CoreSingleLanguage, Win 10 RTM CoreSingleLanguage OEM:DM
    3273 = "68NBD-KD2XT-PGR79-BM8QY-TXXRC" # CoreSingleLanguage, Win 10 RTM CoreSingleLanguage OEM:DM
    3273 = "9X3DN-VGTCM-B4VV6-29VBJ-WB472" # CoreSingleLanguage, Win 10 RTM CoreSingleLanguage OEM:DM
    3273 = "B8HXJ-GKN7Q-B9FTG-T7HWP-4RG4C" # CoreSingleLanguage, Win 10 RTM CoreSingleLanguage OEM:DM
    3273 = "BBHB3-GNRMD-48PJ9-QKYKJ-7FR72" # CoreSingleLanguage, Win 10 RTM CoreSingleLanguage OEM:DM
    3273 = "GXN9C-9G2DB-C2H6F-CG4QY-39MMP" # CoreSingleLanguage, Win 10 RTM CoreSingleLanguage OEM:DM
    3273 = "HFNYM-Y6YPJ-BHP6X-3VTHJ-VH64C" # CoreSingleLanguage, Win 10 RTM CoreSingleLanguage OEM:DM
    3273 = "HGV9R-FNVTF-MQQPJ-VQPWG-VCFBP" # CoreSingleLanguage, Win 10 RTM CoreSingleLanguage OEM:DM
    3273 = "N6PVF-VVYCJ-KH8HC-YCDTR-CR4BP" # CoreSingleLanguage, Win 10 RTM CoreSingleLanguage OEM:DM
    3273 = "NTRHT-XTHTG-GBWCG-4MTMP-HH64C" # CoreSingleLanguage, Win 10 RTM CoreSingleLanguage OEM:DM
    3273 = "TNBBG-X29DX-PF28B-MTH32-CKCH2" # CoreSingleLanguage, Win 10 RTM CoreSingleLanguage OEM:DM
    3273 = "TNYB9-P84KB-VM2T6-YQC3Y-BBHYP" # CoreSingleLanguage, Win 10 RTM CoreSingleLanguage OEM:DM
    3273 = "TYXWC-VNTQ7-6YMHK-PR6XH-VT9RC" # CoreSingleLanguage, Win 10 RTM CoreSingleLanguage OEM:DM
    3273 = "WH2CN-CV37J-RBD3H-7V4HM-X4R72" # CoreSingleLanguage, Win 10 RTM CoreSingleLanguage OEM:DM
    3273 = "XJCJT-YXNCB-G68HM-WXGWP-VFR72" # CoreSingleLanguage, Win 10 RTM CoreSingleLanguage OEM:DM
    3273 = "XNV7F-4MC2J-Q24WR-RGP7G-CGYMP" # CoreSingleLanguage, Win 10 RTM CoreSingleLanguage OEM:DM
    3273 = "XT9TP-N6M8P-R4PYD-MHB6X-FRG4C" # CoreSingleLanguage, Win 10 RTM CoreSingleLanguage OEM:DM
    3274 = "4DJYP-2NVY6-R2GJ9-PBMDV-DRR73" # CoreSingleLanguage, Win 10 RTM CoreSingleLanguage OEM:DM
    3274 = "6QKBJ-8N99P-BCFXF-BR9BR-K4R73" # CoreSingleLanguage, Win 10 RTM CoreSingleLanguage OEM:DM
    3274 = "7N977-4C3F2-KRQYD-J3T8J-PKCH3" # CoreSingleLanguage, Win 10 RTM CoreSingleLanguage OEM:DM
    3274 = "9CNGY-6GWHC-XGMT6-77GXH-VT9RD" # CoreSingleLanguage, Win 10 RTM CoreSingleLanguage OEM:DM
    3274 = "FQ36C-4ND2C-4B977-DVQ32-KW3FD" # CoreSingleLanguage, Win 10 RTM CoreSingleLanguage OEM:DM
    3274 = "H2WVQ-N82CJ-VHGPK-J77MJ-K2FBQ" # CoreSingleLanguage, Win 10 RTM CoreSingleLanguage OEM:DM
    3274 = "HN3B3-X9PC6-GDTBF-T6M43-C37YQ" # CoreSingleLanguage, Win 10 RTM CoreSingleLanguage OEM:DM
    3274 = "M2382-NCG6C-PGBJV-2D6VV-T3BMQ" # CoreSingleLanguage, Win 10 RTM CoreSingleLanguage OEM:DM
    3274 = "M66NY-3BVW3-DVBPQ-CQ3C7-B7VYQ" # CoreSingleLanguage, Win 10 RTM CoreSingleLanguage OEM:DM
    3274 = "MTP4X-N26Y3-69V49-HT8YX-4JRBQ" # CoreSingleLanguage, Win 10 RTM CoreSingleLanguage OEM:DM
    3274 = "QXMHD-T8NFY-J2P3W-CPVHP-KW3FD" # CoreSingleLanguage, Win 10 RTM CoreSingleLanguage OEM:DM
    3274 = "V36XB-NDXCJ-PMGXD-XRYQQ-9764D" # CoreSingleLanguage, Win 10 RTM CoreSingleLanguage OEM:DM
    3274 = "XM9N2-JYHQP-MTP8H-X89BH-BDWV3" # CoreSingleLanguage, Win 10 RTM CoreSingleLanguage OEM:DM
    3274 = "YN4MQ-MQR6P-QWT6F-9BGVP-V8RBQ" # CoreSingleLanguage, Win 10 RTM CoreSingleLanguage OEM:DM
    3274 = "YRD24-NDX6K-Q92J9-42HP6-H8RBQ" # CoreSingleLanguage, Win 10 RTM CoreSingleLanguage OEM:DM
    3275 = "4PN9J-CYGQ9-GG23D-YQH87-JQKRF" # CoreSingleLanguage, Win 10 RTM CoreSingleLanguage OEM:NONSLP
    3275 = "4TNKC-664XB-XDYF8-CR74Y-HT9RF" # CoreSingleLanguage, Win 10 RTM CoreSingleLanguage OEM:NONSLP
    3275 = "96GT9-N299H-9HBTB-9H6WW-82QFF" # CoreSingleLanguage, Win 10 RTM CoreSingleLanguage OEM:NONSLP
    3275 = "C6HQY-NDPTB-B8V8D-BKY6X-FRG4F" # CoreSingleLanguage, Win 10 RTM CoreSingleLanguage OEM:NONSLP
    3275 = "DH2NC-P6PBY-XB7MT-WBF9Q-Y4G4F" # CoreSingleLanguage, Win 10 RTM CoreSingleLanguage OEM:NONSLP
    3275 = "DNFFR-VMJRX-GQRV8-D76WX-HCFBR" # CoreSingleLanguage, Win 10 RTM CoreSingleLanguage OEM:NONSLP
    3275 = "FNR2C-V6GDR-PDVKM-VG6MD-7T9RF" # CoreSingleLanguage, Win 10 RTM CoreSingleLanguage OEM:NONSLP
    3275 = "GH37Y-TNG7X-PP2TK-CMRMT-D3WV4" # CoreSingleLanguage, Win 10 RTM CoreSingleLanguage OEM:NONSLP
    3275 = "HG3NG-MWJ6W-XVT8D-Y9HD8-GVJV4" # CoreSingleLanguage, Win 10 RTM CoreSingleLanguage OEM:NONSLP
    3275 = "N6M8W-86432-PTDYD-943D8-WB474" # CoreSingleLanguage, Win 10 RTM CoreSingleLanguage OEM:NONSLP
    3275 = "PNC83-QYTFB-R3MD8-G96GT-PDKRF" # CoreSingleLanguage, Win 10 RTM CoreSingleLanguage OEM:NONSLP
    3275 = "RNWQJ-2JWM6-C7V2C-9HQWQ-RJRBR" # CoreSingleLanguage, Win 10 RTM CoreSingleLanguage OEM:NONSLP
    3275 = "VP8TQ-B4NC6-D2D27-VV9TF-844BR" # CoreSingleLanguage, Win 10 RTM CoreSingleLanguage OEM:NONSLP
    3275 = "WKVNQ-M8TFY-72JB7-DGDP3-PYT4F" # CoreSingleLanguage, Win 10 RTM CoreSingleLanguage OEM:NONSLP
    3276 = "84YR8-NY984-KPXFV-PWDB7-CYT4G" # CoreSingleLanguage, Win 10 RTM CoreSingleLanguage Retail
    3276 = "89DNY-M3VP8-CB7JK-3QGBC-Q3WV6" # CoreSingleLanguage, Win 10 RTM CoreSingleLanguage Retail
    3276 = "B2C7P-MN9Y4-4F9W4-PFR6X-8QKRG" # CoreSingleLanguage, Win 10 RTM CoreSingleLanguage Retail
    3276 = "BT79Q-G7N6G-PGBYW-4YWX6-6F4BT" # CoreSingleLanguage, Win 10 RTM CoreSingleLanguage Retail
    3276 = "FWW6F-BMN4Y-VJ2C2-D3XKH-VT9RG" # CoreSingleLanguage, Win 10 RTM CoreSingleLanguage Retail
    3276 = "KN773-HKQCT-MVBPM-JRFMG-237YT" # CoreSingleLanguage, Win 10 RTM CoreSingleLanguage Retail
    3276 = "NQKWP-F47YJ-V43H4-QPCX7-DRR76" # CoreSingleLanguage, Win 10 RTM CoreSingleLanguage Retail
    3276 = "RGN8P-66G78-QBGVD-VY73P-FX8V6" # CoreSingleLanguage, Win 10 RTM CoreSingleLanguage Retail
    3276 = "W86ND-FTRMC-7F9HM-486GP-7CFBT" # CoreSingleLanguage, Win 10 RTM CoreSingleLanguage Retail
    3277 = "7HNRX-D7KGG-3K4RQ-4WPJ4-YTDFH" # CoreSingleLanguage, Win 10 RTM CoreSingleLanguage Volume:GVLK
    3277 = "9HGRW-NH2CQ-XQHJD-YCRWB-6VJV7" # CoreSingleLanguage, Win 10 RTM CoreSingleLanguage Volume:GVLK
    3278 = "3WFXN-BKYG9-WGVPV-66V4F-WFG4J" # Education, Win 10 RTM Education OEM:DM
    3278 = "8GPT9-GNYFG-CJVY8-9BBGV-VT9RJ" # Education, Win 10 RTM Education OEM:DM
    3278 = "B3NJP-H76KG-WGPG2-8WJQY-TXXRJ" # Education, Win 10 RTM Education OEM:DM
    3278 = "B6GMV-NJ4P4-PXJ9C-3JQ86-MKMMW" # Education, Win 10 RTM Education OEM:DM
    3278 = "DBVQ7-8N2X7-47FG9-GQ9PY-43KRJ" # Education, Win 10 RTM Education OEM:DM
    3278 = "HMFN6-8M96P-XKR6W-8FH4T-J2QFJ" # Education, Win 10 RTM Education OEM:DM
    3278 = "J9JGX-3VNQ7-QR86Y-GDPP9-YDWV8" # Education, Win 10 RTM Education OEM:DM
    3278 = "K8XQY-KN4WM-KDT29-VXVJW-J8F78" # Education, Win 10 RTM Education OEM:DM
    3278 = "KBTN3-KHBDD-K2XBW-4FYQD-KKXRJ" # Education, Win 10 RTM Education OEM:DM
    3278 = "N9BYX-9TGXH-XCGG2-GKCR8-BWRBW" # Education, Win 10 RTM Education OEM:DM
    3278 = "P8MVM-NFQMH-HM7QM-KQXY9-QV64J" # Education, Win 10 RTM Education OEM:DM
    3278 = "QRP8G-JNKV9-98H69-GWDRG-PDKRJ" # Education, Win 10 RTM Education OEM:DM
    3278 = "T973N-7DY9V-DG9MF-G3BFM-K764J" # Education, Win 10 RTM Education OEM:DM
    3279 = "DNWTT-PXGKJ-2K96V-B789W-33WV9" # Education, Win 10 RTM Education OEM:NONSLP
    3279 = "F8NYP-GYGDR-8C6BC-9FHMJ-K2FBX" # Education, Win 10 RTM Education OEM:NONSLP
    3279 = "P84V3-NVW96-R27W2-CBMTR-K4R79" # Education, Win 10 RTM Education OEM:NONSLP
    3280 = "2FFH9-N92RX-R222K-7YCBV-B7VYY" # Education, Win 10 RTM Education Retail
    3280 = "2JKQN-H82F4-M7DRD-89G7T-HFR8B" # Education, Win 10 RTM Education Retail
    3280 = "2KKN9-PV2KK-QJPHR-KRH8C-PGYMY" # Education, Win 10 RTM Education Retail
    3280 = "2NCBG-M2XX3-B4YMG-HVV6R-Q9MMY" # Education, Win 10 RTM Education Retail
    3280 = "2R6XM-KNQC6-798XD-YV8K3-C37YY" # Education, Win 10 RTM Education Retail
    3280 = "2RNH6-MY3K8-682B9-GW8BC-KW3FM" # Education, Win 10 RTM Education Retail
    3280 = "3D8VV-MMNM7-CFRHH-3M6CP-KW3FM" # Education, Win 10 RTM Education Retail
    3280 = "3NQ4Q-VB8JQ-K9B3M-96T3F-3DBMY" # Education, Win 10 RTM Education Retail
    3280 = "3XFYC-YN792-HV76R-P93XR-MWRBY" # Education, Win 10 RTM Education Retail
    3280 = "4P3NX-4C2PR-PKQFB-P6D8C-TMT4M" # Education, Win 10 RTM Education Retail
    3280 = "6NDBM-3HP48-KJMTX-BY298-YP2JB" # Education, Win 10 RTM Education Retail
    3280 = "6TKG8-2NK2T-D7YRX-MFR2Y-YWRBY" # Education, Win 10 RTM Education Retail
    3280 = "7287N-H8TRG-QRPCQ-93632-2DKRM" # Education, Win 10 RTM Education Retail
    3280 = "7HRGF-NY9PG-FVQTD-83WPT-WXCJB" # Education, Win 10 RTM Education Retail
    3280 = "7VNGR-4KPQH-TJGWQ-MTX2D-RJRBY" # Education, Win 10 RTM Education Retail
    3280 = "8TN92-GW43F-K4FWY-MWFK2-VFR8B" # Education, Win 10 RTM Education Retail
    3280 = "8YJN4-Q4RGJ-T8RGP-3QVFW-33WWB" # Education, Win 10 RTM Education Retail
    3280 = "96HN2-3VGYT-HT3MF-GQJYY-WHVYY" # Education, Win 10 RTM Education Retail
    3280 = "9NJCK-3BFY8-TCXGJ-VYPHH-7QWWB" # Education, Win 10 RTM Education Retail
    3280 = "9NRYB-M2KYW-HMBWC-VXCDC-JB48B" # Education, Win 10 RTM Education Retail
    3280 = "9TGFF-NTV84-D2QVB-XK3T6-FVVYY" # Education, Win 10 RTM Education Retail
    3280 = "B9NJM-WT3JD-HVWFC-PD2C9-8QKRM" # Education, Win 10 RTM Education Retail
    3280 = "BTDBB-8NHY8-24BJ7-32KJQ-WQKRM" # Education, Win 10 RTM Education Retail
    3280 = "C7XKC-N8RJ6-J34CQ-7CY3M-3GPJB" # Education, Win 10 RTM Education Retail
    3280 = "CG4RQ-8PN7X-GPTXX-89MVM-BBHYY" # Education, Win 10 RTM Education Retail
    3280 = "FB96X-PNJR3-Q8KYD-XJP89-3RR8B" # Education, Win 10 RTM Education Retail
    3280 = "FPRPN-X9HX8-K63RC-43MRH-B7VYY" # Education, Win 10 RTM Education Retail
    3280 = "G2JX3-VNG3H-WP76V-DRGCJ-F3KRM" # Education, Win 10 RTM Education Retail
    3280 = "GY267-W9NCP-3VR2G-DFYX3-RJRBY" # Education, Win 10 RTM Education Retail
    3280 = "H42RV-8N8YX-HVP99-VPRR6-CGYMY" # Education, Win 10 RTM Education Retail
    3280 = "H687P-J4NXT-64HG4-DGY64-R3KRM" # Education, Win 10 RTM Education Retail
    3280 = "H8JDN-TW4WP-WVQMM-M8PDG-J2QFM" # Education, Win 10 RTM Education Retail
    3280 = "HDCXN-7HRWX-MP6MW-CD6RM-6VJWB" # Education, Win 10 RTM Education Retail
    3280 = "HMYF4-DNPV9-QCQPD-D4DH4-K4R8B" # Education, Win 10 RTM Education Retail
    3280 = "HN78M-8GMKX-RH4T2-3YW6V-KHJWB" # Education, Win 10 RTM Education Retail
    3280 = "HNRXR-CVJWH-GVRKM-X72C3-JTYMY" # Education, Win 10 RTM Education Retail
    3280 = "HPNDT-4FV74-PYJXK-Y4MY2-D69RM" # Education, Win 10 RTM Education Retail
    3280 = "HXNG6-PFVTC-Q8VRX-XGHJJ-33WWB" # Education, Win 10 RTM Education Retail
    3280 = "JBHWN-87F26-VJ22P-V3B2H-HXMMY" # Education, Win 10 RTM Education Retail
    3280 = "JNMJ6-GWFV9-4FDC8-2HQFC-27JWB" # Education, Win 10 RTM Education Retail
    3280 = "K7MXN-7TC4M-P3PYD-7PQ9H-9BT4M" # Education, Win 10 RTM Education Retail
    3280 = "KMM7C-T4N48-K772F-XYK4Y-DPFBY" # Education, Win 10 RTM Education Retail
    3280 = "KWT46-QJNX8-DWYW6-RTD27-B7VYY" # Education, Win 10 RTM Education Retail
    3280 = "MNGWP-6D72Q-JT2HQ-FJ6Q3-XHJWB" # Education, Win 10 RTM Education Retail
    3280 = "MP2Y9-PNVY2-KVH4X-BXT26-D3WWB" # Education, Win 10 RTM Education Retail
    3280 = "MTWNT-JWK4R-D2WB8-972D9-DYHYY" # Education, Win 10 RTM Education Retail
    3280 = "MWNYY-4XKM6-BYX4G-WFTM8-JFG4M" # Education, Win 10 RTM Education Retail
    3280 = "N4G3D-VDGJ7-G984D-F7QM8-TQ7YY" # Education, Win 10 RTM Education Retail
    3280 = "N4JVH-DY6PV-4Q4XB-RVQ2V-BDWWB" # Education, Win 10 RTM Education Retail
    3280 = "N63FF-HW738-Q88RG-FJK64-MWRBY" # Education, Win 10 RTM Education Retail
    3280 = "N6PB9-4236B-PDM2K-B4THH-7QWWB" # Education, Win 10 RTM Education Retail
    3280 = "N9FPJ-F72HH-9BV2P-F9XHQ-H22JB" # Education, Win 10 RTM Education Retail
    3280 = "NBRV3-RGX4H-97GYG-W997J-VH64M" # Education, Win 10 RTM Education Retail
    3280 = "ND2HJ-F8YWQ-93Q9F-26YK8-VH64M" # Education, Win 10 RTM Education Retail
    3280 = "NV4W3-THJ3C-62W4W-B3HTH-FJRBY" # Education, Win 10 RTM Education Retail
    3280 = "NXH3V-P3J4M-YKBPM-8BW3R-8B48B" # Education, Win 10 RTM Education Retail
    3280 = "PDK3K-KNGRR-8Y9T7-9DTT6-P7JWB" # Education, Win 10 RTM Education Retail
    3280 = "PJN24-BQC3G-Q2P4V-D2VDT-V6DFM" # Education, Win 10 RTM Education Retail
    3280 = "PKN2F-3MXJX-PB3WJ-X7Q9X-V22JB" # Education, Win 10 RTM Education Retail
    3280 = "PKPND-WQRFR-DH6WP-6T4HT-WXCJB" # Education, Win 10 RTM Education Retail
    3280 = "PN76P-B9VQR-D996V-7D4QV-3J3FM" # Education, Win 10 RTM Education Retail
    3280 = "PT3N7-CYHX6-8FPDY-X4QGF-4X8WB" # Education, Win 10 RTM Education Retail
    3280 = "PYBGV-N94P6-PB79J-87RQ7-BDWWB" # Education, Win 10 RTM Education Retail
    3280 = "QC8XT-78NRW-V6KGG-9JJ3K-Y7VYY" # Education, Win 10 RTM Education Retail
    3280 = "QCRHQ-NPHW6-27HMR-G8C2R-KBT4M" # Education, Win 10 RTM Education Retail
    3280 = "QMNRV-HRQGF-CG99P-Q4Q2D-2WF8B" # Education, Win 10 RTM Education Retail
    3280 = "R3JV9-6MN2Q-JQT74-JMQ82-GQ7YY" # Education, Win 10 RTM Education Retail
    3280 = "R69NW-RJPDJ-6KG4G-HKY4R-DJ3FM" # Education, Win 10 RTM Education Retail
    3280 = "RCVQB-9NCYY-HCTRP-93CXB-B4G4M" # Education, Win 10 RTM Education Retail
    3280 = "RHH7B-G8NHX-XCJPH-XHRF2-P9XRM" # Education, Win 10 RTM Education Retail
    3280 = "RP9BR-7NGJK-BF7QB-7YD89-DYHYY" # Education, Win 10 RTM Education Retail
    3280 = "T6M27-HHNPJ-V3RB7-TCBGK-7XMMY" # Education, Win 10 RTM Education Retail
    3280 = "T8TBC-NBXPD-4KK4B-GYPR6-QYHYY" # Education, Win 10 RTM Education Retail
    3280 = "T9GPH-NMRV3-BHBP4-H28C9-4JRBY" # Education, Win 10 RTM Education Retail
    3280 = "TDNKQ-C99X9-DMRGJ-XGCWJ-JFG4M" # Education, Win 10 RTM Education Retail
    3280 = "TVYND-8PBDT-TQTPQ-VT3VJ-4VVYY" # Education, Win 10 RTM Education Retail
    3280 = "TWTQC-WN4RR-FRFP9-QJ9R9-MG9RM" # Education, Win 10 RTM Education Retail
    3280 = "VK4HN-B6XKW-J6RKX-FQHQ4-VMHYY" # Education, Win 10 RTM Education Retail
    3280 = "VTTJ9-C7NQ3-3B4HW-YJ86F-BY48B" # Education, Win 10 RTM Education Retail
    3280 = "VYDRN-8FFYG-6KTHW-7P8BF-VMHYY" # Education, Win 10 RTM Education Retail
    3280 = "W6JFN-WCTJ9-9G96V-Q2QH2-RVVYY" # Education, Win 10 RTM Education Retail
    3280 = "X8HC2-NBHJ7-VHH9M-YMD43-WQKRM" # Education, Win 10 RTM Education Retail
    3280 = "X988V-NRBMW-7FRYK-KGFFV-6XXRM" # Education, Win 10 RTM Education Retail
    3280 = "XBH6H-QNVRB-QKHW4-HPBGD-7T9RM" # Education, Win 10 RTM Education Retail
    3280 = "XJ6N6-73J6J-WD969-D7CB3-VXMMY" # Education, Win 10 RTM Education Retail
    3280 = "XMM3V-NYK4X-V8V44-TGQBV-GCQFM" # Education, Win 10 RTM Education Retail
    3280 = "XN2TH-FV4QP-HM9JC-PP6YX-YDWWB" # Education, Win 10 RTM Education Retail
    3280 = "XN9GY-C7KVX-P28MW-JF6XH-VT9RM" # Education, Win 10 RTM Education Retail
    3280 = "XX37N-33FPJ-PJFFG-7WVQW-J8F8B" # Education, Win 10 RTM Education Retail
    3280 = "YNMGQ-8RYV3-4PGQ3-C8XTP-7CFBY" # Education, Win 10 RTM Education Retail
    3280 = "YNXGW-DH8WG-43Q7X-PR76T-H8RBY" # Education, Win 10 RTM Education Retail
    3281 = "F48BJ-8NX82-MRVY9-PF8BW-HMHY2" # Education, Win 10 RTM Education Volume:GVLK
    3281 = "NW6C2-QMPVW-D7KKK-3GKT6-VCFB2" # Education, Win 10 RTM Education Volume:GVLK
    3282 = "3NGVC-W8MG2-THR8Q-YTDDH-G6PJD" # Education, Win 10 RTM Education Volume:MAK
    3282 = "4GWCJ-NYXHT-3PPMC-Q9MCC-J44B3" # Education, Win 10 RTM Education Volume:MAK
    3282 = "86B93-BNKGR-8MYM7-V83BD-XHJWD" # Education, Win 10 RTM Education Volume:MAK
    3282 = "9QKPB-NV4XR-H3JD7-F336F-BY48D" # Education, Win 10 RTM Education Volume:MAK
    3282 = "9YQP3-N367H-CB4YR-4R2KT-P7JWD" # Education, Win 10 RTM Education Volume:MAK
    3282 = "CGNP9-KFP3C-FPBX6-2R4WD-B98WD" # Education, Win 10 RTM Education Volume:MAK
    3282 = "FX2TT-HGNTQ-2XFKR-FBY67-RGDFQ" # Education, Win 10 RTM Education Volume:MAK
    3282 = "GQBV4-JYN8F-TR99K-V9JPG-Y98WD" # Education, Win 10 RTM Education Volume:MAK
    3282 = "J24RN-WB323-PCYPT-8J8X4-FC2JD" # Education, Win 10 RTM Education Volume:MAK
    3282 = "JTYNQ-D7RXR-23JKV-M3QTX-8QKRQ" # Education, Win 10 RTM Education Volume:MAK
    3282 = "M6GNG-6RRJD-M4VDQ-8K8VW-CPQFQ" # Education, Win 10 RTM Education Volume:MAK
    3282 = "NCHYW-W9P2G-RW847-Q4VHV-BDWWD" # Education, Win 10 RTM Education Volume:MAK
    3282 = "NFD8K-TDM7C-7CVTC-8JKP6-3V64Q" # Education, Win 10 RTM Education Volume:MAK
    3282 = "NG8GB-PRKDX-K6FMJ-4PT47-HXMM3" # Education, Win 10 RTM Education Volume:MAK
    3282 = "NHK7B-F3BDF-42JVF-QXQP3-PYT4Q" # Education, Win 10 RTM Education Volume:MAK
    3282 = "NWGHQ-MWB7V-RWBVX-GRWK7-DRR8D" # Education, Win 10 RTM Education Volume:MAK
    3282 = "QJGRK-CNMBD-GYF9K-RW8M3-GF4B3" # Education, Win 10 RTM Education Volume:MAK
    3282 = "QX3PN-THY2K-X9KPB-2W6PT-683FQ" # Education, Win 10 RTM Education Volume:MAK
    3282 = "RN7DD-C3WDD-BPBTH-Q34MP-HH64Q" # Education, Win 10 RTM Education Volume:MAK
    3282 = "TMNBK-3YQQV-PQQFQ-JVKT3-KKXRQ" # Education, Win 10 RTM Education Volume:MAK
    3283 = "DM2KN-J8JPJ-6VD2F-QPB9D-PYT4R" # EducationN, Win 10 RTM EducationN OEM:DM
    3283 = "G3NDH-4B69M-9DQWK-BMBWC-PGYM4" # EducationN, Win 10 RTM EducationN OEM:DM
    3283 = "GPD27-N7P3R-KB999-JWB7W-WB48F" # EducationN, Win 10 RTM EducationN OEM:DM
    3283 = "HYVNT-498GD-3FHKT-76HDV-M4G4R" # EducationN, Win 10 RTM EducationN OEM:DM
    3283 = "JGN9H-28H2K-DX3T6-XPQ7G-KTPJF" # EducationN, Win 10 RTM EducationN OEM:DM
    3283 = "JR9RG-GKNM3-GBW8C-X9893-2WF8F" # EducationN, Win 10 RTM EducationN OEM:DM
    3283 = "K4GTR-NTMW9-DG63T-G9R7W-CPQFR" # EducationN, Win 10 RTM EducationN OEM:DM
    3283 = "N7D4B-D4MJM-7PY9M-JBFGV-VT9RR" # EducationN, Win 10 RTM EducationN OEM:DM
    3283 = "T9GNW-2WKYM-KC92M-DCM9T-YG9RR" # EducationN, Win 10 RTM EducationN OEM:DM
    3283 = "T9HYM-TFNC2-HHBP3-FB9P7-B7VY4" # EducationN, Win 10 RTM EducationN OEM:DM
    3283 = "TX72N-9YCF8-V9382-CT8KG-H8RB4" # EducationN, Win 10 RTM EducationN OEM:DM
    3283 = "VD7N4-MR9PG-BGQM9-B269F-GXXRR" # EducationN, Win 10 RTM EducationN OEM:DM
    3284 = "9KKNJ-YRMWP-R7K4K-Y2B94-JHVY6" # EducationN, Win 10 RTM EducationN OEM:NONSLP
    3284 = "HX3NQ-H4XT7-RHBXY-KYH7G-CGYM6" # EducationN, Win 10 RTM EducationN OEM:NONSLP
    3284 = "NT4CF-K26Y7-BBKBT-7CMJ3-M7VY6" # EducationN, Win 10 RTM EducationN OEM:NONSLP
    3285 = "279DP-NP3BJ-626G7-238QW-BWRB7" # EducationN, Win 10 RTM EducationN Retail
    3285 = "2MN3W-FDHQC-6RXHD-T3XK4-FC2JH" # EducationN, Win 10 RTM EducationN Retail
    3285 = "2N77G-HG89J-JK6DR-FD4VR-4X8WH" # EducationN, Win 10 RTM EducationN Retail
    3285 = "2PNKX-78KYP-B24X8-BQYF6-9KXRV" # EducationN, Win 10 RTM EducationN Retail
    3285 = "36HKB-NYB4H-X4CDG-7RFX4-TVJWH" # EducationN, Win 10 RTM EducationN Retail
    3285 = "37PGN-R92CV-T37D6-G7733-TCQFV" # EducationN, Win 10 RTM EducationN Retail
    3285 = "3NR8Y-GF6BG-MFBP8-88K8G-BP2JH" # EducationN, Win 10 RTM EducationN Retail
    3285 = "3PN68-JCVVQ-JDMDJ-3Q4XD-T6PJH" # EducationN, Win 10 RTM EducationN Retail
    3285 = "3V79N-WCPDG-CPC6Y-YMWH6-PDKRV" # EducationN, Win 10 RTM EducationN Retail
    3285 = "4N6XT-G8HT4-G9FYT-T3RG7-RGDFV" # EducationN, Win 10 RTM EducationN Retail
    3285 = "4QH2Q-NDXWP-623KQ-BG3R4-PPQFV" # EducationN, Win 10 RTM EducationN Retail
    3285 = "66TN7-8J4HW-BQWWD-G2R6D-DV64V" # EducationN, Win 10 RTM EducationN Retail
    3285 = "6CWVN-QCD7Y-P49VJ-M3JQD-KKXRV" # EducationN, Win 10 RTM EducationN Retail
    3285 = "73YPN-4PPWX-6DP2B-WKQDC-76DFV" # EducationN, Win 10 RTM EducationN Retail
    3285 = "7GJCN-24V3M-FHCBP-9K9CV-FJRB7" # EducationN, Win 10 RTM EducationN Retail
    3285 = "7VN72-KJXKT-79Q9W-PHTXW-XW3FV" # EducationN, Win 10 RTM EducationN Retail
    3285 = "7VNTW-PY974-4H4XH-9QFMP-W2QFV" # EducationN, Win 10 RTM EducationN Retail
    3285 = "84NGF-MHBT6-FXBX8-QWJK7-DRR8H" # EducationN, Win 10 RTM EducationN Retail
    3285 = "8GPDN-WP4TP-23JDB-BF9CF-JHVY7" # EducationN, Win 10 RTM EducationN Retail
    3285 = "8H7NV-TDDMF-VWWM8-QXFCT-683FV" # EducationN, Win 10 RTM EducationN Retail
    3285 = "8VNMK-6JJKX-4XJCB-TBR2J-F3KRV" # EducationN, Win 10 RTM EducationN Retail
    3285 = "9NVCG-R6XF3-VYB4R-R2MV6-D3WWH" # EducationN, Win 10 RTM EducationN Retail
    3285 = "9RPCH-N72XG-7KW4X-QB7M4-DJ3FV" # EducationN, Win 10 RTM EducationN Retail
    3285 = "9XG78-VNMP8-CB3TT-K6CR4-TVJWH" # EducationN, Win 10 RTM EducationN Retail
    3285 = "B88VX-N8G62-X9FCM-J9QC9-4JRB7" # EducationN, Win 10 RTM EducationN Retail
    3285 = "B8WN4-J77KP-X4JC3-KYM43-MDWWH" # EducationN, Win 10 RTM EducationN Retail
    3285 = "BG9YJ-KMNXJ-4FWK8-KR3H9-BKMM7" # EducationN, Win 10 RTM EducationN Retail
    3285 = "BQ4FN-3794Q-8R8QC-KFYT7-94R8H" # EducationN, Win 10 RTM EducationN Retail
    3285 = "BVNHW-749G9-3JW38-3TWW2-KW3FV" # EducationN, Win 10 RTM EducationN Retail
    3285 = "CNFP3-3X4BG-VCP92-W78DG-J2QFV" # EducationN, Win 10 RTM EducationN Retail
    3285 = "CRND9-4JK4T-4WPFM-PM47V-4C2JH" # EducationN, Win 10 RTM EducationN Retail
    3285 = "CVKKW-CRNH8-FPFYQ-RHP3P-J44B7" # EducationN, Win 10 RTM EducationN Retail
    3285 = "D9NHC-WD98H-D2XFD-7FVYH-BDWWH" # EducationN, Win 10 RTM EducationN Retail
    3285 = "DB69P-NQ8B3-WXYCT-KBGRJ-W44B7" # EducationN, Win 10 RTM EducationN Retail
    3285 = "DCQNT-HM2X8-2347J-X4BMT-3V64V" # EducationN, Win 10 RTM EducationN Retail
    3285 = "DNPG2-PTHMR-BVC7F-M9PXC-RVVY7" # EducationN, Win 10 RTM EducationN Retail
    3285 = "DNW47-MGGVW-WK67X-MRP3H-94R8H" # EducationN, Win 10 RTM EducationN Retail
    3285 = "FFPNR-W93H9-6VMTM-KR7PR-4X8WH" # EducationN, Win 10 RTM EducationN Retail
    3285 = "FK43N-HYY8W-WBR68-9PM24-9W3FV" # EducationN, Win 10 RTM EducationN Retail
    3285 = "FNVBR-XV4RX-VV436-29MHJ-J8F8H" # EducationN, Win 10 RTM EducationN Retail
    3285 = "FWNJ7-8FYWP-MYJWK-4RWJ9-M98WH" # EducationN, Win 10 RTM EducationN Retail
    3285 = "G2N6F-RTRB9-R4VDM-Y2D8Q-63BM7" # EducationN, Win 10 RTM EducationN Retail
    3285 = "GF6VN-PJRR4-2PXXQ-8VTWY-FGDFV" # EducationN, Win 10 RTM EducationN Retail
    3285 = "GJC9N-YFMC2-R4BJQ-FVMKW-78RB7" # EducationN, Win 10 RTM EducationN Retail
    3285 = "GNCC9-KWVJ2-QCBQY-Y64VP-CKCJH" # EducationN, Win 10 RTM EducationN Retail
    3285 = "GRRHN-98CD8-HDM2D-2T4YQ-JTYM7" # EducationN, Win 10 RTM EducationN Retail
    3285 = "GVX3Y-NRFH4-F7GF3-C2C6R-9W3FV" # EducationN, Win 10 RTM EducationN Retail
    3285 = "GVXGN-F8DX3-XJP2G-T9PX7-3J3FV" # EducationN, Win 10 RTM EducationN Retail
    3285 = "HDJ2N-XMV29-8YQYW-PVVXC-HH64V" # EducationN, Win 10 RTM EducationN Retail
    3285 = "HP3V7-N3R9Y-7RWBP-CPHW9-7XMM7" # EducationN, Win 10 RTM EducationN Retail
    3285 = "J7DGK-2NX4X-CT8FG-C4TP7-YY48H" # EducationN, Win 10 RTM EducationN Retail
    3285 = "JH4VN-8QP97-THCKD-JYW8D-QRR8H" # EducationN, Win 10 RTM EducationN Retail
    3285 = "JHMNC-CC8KB-68D74-G734X-GJF8H" # EducationN, Win 10 RTM EducationN Retail
    3285 = "JQ4DV-N36TG-VYQGD-CXKW6-MKMM7" # EducationN, Win 10 RTM EducationN Retail
    3285 = "KHXN2-DPGH3-DJTV2-Y2QPR-VMHY7" # EducationN, Win 10 RTM EducationN Retail
    3285 = "KQNM6-6DVQF-CTTFB-PVVBD-TCQFV" # EducationN, Win 10 RTM EducationN Retail
    3285 = "KVH7N-M2XDB-VXV2P-VGKMP-7CFB7" # EducationN, Win 10 RTM EducationN Retail
    3285 = "KW4MN-K7BT3-J8H32-62YF4-JHVY7" # EducationN, Win 10 RTM EducationN Retail
    3285 = "M76NC-RC996-FQBF6-BCF6V-KHJWH" # EducationN, Win 10 RTM EducationN Retail
    3285 = "MDBQM-GHNFT-8JBDF-3FCHF-X2FB7" # EducationN, Win 10 RTM EducationN Retail
    3285 = "MGJJT-6ND2C-BY6MF-684XJ-RX8WH" # EducationN, Win 10 RTM EducationN Retail
    3285 = "MNCP8-3THFY-KF7RB-THGMW-HMHY7" # EducationN, Win 10 RTM EducationN Retail
    3285 = "MQ6XN-YDXR6-2JDKF-QY43V-HXMM7" # EducationN, Win 10 RTM EducationN Retail
    3285 = "MRGBF-DNVQP-Y9YQJ-JK6DF-HQWWH" # EducationN, Win 10 RTM EducationN Retail
    3285 = "N7DW2-C97DX-RCG7P-XFFTM-QJ3FV" # EducationN, Win 10 RTM EducationN Retail
    3285 = "N7XX7-JVWTH-XRVF8-MY7YV-VT9RV" # EducationN, Win 10 RTM EducationN Retail
    3285 = "N86D2-7VDP4-XP96W-PYCPP-Q3WWH" # EducationN, Win 10 RTM EducationN Retail
    3285 = "N8GDC-KPBTF-WGG6T-3QP9F-2KCJH" # EducationN, Win 10 RTM EducationN Retail
    3285 = "NF6BK-JHJVK-3WQVF-3PK7G-KTPJH" # EducationN, Win 10 RTM EducationN Retail
    3285 = "NG4WR-HY8H2-MYPYY-RF36P-MP2JH" # EducationN, Win 10 RTM EducationN Retail
    3285 = "NGB6R-KQJ4K-96F3W-3KBBC-9QBM7" # EducationN, Win 10 RTM EducationN Retail
    3285 = "NHR93-7MJT2-XM3XD-CBCKH-GCQFV" # EducationN, Win 10 RTM EducationN Retail
    3285 = "NKVQ4-X8BVJ-77THT-9QB4V-RGDFV" # EducationN, Win 10 RTM EducationN Retail
    3285 = "NMMCV-HT4KW-KYC63-977X3-2WF8H" # EducationN, Win 10 RTM EducationN Retail
    3285 = "NP4J8-6MRX8-RT7VB-KYYKD-PYT4V" # EducationN, Win 10 RTM EducationN Retail
    3285 = "NPYYR-YP9HT-RTX4M-JVYT3-Y4G4V" # EducationN, Win 10 RTM EducationN Retail
    3285 = "NQ6FT-3TV44-FX86M-4D8BT-D3WWH" # EducationN, Win 10 RTM EducationN Retail
    3285 = "NQQBX-CGCXQ-6JC3T-9Y7XK-P37Y7" # EducationN, Win 10 RTM EducationN Retail
    3285 = "NT874-DKQ4C-VGWDB-YQVXP-XTPJH" # EducationN, Win 10 RTM EducationN Retail
    3285 = "NVFFQ-X3Q8Y-VD9FW-MGQ8C-TMT4V" # EducationN, Win 10 RTM EducationN Retail
    3285 = "NYM7J-CRRVT-D232T-748BW-HMHY7" # EducationN, Win 10 RTM EducationN Retail
    3285 = "PCCN2-XHYB7-8QDRX-PP9PJ-82QFV" # EducationN, Win 10 RTM EducationN Retail
    3285 = "PN29B-HYMYV-QGJTC-9M9XQ-49CJH" # EducationN, Win 10 RTM EducationN Retail
    3285 = "PNBJQ-BR7JV-YB4VR-2KBGH-4C2JH" # EducationN, Win 10 RTM EducationN Retail
    3285 = "PNQ6B-XKHDV-P3T7P-69JPQ-DV64V" # EducationN, Win 10 RTM EducationN Retail
    3285 = "PNT4X-9XWWP-44CJW-HYJCF-JHVY7" # EducationN, Win 10 RTM EducationN Retail
    3285 = "PP3RG-RN4GT-6HK89-CPX99-WTYM7" # EducationN, Win 10 RTM EducationN Retail
    3285 = "PQJ8M-NTHJB-988PK-DTP4Q-VXMM7" # EducationN, Win 10 RTM EducationN Retail
    3285 = "PRN76-HTC6Y-84F4C-T8P28-RX8WH" # EducationN, Win 10 RTM EducationN Retail
    3285 = "PRNYW-FRM3W-XCD2H-4KXV8-29XRV" # EducationN, Win 10 RTM EducationN Retail
    3285 = "Q8XQN-CGGWV-HTKQK-PV86X-YDWWH" # EducationN, Win 10 RTM EducationN Retail
    3285 = "QDWTY-C4NB3-666W7-MK89K-BKMM7" # EducationN, Win 10 RTM EducationN Retail
    3285 = "QGN8F-VCF82-DXQ6D-XCBBW-29XRV" # EducationN, Win 10 RTM EducationN Retail
    3285 = "QKDN8-P9K4F-KF83Q-X33XT-4M48H" # EducationN, Win 10 RTM EducationN Retail
    3285 = "QKQJC-D8NYP-WT7F9-YVX6J-CPQFV" # EducationN, Win 10 RTM EducationN Retail
    3285 = "QMNXW-PRF9D-KWTP6-XXW6C-6JF8H" # EducationN, Win 10 RTM EducationN Retail
    3285 = "QND6M-3X76F-JDKDK-R3Q7V-4C2JH" # EducationN, Win 10 RTM EducationN Retail
    3285 = "R6R4K-N6KT3-TCB7H-9WJ7H-XD7Y7" # EducationN, Win 10 RTM EducationN Retail
    3285 = "RFMN3-827TX-CFCVY-WPYFX-GJF8H" # EducationN, Win 10 RTM EducationN Retail
    3285 = "RNTK7-29XC8-H8JD3-R6J7R-VMHY7" # EducationN, Win 10 RTM EducationN Retail
    3285 = "TDQN2-QQK4K-YMXCP-9CVBJ-2GYM7" # EducationN, Win 10 RTM EducationN Retail
    3285 = "TN7JM-48C4P-RP3H4-QYKY3-KKXRV" # EducationN, Win 10 RTM EducationN Retail
    3285 = "TQG4N-C6BCV-BF6CV-XPBGQ-BG9RV" # EducationN, Win 10 RTM EducationN Retail
    3285 = "V4NQM-628RP-9P6CY-CHHBR-CR4B7" # EducationN, Win 10 RTM EducationN Retail
    3285 = "V7N9J-JKV4Y-DW329-YVMH2-MP2JH" # EducationN, Win 10 RTM EducationN Retail
    3285 = "V7V9Y-DMNDD-637Q4-DPMWR-FC2JH" # EducationN, Win 10 RTM EducationN Retail
    3285 = "VDNW4-K8P7J-7PMW4-VVJFT-8TYM7" # EducationN, Win 10 RTM EducationN Retail
    3285 = "VKKTB-WNX8C-7P4V3-886YG-MKMM7" # EducationN, Win 10 RTM EducationN Retail
    3285 = "VMXK3-YBN6Q-YPQDR-H4GG9-QV64V" # EducationN, Win 10 RTM EducationN Retail
    3285 = "VN6HG-8T6Y7-PR8Q7-PYVK6-V6DFV" # EducationN, Win 10 RTM EducationN Retail
    3285 = "VNMQW-6VK2T-7T2C8-D6FPY-YWRB7" # EducationN, Win 10 RTM EducationN Retail
    3285 = "VPTNX-2HT8D-HMF8Q-PY877-9BT4V" # EducationN, Win 10 RTM EducationN Retail
    3285 = "VQBDN-TCPWJ-C8K73-8QJHX-TF4B7" # EducationN, Win 10 RTM EducationN Retail
    3285 = "VY84N-QKMHQ-67WWW-FV392-YKMM7" # EducationN, Win 10 RTM EducationN Retail
    3285 = "W64N9-TJD8G-3WXJ9-R88V4-Q9MM7" # EducationN, Win 10 RTM EducationN Retail
    3285 = "WF7XN-MJGY8-R44R2-2M49B-F9CJH" # EducationN, Win 10 RTM EducationN Retail
    3285 = "WNDB8-889Y9-F7FJ7-2BM4B-43KRV" # EducationN, Win 10 RTM EducationN Retail
    3285 = "WQJ7D-PBNJB-QW9HH-C9JWF-DJ3FV" # EducationN, Win 10 RTM EducationN Retail
    3285 = "WVBJN-Q4DPW-RPMPV-8CGCK-WTYM7" # EducationN, Win 10 RTM EducationN Retail
    3285 = "X4QDG-7PNMJ-TFG64-2TRB6-J2QFV" # EducationN, Win 10 RTM EducationN Retail
    3285 = "XBPKN-P98XT-DGTVP-FT8FY-XBT4V" # EducationN, Win 10 RTM EducationN Retail
    3285 = "XH38N-R2DXM-PBVDY-PW34K-JXCJH" # EducationN, Win 10 RTM EducationN Retail
    3285 = "XRFNF-PT2GH-37PJV-M44K8-4VVY7" # EducationN, Win 10 RTM EducationN Retail
    3285 = "XT3PN-XP9CD-BDF7M-M29DY-FGDFV" # EducationN, Win 10 RTM EducationN Retail
    3285 = "Y49BN-CPMDC-FYRHP-RV6KW-TQ7Y7" # EducationN, Win 10 RTM EducationN Retail
    3285 = "Y8D8N-6XHGY-D3V7X-8648J-78RB7" # EducationN, Win 10 RTM EducationN Retail
    3285 = "Y8YMN-WWV88-4VJT2-CYD9V-94R8H" # EducationN, Win 10 RTM EducationN Retail
    3285 = "YBNKR-82683-G8K9W-VV6DX-RM48H" # EducationN, Win 10 RTM EducationN Retail
    3285 = "YCT8J-N9JVK-V2KYK-CH7DX-RM48H" # EducationN, Win 10 RTM EducationN Retail
    3285 = "YJRP4-WDNXQ-J4W8B-8PB2P-KW3FV" # EducationN, Win 10 RTM EducationN Retail
    3285 = "YNVDJ-RB8JC-G3PY4-233JG-4M48H" # EducationN, Win 10 RTM EducationN Retail
    3285 = "YRTQN-JCFWT-72Q87-4GDBH-8HVY7" # EducationN, Win 10 RTM EducationN Retail
    3286 = "2WH4N-8QGBV-H22JP-CT43Q-MDWWJ" # EducationN, Win 10 RTM EducationN Volume:GVLK
    3286 = "PPWGW-8NW9C-J77Q9-8WHB9-QV64W" # EducationN, Win 10 RTM EducationN Volume:GVLK
    3287 = "2D3PN-8MMQ3-TGYJR-4KPDF-7H64X" # EducationN, Win 10 RTM EducationN Volume:MAK
    3287 = "3QJ27-8N2GD-P9HGM-7TYKV-G6PJK" # EducationN, Win 10 RTM EducationN Volume:MAK
    3287 = "4QN62-H8C7F-JDW9V-YQ6V7-9BT4X" # EducationN, Win 10 RTM EducationN Volume:MAK
    3287 = "7VN96-G3R8F-PPHBV-DVGMV-QPFB9" # EducationN, Win 10 RTM EducationN Volume:MAK
    3287 = "C9XH3-B2NV7-HKKDC-DYYPK-MG9RX" # EducationN, Win 10 RTM EducationN Volume:MAK
    3287 = "FQGNV-X2XKP-T94YQ-GBFCT-237Y9" # EducationN, Win 10 RTM EducationN Volume:MAK
    3287 = "H3M94-NRWYM-H7WCK-T74XG-H8RB9" # EducationN, Win 10 RTM EducationN Volume:MAK
    3287 = "JRWYN-6M9J7-CP2FC-KQ47P-6JF8K" # EducationN, Win 10 RTM EducationN Volume:MAK
    3287 = "JVNYV-6YRVM-GQ2FX-JFPF8-BWRB9" # EducationN, Win 10 RTM EducationN Volume:MAK
    3287 = "MFN9T-42MKQ-XF4VM-MC92T-C9XRX" # EducationN, Win 10 RTM EducationN Volume:MAK
    3287 = "MXNVQ-Q8TR8-RP9YQ-CVF94-FC2JK" # EducationN, Win 10 RTM EducationN Volume:MAK
    3287 = "N2T7D-3RJ8Q-QJ6V6-26F6M-VQWWK" # EducationN, Win 10 RTM EducationN Volume:MAK
    3287 = "N63P7-TWY9H-PM7RK-3TPMC-CKCJK" # EducationN, Win 10 RTM EducationN Volume:MAK
    3287 = "NFCQ2-TJDXD-X6YFX-2JRDM-XBT4X" # EducationN, Win 10 RTM EducationN Volume:MAK
    3287 = "QN79V-RDKJ8-R378G-JTF3F-7H64X" # EducationN, Win 10 RTM EducationN Volume:MAK
    3287 = "R7NF4-FB42P-TMDF8-TKYHG-KTPJK" # EducationN, Win 10 RTM EducationN Volume:MAK
    3287 = "RK3P8-FNTGF-B8338-63JD9-DYHY9" # EducationN, Win 10 RTM EducationN Volume:MAK
    3287 = "RVN3V-VK8W8-CTCP6-CX763-GF4B9" # EducationN, Win 10 RTM EducationN Volume:MAK
    3287 = "VX84N-JDYBF-V79VF-P6YPK-MG9RX" # EducationN, Win 10 RTM EducationN Volume:MAK
    3288 = "2FNJP-6VTR4-P493H-WK8DM-MY48M" # Enterprise, Win 10 RTM Enterprise OEM:DM
    3288 = "6Q3NP-P9X4K-C392Y-WY4QM-MY48M" # Enterprise, Win 10 RTM Enterprise OEM:DM
    3288 = "8G4DR-2N4RK-R6RJH-Y9XJB-CWF8M" # Enterprise, Win 10 RTM Enterprise OEM:DM
    3288 = "8VN4T-VT6KF-JTTPV-BJMH7-QPFCB" # Enterprise, Win 10 RTM Enterprise OEM:DM
    3288 = "9GPBN-9CRWD-X4893-6WPC7-VT9RY" # Enterprise, Win 10 RTM Enterprise OEM:DM
    3288 = "B99Q2-NV9CP-GYQF2-2F3QV-M4G4Y" # Enterprise, Win 10 RTM Enterprise OEM:DM
    3288 = "BQFBB-6N34Y-TJWPY-WC9RG-PDKRY" # Enterprise, Win 10 RTM Enterprise OEM:DM
    3288 = "CQ89X-NPB2V-FYDKC-6VDKC-DDBPB" # Enterprise, Win 10 RTM Enterprise OEM:DM
    3288 = "GPFMN-2W48F-YP3FV-WHBTG-683FY" # Enterprise, Win 10 RTM Enterprise OEM:DM
    3288 = "HNFWK-JGCHR-B4RWK-VVV2K-MG9RY" # Enterprise, Win 10 RTM Enterprise OEM:DM
    3288 = "N3FBK-8V7WF-FT4XF-MR3FV-CYT4Y" # Enterprise, Win 10 RTM Enterprise OEM:DM
    3288 = "NVGV6-J6FGM-7TFK7-VC9DP-8XCJM" # Enterprise, Win 10 RTM Enterprise OEM:DM
    3288 = "PX437-ND23X-QY7GV-G8FCV-8HV2B" # Enterprise, Win 10 RTM Enterprise OEM:DM
    3288 = "Q4B4P-NMXVT-MRTHW-Q98WJ-78RCB" # Enterprise, Win 10 RTM Enterprise OEM:DM
    3288 = "RWTV4-N4BKJ-CT2Y2-HF7VM-TXXRY" # Enterprise, Win 10 RTM Enterprise OEM:DM
    3288 = "WGPNC-FBRQ4-QQDFV-T7W6Y-92FCB" # Enterprise, Win 10 RTM Enterprise OEM:DM
    3288 = "WKYKR-2NHJK-496TK-BMCKJ-DGPJM" # Enterprise, Win 10 RTM Enterprise OEM:DM
    3288 = "WWNBF-8QPVM-WGWV2-939VV-JQKRY" # Enterprise, Win 10 RTM Enterprise OEM:DM
    3288 = "YNRRQ-2TPDJ-W7HCP-3PMTX-YDWWM" # Enterprise, Win 10 RTM Enterprise OEM:DM
    3289 = "3NBT8-F7YTB-DJQDK-PF3V9-YDWWP" # Enterprise, Win 10 RTM Enterprise OEM:NONSLP
    3289 = "4NHPP-3KJPH-28KGH-8MDW3-XHJWP" # Enterprise, Win 10 RTM Enterprise OEM:NONSLP
    3289 = "6DNHQ-MK49H-HMQD9-KKC7R-YTDF2" # Enterprise, Win 10 RTM Enterprise OEM:NONSLP
    3289 = "6H2YJ-NY243-VRYBY-DW966-J2QF2" # Enterprise, Win 10 RTM Enterprise OEM:NONSLP
    3289 = "6HNX2-8WPCG-4YD6C-99G7X-TF4CC" # Enterprise, Win 10 RTM Enterprise OEM:NONSLP
    3289 = "7RNMY-8K82B-FCX9M-PBM6M-88F8P" # Enterprise, Win 10 RTM Enterprise OEM:NONSLP
    3289 = "9DBC7-NPYQG-VGKMJ-G3YW6-C9XR2" # Enterprise, Win 10 RTM Enterprise OEM:NONSLP
    3289 = "9FGDN-62789-F9V2R-VK68M-HT9R2" # Enterprise, Win 10 RTM Enterprise OEM:NONSLP
    3289 = "9GNTV-CRPWR-6BDMW-WTHGH-T3BPC" # Enterprise, Win 10 RTM Enterprise OEM:NONSLP
    3289 = "9K4Q3-XNV7V-QQFFR-DCXGT-H8RCC" # Enterprise, Win 10 RTM Enterprise OEM:NONSLP
    3289 = "9KM4D-NG3DK-9TBK8-6JQ4W-TQ72C" # Enterprise, Win 10 RTM Enterprise OEM:NONSLP
    3289 = "9M3QN-7CPRK-XVVM4-GFXGH-8HV2C" # Enterprise, Win 10 RTM Enterprise OEM:NONSLP
    3289 = "CXFNW-4HWPJ-B72QX-W36BK-M98WP" # Enterprise, Win 10 RTM Enterprise OEM:NONSLP
    3289 = "FJPN2-GBC2B-CKXGD-2KR6W-7FR8P" # Enterprise, Win 10 RTM Enterprise OEM:NONSLP
    3289 = "FRPMP-6DNPH-82MVV-BHKCD-G83F2" # Enterprise, Win 10 RTM Enterprise OEM:NONSLP
    3289 = "FRWCN-FV7YV-M84HG-M34Q7-BDWWP" # Enterprise, Win 10 RTM Enterprise OEM:NONSLP
    3289 = "HQG3W-RVNYW-7MV7T-T6C2M-TXXR2" # Enterprise, Win 10 RTM Enterprise OEM:NONSLP
    3289 = "J3B2N-BGKG8-F4Y28-36HWC-TMT42" # Enterprise, Win 10 RTM Enterprise OEM:NONSLP
    3289 = "JF9NT-7JJCQ-HPKQF-X4PPJ-VH642" # Enterprise, Win 10 RTM Enterprise OEM:NONSLP
    3289 = "JMN29-GCVF9-D7C92-M3YD7-T3BPC" # Enterprise, Win 10 RTM Enterprise OEM:NONSLP
    3289 = "K9H88-6NFR6-TFK6F-VY6PT-WXCJP" # Enterprise, Win 10 RTM Enterprise OEM:NONSLP
    3289 = "KM6DK-VN9Q4-FHBK2-PP2VV-8HV2C" # Enterprise, Win 10 RTM Enterprise OEM:NONSLP
    3289 = "M6Y8X-H8N8Y-PKKFJ-39FWV-R9CJP" # Enterprise, Win 10 RTM Enterprise OEM:NONSLP
    3289 = "MYJVR-HHN9Q-9BJXB-68F7Q-7T9R2" # Enterprise, Win 10 RTM Enterprise OEM:NONSLP
    3289 = "NJMFF-TXKRR-VG2JY-KMV92-FX8WP" # Enterprise, Win 10 RTM Enterprise OEM:NONSLP
    3289 = "NPPFM-238TT-HJHKC-R2CCJ-4VV2C" # Enterprise, Win 10 RTM Enterprise OEM:NONSLP
    3289 = "NT9F9-FXQ3D-6VJRX-YBRC3-BG9R2" # Enterprise, Win 10 RTM Enterprise OEM:NONSLP
    3289 = "NVRRD-FG4TH-V8V63-CHDB4-R3KR2" # Enterprise, Win 10 RTM Enterprise OEM:NONSLP
    3289 = "P39K2-6NQFV-3DRY4-34TPY-43KR2" # Enterprise, Win 10 RTM Enterprise OEM:NONSLP
    3289 = "P3NFB-3DD4J-8BV29-6FGVP-KW3F2" # Enterprise, Win 10 RTM Enterprise OEM:NONSLP
    3289 = "P8MNP-VBFY9-2PGQT-3FBV6-722JP" # Enterprise, Win 10 RTM Enterprise OEM:NONSLP
    3289 = "QNG88-GPCPC-V9FF2-MTCC2-MP2JP" # Enterprise, Win 10 RTM Enterprise OEM:NONSLP
    3289 = "R2CNT-9XPV2-M4PRH-G7D97-XD72C" # Enterprise, Win 10 RTM Enterprise OEM:NONSLP
    3289 = "RGPNR-HXPW8-JJ376-8T3YT-XQBPC" # Enterprise, Win 10 RTM Enterprise OEM:NONSLP
    3289 = "RPJNW-QC3PB-4PP3H-2PGTF-4X8WP" # Enterprise, Win 10 RTM Enterprise OEM:NONSLP
    3289 = "WFVFN-G7DQG-YR6BQ-49F46-CGYPC" # Enterprise, Win 10 RTM Enterprise OEM:NONSLP
    3289 = "WKKYN-2TTTP-2B4V7-MGFHY-YWRCC" # Enterprise, Win 10 RTM Enterprise OEM:NONSLP
    3289 = "XGVPP-NMH47-7TTHJ-W3FW7-8HV2C" # Enterprise, Win 10 RTM Enterprise OEM:NONSLP
    3289 = "XMW6N-FC76F-HMK9T-MW3W6-WXCJP" # Enterprise, Win 10 RTM Enterprise OEM:NONSLP
    3289 = "Y9YPN-6X7VH-HD3JW-T8V6P-DDBPC" # Enterprise, Win 10 RTM Enterprise OEM:NONSLP
    3289 = "YGMXY-HRNYX-HBBVY-MC4YV-9BT42" # Enterprise, Win 10 RTM Enterprise OEM:NONSLP
    3289 = "YN9TR-MCTJK-82M3Y-DV7TV-VT9R2" # Enterprise, Win 10 RTM Enterprise OEM:NONSLP
    3290 = "96YNV-9X4RP-2YYKB-RMQH4-6Q72D" # Enterprise, Win 10 RTM Enterprise Volume:GVLK
    3290 = "NPPR9-FWDCX-D2C8J-H872K-2YT43" # Enterprise, Win 10 RTM Enterprise Volume:GVLK
    3291 = "44NYX-TKR9D-CCM2D-V6B8F-HQWWR" # Enterprise, Win 10 RTM Enterprise Volume:MAK
    3291 = "6K3GQ-N2KF9-84J97-K4FVC-YKMPF" # Enterprise, Win 10 RTM Enterprise Volume:MAK
    3291 = "6VVFQ-NHJC6-K7D39-83VG8-JFG44" # Enterprise, Win 10 RTM Enterprise Volume:MAK
    3291 = "73KBB-9NP4R-YC23T-6DFRV-6XXR4" # Enterprise, Win 10 RTM Enterprise Volume:MAK
    3291 = "744TC-NFG8T-3YDJ7-884TX-P372F" # Enterprise, Win 10 RTM Enterprise Volume:MAK
    3291 = "9RNQV-3KMXY-9FFM9-WVXYM-88F8R" # Enterprise, Win 10 RTM Enterprise Volume:MAK
    3291 = "C784F-9KNXX-YWYKK-2FCMP-RVV2F" # Enterprise, Win 10 RTM Enterprise Volume:MAK
    3291 = "CTXFJ-PN78H-XHJ43-DTVPK-WTYPF" # Enterprise, Win 10 RTM Enterprise Volume:MAK
    3291 = "D7WMX-NMQXC-6VFVK-DFYFC-27JWR" # Enterprise, Win 10 RTM Enterprise Volume:MAK
    3291 = "F83XK-9QND6-T3GC9-DX6PD-C372F" # Enterprise, Win 10 RTM Enterprise Volume:MAK
    3291 = "G4NCM-F9JB6-2MRX7-WP9FQ-9D72F" # Enterprise, Win 10 RTM Enterprise Volume:MAK
    3291 = "GHPJR-6NJ96-432GB-DXBC8-MTDF4" # Enterprise, Win 10 RTM Enterprise Volume:MAK
    3291 = "GN8GQ-B494K-BXW6Q-G9RGB-X4R8R" # Enterprise, Win 10 RTM Enterprise Volume:MAK
    3291 = "H8CNK-6PDC2-JQPDR-9RYR7-XD72F" # Enterprise, Win 10 RTM Enterprise Volume:MAK
    3291 = "HKRNV-YTR7Y-P9BYK-BB6Y4-W8F8R" # Enterprise, Win 10 RTM Enterprise Volume:MAK
    3291 = "HYKKP-B7NJF-GD7KB-3X98Y-PR4CF" # Enterprise, Win 10 RTM Enterprise Volume:MAK
    3291 = "J3QFK-NTXB9-VM699-JT2FB-KD72F" # Enterprise, Win 10 RTM Enterprise Volume:MAK
    3291 = "KVN6T-MM2W2-JJWJV-6JP6H-8HV2F" # Enterprise, Win 10 RTM Enterprise Volume:MAK
    3291 = "NFBM4-MHXHX-BQDR4-H7QP8-W44CF" # Enterprise, Win 10 RTM Enterprise Volume:MAK
    3291 = "NRGK8-DBW6B-RKWGY-6HJM3-GF4CF" # Enterprise, Win 10 RTM Enterprise Volume:MAK
    3291 = "PGNKQ-J7P7C-7P6X7-KRKF9-MG9R4" # Enterprise, Win 10 RTM Enterprise Volume:MAK
    3291 = "Q3FT7-64NXV-924XG-RBRT2-JB48R" # Enterprise, Win 10 RTM Enterprise Volume:MAK
    3291 = "Q73N4-C93QV-YQ826-HGQ79-JXCJR" # Enterprise, Win 10 RTM Enterprise Volume:MAK
    3291 = "T7TMJ-6RNKP-Q8VX2-82JT9-KQBPF" # Enterprise, Win 10 RTM Enterprise Volume:MAK
    3291 = "TNWT4-J9899-FX9VF-RDQXR-HQWWR" # Enterprise, Win 10 RTM Enterprise Volume:MAK
    3291 = "TVDW8-7NPHX-GXY7F-X6T3H-G6PJR" # Enterprise, Win 10 RTM Enterprise Volume:MAK
    3291 = "WXW9N-48W7R-VX939-B3XYX-BKMPF" # Enterprise, Win 10 RTM Enterprise Volume:MAK
    3291 = "YN47Q-6C9WV-2JH87-X7HCQ-H22JR" # Enterprise, Win 10 RTM Enterprise Volume:MAK
    3292 = "7HBDQ-QNKVG-K4RBF-HMBY6-YG9R6" # EnterpriseEval, Win 10 RTM EnterpriseEval Retail:TB:Eval
    3292 = "VPMWD-PVNRR-79WJ9-VVJQC-3YH2G" # EnterpriseEval, Win 10 RTM EnterpriseEval Retail:TB:Eval
    3293 = "2PD9D-XCN6V-GBPBC-C487K-2YT47" # EnterpriseS, Win 10 RTM EnterpriseS OEM:DM
    3293 = "36QD2-NCRVY-HT9WM-YF4Y3-GF4CH" # EnterpriseS, Win 10 RTM EnterpriseS OEM:DM
    3293 = "3KXNM-8TKWH-P7FR9-9FKMB-39MPH" # EnterpriseS, Win 10 RTM EnterpriseS OEM:DM
    3293 = "494NJ-FVQHY-8CCW8-B7PYB-39MPH" # EnterpriseS, Win 10 RTM EnterpriseS OEM:DM
    3293 = "7W6WN-DV9KG-WKF2X-4DPM8-D9MPH" # EnterpriseS, Win 10 RTM EnterpriseS OEM:DM
    3293 = "DYBNB-3PWX4-WWRG9-9G9RW-78RCH" # EnterpriseS, Win 10 RTM EnterpriseS OEM:DM
    3293 = "FFN4X-TMK7K-H2QKG-Q9PYV-QPFCH" # EnterpriseS, Win 10 RTM EnterpriseS OEM:DM
    3293 = "G8DYN-XC92W-W9F36-C9CF6-GMT47" # EnterpriseS, Win 10 RTM EnterpriseS OEM:DM
    3293 = "GRHTF-6DNPT-6XD8T-M6G7X-M98WV" # EnterpriseS, Win 10 RTM EnterpriseS OEM:DM
    3293 = "J684N-7BGDF-8QGJR-Y6WDT-V6DF7" # EnterpriseS, Win 10 RTM EnterpriseS OEM:DM
    3293 = "KRY98-NJPFT-VMD8B-YPYVD-G83F7" # EnterpriseS, Win 10 RTM EnterpriseS OEM:DM
    3293 = "KTM82-JNT68-M9X3F-HHYKD-8K8WV" # EnterpriseS, Win 10 RTM EnterpriseS OEM:DM
    3293 = "N83CP-P7WB3-TQGVG-6C8QJ-JFG47" # EnterpriseS, Win 10 RTM EnterpriseS OEM:DM
    3293 = "NFQ32-9HY9C-TT69X-P24TM-43KR7" # EnterpriseS, Win 10 RTM EnterpriseS OEM:DM
    3293 = "P9CHT-7FNXD-8FV64-TD8WB-WHV2H" # EnterpriseS, Win 10 RTM EnterpriseS OEM:DM
    3293 = "QMJPN-978BY-W46DM-RQGJM-3GPJV" # EnterpriseS, Win 10 RTM EnterpriseS OEM:DM
    3293 = "T6BBG-2NCM8-6WC84-8FBJ3-TCQF7" # EnterpriseS, Win 10 RTM EnterpriseS OEM:DM
    3293 = "TG7XP-CTN27-2XRFT-MGY3Q-RJRCH" # EnterpriseS, Win 10 RTM EnterpriseS OEM:DM
    3293 = "Y4H2D-N3QRT-YQ9R6-7R3VP-CKCJV" # EnterpriseS, Win 10 RTM EnterpriseS OEM:DM
    3294 = "2NXHF-48B64-6RDPW-3YF4P-PGYPJ" # EnterpriseS, Win 10 RTM EnterpriseS OEM:NONSLP
    3294 = "4CMN6-63X62-8K77C-TGBJ3-H22JW" # EnterpriseS, Win 10 RTM EnterpriseS OEM:NONSLP
    3294 = "4YPQ8-NB9RD-GG7D3-3DGB6-BP2JW" # EnterpriseS, Win 10 RTM EnterpriseS OEM:NONSLP
    3294 = "8PDCN-G999D-3GRGY-3CF48-BWRCJ" # EnterpriseS, Win 10 RTM EnterpriseS OEM:NONSLP
    3294 = "9T3WN-7JHM3-W6XYP-YQ9RG-PDKR8" # EnterpriseS, Win 10 RTM EnterpriseS OEM:NONSLP
    3294 = "9TVHM-2NF92-K2VF9-6VYBT-XQBPJ" # EnterpriseS, Win 10 RTM EnterpriseS OEM:NONSLP
    3294 = "BHFNP-BVCVX-42QPB-VT8P2-MP2JW" # EnterpriseS, Win 10 RTM EnterpriseS OEM:NONSLP
    3294 = "CRYTQ-3WND3-8BVWM-8T9M7-WK8WW" # EnterpriseS, Win 10 RTM EnterpriseS OEM:NONSLP
    3294 = "DCNFJ-X9H4W-DY4TP-TD4QJ-JFG48" # EnterpriseS, Win 10 RTM EnterpriseS OEM:NONSLP
    3294 = "FMVNP-RT7TK-DPKVW-8V6WD-GF4CJ" # EnterpriseS, Win 10 RTM EnterpriseS OEM:NONSLP
    3294 = "FWN7H-PF93Q-4GGP8-M8RF3-MDWWW" # EnterpriseS, Win 10 RTM EnterpriseS OEM:NONSLP
    3294 = "HWJR7-Q7N48-WWKJ9-GTX3K-CDKR8" # EnterpriseS, Win 10 RTM EnterpriseS OEM:NONSLP
    3294 = "JWN46-8J86K-K722B-Q84DG-P7JWW" # EnterpriseS, Win 10 RTM EnterpriseS OEM:NONSLP
    3294 = "MN3JK-47H3C-HF2VP-BBG83-3PFCJ" # EnterpriseS, Win 10 RTM EnterpriseS OEM:NONSLP
    3294 = "MNJYW-QRDXQ-9C4KV-CRRG2-TMT48" # EnterpriseS, Win 10 RTM EnterpriseS OEM:NONSLP
    3294 = "NC4V4-7Y83H-9W3K3-WRMXB-KD72J" # EnterpriseS, Win 10 RTM EnterpriseS OEM:NONSLP
    3294 = "NV6WJ-PCRGB-7TRDB-96JRB-88F8W" # EnterpriseS, Win 10 RTM EnterpriseS OEM:NONSLP
    3294 = "P9FGN-WGGHX-RPPJ7-TXCQW-QDBPJ" # EnterpriseS, Win 10 RTM EnterpriseS OEM:NONSLP
    3294 = "Q3NC7-8VW3C-FD6XW-XJYH9-JXCJW" # EnterpriseS, Win 10 RTM EnterpriseS OEM:NONSLP
    3294 = "RFQB9-DN4G8-K4FH3-PCK8H-6XXR8" # EnterpriseS, Win 10 RTM EnterpriseS OEM:NONSLP
    3294 = "V4WCN-MTH2K-B3HXH-M29TW-DGPJW" # EnterpriseS, Win 10 RTM EnterpriseS OEM:NONSLP
    3294 = "WK998-7WNB2-YKFM6-XWJ8X-C7JWW" # EnterpriseS, Win 10 RTM EnterpriseS OEM:NONSLP
    3294 = "X8K2B-NMJ7J-DXQKW-VM88X-C7JWW" # EnterpriseS, Win 10 RTM EnterpriseS OEM:NONSLP
    3294 = "XH79R-XN6WB-GYJQB-2HHX7-XD72J" # EnterpriseS, Win 10 RTM EnterpriseS OEM:NONSLP
    3294 = "XNBMX-WJ92K-W964P-GJ3K8-F3KR8" # EnterpriseS, Win 10 RTM EnterpriseS OEM:NONSLP
    3294 = "XXYMP-NTYJQ-7R7Q8-PB4G2-TMT48" # EnterpriseS, Win 10 RTM EnterpriseS OEM:NONSLP
    3294 = "YP4NW-FFH8W-22MBD-72MPV-X7648" # EnterpriseS, Win 10 RTM EnterpriseS OEM:NONSLP
    3295 = "NFG9D-HFJ79-J6HTB-4XB2X-TF4CK" # EnterpriseS, Win 10 RTM EnterpriseS Volume:GVLK
    3295 = "WNMTR-4C88C-JK8YV-HQ7T2-76DF9" # EnterpriseS, Win 10 RTM EnterpriseS Volume:GVLK
    3296 = "4XWF8-XNBVH-7C3YD-4828B-CWF8Y" # EnterpriseS, Win 10 RTM EnterpriseS Volume:MAK
    3296 = "6KBRN-X9YJW-HG2XV-D6CFP-PGYPM" # EnterpriseS, Win 10 RTM EnterpriseS Volume:MAK
    3296 = "6WNM7-XV3Y4-K7C2V-HJ4TX-FRG6B" # EnterpriseS, Win 10 RTM EnterpriseS Volume:MAK
    3296 = "7DRXG-NMXG6-69G48-9JK2H-3J3GB" # EnterpriseS, Win 10 RTM EnterpriseS Volume:MAK
    3296 = "7N2VV-B2XCW-28K4T-KR42R-BY48Y" # EnterpriseS, Win 10 RTM EnterpriseS Volume:MAK
    3296 = "7N6XX-C7J2W-BXK8B-KRDKV-2R4CM" # EnterpriseS, Win 10 RTM EnterpriseS Volume:MAK
    3296 = "8NKYB-38VFV-JYY9G-27WVY-F9CJY" # EnterpriseS, Win 10 RTM EnterpriseS Volume:MAK
    3296 = "DGN8Y-24HMH-VF4JH-P8Y73-T6PJY" # EnterpriseS, Win 10 RTM EnterpriseS Volume:MAK
    3296 = "DVWKN-3GCMV-Q2XF4-DDPGM-VQWWY" # EnterpriseS, Win 10 RTM EnterpriseS Volume:MAK
    3296 = "F6394-GNTG9-8B3XQ-78TBK-M98WY" # EnterpriseS, Win 10 RTM EnterpriseS Volume:MAK
    3296 = "GNMFF-P9DHW-PXD4B-GG7DD-49CJY" # EnterpriseS, Win 10 RTM EnterpriseS Volume:MAK
    3296 = "HYFMB-N6F88-DHBK6-MQGM4-3DBPM" # EnterpriseS, Win 10 RTM EnterpriseS Volume:MAK
    3296 = "K6MMK-NBW82-KWRMC-TFP33-DV66B" # EnterpriseS, Win 10 RTM EnterpriseS Volume:MAK
    3296 = "KM3F2-FDNQR-B6Q2W-9CYT2-TMT6B" # EnterpriseS, Win 10 RTM EnterpriseS Volume:MAK
    3296 = "M79GN-7CM49-FB4RW-QM849-66PJY" # EnterpriseS, Win 10 RTM EnterpriseS Volume:MAK
    3296 = "NGM9H-WQDFY-QQ4KP-RK743-MDWWY" # EnterpriseS, Win 10 RTM EnterpriseS Volume:MAK
    3296 = "NH7PR-B6X64-KBVVY-WGQQB-2PQGB" # EnterpriseS, Win 10 RTM EnterpriseS Volume:MAK
    3296 = "NMGTJ-BCXPQ-J4BGB-VXJ24-GXXTB" # EnterpriseS, Win 10 RTM EnterpriseS Volume:MAK
    3296 = "P99B7-WNTBB-XX44W-PDPC4-Q9MPM" # EnterpriseS, Win 10 RTM EnterpriseS Volume:MAK
    3296 = "R2WFM-NMD47-FBK3G-HR2YK-DYH2M" # EnterpriseS, Win 10 RTM EnterpriseS Volume:MAK
    3296 = "TKNDC-7QRWR-VHQR2-QWP9K-YDWWY" # EnterpriseS, Win 10 RTM EnterpriseS Volume:MAK
    3296 = "WCQ7N-RY2XV-HDF3W-7B97D-RJRCM" # EnterpriseS, Win 10 RTM EnterpriseS Volume:MAK
    3297 = "7TNX7-H36JG-QFF42-K4JYV-YY482" # EnterpriseSEval, Win 10 RTM EnterpriseSEval Retail:TB:Eval
    3298 = "D3M8K-4YN49-89KYG-4F3DR-TVJW3" # EnterpriseSNEval, Win 10 RTM EnterpriseSNEval Retail:TB:Eval
    3299 = "DPH2V-TTNVB-4X9Q3-TJR4H-KHJW4" # EnterpriseN, Win 10 RTM EnterpriseN Volume:GVLK
    3299 = "WGGHN-J84D6-QYCPR-T7PJ7-X766F" # EnterpriseN, Win 10 RTM EnterpriseN Volume:GVLK
    3300 = "23MXW-YN2QD-FB2M6-4KP6C-2DKTG" # EnterpriseN, Win 10 RTM EnterpriseN Volume:MAK
    3300 = "3V6Q6-NQXCX-V8YXR-9QCYV-QPFCT" # EnterpriseN, Win 10 RTM EnterpriseN Volume:MAK
    3300 = "46BNG-GP74X-PT69H-MVWD3-7T9TG" # EnterpriseN, Win 10 RTM EnterpriseN Volume:MAK
    3300 = "4NK4C-44FKK-TDQKK-3QDP8-W44CT" # EnterpriseN, Win 10 RTM EnterpriseN Volume:MAK
    3300 = "8C3ND-JRGWR-3RF9P-92KD8-K2FCT" # EnterpriseN, Win 10 RTM EnterpriseN Volume:MAK
    3300 = "BNY6R-2PG44-HX6Q2-P4V4F-WFG6G" # EnterpriseN, Win 10 RTM EnterpriseN Volume:MAK
    3300 = "BTQTW-N6VJB-63M8G-PHQ77-GCQGG" # EnterpriseN, Win 10 RTM EnterpriseN Volume:MAK
    3300 = "CFN49-BR4B6-9KCJK-KVY6X-FRG6G" # EnterpriseN, Win 10 RTM EnterpriseN Volume:MAK
    3300 = "DRDNB-GPC7W-M8T7C-GQTFB-YWRCT" # EnterpriseN, Win 10 RTM EnterpriseN Volume:MAK
    3300 = "FN9MV-2D8M3-F742C-W9RG2-TMT6G" # EnterpriseN, Win 10 RTM EnterpriseN Volume:MAK
    3300 = "GTHNT-JQHQM-YQVKH-CB6JB-K766G" # EnterpriseN, Win 10 RTM EnterpriseN Volume:MAK
    3300 = "KNRWR-JTCF6-8636P-9YRD7-JQKTG" # EnterpriseN, Win 10 RTM EnterpriseN Volume:MAK
    3300 = "N6CD6-3QB8V-G3JM6-JDHRF-6Q72T" # EnterpriseN, Win 10 RTM EnterpriseN Volume:MAK
    3300 = "NRMFG-W72MC-YF83V-4KFM3-QRR86" # EnterpriseN, Win 10 RTM EnterpriseN Volume:MAK
    3300 = "QTYGN-TW9VB-XRG78-97DHJ-82QGG" # EnterpriseN, Win 10 RTM EnterpriseN Volume:MAK
    3300 = "RMMRN-9B43V-4DYBD-P2RFT-BP2J6" # EnterpriseN, Win 10 RTM EnterpriseN Volume:MAK
    3300 = "RN4QM-C93P4-7G7W9-2V8BK-7XMPT" # EnterpriseN, Win 10 RTM EnterpriseN Volume:MAK
    3300 = "TNJ4M-XQVBB-6DKCF-74FDG-P7JW6" # EnterpriseN, Win 10 RTM EnterpriseN Volume:MAK
    3300 = "VFN72-MT369-966D8-XVGDF-W8F86" # EnterpriseN, Win 10 RTM EnterpriseN Volume:MAK
    3300 = "VN7GG-XJ738-R6HXV-2CX3F-HQWW6" # EnterpriseN, Win 10 RTM EnterpriseN Volume:MAK
    3300 = "WKF9N-MTH43-WD4FF-H9D64-7H66G" # EnterpriseN, Win 10 RTM EnterpriseN Volume:MAK
    3300 = "Y8XFV-4YNCP-F4KQQ-YHH9T-8TYPT" # EnterpriseN, Win 10 RTM EnterpriseN Volume:MAK
    3300 = "YHMNQ-PPQW2-P8PGP-32643-C372T" # EnterpriseN, Win 10 RTM EnterpriseN Volume:MAK
    3300 = "YNCGC-P3WW4-8GQX3-DTVPW-WB486" # EnterpriseN, Win 10 RTM EnterpriseN Volume:MAK
    3300 = "YWRXB-FNXQ6-TH9QB-6PKW6-683GG" # EnterpriseN, Win 10 RTM EnterpriseN Volume:MAK
    3301 = "4N8VT-7Y686-43DGV-THTW9-M98W7" # EnterpriseNEval, Win 10 RTM EnterpriseNEval Retail:TB:Eval
    3301 = "MNXKQ-WY2CT-JWBJ2-T68TQ-YBH2V" # EnterpriseNEval, Win 10 RTM EnterpriseNEval Retail:TB:Eval
    3302 = "2F77B-TNFGY-69QQF-B8YKP-D69TJ" # EnterpriseSN, Win 10 RTM EnterpriseSN Volume:GVLK
    3302 = "X4R4B-NV6WD-PKTVK-F98BH-4C2J8" # EnterpriseSN, Win 10 RTM EnterpriseSN Volume:GVLK
    3303 = "2JVWR-4TNYV-6PFVY-KD83W-F3KTK" # EnterpriseSN, Win 10 RTM EnterpriseSN Volume:MAK
    3303 = "32N2Y-2B9RM-RMQQR-J6PTJ-GVJW9" # EnterpriseSN, Win 10 RTM EnterpriseSN Volume:MAK
    3303 = "64BJJ-VNPB3-62XQF-6RWMK-XKXTK" # EnterpriseSN, Win 10 RTM EnterpriseSN Volume:MAK
    3303 = "66YQ8-NXVXM-G3HDD-23JR2-4RG6K" # EnterpriseSN, Win 10 RTM EnterpriseSN Volume:MAK
    3303 = "7JK9M-NXRPK-9XMGK-XCXFB-QJ3GK" # EnterpriseSN, Win 10 RTM EnterpriseSN Volume:MAK
    3303 = "8NFDQ-2PVD8-79TYF-W4CCR-BY489" # EnterpriseSN, Win 10 RTM EnterpriseSN Volume:MAK
    3303 = "8V8WN-3GXBH-2TCMG-XHRX3-9766K" # EnterpriseSN, Win 10 RTM EnterpriseSN Volume:MAK
    3303 = "9QV33-2NP9G-3P8G4-WR4KD-PYT6K" # EnterpriseSN, Win 10 RTM EnterpriseSN Volume:MAK
    3303 = "C9PJ7-9NDVP-2F9WG-H78C4-2KCJ9" # EnterpriseSN, Win 10 RTM EnterpriseSN Volume:MAK
    3303 = "DCTTV-R6N6B-PGXJ7-CWGD6-RRG6K" # EnterpriseSN, Win 10 RTM EnterpriseSN Volume:MAK
    3303 = "F4YN4-3VHVX-FQ23T-K6BG4-7H66K" # EnterpriseSN, Win 10 RTM EnterpriseSN Volume:MAK
    3303 = "G3GNW-FM4MX-676D2-DFJQT-KTPJ9" # EnterpriseSN, Win 10 RTM EnterpriseSN Volume:MAK
    3303 = "MJRHD-N8TW6-HFRQP-4BTV7-9BT6K" # EnterpriseSN, Win 10 RTM EnterpriseSN Volume:MAK
    3303 = "N9M76-GQGGF-PXDD2-JW9R4-FC2J9" # EnterpriseSN, Win 10 RTM EnterpriseSN Volume:MAK
    3303 = "NH6V9-3MXYJ-WVPFD-8CFMW-HMH2X" # EnterpriseSN, Win 10 RTM EnterpriseSN Volume:MAK
    3303 = "NRVDP-F24D4-D8DD2-C2FPB-3GPJ9" # EnterpriseSN, Win 10 RTM EnterpriseSN Volume:MAK
    3303 = "NTX6B-BRYC2-K6786-F6MVQ-M7V2X" # EnterpriseSN, Win 10 RTM EnterpriseSN Volume:MAK
    3303 = "QBNWM-2662D-V689T-2336B-8FG6K" # EnterpriseSN, Win 10 RTM EnterpriseSN Volume:MAK
    3303 = "QG8NW-JH9J3-MMJ63-7JT66-P7JW9" # EnterpriseSN, Win 10 RTM EnterpriseSN Volume:MAK
    3303 = "QNQDW-RMT2G-388H3-M34J8-GVJW9" # EnterpriseSN, Win 10 RTM EnterpriseSN Volume:MAK
    3303 = "VYXYN-6Q344-6HPY9-W8DHG-6F4CX" # EnterpriseSN, Win 10 RTM EnterpriseSN Volume:MAK
    3303 = "WQNJ4-8D793-9K349-TRT63-KKXTK" # EnterpriseSN, Win 10 RTM EnterpriseSN Volume:MAK
    3303 = "YVGNF-FDWH9-R3PXX-WRKXX-6CQGK" # EnterpriseSN, Win 10 RTM EnterpriseSN Volume:MAK
    3304 = "FFMT6-KWNBD-K3B3C-JYG4H-B7V2Y" # PPIPro, Win 10 RTM PPIPro OEM:NONSLP
    3304 = "GKHN2-DYYPG-J94DP-Y4WK7-M4G6M" # PPIPro, Win 10 RTM PPIPro OEM:NONSLP
    3304 = "XKCNC-J26Q9-KFHD2-FKTHY-KD72Y" # PPIPro, Win 10 RTM PPIPro OEM:NONSLP
    3305 = "2B7BM-NFQFX-XKGFX-2W7QF-3DBP2" # Professional, Win 10 RTM Professional OEM:DM
    3305 = "2YBN6-VRYPG-DY93Q-D8CF9-HCFC2" # Professional, Win 10 RTM Professional OEM:DM
    3305 = "3QQJN-FFCB4-3R93M-2P886-C9XTP" # Professional, Win 10 RTM Professional OEM:DM
    3305 = "4KBN9-XVMTT-M9BTB-YPHHY-43KTP" # Professional, Win 10 RTM Professional OEM:DM
    3305 = "4MNVJ-6RK2F-RVFJ3-T7PK4-FC2KC" # Professional, Win 10 RTM Professional OEM:DM
    3305 = "6F6HC-CNG6V-QPM66-GTX37-JQKTP" # Professional, Win 10 RTM Professional OEM:DM
    3305 = "6Q3N8-3R9CG-M8V87-WRVQQ-9766P" # Professional, Win 10 RTM Professional OEM:DM
    3305 = "79VNQ-RC29R-MJJKX-8GWRB-VQWXC" # Professional, Win 10 RTM Professional OEM:DM
    3305 = "7PVM6-HNVGY-9CMHC-B26MJ-WB49C" # Professional, Win 10 RTM Professional OEM:DM
    3305 = "88W7N-YHTFC-TG683-BQMMC-GQ722" # Professional, Win 10 RTM Professional OEM:DM
    3305 = "8CG9N-KXGTV-P99BK-C8WBR-Q9MP2" # Professional, Win 10 RTM Professional OEM:DM
    3305 = "8HFNR-6MYQ7-8B2DM-MB4M8-XW3GP" # Professional, Win 10 RTM Professional OEM:DM
    3305 = "8MQHN-DCT7Q-FCMH9-TFHTX-T83GP" # Professional, Win 10 RTM Professional OEM:DM
    3305 = "8N63Q-V4MRF-B62BJ-964HJ-J8F9C" # Professional, Win 10 RTM Professional OEM:DM
    3305 = "8RCM9-N29CV-8Q2KJ-Y6KVY-QJ3GP" # Professional, Win 10 RTM Professional OEM:DM
    3305 = "9DKR9-N7WFT-JMH2M-HT2RH-VT9TP" # Professional, Win 10 RTM Professional OEM:DM
    3305 = "9PJNQ-RWBV9-4M9BD-3F4P2-7CFC2" # Professional, Win 10 RTM Professional OEM:DM
    3305 = "B4PN9-K4RCK-XKV72-7RP9F-2KCKC" # Professional, Win 10 RTM Professional OEM:DM
    3305 = "BBN4R-JC2GG-WBWQP-VHTHY-VQWXC" # Professional, Win 10 RTM Professional OEM:DM
    3305 = "BQBNY-JQH2M-DCYD3-VYJQY-X4R9C" # Professional, Win 10 RTM Professional OEM:DM
    3305 = "BXKND-BCHXG-769CD-2MHJX-C7JXC" # Professional, Win 10 RTM Professional OEM:DM
    3305 = "C6YWN-8X26M-JVXY7-BYGGH-8HV22" # Professional, Win 10 RTM Professional OEM:DM
    3305 = "C99T8-FXN7C-PWRKJ-KC24F-2KCKC" # Professional, Win 10 RTM Professional OEM:DM
    3305 = "CMG9N-XCYF6-RCCJ9-JDF6M-KD722" # Professional, Win 10 RTM Professional OEM:DM
    3305 = "CNB4R-3DPQ8-FRR3H-FF4CC-8XCKC" # Professional, Win 10 RTM Professional OEM:DM
    3305 = "CVXN2-C3FKB-G8XPV-KC7PK-WTYP2" # Professional, Win 10 RTM Professional OEM:DM
    3305 = "D6FXR-NHQJ8-2VGBC-3H8DF-DJ3GP" # Professional, Win 10 RTM Professional OEM:DM
    3305 = "DFD3B-KVNHG-DXKRH-9Q2W4-F6YP2" # Professional, Win 10 RTM Professional OEM:DM
    3305 = "DR8JT-WNRW9-J8249-CF33J-33WXC" # Professional, Win 10 RTM Professional OEM:DM
    3305 = "DTNY6-DG63P-TFCVM-BM4KY-7MH22" # Professional, Win 10 RTM Professional OEM:DM
    3305 = "DYNWJ-7V4BK-YRCRR-FH97M-JK8XC" # Professional, Win 10 RTM Professional OEM:DM
    3305 = "F7KM6-8NM69-8YG74-DV6G4-R3KTP" # Professional, Win 10 RTM Professional OEM:DM
    3305 = "FFRBN-M77K6-2PCXM-W9GV8-DGPKC" # Professional, Win 10 RTM Professional OEM:DM
    3305 = "FHTWJ-HN6D9-YYTPD-QW94V-CYT6P" # Professional, Win 10 RTM Professional OEM:DM
    3305 = "H3DNW-WTYJT-MVQFM-M4YTV-KHJXC" # Professional, Win 10 RTM Professional OEM:DM
    3305 = "HHNW8-PR2Y2-7CJ7Y-FG8QQ-9766P" # Professional, Win 10 RTM Professional OEM:DM
    3305 = "J8CPR-DCNTX-TRT84-THPFP-JB49C" # Professional, Win 10 RTM Professional OEM:DM
    3305 = "JHKT4-XDNYB-3G7J2-WKQJJ-D9MP2" # Professional, Win 10 RTM Professional OEM:DM
    3305 = "KF8KW-MN8WW-W9W2D-V7GTV-YY49C" # Professional, Win 10 RTM Professional OEM:DM
    3305 = "KGP69-78NRW-DD3BW-49C7G-6F4C2" # Professional, Win 10 RTM Professional OEM:DM
    3305 = "M4XCV-N3GXF-Y8R2P-HF29D-T6PKC" # Professional, Win 10 RTM Professional OEM:DM
    3305 = "MQFQM-9HNV6-KJMQX-CPDCF-PPQGP" # Professional, Win 10 RTM Professional OEM:DM
    3305 = "MYFGN-J38HR-9WQDM-3T4HG-GMT6P" # Professional, Win 10 RTM Professional OEM:DM
    3305 = "N2J2T-MK6YT-9FHC7-GPCJ2-6JF9C" # Professional, Win 10 RTM Professional OEM:DM
    3305 = "N4YVY-D4WTH-2JT2H-YWBDR-JHV22" # Professional, Win 10 RTM Professional OEM:DM
    3305 = "N6JDV-VMQ8H-HBV7P-GYX7X-XKXTP" # Professional, Win 10 RTM Professional OEM:DM
    3305 = "N7GVH-7P4PQ-YHPFP-RM84P-D69TP" # Professional, Win 10 RTM Professional OEM:DM
    3305 = "N8V99-BHRWD-9XM99-9X837-JQKTP" # Professional, Win 10 RTM Professional OEM:DM
    3305 = "ND3GD-HR37X-JCRV3-787CJ-4VV22" # Professional, Win 10 RTM Professional OEM:DM
    3305 = "NF6HC-QH89W-F8WYV-WWXV4-WFG6P" # Professional, Win 10 RTM Professional OEM:DM
    3305 = "NFGJH-BRG22-VX7BQ-KRFQ7-JQKTP" # Professional, Win 10 RTM Professional OEM:DM
    3305 = "NH382-3HF4H-YVK4F-FP9RV-2R4C2" # Professional, Win 10 RTM Professional OEM:DM
    3305 = "NK7X2-YQD6T-KCWP2-HPFCV-PWF9C" # Professional, Win 10 RTM Professional OEM:DM
    3305 = "NRMBT-TGK4V-4RFD7-HFMH4-CR4C2" # Professional, Win 10 RTM Professional OEM:DM
    3305 = "NV8QP-FB7GV-PJP6F-WRCYD-7T9TP" # Professional, Win 10 RTM Professional OEM:DM
    3305 = "NVCVV-VTPF4-M2BFY-HVWF6-QYH22" # Professional, Win 10 RTM Professional OEM:DM
    3305 = "NWKB2-2XV8W-J2PW3-K4R3M-MY49C" # Professional, Win 10 RTM Professional OEM:DM
    3305 = "NX9QG-G8KBH-284DX-34G8P-J44C2" # Professional, Win 10 RTM Professional OEM:DM
    3305 = "P7CWN-97Q2H-DGGG6-8RQDH-CYT6P" # Professional, Win 10 RTM Professional OEM:DM
    3305 = "PK326-NTQD8-7Q3C6-8RR9Q-VXMP2" # Professional, Win 10 RTM Professional OEM:DM
    3305 = "PN7T2-8D26F-6KP34-BGBPV-T3BP2" # Professional, Win 10 RTM Professional OEM:DM
    3305 = "PT98N-K47YD-4MHH4-23BWV-3J3GP" # Professional, Win 10 RTM Professional OEM:DM
    3305 = "QHBGV-DRNCD-PK6MC-MQ2KD-FM49C" # Professional, Win 10 RTM Professional OEM:DM
    3305 = "QP9MH-YNR4M-CHW79-DH99Q-Y4G6P" # Professional, Win 10 RTM Professional OEM:DM
    3305 = "QQPH7-THN9Q-498JG-93K33-DV66P" # Professional, Win 10 RTM Professional OEM:DM
    3305 = "QW876-NFKK2-9CHBQ-4VK88-2GYP2" # Professional, Win 10 RTM Professional OEM:DM
    3305 = "R27HM-9NV6R-6D9CY-9M3BJ-6MT6P" # Professional, Win 10 RTM Professional OEM:DM
    3305 = "RHNH8-QC93V-TB974-QCGDK-9HJXC" # Professional, Win 10 RTM Professional OEM:DM
    3305 = "RKYFK-NMQTB-X2DR7-MBFT7-MBH22" # Professional, Win 10 RTM Professional OEM:DM
    3305 = "RRWNW-FRKRX-6MMJJ-WVWY3-KKXTP" # Professional, Win 10 RTM Professional OEM:DM
    3305 = "RVY44-JNB3D-WPV69-692PQ-3PFC2" # Professional, Win 10 RTM Professional OEM:DM
    3305 = "T9D8N-TWPHV-VB9TJ-DB2QW-F3KTP" # Professional, Win 10 RTM Professional OEM:DM
    3305 = "TCHPB-8NRVC-67BHH-V97KF-9W3GP" # Professional, Win 10 RTM Professional OEM:DM
    3305 = "TGGGV-NH8PJ-2R6M2-7QVJK-CDKTP" # Professional, Win 10 RTM Professional OEM:DM
    3305 = "TNDRX-XY2X9-XDC49-4CKFC-W2QGP" # Professional, Win 10 RTM Professional OEM:DM
    3305 = "TNH32-DBVVJ-TVPBB-TXBGQ-T6PKC" # Professional, Win 10 RTM Professional OEM:DM
    3305 = "TNXYC-VT8MV-CTTRJ-XPCBD-7T9TP" # Professional, Win 10 RTM Professional OEM:DM
    3305 = "VMJN8-J6823-MBTPP-TR4GM-VQWXC" # Professional, Win 10 RTM Professional OEM:DM
    3305 = "WBH8V-JNMH6-YHB24-WRQ83-DV66P" # Professional, Win 10 RTM Professional OEM:DM
    3305 = "WCNYF-DKFDT-K6GVJ-F9FGW-DGPKC" # Professional, Win 10 RTM Professional OEM:DM
    3305 = "WQQGC-TYN9Y-DM2DB-HTVY6-YG9TP" # Professional, Win 10 RTM Professional OEM:DM
    3305 = "X3VPN-YDJDD-VQ3YY-Y23QB-2PQGP" # Professional, Win 10 RTM Professional OEM:DM
    3305 = "Y2NJB-Y87HH-PKQJ4-3YG86-683GP" # Professional, Win 10 RTM Professional OEM:DM
    3305 = "YF79N-KJJY4-8VTQ8-MXQJ9-M98XC" # Professional, Win 10 RTM Professional OEM:DM
    3305 = "YFQNG-72G84-TJF2H-MC6XJ-29XTP" # Professional, Win 10 RTM Professional OEM:DM
    3305 = "YMBTJ-XNYVP-CQM89-Y327T-RRG6P" # Professional, Win 10 RTM Professional OEM:DM
    3306 = "2DGWC-6VNGF-YM3YR-Q2HQB-RC2KD" # Professional, Win 10 RTM Professional OEM:DM
    3306 = "2N36K-MR6MQ-TGHPG-XGR6Q-YBH23" # Professional, Win 10 RTM Professional OEM:DM
    3306 = "4FNRT-B4VXV-JCWDT-TTRVQ-DV66Q" # Professional, Win 10 RTM Professional OEM:DM
    3306 = "4NKF9-DKB62-C37M6-RH4XT-YG9TQ" # Professional, Win 10 RTM Professional OEM:DM
    3306 = "6NFV3-F2M2P-38MXH-X89X6-CGYP3" # Professional, Win 10 RTM Professional OEM:DM
    3306 = "7JCG6-NF9GY-BQD93-GRJQH-94R9D" # Professional, Win 10 RTM Professional OEM:DM
    3306 = "BHJTH-NF9V2-8KFBK-4DBQM-XBT6Q" # Professional, Win 10 RTM Professional OEM:DM
    3306 = "CX9MK-PFNX4-4GHQR-FMGQH-RGDGQ" # Professional, Win 10 RTM Professional OEM:DM
    3306 = "DQPNF-KFH74-2F7Y7-YGP36-RRG6Q" # Professional, Win 10 RTM Professional OEM:DM
    3306 = "GKBNK-C4HDW-VQ3WF-32MCQ-M7V23" # Professional, Win 10 RTM Professional OEM:DM
    3306 = "HM7N4-MX7BW-7X74R-KD8CB-3GPKD" # Professional, Win 10 RTM Professional OEM:DM
    3306 = "HN49G-V24KT-T6C2T-WH62T-MKMP3" # Professional, Win 10 RTM Professional OEM:DM
    3306 = "J3DNW-3RDWM-8WHBX-YCX3X-RM49D" # Professional, Win 10 RTM Professional OEM:DM
    3306 = "JKDN6-VP37T-G7W39-PG788-Q69TQ" # Professional, Win 10 RTM Professional OEM:DM
    3306 = "JVKQN-FTGGK-84B79-7V2PQ-3PFC3" # Professional, Win 10 RTM Professional OEM:DM
    3306 = "K6TB3-NW2DJ-TXPX2-F39YM-YWRC3" # Professional, Win 10 RTM Professional OEM:DM
    3306 = "KRFFT-YQNJV-F24R3-6GCMT-H8RC3" # Professional, Win 10 RTM Professional OEM:DM
    3306 = "MB2VG-4NKDH-BQRX8-K6R8P-BTDGQ" # Professional, Win 10 RTM Professional OEM:DM
    3306 = "MNH8T-CMDTX-7GK96-TM2TY-2PQGQ" # Professional, Win 10 RTM Professional OEM:DM
    3306 = "N2WYB-6YPMV-7DMGJ-H7TMK-DYH23" # Professional, Win 10 RTM Professional OEM:DM
    3306 = "N3JCC-3JTWF-KKHX2-3FBCR-4X8XD" # Professional, Win 10 RTM Professional OEM:DM
    3306 = "NJJX7-2FV3V-7W6D3-J3764-W8F9D" # Professional, Win 10 RTM Professional OEM:DM
    3306 = "NMK6H-DQGYD-R6WQ6-XGCYP-HH66Q" # Professional, Win 10 RTM Professional OEM:DM
    3306 = "NTQ9H-2YF4B-JC6PC-VF6KF-2KCKD" # Professional, Win 10 RTM Professional OEM:DM
    3306 = "NVXKD-FXT9G-7VB23-BG97Q-7T9TQ" # Professional, Win 10 RTM Professional OEM:DM
    3306 = "P6DH4-PHNT4-V32D6-TBP2T-WXCKD" # Professional, Win 10 RTM Professional OEM:DM
    3306 = "PXY9N-22X2B-WQR4R-BPYWM-DPFC3" # Professional, Win 10 RTM Professional OEM:DM
    3306 = "Q7VBD-N6MY2-K7WV6-BMKRD-JTYP3" # Professional, Win 10 RTM Professional OEM:DM
    3306 = "RN7HF-W962Q-329TQ-GH4B3-Y4G6Q" # Professional, Win 10 RTM Professional OEM:DM
    3306 = "RR77N-QRRM8-KJTGV-HFT8G-BP2KD" # Professional, Win 10 RTM Professional OEM:DM
    3306 = "T3NJV-7X6JX-V7HRD-7TMKD-YBH23" # Professional, Win 10 RTM Professional OEM:DM
    3306 = "WHYNJ-7B694-MWQJY-DF96F-KBT6Q" # Professional, Win 10 RTM Professional OEM:DM
    3306 = "WVCX3-RN4GC-FMXF7-DX9W6-683GQ" # Professional, Win 10 RTM Professional OEM:DM
    3307 = "2Q9YQ-N4XJJ-6PH9T-2KJHG-GMT6R" # Professional, Win 10 RTM Professional OEM:NONSLP
    3307 = "4NWM8-PYFJV-R9JVX-H63K6-CGYP4" # Professional, Win 10 RTM Professional OEM:NONSLP
    3307 = "62DJN-XDMVP-JG82T-6B7M7-RGDGR" # Professional, Win 10 RTM Professional OEM:NONSLP
    3307 = "97WTN-WY7D4-G8V3T-CHKPW-2GYP4" # Professional, Win 10 RTM Professional OEM:NONSLP
    3307 = "CNKP9-M3W7P-38RD7-GHH4Y-R6YP4" # Professional, Win 10 RTM Professional OEM:NONSLP
    3307 = "D8W23-NBJX6-GD3V7-VW4YT-D3WXF" # Professional, Win 10 RTM Professional OEM:NONSLP
    3307 = "DCTRN-JH8PH-HGY4C-X42X6-GMT6R" # Professional, Win 10 RTM Professional OEM:NONSLP
    3307 = "GJTR7-XN3D4-QJF73-KP8K9-WTYP4" # Professional, Win 10 RTM Professional OEM:NONSLP
    3307 = "MFKNB-7WB77-TJCYY-497BB-TXXTR" # Professional, Win 10 RTM Professional OEM:NONSLP
    3307 = "MVP4T-DQNCR-W2YMQ-7889Y-MY49F" # Professional, Win 10 RTM Professional OEM:NONSLP
    3307 = "NBWP3-FT7TB-PJRQW-C6HH3-PYT6R" # Professional, Win 10 RTM Professional OEM:NONSLP
    3307 = "NJP6C-K7R7D-BP23D-KQWVW-K2FC4" # Professional, Win 10 RTM Professional OEM:NONSLP
    3307 = "NT78P-JKW68-XMYBT-VM3CF-8B49F" # Professional, Win 10 RTM Professional OEM:NONSLP
    3307 = "QHBBC-XNCHQ-D4WX6-TMWRF-Q9MP4" # Professional, Win 10 RTM Professional OEM:NONSLP
    3307 = "RHGJR-N7FVY-Q3B8F-KBQ6V-46YP4" # Professional, Win 10 RTM Professional OEM:NONSLP
    3307 = "XYVDB-NTPFD-4CG33-WHDP6-3V66R" # Professional, Win 10 RTM Professional OEM:NONSLP
    3307 = "Y69N9-6TM37-HRPM4-JPCD9-DYH24" # Professional, Win 10 RTM Professional OEM:NONSLP
    3307 = "YNQYX-MFJ4H-D2KWX-96Q9V-WK8XF" # Professional, Win 10 RTM Professional OEM:NONSLP
    3308 = "2T8KN-8F24T-DPHGJ-Y2M9P-D69TT" # Professional, Win 10 RTM Professional Retail
    3308 = "36PNX-6MTFJ-4PTY6-CWFW9-7XMP6" # Professional, Win 10 RTM Professional Retail
    3308 = "3B2KJ-Q6NFR-H8PHY-PCYFM-K766T" # Professional, Win 10 RTM Professional Retail
    3308 = "3HXKB-FNPRP-73XFC-9P892-4RG6T" # Professional, Win 10 RTM Professional Retail
    3308 = "3XWDQ-83NTJ-PB2RK-QVQ7B-MY49G" # Professional, Win 10 RTM Professional Retail
    3308 = "4BTDQ-NF6WC-9GVV8-DFMJK-9HJXG" # Professional, Win 10 RTM Professional Retail
    3308 = "4BTVN-8469B-GG8H6-D7YWY-FGDGT" # Professional, Win 10 RTM Professional Retail
    3308 = "6NCT3-8HGPG-VY8H7-843W6-683GT" # Professional, Win 10 RTM Professional Retail
    3308 = "7NGMM-23R38-P8Q9X-GTTKP-D69TT" # Professional, Win 10 RTM Professional Retail
    3308 = "8CW4N-MCWMY-FGXK7-M34XJ-W44C6" # Professional, Win 10 RTM Professional Retail
    3308 = "8FGN2-Y48RF-HY6BM-XJG2V-BDWXG" # Professional, Win 10 RTM Professional Retail
    3308 = "9D9YT-QNQPJ-RYXJF-XPG9P-3YH26" # Professional, Win 10 RTM Professional Retail
    3308 = "9DVWF-N8967-83Q9K-HY8R4-JHV26" # Professional, Win 10 RTM Professional Retail
    3308 = "BGQ3W-4N7FY-VDT2P-J43GQ-FM49G" # Professional, Win 10 RTM Professional Retail
    3308 = "BN4FC-YDQB4-MBG6Y-M8MJX-WTYP6" # Professional, Win 10 RTM Professional Retail
    3308 = "DC728-VJNQH-3JJTQ-DYYQR-TVJXG" # Professional, Win 10 RTM Professional Retail
    3308 = "DMPGG-2N9BM-3HF7W-G6DG7-RGDGT" # Professional, Win 10 RTM Professional Retail
    3308 = "DPD3R-WRN64-M98QT-WY4GK-M98XG" # Professional, Win 10 RTM Professional Retail
    3308 = "DR333-NJ97M-CVYT6-TGKVP-KW3GT" # Professional, Win 10 RTM Professional Retail
    3308 = "DYHRN-MM9MT-TMRRW-497WH-6XXTT" # Professional, Win 10 RTM Professional Retail
    3308 = "DYVQN-FJJPH-M9B33-87299-C7JXG" # Professional, Win 10 RTM Professional Retail
    3308 = "F66MD-4NXJP-VCF8X-WG49R-DJ3GT" # Professional, Win 10 RTM Professional Retail
    3308 = "F833G-VNMTF-Q7CGM-6RRFB-88F9G" # Professional, Win 10 RTM Professional Retail
    3308 = "FD6N9-BRHQC-47BVQ-YCFCF-PPQGT" # Professional, Win 10 RTM Professional Retail
    3308 = "FNK3C-V7RCJ-CMMJW-QMG7J-J8F9G" # Professional, Win 10 RTM Professional Retail
    3308 = "G7FJC-PN8KK-Y8DRB-YR28B-K766T" # Professional, Win 10 RTM Professional Retail
    3308 = "GMY6X-NHC3D-YTXVK-MPGRD-8K8XG" # Professional, Win 10 RTM Professional Retail
    3308 = "GTN9W-7JQ3W-VPKVR-G3XMJ-6MT6T" # Professional, Win 10 RTM Professional Retail
    3308 = "H729N-PCH44-BP76H-QVTPR-KBT6T" # Professional, Win 10 RTM Professional Retail
    3308 = "HM46M-M4NW2-9CCFY-CVQ4K-T83GT" # Professional, Win 10 RTM Professional Retail
    3308 = "HRPNB-T4YBP-W6233-888XM-92FC6" # Professional, Win 10 RTM Professional Retail
    3308 = "K93XN-VTF4B-DJWPG-G8Y92-FX8XG" # Professional, Win 10 RTM Professional Retail
    3308 = "MF7NT-FVBTF-B3PX8-HDFMR-GXXTT" # Professional, Win 10 RTM Professional Retail
    3308 = "MN6BV-H3XRF-89T3G-3Q7QB-2PQGT" # Professional, Win 10 RTM Professional Retail
    3308 = "N6HM8-VYWXY-PK8V2-R8DV8-HMH26" # Professional, Win 10 RTM Professional Retail
    3308 = "N6KJ2-6HXCT-M767T-RQB2B-MY49G" # Professional, Win 10 RTM Professional Retail
    3308 = "NJCPF-TH8M2-TX8D6-MGQTQ-FM49G" # Professional, Win 10 RTM Professional Retail
    3308 = "NRFB4-YX7BF-YK66J-62JYH-T3BP6" # Professional, Win 10 RTM Professional Retail
    3308 = "NXWHD-CQMGR-D96C9-Y6TY2-76DGT" # Professional, Win 10 RTM Professional Retail
    3308 = "P4G7N-HV6D6-PBTBG-C7666-YG9TT" # Professional, Win 10 RTM Professional Retail
    3308 = "PTM8T-PN2TG-GX9TH-2YGQB-K766T" # Professional, Win 10 RTM Professional Retail
    3308 = "PYR2J-JN67D-KW44C-2832K-HCFC6" # Professional, Win 10 RTM Professional Retail
    3308 = "PYXTT-6BN2R-DMYYQ-YD24F-9W3GT" # Professional, Win 10 RTM Professional Retail
    3308 = "QMJNW-CXDX4-GR8W6-DVD2F-369TT" # Professional, Win 10 RTM Professional Retail
    3308 = "QP2WN-49X2P-W66XQ-KWB9G-TJF9G" # Professional, Win 10 RTM Professional Retail
    3308 = "TC6N8-DFD9K-RKPCC-7H93R-FC2KG" # Professional, Win 10 RTM Professional Retail
    3308 = "TYNHW-PQ6GK-6T847-DCJQW-YP2KG" # Professional, Win 10 RTM Professional Retail
    3308 = "TYQNP-74GHW-DCDV7-Q6K37-PWF9G" # Professional, Win 10 RTM Professional Retail
    3308 = "V3VRY-WYNMD-PW8GJ-2XV4M-CWF9G" # Professional, Win 10 RTM Professional Retail
    3308 = "VC7CG-XRNPF-X6FM4-J33YM-B4G6T" # Professional, Win 10 RTM Professional Retail
    3308 = "VJNY2-B8W2H-6B8CT-W26GF-KBT6T" # Professional, Win 10 RTM Professional Retail
    3308 = "VK7JG-NPHTM-C97JM-9MPGT-3V66T" # Professional, Win 10 RTM Professional Retail
    3308 = "W69BB-N79M9-M223P-JVQDC-JB49G" # Professional, Win 10 RTM Professional Retail
    3308 = "WX46C-N9RK4-9P3FV-Y4M9G-PDKTT" # Professional, Win 10 RTM Professional Retail
    3308 = "XFH34-N8YPQ-MQKMB-KTJX8-F3KTT" # Professional, Win 10 RTM Professional Retail
    3308 = "XGYGN-8DQ7H-HGWFQ-XB7CY-KD726" # Professional, Win 10 RTM Professional Retail
    3308 = "XNMX6-4Q946-9QRMF-THQT6-BP2KG" # Professional, Win 10 RTM Professional Retail
    3308 = "XNTC7-BPJQC-GX46V-6CG82-Q3WXG" # Professional, Win 10 RTM Professional Retail
    3308 = "XNWRG-DJ96J-XJ8P7-Y4DHQ-M7V26" # Professional, Win 10 RTM Professional Retail
    3309 = "88G7P-HD74N-MG9WP-93XWQ-MDWXH" # Professional, Win 10 RTM Professional Retail
    3309 = "DJBMD-4F9CD-YJ9Q4-NDHD2-6JF9H" # Professional, Win 10 RTM Professional Retail
    3309 = "FDTTH-PGBYW-XW2RD-NCYMM-88F9H" # Professional, Win 10 RTM Professional Retail
    3309 = "Q27W6-FJBV9-4DFRT-N9WV8-RX8XH" # Professional, Win 10 RTM Professional Retail
    3310 = "63FTG-KN7RX-RMYHH-4TGHW-CPQGW" # Professional, Win 10 RTM Professional Retail
    3310 = "6TDNG-YWPDR-W3FDM-WPKTP-7CFC8" # Professional, Win 10 RTM Professional Retail
    3310 = "BNWWD-82X4R-WTMQC-72YF8-J8F9J" # Professional, Win 10 RTM Professional Retail
    3310 = "HD3M6-MN2PH-WDHDQ-F4CJG-J2QGW" # Professional, Win 10 RTM Professional Retail
    3310 = "HF29H-DFNHX-JKM6X-3XVK2-YKMP8" # Professional, Win 10 RTM Professional Retail
    3310 = "JPHNP-VJ3RW-HX2HT-6X9GB-X4R9J" # Professional, Win 10 RTM Professional Retail
    3310 = "NHCJT-BG7GG-J44P8-F3HX6-V6DGW" # Professional, Win 10 RTM Professional Retail
    3310 = "NJQK8-TPGT8-W98WH-KXJMQ-JTYP8" # Professional, Win 10 RTM Professional Retail
    3310 = "XFRQW-P8NBD-VFRFX-V2GDD-B98XJ" # Professional, Win 10 RTM Professional Retail
    3311 = "W269N-WFGWX-YVC9B-4J6C9-T83GX" # Professional, Win 10 RTM Professional Volume:GVLK
    3311 = "YC7N8-G7WR6-9WR4H-6Y2W4-KBT6X" # Professional, Win 10 RTM Professional Volume:GVLK
    3312 = "3C3XJ-BNGYF-GT9VV-KYTRT-8TYQB" # Professional, Win 10 RTM Professional Volume:MAK
    3312 = "3N46B-F8R7T-BM6CV-TRTMX-T83GY" # Professional, Win 10 RTM Professional Volume:MAK
    3312 = "9P9NR-C9T8T-PFQF9-JRDXP-JB49M" # Professional, Win 10 RTM Professional Volume:MAK
    3312 = "BNG7W-CCTQ9-HP93Q-TJWT7-G6PKM" # Professional, Win 10 RTM Professional Volume:MAK
    3312 = "CGKNM-P2HMP-3DDXH-6G4MD-M7V3B" # Professional, Win 10 RTM Professional Volume:MAK
    3312 = "D2H3X-N82QX-2WVVK-C9K4M-RC2KM" # Professional, Win 10 RTM Professional Volume:MAK
    3312 = "D84KV-7NXJR-FTWTG-GYYXG-D3WXM" # Professional, Win 10 RTM Professional Volume:MAK
    3312 = "DH3PM-NJ3QG-CFMPQ-DKJGF-4X8XM" # Professional, Win 10 RTM Professional Volume:MAK
    3312 = "DHWP9-NWWKH-G72RJ-CQ49T-P7JXM" # Professional, Win 10 RTM Professional Volume:MAK
    3312 = "G7MQD-DN2QR-J94CG-KVF7R-VMH3B" # Professional, Win 10 RTM Professional Volume:MAK
    3312 = "GDTNP-H4DWW-K8X3B-RFQQD-49CKM" # Professional, Win 10 RTM Professional Volume:MAK
    3312 = "H74JJ-7FNDK-FKBT6-RF7XD-YBH3B" # Professional, Win 10 RTM Professional Volume:MAK
    3312 = "HB2G7-NJB3W-C3CT2-HVQXH-B7V3B" # Professional, Win 10 RTM Professional Volume:MAK
    3312 = "JDCKB-7VNPD-QD376-MMRQJ-JFG6Y" # Professional, Win 10 RTM Professional Volume:MAK
    3312 = "JHKRN-JQGBG-DH7JB-JD77X-7XMQB" # Professional, Win 10 RTM Professional Volume:MAK
    3312 = "JNXX2-JTB9M-FDK3V-GQXJW-BWRDB" # Professional, Win 10 RTM Professional Volume:MAK
    3312 = "KFW8N-J4MP3-Q37H9-GQ2P8-MTDGY" # Professional, Win 10 RTM Professional Volume:MAK
    3312 = "MNWM3-Y2HKW-H22TJ-D8VG8-JFG6Y" # Professional, Win 10 RTM Professional Volume:MAK
    3312 = "MWY8V-N8QCR-VV9MV-RQ7R6-QYH3B" # Professional, Win 10 RTM Professional Volume:MAK
    3312 = "N3TDW-CW7TP-69FJC-RT2WD-QRR9M" # Professional, Win 10 RTM Professional Volume:MAK
    3312 = "N66WH-MDHRC-DWT3T-Y383K-Y7V3B" # Professional, Win 10 RTM Professional Volume:MAK
    3312 = "N7CXQ-RW8G8-QT9RC-9BBRH-YY49M" # Professional, Win 10 RTM Professional Volume:MAK
    3312 = "NCTH2-M3KRD-QRQMK-6XMXX-CDKTY" # Professional, Win 10 RTM Professional Volume:MAK
    3312 = "NMQWG-TM4R6-2QKJK-MPRCC-BTDGY" # Professional, Win 10 RTM Professional Volume:MAK
    3312 = "NW9MP-GRTT8-3RXM9-W446T-XQBQB" # Professional, Win 10 RTM Professional Volume:MAK
    3312 = "NYPVG-GFKXY-H6FKC-4JFGB-X4R9M" # Professional, Win 10 RTM Professional Volume:MAK
    3312 = "P9PDH-NCJ7Q-92T89-7FX76-722KM" # Professional, Win 10 RTM Professional Volume:MAK
    3312 = "PNDGK-PM26G-BDG9X-J69CQ-TCQGY" # Professional, Win 10 RTM Professional Volume:MAK
    3312 = "Q6VNQ-TCM4W-CCVWY-B4QKX-6CQGY" # Professional, Win 10 RTM Professional Volume:MAK
    3312 = "QJNXR-YD97Q-K7WH4-RYWQ8-6MT6Y" # Professional, Win 10 RTM Professional Volume:MAK
    3312 = "QPNBW-VC6VR-2B7JR-XX496-Y98XM" # Professional, Win 10 RTM Professional Volume:MAK
    3312 = "QVPYN-C3P8F-XMBWR-J9QWC-PGYQB" # Professional, Win 10 RTM Professional Volume:MAK
    3312 = "RN6T7-3GV49-43DQJ-89RQM-MY49M" # Professional, Win 10 RTM Professional Volume:MAK
    3312 = "VCTJH-KNG8D-3Y36V-W9Y48-J8F9M" # Professional, Win 10 RTM Professional Volume:MAK
    3312 = "VG26N-GFX8Y-V2B79-8C8RC-27JXM" # Professional, Win 10 RTM Professional Volume:MAK
    3312 = "XGNJ6-WRVRD-M4R3Q-8BTC4-6Q73B" # Professional, Win 10 RTM Professional Volume:MAK
    3312 = "XGXGD-NQRGY-2JBBQ-266HK-RM49M" # Professional, Win 10 RTM Professional Volume:MAK
    3313 = "CFQFT-XNTXF-VJ4MC-3DDXV-94R9P" # Professional, Win 10 RTM Professional Volume:MAK
    3313 = "DGN4F-YHHRJ-M8G6D-BDBHQ-XHJXP" # Professional, Win 10 RTM Professional Volume:MAK
    3313 = "FTNVJ-JBBWC-26CGT-28XVT-HFR9P" # Professional, Win 10 RTM Professional Volume:MAK
    3313 = "NR4R9-WF6TQ-4TVB6-3YMX7-XD73C" # Professional, Win 10 RTM Professional Volume:MAK
    3314 = "2QN79-MFHKY-VW4HX-TFD9J-7FR9Q" # ProfessionalN, Win 10 RTM ProfessionalN OEM:DM
    3314 = "3C98C-DRNGM-MCTQJ-WY949-2YT63" # ProfessionalN, Win 10 RTM ProfessionalN OEM:DM
    3314 = "3XFBN-WY2B8-DQ4FJ-TQHJV-7QWXQ" # ProfessionalN, Win 10 RTM ProfessionalN OEM:DM
    3314 = "4DBW3-XN8YC-F74XR-QKFRH-QPFDD" # ProfessionalN, Win 10 RTM ProfessionalN OEM:DM
    3314 = "6V43W-6N6XV-HT892-Y6GF7-3J3G3" # ProfessionalN, Win 10 RTM ProfessionalN OEM:DM
    3314 = "6X4N2-PXTF7-BWTFB-4Q9BV-46YQD" # ProfessionalN, Win 10 RTM ProfessionalN OEM:DM
    3314 = "736V8-NM7JQ-HJRFC-B9C8B-K7663" # ProfessionalN, Win 10 RTM ProfessionalN OEM:DM
    3314 = "BNMVG-QJR9K-B87YR-XYRPR-VMH3D" # ProfessionalN, Win 10 RTM ProfessionalN OEM:DM
    3314 = "CNH8T-Q7JMM-4M8BY-3FVDX-2YT63" # ProfessionalN, Win 10 RTM ProfessionalN OEM:DM
    3314 = "CPVVD-PNB4C-DFFX2-DJHHD-RJRDD" # ProfessionalN, Win 10 RTM ProfessionalN OEM:DM
    3314 = "CWHF2-FNTDD-6FMTF-7K6HC-FX8XQ" # ProfessionalN, Win 10 RTM ProfessionalN OEM:DM
    3314 = "DMXJN-DCCMP-MKYJT-44W9W-TQ73D" # ProfessionalN, Win 10 RTM ProfessionalN OEM:DM
    3314 = "FCNMP-DHHJM-GDF9P-G9XPC-4RG63" # ProfessionalN, Win 10 RTM ProfessionalN OEM:DM
    3314 = "FKPYH-9CN4Q-MTH96-VYWG7-RGDG3" # ProfessionalN, Win 10 RTM ProfessionalN OEM:DM
    3314 = "HDKJD-QGNVJ-YGWJ4-TT3WJ-D9MQD" # ProfessionalN, Win 10 RTM ProfessionalN OEM:DM
    3314 = "HN6JV-2PVDT-VHX2K-BVRMY-WHV3D" # ProfessionalN, Win 10 RTM ProfessionalN OEM:DM
    3314 = "J292X-9NTDX-KG7H9-3D837-FJRDD" # ProfessionalN, Win 10 RTM ProfessionalN OEM:DM
    3314 = "JGDN9-WKM9H-7RKXC-73PKD-FM49Q" # ProfessionalN, Win 10 RTM ProfessionalN OEM:DM
    3314 = "JMCNR-7YBB8-4C7H3-8YGF9-66PKQ" # ProfessionalN, Win 10 RTM ProfessionalN OEM:DM
    3314 = "KQP6C-NH3KF-D3XCW-H9JMP-27JXQ" # ProfessionalN, Win 10 RTM ProfessionalN OEM:DM
    3314 = "KW3PX-39NVG-3RYYB-929FB-YWRDD" # ProfessionalN, Win 10 RTM ProfessionalN OEM:DM
    3314 = "N7KWP-RFCTM-8TM42-HVPTC-9QBQD" # ProfessionalN, Win 10 RTM ProfessionalN OEM:DM
    3314 = "NF3Q3-4KTWH-489DP-3YDRW-XW3G3" # ProfessionalN, Win 10 RTM ProfessionalN OEM:DM
    3314 = "NGMHF-GW28B-76HMB-6JTRX-GJF9Q" # ProfessionalN, Win 10 RTM ProfessionalN OEM:DM
    3314 = "NH7W7-BMC3R-4W9XT-94B6D-TCQG3" # ProfessionalN, Win 10 RTM ProfessionalN OEM:DM
    3314 = "NWVJP-VTWVQ-PBFHB-YPW9C-7CFDD" # ProfessionalN, Win 10 RTM ProfessionalN OEM:DM
    3314 = "NWWGK-3QTDG-D322H-PRD7G-V6DG3" # ProfessionalN, Win 10 RTM ProfessionalN OEM:DM
    3314 = "PN4GV-KP7DG-629XG-VDXJB-CWF9Q" # ProfessionalN, Win 10 RTM ProfessionalN OEM:DM
    3314 = "PVR6H-NTGD7-BQ7X4-93Q9R-MWRDD" # ProfessionalN, Win 10 RTM ProfessionalN OEM:DM
    3314 = "QNTWT-3MMT6-Y3QVC-FYPHF-369T3" # ProfessionalN, Win 10 RTM ProfessionalN OEM:DM
    3314 = "QPC3X-T9NPC-RW8BB-RRGQP-8XCKQ" # ProfessionalN, Win 10 RTM ProfessionalN OEM:DM
    3314 = "QVPCV-NCD6K-KQV3Q-X6RWP-VFR9Q" # ProfessionalN, Win 10 RTM ProfessionalN OEM:DM
    3314 = "R2TJ7-9DNRJ-JY6XW-PXVKH-KHJXQ" # ProfessionalN, Win 10 RTM ProfessionalN OEM:DM
    3314 = "RDGBN-RMM3C-R66WW-J82GM-43KT3" # ProfessionalN, Win 10 RTM ProfessionalN OEM:DM
    3314 = "RFPF3-NWRDC-83K94-HQTKQ-KKXT3" # ProfessionalN, Win 10 RTM ProfessionalN OEM:DM
    3314 = "VCJNR-MY9XK-BCQ63-VGWF6-QYH3D" # ProfessionalN, Win 10 RTM ProfessionalN OEM:DM
    3314 = "VDPNF-J4X9B-FJC2P-7JQFD-JTYQD" # ProfessionalN, Win 10 RTM ProfessionalN OEM:DM
    3314 = "VWTXN-MJ2HW-8R3KB-9WYD2-V8RDD" # ProfessionalN, Win 10 RTM ProfessionalN OEM:DM
    3314 = "VXN7G-4G9P9-F6GKT-CF422-MP2KQ" # ProfessionalN, Win 10 RTM ProfessionalN OEM:DM
    3314 = "W7JC8-G7N7P-C2WTV-44W6Q-YBH3D" # ProfessionalN, Win 10 RTM ProfessionalN OEM:DM
    3315 = "2KMWQ-NRH27-DV92J-J9GGT-TJF9R" # ProfessionalN, Win 10 RTM ProfessionalN OEM:NONSLP
    3315 = "33WWX-XHN6G-CC88J-CFWJD-9D73F" # ProfessionalN, Win 10 RTM ProfessionalN OEM:NONSLP
    3315 = "4J87H-N2833-6PCWF-7HWFF-2KCKR" # ProfessionalN, Win 10 RTM ProfessionalN OEM:NONSLP
    3315 = "9XPNQ-P9CWR-9R8KP-PB4HW-WB49R" # ProfessionalN, Win 10 RTM ProfessionalN OEM:NONSLP
    3315 = "FY327-QNYQC-3WDFC-MKQDC-PGYQF" # ProfessionalN, Win 10 RTM ProfessionalN OEM:NONSLP
    3315 = "N6233-Y6GCR-6RCM3-QFF3Y-8FG64" # ProfessionalN, Win 10 RTM ProfessionalN OEM:NONSLP
    3315 = "NJ6Y6-HQ4JJ-GXJY6-JCPM6-BP2KR" # ProfessionalN, Win 10 RTM ProfessionalN OEM:NONSLP
    3315 = "NK8HP-6D7GB-9RTK6-4KDRH-GCQG4" # ProfessionalN, Win 10 RTM ProfessionalN OEM:NONSLP
    3315 = "NQ223-PC2F9-6TJJK-Y9P7F-X2FDF" # ProfessionalN, Win 10 RTM ProfessionalN OEM:NONSLP
    3315 = "NRTKY-9489Y-48WB6-QT6X6-Y98XR" # ProfessionalN, Win 10 RTM ProfessionalN OEM:NONSLP
    3315 = "QNH8Y-PG6KP-C7MDM-CX9XP-TMT64" # ProfessionalN, Win 10 RTM ProfessionalN OEM:NONSLP
    3315 = "TV4D3-R2NC9-QQHB7-GDDY4-MWRDF" # ProfessionalN, Win 10 RTM ProfessionalN OEM:NONSLP
    3315 = "YQH9J-XYNRK-C2FQK-VQDRY-3GPKR" # ProfessionalN, Win 10 RTM ProfessionalN OEM:NONSLP
    3316 = "2B29T-NRCQT-TGH7G-KDTDK-6CQG6" # ProfessionalN, Win 10 RTM ProfessionalN Retail
    3316 = "2B87N-8KFHP-DKV6R-Y2C8J-PKCKT" # ProfessionalN, Win 10 RTM ProfessionalN Retail
    3316 = "3QGTR-G7N3P-3MX3F-W4B4W-JFG66" # ProfessionalN, Win 10 RTM ProfessionalN Retail
    3316 = "3WTKN-RV9XV-XDRHF-HD2QX-66PKT" # ProfessionalN, Win 10 RTM ProfessionalN Retail
    3316 = "6B2KN-9JDVT-J78JB-284R9-66PKT" # ProfessionalN, Win 10 RTM ProfessionalN Retail
    3316 = "6MFNB-H2K7D-8QCBM-DGB8V-R9CKT" # ProfessionalN, Win 10 RTM ProfessionalN Retail
    3316 = "7MND6-J7F4G-F887Y-99XMG-2373G" # ProfessionalN, Win 10 RTM ProfessionalN Retail
    3316 = "84CP6-N89B6-FTWQJ-GY62C-FX8XT" # ProfessionalN, Win 10 RTM ProfessionalN Retail
    3316 = "8CB8D-N2C2H-YGPC9-R984X-Y7V3G" # ProfessionalN, Win 10 RTM ProfessionalN Retail
    3316 = "8NQTV-7FQR9-27KKV-2M4HG-KTPKT" # ProfessionalN, Win 10 RTM ProfessionalN Retail
    3316 = "9NG77-WFMT2-FKH7W-38DMW-RX8XT" # ProfessionalN, Win 10 RTM ProfessionalN Retail
    3316 = "BR2Q9-FN6VT-D6JFM-BRCP7-KHJXT" # ProfessionalN, Win 10 RTM ProfessionalN Retail
    3316 = "DM4NY-Y2WF7-VJJF9-9PTK2-J44DG" # ProfessionalN, Win 10 RTM ProfessionalN Retail
    3316 = "DPPRN-PP9D6-RMP3J-HPDHV-BDWXT" # ProfessionalN, Win 10 RTM ProfessionalN Retail
    3316 = "F6GJC-NXCM6-JW4C2-DCRQJ-JFG66" # ProfessionalN, Win 10 RTM ProfessionalN Retail
    3316 = "F6KN6-Q3FX6-WTH7M-G9RJ4-VMH3G" # ProfessionalN, Win 10 RTM ProfessionalN Retail
    3316 = "F6QCD-BNYYR-K7HCJ-X9B34-F6YQG" # ProfessionalN, Win 10 RTM ProfessionalN Retail
    3316 = "FBVNY-B4B3R-WG8YB-RHV8Y-PR4DG" # ProfessionalN, Win 10 RTM ProfessionalN Retail
    3316 = "GHH37-F4N9K-3MHBJ-MQRRW-D9MQG" # ProfessionalN, Win 10 RTM ProfessionalN Retail
    3316 = "GWN7J-TJ38Q-Q4399-MXJXG-XQBQG" # ProfessionalN, Win 10 RTM ProfessionalN Retail
    3316 = "HNVPH-MXM9Y-JDG4P-WHC23-8K8XT" # ProfessionalN, Win 10 RTM ProfessionalN Retail
    3316 = "HX8YX-3NXK4-3J9JF-TKQB8-78RDG" # ProfessionalN, Win 10 RTM ProfessionalN Retail
    3316 = "KN368-RBYCH-GW4CW-K8WRV-WK8XT" # ProfessionalN, Win 10 RTM ProfessionalN Retail
    3316 = "N6978-P8C8P-7J8R6-JT96R-2KCKT" # ProfessionalN, Win 10 RTM ProfessionalN Retail
    3316 = "N6C3Q-J7CJ4-V96RG-G7QQQ-C373G" # ProfessionalN, Win 10 RTM ProfessionalN Retail
    3316 = "N79KC-MKD68-96QY3-CPRFC-RVV3G" # ProfessionalN, Win 10 RTM ProfessionalN Retail
    3316 = "NGWYK-MTVH2-XTK8H-JGP36-C9XT6" # ProfessionalN, Win 10 RTM ProfessionalN Retail
    3316 = "NW7J8-Y88HJ-GCP33-8X623-YBH3G" # ProfessionalN, Win 10 RTM ProfessionalN Retail
    3316 = "NXK79-7C62G-VK67V-34QFV-WK8XT" # ProfessionalN, Win 10 RTM ProfessionalN Retail
    3316 = "NXWG9-VDHMG-W3PWP-79DJ7-X7666" # ProfessionalN, Win 10 RTM ProfessionalN Retail
    3316 = "NYHVP-6PBK9-JJRJV-BYYWP-BTDG6" # ProfessionalN, Win 10 RTM ProfessionalN Retail
    3316 = "PJX3N-CBC24-FPB6M-P7CBG-RRG66" # ProfessionalN, Win 10 RTM ProfessionalN Retail
    3316 = "PNPMD-M4CPD-34TGW-37GYW-W44DG" # ProfessionalN, Win 10 RTM ProfessionalN Retail
    3316 = "Q4RMX-GNQT4-W6VFQ-CQHY3-Y4G66" # ProfessionalN, Win 10 RTM ProfessionalN Retail
    3316 = "R24N9-QH8VH-WQ3Y7-QY7K2-8XCKT" # ProfessionalN, Win 10 RTM ProfessionalN Retail
    3316 = "RR693-DPN6P-Y4V4Y-G4M39-7XMQG" # ProfessionalN, Win 10 RTM ProfessionalN Retail
    3316 = "THPBQ-N4F6M-JPK6B-RG699-WTYQG" # ProfessionalN, Win 10 RTM ProfessionalN Retail
    3316 = "TXMBR-N7DH3-2PFDF-67C3T-GMT66" # ProfessionalN, Win 10 RTM ProfessionalN Retail
    3316 = "VGN89-VKGKP-BGTXV-BRQJW-VH666" # ProfessionalN, Win 10 RTM ProfessionalN Retail
    3316 = "VHTMN-GFRPG-78FGF-88H7Q-M7V3G" # ProfessionalN, Win 10 RTM ProfessionalN Retail
    3316 = "WWH86-NMX7H-BFKHW-BKG8F-MWRDG" # ProfessionalN, Win 10 RTM ProfessionalN Retail
    3316 = "XY6BR-KNDCB-DQHHC-WJQYH-X7666" # ProfessionalN, Win 10 RTM ProfessionalN Retail
    3317 = "4B98P-WP9HN-XKDDP-HWCTM-KD73H" # ProfessionalN, Win 10 RTM ProfessionalN Retail
    3317 = "6CRRT-MFK42-PVN9R-BTYV6-722KV" # ProfessionalN, Win 10 RTM ProfessionalN Retail
    3317 = "WKVBF-F226X-NR2XW-3WW93-2WF9V" # ProfessionalN, Win 10 RTM ProfessionalN Retail
    3318 = "8NVGM-CKCPY-VFHVY-KTMH2-HH668" # ProfessionalN, Win 10 RTM ProfessionalN Retail
    3318 = "FMVRD-WNQVD-D6QPB-RT88T-QYH3J" # ProfessionalN, Win 10 RTM ProfessionalN Retail
    3318 = "GNCFB-XDTMQ-47342-62VKK-YDWXW" # ProfessionalN, Win 10 RTM ProfessionalN Retail
    3318 = "Q2NKV-98YCF-C6KMW-TKKTJ-2GYQJ" # ProfessionalN, Win 10 RTM ProfessionalN Retail
    3318 = "RNR8D-B4QK8-BDP4D-GTPCR-BY49W" # ProfessionalN, Win 10 RTM ProfessionalN Retail
    3318 = "YKMY3-NTHJ6-3GVPJ-R7F93-2WF9W" # ProfessionalN, Win 10 RTM ProfessionalN Retail
    3319 = "HMNWJ-V69R6-B2CDC-8P7VT-2373K" # ProfessionalN, Win 10 RTM ProfessionalN Volume:GVLK
    3319 = "MH37W-N47XK-V7XM9-C7227-GCQG9" # ProfessionalN, Win 10 RTM ProfessionalN Volume:GVLK
    3320 = "44PQX-NFXFH-XD9QY-38JVR-844DM" # ProfessionalN, Win 10 RTM ProfessionalN Volume:MAK
    3320 = "9NKWQ-28467-CRMKC-9YB2V-PWF9Y" # ProfessionalN, Win 10 RTM ProfessionalN Volume:MAK
    3320 = "DFDYN-WJR3R-CJC87-R7B9K-JXCKY" # ProfessionalN, Win 10 RTM ProfessionalN Volume:MAK
    3320 = "DKDNW-TVC88-9TMY7-YT9PF-8B49Y" # ProfessionalN, Win 10 RTM ProfessionalN Volume:MAK
    3320 = "F2NVG-HKM28-VY6RW-FJWRF-CR4DM" # ProfessionalN, Win 10 RTM ProfessionalN Volume:MAK
    3320 = "FNPJB-C6Y6X-GXQWM-79GJJ-XW3HB" # ProfessionalN, Win 10 RTM ProfessionalN Volume:MAK
    3320 = "FNTQK-DP7FM-GPQB2-M9BKR-DJ3HB" # ProfessionalN, Win 10 RTM ProfessionalN Volume:MAK
    3320 = "GC9GD-N2YRX-2FRPT-M7XWT-QYH3M" # ProfessionalN, Win 10 RTM ProfessionalN Volume:MAK
    3320 = "GKDTR-NDC27-Y64GV-J42D6-2373M" # ProfessionalN, Win 10 RTM ProfessionalN Volume:MAK
    3320 = "HRNHB-MDMKJ-7B74M-FB6M8-JFG7B" # ProfessionalN, Win 10 RTM ProfessionalN Volume:MAK
    3320 = "HRY3G-NXWKM-FH7YY-BDWPR-KBT7B" # ProfessionalN, Win 10 RTM ProfessionalN Volume:MAK
    3320 = "KDPBN-MKMTM-VPQK2-PHVBV-9BT7B" # ProfessionalN, Win 10 RTM ProfessionalN Volume:MAK
    3320 = "MMKYK-QNQFH-KJF3V-J4HTF-BY49Y" # ProfessionalN, Win 10 RTM ProfessionalN Volume:MAK
    3320 = "N3M67-82C2B-64DVW-C7BP2-7CFDM" # ProfessionalN, Win 10 RTM ProfessionalN Volume:MAK
    3320 = "N6PP2-2BMR3-8CBJ4-7JFWD-9D73M" # ProfessionalN, Win 10 RTM ProfessionalN Volume:MAK
    3320 = "NJ3GV-MCQHC-DJMDK-TK8F3-C373M" # ProfessionalN, Win 10 RTM ProfessionalN Volume:MAK
    3320 = "NYJVK-8TTVJ-C68BC-RMW29-P373M" # ProfessionalN, Win 10 RTM ProfessionalN Volume:MAK
    3320 = "Q8GBV-YN6BP-WXBHJ-P69JW-YP2KY" # ProfessionalN, Win 10 RTM ProfessionalN Volume:MAK
    3320 = "QM8CX-N29PT-FFFCD-BPJYC-CKCKY" # ProfessionalN, Win 10 RTM ProfessionalN Volume:MAK
    3320 = "QQRNR-MM8WD-X3C43-VWVMD-DV67B" # ProfessionalN, Win 10 RTM ProfessionalN Volume:MAK
    3320 = "RNB93-FKP46-P23DM-M7CFR-R3KVB" # ProfessionalN, Win 10 RTM ProfessionalN Volume:MAK
    3320 = "TVQN9-H4VQW-YPYVH-PTTBX-4JRDM" # ProfessionalN, Win 10 RTM ProfessionalN Volume:MAK
    3320 = "W3NJG-HJ66R-XBQ6V-YRYBJ-K2FDM" # ProfessionalN, Win 10 RTM ProfessionalN Volume:MAK
    3320 = "XVMNF-PH2KF-HXQ3B-RGMDV-DRR9Y" # ProfessionalN, Win 10 RTM ProfessionalN Volume:MAK
    3320 = "XW8K7-NC8B8-FPJ26-FYKFM-6VJXY" # ProfessionalN, Win 10 RTM ProfessionalN Volume:MAK
    3321 = "3M3F8-YN4T9-DJMK9-VTP6G-MKMQP" # ProfessionalN, Win 10 RTM ProfessionalN Volume:MAK
    3321 = "9Y2N2-RF983-M8DXX-QGV6V-KHJX2" # ProfessionalN, Win 10 RTM ProfessionalN Volume:MAK
    3321 = "DCYNY-GFW6C-28PR9-HXVQR-JHV3P" # ProfessionalN, Win 10 RTM ProfessionalN Volume:MAK
    3321 = "XDWQ9-DDNCH-CY4WT-KXWBG-2373P" # ProfessionalN, Win 10 RTM ProfessionalN Volume:MAK
    3422 = "29N8G-XMMD7-8PTV2-6FF7F-TVJ48" # Core, Win 10 RTM Core OEM:DM
    3422 = "368WN-4TYJW-BKYFP-4WY9T-YG92J" # Core, Win 10 RTM Core OEM:DM
    3422 = "7YWP7-YN82T-3BPHM-VY2JB-6VJ48" # Core, Win 10 RTM Core OEM:DM
    3422 = "8NDWP-X6X8C-GFWXX-4BM6Q-8K848" # Core, Win 10 RTM Core OEM:DM
    3422 = "8PCMT-WNMRK-7MF6V-PFHXJ-7FTF8" # Core, Win 10 RTM Core OEM:DM
    3422 = "B8W89-NFC8F-C782R-6G7HM-39MWW" # Core, Win 10 RTM Core OEM:DM
    3422 = "DB4MM-NPT6H-W6Q63-M73Y7-CYVCJ" # Core, Win 10 RTM Core OEM:DM
    3422 = "DND7D-RXVTB-DYP44-XYQYG-HFTF8" # Core, Win 10 RTM Core OEM:DM
    3422 = "G4K2H-KTNGB-6KBBF-2R8WX-MG92J" # Core, Win 10 RTM Core OEM:DM
    3422 = "GX7VW-JRNT2-7MXMP-DMTHP-V8RJW" # Core, Win 10 RTM Core OEM:DM
    3422 = "H2FN2-F294C-GWT3W-JPDF7-HXMWW" # Core, Win 10 RTM Core OEM:DM
    3422 = "HBY4H-RNXB8-Y2YTR-443VB-MY6F8" # Core, Win 10 RTM Core OEM:DM
    3422 = "HMNXT-HFMD2-KGXHP-JVCJR-FC2R8" # Core, Win 10 RTM Core OEM:DM
    3422 = "HNGVG-HGJFG-6BKFM-MDW7K-RM6F8" # Core, Win 10 RTM Core OEM:DM
    3422 = "JNPM6-RQB23-8TGWF-Y6TCT-683PJ" # Core, Win 10 RTM Core OEM:DM
    3422 = "M2P7N-69983-C3RCQ-Y9FC4-9W3PJ" # Core, Win 10 RTM Core OEM:DM
    3422 = "N2G4K-Y8TB2-QFD9J-4V9JW-4VV8W" # Core, Win 10 RTM Core OEM:DM
    3422 = "NVM98-MRGJ2-6F4D8-XRK4D-BG92J" # Core, Win 10 RTM Core OEM:DM
    3422 = "PNV78-286W9-RQDD9-HTC7K-HCFJW" # Core, Win 10 RTM Core OEM:DM
    3422 = "QWHVM-3NKBV-TWJ8J-FHRMW-7FTF8" # Core, Win 10 RTM Core OEM:DM
    3422 = "RQDTH-PN3PK-96YF2-9H98C-XTPR8" # Core, Win 10 RTM Core OEM:DM
    3422 = "TJJTV-HNW4M-4KY28-BRQD2-6JGF8" # Core, Win 10 RTM Core OEM:DM
    3422 = "V2NHV-GQ43K-88YJP-JXF3Y-TXX2J" # Core, Win 10 RTM Core OEM:DM
    3422 = "YQTNY-6Y3D3-HYCF9-BB99B-43K2J" # Core, Win 10 RTM Core OEM:DM
    3423 = "2WPGN-4JH6M-BB4YK-TVF3F-7H7CK" # CoreCountrySpecific, Win 10 RTM CoreCountrySpecific OEM:DM
    3423 = "39JC3-TN66J-TQ3GM-94PG4-DJ3PK" # CoreCountrySpecific, Win 10 RTM CoreCountrySpecific OEM:DM
    3423 = "4YNX2-TT84J-HKRVH-YM9BB-39MWX" # CoreCountrySpecific, Win 10 RTM CoreCountrySpecific OEM:DM
    3423 = "78NGV-VTM63-8V4QQ-PJ94G-D3W49" # CoreCountrySpecific, Win 10 RTM CoreCountrySpecific OEM:DM
    3423 = "7NY2F-2RPB3-TJ734-YW6TM-B4HCK" # CoreCountrySpecific, Win 10 RTM CoreCountrySpecific OEM:DM
    3423 = "DCC6N-X83T4-DTH4H-4KH4W-TQ78X" # CoreCountrySpecific, Win 10 RTM CoreCountrySpecific OEM:DM
    3423 = "F987P-6N62H-V938R-XKCBR-6Q78X" # CoreCountrySpecific, Win 10 RTM CoreCountrySpecific OEM:DM
    3423 = "HHJFP-J7NCP-C6MFC-YXR4G-D3W49" # CoreCountrySpecific, Win 10 RTM CoreCountrySpecific OEM:DM
    3423 = "HKFJR-N3H3P-7FCQ7-WDBQM-XBVCK" # CoreCountrySpecific, Win 10 RTM CoreCountrySpecific OEM:DM
    3423 = "KTRKN-8RCFX-3T47M-VGDT8-JFHCK" # CoreCountrySpecific, Win 10 RTM CoreCountrySpecific OEM:DM
    3423 = "MX7CG-3NV7R-979CY-RBWM6-J2QPK" # CoreCountrySpecific, Win 10 RTM CoreCountrySpecific OEM:DM
    3423 = "NCM4C-9DM2J-GG7YC-XJCRK-BKMWX" # CoreCountrySpecific, Win 10 RTM CoreCountrySpecific OEM:DM
    3423 = "NF3C7-QJCH4-XMB9G-HT9HK-HCFJX" # CoreCountrySpecific, Win 10 RTM CoreCountrySpecific OEM:DM
    3423 = "NGD9M-9RKHB-68KVG-2QB8M-HT92K" # CoreCountrySpecific, Win 10 RTM CoreCountrySpecific OEM:DM
    3423 = "NWFGV-2B6FY-RWD28-FM6XR-7H7CK" # CoreCountrySpecific, Win 10 RTM CoreCountrySpecific OEM:DM
    3423 = "YNDMB-2QCFC-HTFBP-JF9HC-FX849" # CoreCountrySpecific, Win 10 RTM CoreCountrySpecific OEM:DM
    3423 = "YNG9G-C88QB-B88K9-BWWQ8-6MVCK" # CoreCountrySpecific, Win 10 RTM CoreCountrySpecific OEM:DM
    3424 = "FHDPX-JNVDW-FF3RD-HPDKC-MP2TB" # CoreSingleLanguage, Win 10 RTM CoreSingleLanguage OEM:DM
    3424 = "H6G89-NQVMR-V9QDD-BHJPM-8FHCM" # CoreSingleLanguage, Win 10 RTM CoreSingleLanguage OEM:DM
    3424 = "JFT78-J8N8P-GJ8KQ-R9TVP-KW3PM" # CoreSingleLanguage, Win 10 RTM CoreSingleLanguage OEM:DM
    3424 = "K62NP-KT2WK-6HX2X-B8JJR-PPQPM" # CoreSingleLanguage, Win 10 RTM CoreSingleLanguage OEM:DM
    3424 = "KJ8MH-MNJMF-XPRD4-BTT49-MG92M" # CoreSingleLanguage, Win 10 RTM CoreSingleLanguage OEM:DM
    3424 = "TKMKK-8NH9Y-VKD4Y-B2RDD-KKX2M" # CoreSingleLanguage, Win 10 RTM CoreSingleLanguage OEM:DM
    3424 = "TN83Y-KKVQK-YJKVD-FVWY6-BP2TB" # CoreSingleLanguage, Win 10 RTM CoreSingleLanguage OEM:DM
    3425 = "3RKN7-8PWXC-VRKJW-6RRGP-DDBW2" # Professional, Win 10 RTM Professional OEM:DM
    3425 = "6C3Q3-3NFYH-YYYXW-3TQMJ-WB6GC" # Professional, Win 10 RTM Professional OEM:DM
    3425 = "847K2-NHK4Y-J48Y9-MK8GD-TCQPP" # Professional, Win 10 RTM Professional OEM:DM
    3425 = "8WVNW-47G3Q-QFHXC-F678C-D692P" # Professional, Win 10 RTM Professional OEM:DM
    3425 = "9R63F-NGF82-938JB-J7DCQ-H22TC" # Professional, Win 10 RTM Professional OEM:DM
    3425 = "G88NP-2HYMW-B4QGH-87K7H-M4HCP" # Professional, Win 10 RTM Professional OEM:DM
    3425 = "HDNGX-P72PX-PVYMX-K932H-R9CTC" # Professional, Win 10 RTM Professional OEM:DM
    3425 = "K3RTH-NHMX6-T4KK4-WQWXY-XBVCP" # Professional, Win 10 RTM Professional OEM:DM
    3425 = "M9H87-JN9JF-FHDJ9-67MF6-Y986C" # Professional, Win 10 RTM Professional OEM:DM
    3425 = "MT3Q7-XTN4Y-7F7J4-4GHTQ-BG92P" # Professional, Win 10 RTM Professional OEM:DM
    3425 = "NJ699-4WWMC-39RH9-TXD7J-QDBW2" # Professional, Win 10 RTM Professional OEM:DM
    3425 = "NM7HJ-FYJ4F-7G82H-CG2DT-KTPTC" # Professional, Win 10 RTM Professional OEM:DM
    3425 = "QY2N8-QJB87-234JV-KRBRY-HT92P" # Professional, Win 10 RTM Professional OEM:DM
    3425 = "XKDVP-CRN3D-V97G6-GHKBY-WHV82" # Professional, Win 10 RTM Professional OEM:DM
    3473 = "R3YNH-RXJTK-2MVGR-WF7WC-TMVFP" # EducationN, Win Next Pre-Release EducationN OEM:DM
    3475 = "KBTM7-2XN2J-YFGGP-VR6H3-FM6JF" # EducationN, Win Next Pre-Release EducationN Volume:GVLK
    3477 = "HDN7M-3B6D9-QRKV2-Q8MP3-BG94V" # Core, Win Next Pre-Release Core Retail
    3479 = "TCBYX-PN62G-9KGFJ-MCVHM-8FHFX" # Professional, Win Next Pre-Release Professional Retail
    3481 = "3NF4D-GF9GY-63VKH-QRC3V-7QW8P" # ProfessionalS, Win Next Pre-Release ProfessionalS Volume:GVLK
    3482 = "8NKQT-94VBW-XPH38-4YCVH-M4HF3" # ProfessionalS, Win Next Pre-Release ProfessionalS Volume:MAK
    3483 = "8Q36Y-N2F39-HRMHT-4XW33-TCQR4" # ProfessionalSN, Win Next Pre-Release ProfessionalSN Volume:GVLK
    3483 = "KNDJ3-GVHWT-3TV4V-36K8Y-PR4PF" # ProfessionalSN, Win Next Pre-Release ProfessionalSN Volume:GVLK
    3484 = "WRX3N-KBVHB-TBVP7-99C96-KTPWT" # ProfessionalSN, Win Next Pre-Release ProfessionalSN Volume:MAK
    3485 = "RFNQC-YMPKP-G9G4X-BQF2B-XBVF7" # EnterpriseS, Win Next Pre-Release EnterpriseS OEM:DM
    3488 = "CDPQN-G99KT-WXG77-RJ224-CR4PM" # EnterpriseS, Win Next Pre-Release EnterpriseS Volume:GVLK
    3489 = "KFNCW-PRMTQ-YXJXY-XQJ6G-HFTJ2" # EnterpriseSN, Win Next Pre-Release EnterpriseSN OEM:DM
    3492 = "4QRRP-N7CDF-RVYDJ-TKVDB-6VJ86" # EnterpriseSN, Win Next Pre-Release EnterpriseSN Volume:GVLK
    3493 = "Q63NY-BJFCR-MBG7C-CHBRT-FVWCV" # EnterpriseSEval, Win Next Pre-Release EnterpriseSEval Retail:TB:Eval
    3494 = "BN6B9-CHPDX-MYV9D-2PDDR-X2FPW" # EnterpriseSNEval, Win Next Pre-Release EnterpriseSNEval Retail:TB:Eval
    3495 = "R2RFV-BN8G3-4HDWR-R724J-29X6K" # MobileCore, Win Next Pre-Release MobileCore Retail
    3496 = "3QRDN-HHY7Y-BH34H-2PQ3P-BTDTM" # MobileEnterprise, Win Next Pre-Release MobileEnterprise Volume:MAK
    3496 = "MN2VC-BHTWX-8WBPC-WBRXT-YG96M" # MobileEnterprise, Win Next Pre-Release MobileEnterprise Volume:MAK
    3500 = "7VX4N-3VDHQ-VYGHB-JXJVP-9QB26" # ServerHI, Windows Server Next Beta ServerHI Volume:GVLK
    3500 = "8NPPB-WGMTQ-7QWMY-VHWXQ-KKX6T" # ServerHI, Windows Server Next Beta ServerHI Volume:GVLK
    3504 = "NHF4B-PC2H9-B8F3T-JCGTC-9QB3B" # Core, Win 10 RTM Core Retail
    3504 = "WCBQD-VN8PB-FH2RR-WPFCX-3RTKM" # Core, Win 10 RTM Core Retail
    3505 = "49NT7-6HWP2-KX7GX-FRWDJ-TQ8DC" # Core, Win 10 RTM Core Retail
    3505 = "D7MXN-HGMTK-3DY7V-T9PTM-KD8DC" # Core, Win 10 RTM Core Retail
    3506 = "X9NV3-MCH4F-M3G24-2PKR2-BTDT3" # Professional, Win 10 RTM Professional Retail
    3506 = "XN9J7-JRDBW-H38BQ-8CFVW-WB6KQ" # Professional, Win 10 RTM Professional Retail
    3507 = "C73NR-P6XW4-VGKPT-KCFTT-PDK64" # Professional, Win 10 RTM Professional Retail
    3507 = "DYYRT-NY9VP-4CB2F-8VC7H-DRTKR" # Professional, Win 10 RTM Professional Retail
    3507 = "GKNKW-8BFVQ-7C3WD-J72T9-KQB3F" # Professional, Win 10 RTM Professional Retail
    3510 = "DP3NW-RXVQ6-79BFR-VBX83-TCQT8" # ServerARM64, Windows Server Next Beta ServerARM64 Retail
    3555 = "9JCQ7-NPXP3-8WM3R-VYTFR-R3K84" # Professional, Win 10 RTM Professional OEM:DM
    3555 = "CXNKG-H9YBF-4988R-XJJW8-GVKCR" # Professional, Win 10 RTM Professional OEM:DM
    3556 = "N33V3-9KKBK-FBGYW-KDQ6P-7CFTG" # Professional, Win 10 RTM Professional OEM:DM
    3556 = "TQN2F-TQWM4-DTPVH-D3FB7-CYVJ6" # Professional, Win 10 RTM Professional OEM:DM
    3557 = "4WQN9-2BWFT-PHQVP-YPT2Q-TCQW7" # Professional, Win 10 RTM Professional OEM:DM
    3557 = "Y7YJC-NKRQ6-D3VPG-GTX96-KTP2V" # Professional, Win 10 RTM Professional OEM:DM
    3558 = "3PJXD-QNDX8-C2X37-TWX3C-JB6PW" # ProfessionalN, Win 10 RTM ProfessionalN OEM:DM
    3558 = "9J364-N6P64-CRFC4-D4C9T-FVWGJ" # ProfessionalN, Win 10 RTM ProfessionalN OEM:DM
    3559 = "G62PN-6BKV7-YY39J-YVPG4-W8GPX" # ProfessionalN, Win 10 RTM ProfessionalN OEM:DM
    3559 = "NBHQV-BQC4F-BP4KD-6TBC3-PYVJ9" # ProfessionalN, Win 10 RTM ProfessionalN OEM:DM
    3560 = "CRNFH-JP4RJ-6MTJ4-C4XR9-WTY6M" # Core, Win 10 RTM Core OEM:DM
    3560 = "FMGHT-G2NBT-7QXYM-GX8BJ-CPQXB" # Core, Win 10 RTM Core OEM:DM
    3560 = "FPN6M-RCWPF-BJHXY-8P3PY-VQXCY" # Core, Win 10 RTM Core OEM:DM
    3560 = "FWDNG-YRM8C-26J68-348V8-29X9B" # Core, Win 10 RTM Core OEM:DM
    3560 = "H22VK-NM8QD-CG3VR-VWBW8-Q699B" # Core, Win 10 RTM Core OEM:DM
    3560 = "H9CNQ-XT3PG-GDFGD-Q983T-KTP2Y" # Core, Win 10 RTM Core OEM:DM
    3560 = "HRTMN-TD7V8-8R99C-P648K-GJGPY" # Core, Win 10 RTM Core OEM:DM
    3560 = "J8KYN-XVH8C-MC8HD-RWRKJ-7FTPY" # Core, Win 10 RTM Core OEM:DM
    3560 = "JBWQB-VNWQG-93G4V-R23W8-9TP2Y" # Core, Win 10 RTM Core OEM:DM
    3560 = "JV34N-8GBMD-43J9Q-262CR-KBVKB" # Core, Win 10 RTM Core OEM:DM
    3560 = "K9MR3-WN7R2-866WW-8MDJ4-BY6PY" # Core, Win 10 RTM Core OEM:DM
    3560 = "KD93X-TNKDG-6KY3C-7GRVC-8XC2Y" # Core, Win 10 RTM Core OEM:DM
    3560 = "KNWBR-KQ8FV-CKBJD-MT6B3-GF4TM" # Core, Win 10 RTM Core OEM:DM
    3560 = "M6NDM-3HYKM-93838-Y463P-YKM6M" # Core, Win 10 RTM Core OEM:DM
    3560 = "RDN98-QF2FV-VBFXF-QWJGP-DDB6M" # Core, Win 10 RTM Core OEM:DM
    3560 = "T3RTN-VJHYH-CMVH6-84TDF-7H7KB" # Core, Win 10 RTM Core OEM:DM
    3560 = "TD97K-V6NPB-W8432-XRYKX-V222Y" # Core, Win 10 RTM Core OEM:DM
    3560 = "WMX8Q-7GN9V-RJ2KH-YRG49-WTY6M" # Core, Win 10 RTM Core OEM:DM
    3560 = "WPT3X-RDN87-MBFRP-7DGPG-QYJGM" # Core, Win 10 RTM Core OEM:DM
    3560 = "XP6DX-NRFYJ-HK736-Q2FQD-KKX9B" # Core, Win 10 RTM Core OEM:DM
    3561 = "24WMH-RNHKB-7M29G-BH8RX-9HKC2" # CoreCountrySpecific, Win 10 RTM CoreCountrySpecific OEM:DM
    3561 = "2KJ8Y-NJ78C-CKMJH-HQ93F-DJ3XC" # CoreCountrySpecific, Win 10 RTM CoreCountrySpecific OEM:DM
    3561 = "39CRN-27R8Y-8H3BW-834W2-9QB6P" # CoreCountrySpecific, Win 10 RTM CoreCountrySpecific OEM:DM
    3561 = "49WPM-GNK3J-2CDRH-3D4VY-YWRTP" # CoreCountrySpecific, Win 10 RTM CoreCountrySpecific OEM:DM
    3561 = "83KNH-KMG24-PBTQG-VWJVT-HFTP2" # CoreCountrySpecific, Win 10 RTM CoreCountrySpecific OEM:DM
    3561 = "9FMFN-42B2R-8Q8M3-W2P36-RRHKC" # CoreCountrySpecific, Win 10 RTM CoreCountrySpecific OEM:DM
    3561 = "9JCN8-D6K64-2H7TY-XB3TW-DGP22" # CoreCountrySpecific, Win 10 RTM CoreCountrySpecific OEM:DM
    3561 = "BMRN3-KDT93-FTPHK-HY9JM-3GP22" # CoreCountrySpecific, Win 10 RTM CoreCountrySpecific OEM:DM
    3561 = "BN6W9-JDGFQ-FW483-V4MB7-MBJGP" # CoreCountrySpecific, Win 10 RTM CoreCountrySpecific OEM:DM
    3561 = "CWHNV-R8QM6-8JQM8-4874Q-GF4TP" # CoreCountrySpecific, Win 10 RTM CoreCountrySpecific OEM:DM
    3561 = "F4NHY-FK2RK-BX726-9MWJ2-9QB6P" # CoreCountrySpecific, Win 10 RTM CoreCountrySpecific OEM:DM
    3561 = "FPBG8-NQ6F2-PBG2X-73GBC-KW3XC" # CoreCountrySpecific, Win 10 RTM CoreCountrySpecific OEM:DM
    3561 = "JY2G2-FN9RJ-D96C8-K8CBC-V8RTP" # CoreCountrySpecific, Win 10 RTM CoreCountrySpecific OEM:DM
    3561 = "K8TDD-MNPB4-BCFYR-MGRD7-T3B6P" # CoreCountrySpecific, Win 10 RTM CoreCountrySpecific OEM:DM
    3561 = "N9YYM-82XGT-FQG6K-2V76V-VT99C" # CoreCountrySpecific, Win 10 RTM CoreCountrySpecific OEM:DM
    3561 = "PFBN4-TKGGF-XDWQY-P436P-W2QXC" # CoreCountrySpecific, Win 10 RTM CoreCountrySpecific OEM:DM
    3561 = "TNRHX-C7XKY-TXB6F-WWK42-BTDXC" # CoreCountrySpecific, Win 10 RTM CoreCountrySpecific OEM:DM
    3561 = "TV9QN-3DF2G-6QBCH-M6DWG-BP222" # CoreCountrySpecific, Win 10 RTM CoreCountrySpecific OEM:DM
    3561 = "VN9WJ-3VGYC-PPFYD-82RBB-BBJGP" # CoreCountrySpecific, Win 10 RTM CoreCountrySpecific OEM:DM
    3561 = "WDBN4-M33XM-48H6F-Y74TB-X4TP2" # CoreCountrySpecific, Win 10 RTM CoreCountrySpecific OEM:DM
    3562 = "43HVN-Y6V6C-WC73G-RHMPF-PPQXD" # CoreSingleLanguage, Win 10 RTM CoreSingleLanguage OEM:DM
    3562 = "4N7JM-H4DHH-RHQ9M-TT9VP-KW3XD" # CoreSingleLanguage, Win 10 RTM CoreSingleLanguage OEM:DM
    3562 = "7PMGW-KN2K8-JXP2D-XJ98Y-X4TP3" # CoreSingleLanguage, Win 10 RTM CoreSingleLanguage OEM:DM
    3562 = "8FD96-KNCQ6-M26FY-T38CP-Q3XC3" # CoreSingleLanguage, Win 10 RTM CoreSingleLanguage OEM:DM
    3562 = "8JJ9W-CNMJ3-MHX9B-MKWHQ-M7WGQ" # CoreSingleLanguage, Win 10 RTM CoreSingleLanguage OEM:DM
    3562 = "8PXG6-NT6GR-VTFFC-GQG42-J44TQ" # CoreSingleLanguage, Win 10 RTM CoreSingleLanguage OEM:DM
    3562 = "FFGDT-8TNGF-QW4D7-367BJ-6MVKD" # CoreSingleLanguage, Win 10 RTM CoreSingleLanguage OEM:DM
    3562 = "G4N9R-HX2VG-633R6-6P84P-PGY6Q" # CoreSingleLanguage, Win 10 RTM CoreSingleLanguage OEM:DM
    3562 = "G83W4-NH2PT-6GJR3-Y2P47-3J3XD" # CoreSingleLanguage, Win 10 RTM CoreSingleLanguage OEM:DM
    3562 = "HNQFF-CPM78-BQJXP-9JRDM-7MJGQ" # CoreSingleLanguage, Win 10 RTM CoreSingleLanguage OEM:DM
    3562 = "J3DY3-HWNTC-YTJ8H-637K6-CGY6Q" # CoreSingleLanguage, Win 10 RTM CoreSingleLanguage OEM:DM
    3562 = "J7D66-7NJXV-KK87W-CMB3J-TQ8GQ" # CoreSingleLanguage, Win 10 RTM CoreSingleLanguage OEM:DM
    3562 = "KGBJC-N8DR2-4TW94-R3QWC-76DXD" # CoreSingleLanguage, Win 10 RTM CoreSingleLanguage OEM:DM
    3562 = "NDCD9-K4JJB-VKCT2-Q9BJC-XTP23" # CoreSingleLanguage, Win 10 RTM CoreSingleLanguage OEM:DM
    3562 = "PPNQJ-T6RG8-9MF42-TMMGX-8QK9D" # CoreSingleLanguage, Win 10 RTM CoreSingleLanguage OEM:DM
    3562 = "PXYNJ-FYCDY-P3KKV-V6B9T-8TY6Q" # CoreSingleLanguage, Win 10 RTM CoreSingleLanguage OEM:DM
    3562 = "QXV7H-NV2J3-2V68C-FB2WD-Y4HKD" # CoreSingleLanguage, Win 10 RTM CoreSingleLanguage OEM:DM
    3562 = "WN7RF-QBR8G-4PMJR-2DJJF-HQXC3" # CoreSingleLanguage, Win 10 RTM CoreSingleLanguage OEM:DM
    3562 = "XN829-2DTD4-RRV3C-GVGJ4-VMJGQ" # CoreSingleLanguage, Win 10 RTM CoreSingleLanguage OEM:DM
    3562 = "YF922-NMRJ6-JY939-HFGQ6-RRHKD" # CoreSingleLanguage, Win 10 RTM CoreSingleLanguage OEM:DM
    3563 = "2PVXM-GN9GV-4QJ7K-CRF7T-HFTP4" # Professional, Win 10 RTM Professional OEM:DM
    3563 = "3NKG2-H79C3-8W7KK-FFBQJ-33XC4" # Professional, Win 10 RTM Professional OEM:DM
    3563 = "6MNDJ-WFKGG-C8VP8-44MCH-3J3XF" # Professional, Win 10 RTM Professional OEM:DM
    3563 = "6NYJH-YBYFY-96TVD-B9FHM-TXX9F" # Professional, Win 10 RTM Professional OEM:DM
    3563 = "7N6PP-MYR7R-YMPX3-K3B7W-WB6P4" # Professional, Win 10 RTM Professional OEM:DM
    3563 = "7N9T3-P3MKD-BY23G-V7DRJ-RX9C4" # Professional, Win 10 RTM Professional OEM:DM
    3563 = "9NRVV-F7GMC-DPR6X-GRDBH-BDXC4" # Professional, Win 10 RTM Professional OEM:DM
    3563 = "B4CRN-GXQVV-79THX-9QYVB-DPFTR" # Professional, Win 10 RTM Professional OEM:DM
    3563 = "B8CMN-PRD7H-JKCWT-6VYBQ-4GDXF" # Professional, Win 10 RTM Professional OEM:DM
    3563 = "C72WR-KQNKK-K2JHF-B92YK-M99C4" # Professional, Win 10 RTM Professional OEM:DM
    3563 = "FCGFG-FVNT9-98CGY-F4JM6-VCFTR" # Professional, Win 10 RTM Professional OEM:DM
    3563 = "FTPKP-6DNGQ-47VWJ-R4X2W-Q699F" # Professional, Win 10 RTM Professional OEM:DM
    3563 = "K3QRN-RMXRR-DDY22-PDB6G-683XF" # Professional, Win 10 RTM Professional OEM:DM
    3563 = "MNGHX-GBT73-MQC8B-KKD68-JFHKF" # Professional, Win 10 RTM Professional OEM:DM
    3563 = "MNPJW-XM6KJ-TKJ7M-3RWW7-8HWGR" # Professional, Win 10 RTM Professional OEM:DM
    3563 = "N27GV-J68WH-Q8899-K8QM4-R3K9F" # Professional, Win 10 RTM Professional OEM:DM
    3563 = "N2GRM-XWYJ7-QB94J-FYJDD-KKX9F" # Professional, Win 10 RTM Professional OEM:DM
    3563 = "NG6FW-VRCRR-WX78V-6FRHQ-XHKC4" # Professional, Win 10 RTM Professional OEM:DM
    3563 = "NX79V-FMVY4-RR4YR-9GCPB-R6Y6R" # Professional, Win 10 RTM Professional OEM:DM
    3563 = "VBNFV-K94KJ-WQX6X-2WMH7-QPFTR" # Professional, Win 10 RTM Professional OEM:DM
    3568 = "BNG2Q-VKJ4R-8PX28-C772P-Q3XDB" # Core, Win 10 Pre-Release Core OEM:DM
    3569 = "PYDXP-3N9MD-7V6FJ-6VHDR-JHWG2" # Core, Win 10 Pre-Release Core OEM:NONSLP
    3570 = "7NQVF-QB396-FM8FM-P3BPT-RRHKQ" # Core, Win 10 Pre-Release Core Retail
    3570 = "D43PH-NJP6R-C4GGV-HCX23-PYVKQ" # Core, Win 10 Pre-Release Core Retail
    3570 = "JTN9B-QXPJK-DFDY7-WV82J-VH7KQ" # Core, Win 10 Pre-Release Core Retail
    3570 = "KTNPV-KTRK4-3RRR8-39X6W-W44T3" # Core, Win 10 Pre-Release Core Retail
    3571 = "BJBKV-PQNJV-K4Y3H-4TJB7-CYVKR" # Core, Win 10 Pre-Release Core Retail Qihoo
    3571 = "PYHNX-QGQFG-GTCV8-CGDY9-GJGQF" # Core, Win 10 Pre-Release Core Retail Qihoo
    3571 = "YNV4T-WVC3V-B36RW-2BHT3-B99DF" # Core, Win 10 Pre-Release Core Retail Qihoo
    3572 = "3NJK8-F2Q9H-TXQC2-JC8CR-VMJG6" # Core, Win 10 Pre-Release Core Retail Tencent
    3572 = "9PCFV-XNFWP-HFM8J-4DGG4-MWRT6" # Core, Win 10 Pre-Release Core Retail Tencent
    3572 = "K6NQ4-2RDX4-PPH2B-CWRK9-RM6QG" # Core, Win 10 Pre-Release Core Retail Tencent
    3573 = "3KNVR-PXJFJ-MXRQY-KKQH7-YY6QH" # Core, Win 10 Pre-Release Core Volume:GVLK
    3573 = "JTJ43-TNBFV-YDGKB-92WGV-GCQXV" # Core, Win 10 Pre-Release Core Volume:GVLK
    3574 = "B7JR7-N48R8-6JB9G-942YX-T83XW" # CoreCountrySpecific, Win 10 Pre-Release CoreCountrySpecific OEM:DM
    3575 = "FNPG6-GVG6G-8HWJQ-8FR3C-3YJG9" # CoreCountrySpecific, Win 10 Pre-Release CoreCountrySpecific OEM:NONSLP
    3576 = "DXH3Y-8N27T-MJVDQ-WP3J6-683XY" # CoreCountrySpecific, Win 10 Pre-Release CoreCountrySpecific Retail
    3576 = "R3BYW-CBNWT-F3JTP-FM942-BTDXY" # CoreCountrySpecific, Win 10 Pre-Release CoreCountrySpecific Retail
    3577 = "TFKN7-3BRDR-9H7CY-XXQQ4-YTDX2" # CoreCountrySpecific, Win 10 Pre-Release CoreCountrySpecific Volume:GVLK
    3578 = "J2CN7-4MGKJ-KQ6G2-CR9F9-WTY7D" # CoreN, Win 10 Pre-Release CoreN OEM:DM
    3579 = "RN8J9-272YP-DX3XR-Y798C-XTP3R" # CoreN, Win 10 Pre-Release CoreN OEM:NONSLP
    3580 = "NH29J-RHHRK-G4TK6-4B2CR-BY6QT" # CoreN, Win 10 Pre-Release CoreN Retail
    3581 = "K8ND4-KBPFY-3QCDH-2MQQB-2PQX7" # CoreN, Win 10 Pre-Release CoreN Volume:GVLK
    3582 = "V2MF4-NG9CF-7GMQX-TB433-XHKDW" # CoreSingleLanguage, Win 10 Pre-Release CoreSingleLanguage OEM:DM
    3583 = "PMWTN-WT8XM-YCYHT-2MYJR-8B6QX" # CoreSingleLanguage, Win 10 Pre-Release CoreSingleLanguage OEM:NONSLP
    3584 = "6DWPW-GNMQ4-WYJH9-VD7K4-37BBB" # CoreSingleLanguage, Win 10 Pre-Release CoreSingleLanguage Retail
    3584 = "JPYNJ-XTFCR-372YJ-YJJ3Q-G83YB" # CoreSingleLanguage, Win 10 Pre-Release CoreSingleLanguage Retail
    3585 = "7GNT4-DJHXD-VFPJY-384GG-683YC" # CoreSingleLanguage, Win 10 Pre-Release CoreSingleLanguage Volume:GVLK
    3586 = "Q8CGD-NJVMC-XVFR6-696J4-KBVMD" # Education, Win 10 Pre-Release Education OEM:DM
    3587 = "FP7QN-KR4PT-X6K6X-3RGMP-HH7MF" # Education, Win 10 Pre-Release Education OEM:NONSLP
    3588 = "B2V2J-RPNXQ-2HB33-4X397-XD8HT" # Education, Win 10 Pre-Release Education Retail
    3589 = "DNBM8-2JPG2-MHCJK-4FXTY-G3B7V" # Education, Win 10 Pre-Release Education Volume:GVLK
    3589 = "YVKRN-H6QFQ-JQGG3-T7BF3-2WGQ7" # Education, Win 10 Pre-Release Education Volume:GVLK
    3590 = "G43BN-4MD4H-MDCFH-PCCGY-92FVW" # Education, Win 10 Pre-Release Education Volume:MAK
    3591 = "TN4KB-9GTMD-PDKHH-FDH4W-D9M7X" # EducationN, Win 10 Pre-Release EducationN OEM:DM
    3592 = "3TQMN-7HFW3-F3DHR-Y9DFM-WHWHY" # EducationN, Win 10 Pre-Release EducationN OEM:NONSLP
    3593 = "74R7N-QX2QT-69CQ2-K2BPC-BTDYP" # EducationN, Win 10 Pre-Release EducationN Retail
    3594 = "4HNYR-F9BXF-TC2CH-H7MR8-VH7MQ" # EducationN, Win 10 Pre-Release EducationN Volume:GVLK
    3595 = "3MWP6-DKNRJ-GG2RC-Y8VR8-4VWH4" # EducationN, Win 10 Pre-Release EducationN Volume:MAK
    3596 = "GN7FR-4QK4T-8XPDY-P2RYF-QGP4G" # Enterprise, Win 10 Pre-Release Enterprise OEM:DM
    3597 = "F2Y9N-DW82B-BK2W3-49WJ4-4X9FH" # Enterprise, Win 10 Pre-Release Enterprise OEM:NONSLP
    3598 = "K3HBC-NKD87-HQV6K-X8Y62-JB6RJ" # Enterprise, Win 10 Pre-Release Enterprise Volume:GVLK
    3598 = "MFY6B-WNCVR-9KWQ4-9CGGM-QJ3YW" # Enterprise, Win 10 Pre-Release Enterprise Volume:GVLK
    3598 = "QNMXX-GCD3W-TCCT4-872RV-G6P4J" # Enterprise, Win 10 Pre-Release Enterprise Volume:GVLK
    3599 = "CKFK9-QNGF2-D34FM-99QX2-8XC4K" # Enterprise, Win 10 Pre-Release Enterprise Retail
    3599 = "THN6R-6GYFG-J2MWM-6R2CG-Y99FK" # Enterprise, Win 10 Pre-Release Enterprise Retail
    3600 = "NPWBB-M6DWX-JGQWH-RRX2W-GVKFM" # Enterprise, Win 10 Pre-Release Enterprise Volume:MAK
    3601 = "CWHKR-GNB9F-6JJTC-CQH9D-PYVM2" # EnterpriseEval, Win 10 Pre-Release EnterpriseEval Retail:TB:Eval
    3602 = "9N9WF-7QKQ2-2W69C-92GWG-J2QY3" # EnterpriseS, Win 10 Pre-Release EnterpriseS Retail
    3603 = "NDB7V-27VC9-XGHJP-3J668-TQ8JF" # EnterpriseS, Win 10 Pre-Release EnterpriseS OEM:DM
    3604 = "QTNH3-VBKCC-7GTGY-PRPWD-QRTRT" # EnterpriseS, Win 10 Pre-Release EnterpriseS OEM:NONSLP
    3605 = "YRNM6-H6F6D-9B36P-4QGPG-GMVM7" # EnterpriseS, Win 10 Pre-Release EnterpriseS Volume:GVLK
    3606 = "X297P-NVC2F-6P7K9-Y2G2Y-VQXFW" # EnterpriseS, Win 10 Pre-Release EnterpriseS Volume:MAK
    3607 = "4F973-NKYKY-X6MBQ-3X93P-FX9FX" # EnterpriseSEval, Win 10 Pre-Release EnterpriseSEval Retail:TB:Eval
    3608 = "BN3CX-XK2J6-F6MW7-7JHXB-VQXFY" # EnterpriseSNEval, Win 10 Pre-Release EnterpriseSNEval Retail:TB:Eval
    3609 = "NF3W7-8C4B7-BFRT9-VKR44-8B6R2" # EnterpriseN, Win 10 Pre-Release EnterpriseN Volume:GVLK
    3610 = "977WD-QNC9M-4T6R7-B8D2R-4X9F3" # EnterpriseN, Win 10 Pre-Release EnterpriseN Retail
    3611 = "4NKJY-VJKYH-8MV33-262F8-BWRWR" # EnterpriseN, Win 10 Pre-Release EnterpriseN Volume:MAK
    3612 = "WWRND-H328G-J8CC2-RTPTW-W44WT" # EnterpriseNEval, Win 10 Pre-Release EnterpriseNEval Retail:TB:Eval
    3613 = "MVBNC-DB8WB-96B63-QK44V-WK9F7" # EnterpriseSN, Win 10 Pre-Release EnterpriseSN Volume:GVLK
    3614 = "KCNVV-DVG9M-R93RQ-KVMD4-QGP48" # EnterpriseSN, Win 10 Pre-Release EnterpriseSN OEM:DM
    3615 = "NBTQ7-XRQ9R-GXK6H-Y62RX-QV7PK" # EnterpriseSN, Win 10 Pre-Release EnterpriseSN OEM:NONSLP
    3616 = "NR422-P2BWP-BF987-JHPP2-DDB8Y" # EnterpriseSN, Win 10 Pre-Release EnterpriseSN Volume:MAK
    3617 = "27FB3-G8NKF-X8RGK-GDBV6-7226C" # PPIPro, Win 10 Pre-Release PPIPro Volume:GVLK
    3618 = "YNCKW-C4B3Y-Q4BWG-37MTX-P38J3" # PPIPro, Win 10 Pre-Release PPIPro OEM:NONSLP
    3619 = "MXR8F-33NPH-K4Q6G-K728D-GF4W4" # Professional, Win 10 Pre-Release Professional OEM:DM
    3620 = "NF2WR-678CT-24CPY-DVP9C-MP26G" # Professional, Win 10 Pre-Release Professional OEM:NONSLP
    3621 = "NJ4MX-VQQ7Q-FP3DB-VDGHX-7XM87" # Professional, Win 10 Pre-Release Professional Retail
    3621 = "VNMM9-9DMCX-4FT94-KYDTP-W2Q2V" # Professional, Win 10 Pre-Release Professional Retail
    3621 = "W3GNW-YXYVB-WCKXH-364FM-G3B87" # Professional, Win 10 Pre-Release Professional Retail
    3622 = "8X6NF-4Y9YF-VRGD4-46PJJ-78RW8" # Professional, Win 10 Pre-Release Professional Retail Qihoo
    3622 = "FNJXY-3HTTH-28G88-GVX68-TQ8J8" # Professional, Win 10 Pre-Release Professional Retail Qihoo
    3622 = "WBWKN-YKMW2-4HX8B-CQGMK-XKYCW" # Professional, Win 10 Pre-Release Professional Retail Qihoo
    3623 = "6PDKD-N2PRH-K72QG-PHQKR-7H7PX" # Professional, Win 10 Pre-Release Professional Retail Tencent
    3623 = "FF69K-FWN4P-P3HHJ-MJY6B-PR4W9" # Professional, Win 10 Pre-Release Professional Retail Tencent
    3623 = "XYFDK-VNWHK-YWQDB-MTKHY-F9C6K" # Professional, Win 10 Pre-Release Professional Retail Tencent
    3624 = "43BNY-B3MHX-37RT3-HT88J-33XGM" # Professional, Win 10 Pre-Release Professional Volume:GVLK
    3624 = "R7NPP-B8F2Y-9289P-922Y4-3DB9B" # Professional, Win 10 Pre-Release Professional Volume:GVLK
    3624 = "XQHPH-N4D9W-M8P96-DPDFP-TMVPY" # Professional, Win 10 Pre-Release Professional Volume:GVLK
    3625 = "MC8P7-QXNC3-Y7MVX-9DYY6-VCFXC" # Professional, Win 10 Pre-Release Professional Volume:MAK
    3626 = "84NJF-R7748-RB4W8-WB72F-FC26Q" # ProfessionalN, Win 10 Pre-Release ProfessionalN OEM:DM
    3627 = "MBCYQ-QPNYT-WGFM7-2VD39-XKYC4" # ProfessionalN, Win 10 Pre-Release ProfessionalN OEM:NONSLP
    3628 = "J6NW8-62PJK-7QR4Y-DJC74-6Q8KG" # ProfessionalN, Win 10 Pre-Release ProfessionalN Retail
    3629 = "2QW8H-7RNHB-MPWPJ-8RJDT-V6D27" # ProfessionalN, Win 10 Pre-Release ProfessionalN Volume:GVLK
    3630 = "3MHNP-33X7K-Q9MYM-9QP7H-DRTTW" # ProfessionalN, Win 10 Pre-Release ProfessionalN Volume:MAK
    3633 = "9V76T-NJ3VH-2D2WT-M84D4-F6Y9P" # CoreARM, Win 10 Pre-Release CoreARM OEM:DM
    3634 = "W6GWT-TNTYG-7X99K-FQ9DY-BBJKQ" # CoreARM, Win 10 Pre-Release CoreARM OEM:NONSLP
    3635 = "7NX88-X6YM3-9Q3YT-CCGBF-KBVQF" # CoreARM, Win 10 Pre-Release CoreARM Volume:GVLK
    3635 = "NHY4C-KCMKV-V9K9M-7R43T-KTP64" # CoreARM, Win 10 Pre-Release CoreARM Volume:GVLK
    3672 = "328NF-RTPQT-84J4Q-V44B8-78R2B" # ProfessionalWMC, Win 10 Pre-Release ProfessionalWMC Volume:GVLK
    3672 = "NKPM6-TCVPT-3HRFX-Q4H9B-QJ34Y" # ProfessionalWMC, Win 10 Pre-Release ProfessionalWMC Volume:GVLK
    3673 = "DCNJ8-44Y2Y-Q3JTT-RGX4F-K4TWP" # ProfessionalWMC, Win 10 Pre-Release ProfessionalWMC Retail
    3676 = "62RVV-QH82X-9YDXN-YRV7M-JK9JT" # Professional, Win 10 Pre-Release Professional Retail
    3676 = "GD7KH-DV2JH-NX4JF-42MTJ-9TP8T" # Professional, Win 10 Pre-Release Professional Retail
    3677 = "6MQMH-2M9TJ-69JQN-JKKCM-PR42H" # ProfessionalN, Win 10 Pre-Release ProfessionalN Retail
    3677 = "HFMVH-KCBNC-7TJWY-KXRQY-X4TWV" # ProfessionalN, Win 10 Pre-Release ProfessionalN Retail
    3678 = "RHDN4-9MKR3-G7WQM-9WKTY-RC28W" # AnalogOneCore, Win 10 RTM AnalogOneCore Retail
    3679 = "N2M44-T82CF-D2BBR-R2TYB-39PCK" # AnalogOneCoreEnterprise, Win 10 RTM AnalogOneCoreEnterprise Volume:MAK
    3720 = "3PNGX-M88FX-8K4B3-2G86G-C9YHY" # IoTUAP, Win 10 RTM IoTUAP Retail
    3721 = "VY8RQ-KN26P-CQYVC-248YC-CKDBP" # IoTUAPCommercial, Win 10 RTM IoTUAPCommercial Volume:MAK
    3728 = "6DWFN-9DBPB-99W4C-XYWKQ-VXPFM" # CoreSystemServer, Windows Server 12 R2 RTM CoreSystemServer Retail
    3732 = "BFM6D-TKNBY-X6RGR-PHJ4G-723B6" # ServerDatacenterNano, Windows Server Next RTM ServerDatacenterNano Retail
    3733 = "69NHX-WQQ7G-QVBPG-4HPQP-8XDB7" # ServerStandardNano, Windows Server Next RTM ServerStandardNano Retail
    3744 = "N4PCD-PQP76-PJKHY-YJ2T7-G6QCM" # ServerCloudStorage, ServerCloudStorage 2016 RTM ServerCloudStorage OEM:NONSLP
    3744 = "PF7NJ-YGJPY-6B4XG-C864G-TJG2M" # ServerCloudStorage, ServerCloudStorage 2016 RTM ServerCloudStorage OEM:NONSLP
    3744 = "W89N9-BYMXK-27PQ9-T79MB-X4T2M" # ServerCloudStorage, ServerCloudStorage 2016 RTM ServerCloudStorage OEM:NONSLP
    3745 = "6FC8Y-TN3KG-Q8CGW-BK43G-FVWTC" # ServerCloudStorage, ServerCloudStorage 2016 RTM ServerCloudStorage OEM:SLP
    3745 = "B7CPN-V2Q4F-BP2JJ-6JJXR-R3MJ2" # ServerCloudStorage, ServerCloudStorage 2016 RTM ServerCloudStorage OEM:SLP
    3745 = "N4KY4-FBKV9-TQ7KV-VB4HQ-TCQ82" # ServerCloudStorage, ServerCloudStorage 2016 RTM ServerCloudStorage OEM:SLP
    3746 = "94DPN-4KQ7Y-YJ3Y9-29DGQ-BHBJ3" # ServerCloudStorage, ServerCloudStorage 2016 RTM ServerCloudStorage Retail
    3746 = "GKNCV-R422X-TGQ7G-XW8JX-66QCQ" # ServerCloudStorage, ServerCloudStorage 2016 RTM ServerCloudStorage Retail
    3746 = "TY4N3-G47XF-FVPXJ-434DQ-63CGD" # ServerCloudStorage, ServerCloudStorage 2016 RTM ServerCloudStorage Retail
    3747 = "7NKJ9-WDBYK-B6B3T-T37D7-8HWTF" # ServerCloudStorage, ServerCloudStorage 2016 RTM ServerCloudStorage Volume:GVLK
    3747 = "N66TG-8BFW9-DXM3R-YPQPJ-BWR6F" # ServerCloudStorage, ServerCloudStorage 2016 RTM ServerCloudStorage Volume:GVLK
    3747 = "QN4C6-GBJD2-FB422-GHWJK-GJG2R" # ServerCloudStorage, ServerCloudStorage 2016 RTM ServerCloudStorage Volume:GVLK
    3748 = "KCQMB-H2NQ3-GX372-86JX3-63CGG" # ServerStorageStandard, Storage Server 2016 RTM ServerStorageStandard OEM:SLP
    3748 = "NHPGM-RDWMC-FQ466-DW6WX-C7KPT" # ServerStorageStandard, Storage Server 2016 RTM ServerStorageStandard OEM:SLP
    3748 = "R9N8B-HPVKF-P2QCD-FV4VF-PPQ86" # ServerStorageStandard, Storage Server 2016 RTM ServerStorageStandard OEM:SLP
    3748 = "RNTWR-TJVT7-3V6P6-X8WCG-CG2GG" # ServerStorageStandard, Storage Server 2016 RTM ServerStorageStandard OEM:SLP
    3749 = "88N8C-QR2GH-VPT2R-BB9XR-7H7W7" # ServerStorageStandard, Storage Server 2016 RTM ServerStorageStandard OEM:NONSLP
    3749 = "G3CNG-XW8VJ-MW9GV-WWMDB-WHWTH" # ServerStorageStandard, Storage Server 2016 RTM ServerStorageStandard OEM:NONSLP
    3749 = "TNMG8-XXYM8-M8BF4-KXHHR-BY62V" # ServerStorageStandard, Storage Server 2016 RTM ServerStorageStandard OEM:NONSLP
    3750 = "4FNXQ-HP9T2-7JW9D-92YCK-2YVW8" # ServerStorageStandard, Storage Server 2016 RTM ServerStorageStandard Retail
    3750 = "BR2NW-KHWVX-7D3Y7-6BT76-H8R6J" # ServerStorageStandard, Storage Server 2016 RTM ServerStorageStandard Retail
    3750 = "GN2MR-4XGVX-6V9CP-RJ6V6-723CW" # ServerStorageStandard, Storage Server 2016 RTM ServerStorageStandard Retail
    3750 = "MJTNK-8WMBT-TF38F-JBHH7-VVBJ8" # ServerStorageStandard, Storage Server 2016 RTM ServerStorageStandard Retail
    3750 = "P388J-NYHGW-QGWDV-B6K2H-7QXPW" # ServerStorageStandard, Storage Server 2016 RTM ServerStorageStandard Retail
    3750 = "VN8D3-PR82H-DB6BJ-J9P4M-92F6J" # ServerStorageStandard, Storage Server 2016 RTM ServerStorageStandard Retail
    3751 = "D2N9H-X4J43-39FTB-VXR99-C7KPX" # ServerStorageWorkgroup, Storage Server 2016 RTM ServerStorageWorkgroup OEM:SLP
    3751 = "FYJJM-NCV6V-WMCPM-YXHYM-QJ389" # ServerStorageWorkgroup, Storage Server 2016 RTM ServerStorageWorkgroup OEM:SLP
    3751 = "H6KND-VYQH7-C9FDB-74KVX-TF46K" # ServerStorageWorkgroup, Storage Server 2016 RTM ServerStorageWorkgroup OEM:SLP
    3751 = "NWRTC-QK6Q7-4VD27-9MFVB-3GQCX" # ServerStorageWorkgroup, Storage Server 2016 RTM ServerStorageWorkgroup OEM:SLP
    3752 = "FH4VN-9GV78-6F6CF-6TPG7-WK9PY" # ServerStorageWorkgroup, Storage Server 2016 RTM ServerStorageWorkgroup OEM:NONSLP
    3752 = "FTNB6-4CDYV-YK4J7-XHPV6-XQCGM" # ServerStorageWorkgroup, Storage Server 2016 RTM ServerStorageWorkgroup OEM:NONSLP
    3752 = "GV3BN-CP3KR-YGVMP-B92TQ-T6QCY" # ServerStorageWorkgroup, Storage Server 2016 RTM ServerStorageWorkgroup OEM:NONSLP
    3752 = "WD6TN-3P6WQ-VPH2M-HDPRP-JB62Y" # ServerStorageWorkgroup, Storage Server 2016 RTM ServerStorageWorkgroup OEM:NONSLP
    3753 = "48TQX-NVK3R-D8QR3-GTHHM-8FHXC" # ServerStorageWorkgroup, Storage Server 2016 RTM ServerStorageWorkgroup Retail
    3753 = "67N2F-CC6J8-6CPMG-3J33G-4M622" # ServerStorageWorkgroup, Storage Server 2016 RTM ServerStorageWorkgroup Retail
    3753 = "6XTNT-F9WY7-CFWH2-99DKP-XTQC2" # ServerStorageWorkgroup, Storage Server 2016 RTM ServerStorageWorkgroup Retail
    3753 = "7NPMQ-FBPRM-CCY8W-3D3PC-YKPGP" # ServerStorageWorkgroup, Storage Server 2016 RTM ServerStorageWorkgroup Retail
    3753 = "B429H-PTN63-V2B8W-P3XXJ-DGQC2" # ServerStorageWorkgroup, Storage Server 2016 RTM ServerStorageWorkgroup Retail
    3753 = "KKMNG-G6C7Q-67BWY-C799X-Y7WTP" # ServerStorageWorkgroup, Storage Server 2016 RTM ServerStorageWorkgroup Retail
    3753 = "N4WTW-VK28C-3RYCB-8Y3XK-JXDC2" # ServerStorageWorkgroup, Storage Server 2016 RTM ServerStorageWorkgroup Retail
    3754 = "4J6JT-YNCHM-VHHMM-MPVYT-3V7XD" # ServerSolution, Windows Server Essentials 2016 RTM ServerSolution OEM:NONSLP
    3754 = "G3JNX-Y343M-TVJJD-PX8WG-FVWTQ" # ServerSolution, Windows Server Essentials 2016 RTM ServerSolution OEM:NONSLP
    3754 = "VDY9W-RNK2C-7FBXV-6D9YM-43MKD" # ServerSolution, Windows Server Essentials 2016 RTM ServerSolution OEM:NONSLP
    3754 = "XGJWJ-NCD7B-6PC9M-PV7TR-WFHXD" # ServerSolution, Windows Server Essentials 2016 RTM ServerSolution OEM:NONSLP
    3755 = "BPRBF-7HNWY-J2X4W-PFYXM-6VKP4" # ServerSolution, Windows Server Essentials 2016 RTM ServerSolution OEM:NONSLP (MUI locked to zh-CN)
    3755 = "NDMH8-QK8GX-2R9GC-44BBR-CR46R" # ServerSolution, Windows Server Essentials 2016 RTM ServerSolution OEM:NONSLP (MUI locked to zh-CN)
    3756 = "4W824-QNG4W-FXKKH-7XTR9-2YVXG" # ServerSolution, Windows Server Essentials 2016 RTM ServerSolution OEM:SLP
    3756 = "8MK4G-N6J4K-9W967-Q9RYJ-WB626" # ServerSolution, Windows Server Essentials 2016 RTM ServerSolution OEM:SLP
    3757 = "9XYNB-H8F34-QQC9Y-Y2R97-M4HXH" # ServerSolution, Windows Server Essentials 2016 RTM ServerSolution OEM:SLP (MUI locked to zh-CN)
    3757 = "WJFM4-NJ7TB-KW86J-Q96YX-P38TV" # ServerSolution, Windows Server Essentials 2016 RTM ServerSolution OEM:SLP (MUI locked to zh-CN)
    3758 = "3YFJR-2MN3C-RFWHV-3PTPT-238TW" # ServerSolution, Windows Server Essentials 2016 RTM ServerSolution Retail
    3758 = "BB8JC-JNMTQ-6D8TK-J7KRT-8T2GW" # ServerSolution, Windows Server Essentials 2016 RTM ServerSolution Retail
    3758 = "BN7CM-Y89GG-RMJM6-3V63F-W8G28" # ServerSolution, Windows Server Essentials 2016 RTM ServerSolution Retail
    3758 = "CTFPM-YN9D3-PT2CR-GTDJ4-8446W" # ServerSolution, Windows Server Essentials 2016 RTM ServerSolution Retail
    3758 = "R73M8-WPN42-P9WJ3-HW3CM-JK9P8" # ServerSolution, Windows Server Essentials 2016 RTM ServerSolution Retail
    3758 = "RN927-GK377-GTVKW-FX98Q-G839J" # ServerSolution, Windows Server Essentials 2016 RTM ServerSolution Retail
    3758 = "V37PR-NPKBK-BH398-PPY9W-78R6W" # ServerSolution, Windows Server Essentials 2016 RTM ServerSolution Retail
    3758 = "VN9MG-F8WBB-WP39G-FKJ3F-3DCGW" # ServerSolution, Windows Server Essentials 2016 RTM ServerSolution Retail
    3758 = "WHJMJ-NK3YX-HMXXW-4Y6J2-KW39J" # ServerSolution, Windows Server Essentials 2016 RTM ServerSolution Retail
    3758 = "X667N-64YF8-F9T2C-C98HY-VQXP8" # ServerSolution, Windows Server Essentials 2016 RTM ServerSolution Retail
    3758 = "XX3KN-T34CR-M98FR-BKFFC-W2Q9J" # ServerSolution, Windows Server Essentials 2016 RTM ServerSolution Retail
    3759 = "BCGKW-K4NP9-BC8FT-VBJMP-7CF6X" # ServerSolution, Windows Server Essentials 2016 RTM ServerSolution Retail:TB:Eval
    3759 = "PYN6P-33TQC-8Y39D-8X4YC-6JG29" # ServerSolution, Windows Server Essentials 2016 RTM ServerSolution Retail:TB:Eval
    3760 = "98YNF-QCDGK-HC2PD-9C9FR-DJ39M" # ServerSolution, Windows Server Essentials 2016 RTM ServerSolution Volume:GVLK
    3760 = "JCKRF-N37P4-C2D82-9YXRT-4M63B" # ServerSolution, Windows Server Essentials 2016 RTM ServerSolution Volume:GVLK
    3760 = "WP7Y3-7NPCB-MKFTC-YJ2KJ-MTD9M" # ServerSolution, Windows Server Essentials 2016 RTM ServerSolution Volume:GVLK
    3761 = "DJR24-79NXB-TBBGF-HJ6CJ-YP3DC" # ServerSolution, Windows Server Essentials 2016 RTM ServerSolution Volume:MAK
    3761 = "DKNP4-CQBXX-BPXJD-PJCD7-BDXQC" # ServerSolution, Windows Server Essentials 2016 RTM ServerSolution Volume:MAK
    3761 = "GVJX9-QN4RD-QKRTM-QJVHX-H6D9P" # ServerSolution, Windows Server Essentials 2016 RTM ServerSolution Volume:MAK
    3761 = "JV9VQ-7NB7T-9C3K2-D7XQP-VFT3C" # ServerSolution, Windows Server Essentials 2016 RTM ServerSolution Volume:MAK
    3761 = "MHCVN-KYCTH-KFXHG-D87TP-RVWT2" # ServerSolution, Windows Server Essentials 2016 RTM ServerSolution Volume:MAK
    3761 = "MVXX8-3TNK6-K9JHT-TW2TB-BBJT2" # ServerSolution, Windows Server Essentials 2016 RTM ServerSolution Volume:MAK
    3761 = "P2RNV-98CFW-VD968-RFT9P-JB63C" # ServerSolution, Windows Server Essentials 2016 RTM ServerSolution Volume:MAK
    3761 = "WNTRM-8YR3G-2PHBQ-7678V-7QXQC" # ServerSolution, Windows Server Essentials 2016 RTM ServerSolution Volume:MAK
    3762 = "7MTX9-PNH6X-7RMWG-MYXF4-TVKQD" # ServerSolution, Windows Server Essentials 2016 RTM ServerSolution VT:IA
    3762 = "YVX9Y-NQF4F-39PD4-H9XJ2-GQ8T3" # ServerSolution, Windows Server Essentials 2016 RTM ServerSolution VT:IA
    3763 = "623H6-N2399-P9J4X-MPD8T-V6D9R" # ServerStandard, Windows Server 2016 RTM ServerStandard Retail
    3763 = "6DQBR-MN24F-GKG2G-WYFRD-YBJT4" # ServerStandard, Windows Server 2016 RTM ServerStandard Retail
    3763 = "7HNTT-W3264-X9HHP-CR4T8-78R64" # ServerStandard, Windows Server 2016 RTM ServerStandard Retail
    3763 = "7QN7B-QDBY7-BPKBK-TH27K-2YVXR" # ServerStandard, Windows Server 2016 RTM ServerStandard Retail
    3763 = "CNB94-JG22P-HRG29-R7T48-YP3DF" # ServerStandard, Windows Server 2016 RTM ServerStandard Retail
    3763 = "JN8MW-HMM7W-23WQT-WG266-BP3DF" # ServerStandard, Windows Server 2016 RTM ServerStandard Retail
    3763 = "KGNCB-CBBBH-7BMHG-J9KF6-6F464" # ServerStandard, Windows Server 2016 RTM ServerStandard Retail
    3763 = "NHVHJ-WMWPH-8BG3T-JQBDY-X4T3F" # ServerStandard, Windows Server 2016 RTM ServerStandard Retail
    3763 = "WKHQ9-J3NT4-CJT8G-DVYBJ-Q7BKR" # ServerStandard, Windows Server 2016 RTM ServerStandard Retail
    3763 = "XVKQN-TX4FB-MJR9T-27TFW-33XQF" # ServerStandard, Windows Server 2016 RTM ServerStandard Retail
    3764 = "CB7KF-BWN84-R7R2Y-793K2-8XDDG" # ServerDatacenter, Windows Server 2016 RTM ServerDatacenter Volume:GVLK
    3764 = "J34ND-TJJTV-HQR9M-7GK9P-TMVXT" # ServerDatacenter, Windows Server 2016 RTM ServerDatacenter Volume:GVLK
    3764 = "K97VN-B87KF-M4W9D-4HP74-2KDDG" # ServerDatacenter, Windows Server 2016 RTM ServerDatacenter Volume:GVLK
    3764 = "RYNGC-7H7T8-PFJ8K-B9JMR-9W39T" # ServerDatacenter, Windows Server 2016 RTM ServerDatacenter Volume:GVLK
    3765 = "74X8N-P3C8V-YPKWF-9X7WX-RM63H" # ServerDatacenter, Windows Server 2016 RTM ServerDatacenter Volume:MAK
    3765 = "77HJN-8MTTB-QMXH7-VHMR8-YP3DH" # ServerDatacenter, Windows Server 2016 RTM ServerDatacenter Volume:MAK
    3765 = "7MNP7-3348D-688CY-8MJXX-9HKQH" # ServerDatacenter, Windows Server 2016 RTM ServerDatacenter Volume:MAK
    3765 = "82TGX-CN93G-VYWYR-78HRF-9W39V" # ServerDatacenter, Windows Server 2016 RTM ServerDatacenter Volume:MAK
    3765 = "8MHN3-69PYD-BW977-7FTRF-Q9PG7" # ServerDatacenter, Windows Server 2016 RTM ServerDatacenter Volume:MAK
    3765 = "98KNC-MK9QM-8RC82-4WBQQ-63CG7" # ServerDatacenter, Windows Server 2016 RTM ServerDatacenter Volume:MAK
    3765 = "D8F4Y-FNBKB-973FK-WC93Q-WQMKV" # ServerDatacenter, Windows Server 2016 RTM ServerDatacenter Volume:MAK
    3765 = "DNG3J-HHXDB-CWQGR-KKM2B-7MJT7" # ServerDatacenter, Windows Server 2016 RTM ServerDatacenter Volume:MAK
    3765 = "FN8H8-YKJGW-J9BC4-GH6WB-G3CG7" # ServerDatacenter, Windows Server 2016 RTM ServerDatacenter Volume:MAK
    3765 = "FWD7N-764HM-8G4P9-BRBKG-D3XQH" # ServerDatacenter, Windows Server 2016 RTM ServerDatacenter Volume:MAK
    3765 = "GB79F-NCHD7-FW7FB-MQFVF-8B63H" # ServerDatacenter, Windows Server 2016 RTM ServerDatacenter Volume:MAK
    3765 = "HN3YC-H3XK4-YYD79-X92KG-D3XQH" # ServerDatacenter, Windows Server 2016 RTM ServerDatacenter Volume:MAK
    3765 = "J72FH-7MND3-KB2Y3-CTHVK-66QDH" # ServerDatacenter, Windows Server 2016 RTM ServerDatacenter Volume:MAK
    3765 = "JNVR2-7TVH7-8TT94-CCKBW-DGQDH" # ServerDatacenter, Windows Server 2016 RTM ServerDatacenter Volume:MAK
    3765 = "K2PNR-YCR3H-M6YCD-BYJ22-HH7XV" # ServerDatacenter, Windows Server 2016 RTM ServerDatacenter Volume:MAK
    3765 = "KH3YC-9NYMC-RP838-VH9Y4-MWR67" # ServerDatacenter, Windows Server 2016 RTM ServerDatacenter Volume:MAK
    3765 = "KNTCK-VT86X-PPDX7-BGK86-238T7" # ServerDatacenter, Windows Server 2016 RTM ServerDatacenter Volume:MAK
    3765 = "KT3HG-NRKVG-6HYHX-GT87X-H6D9V" # ServerDatacenter, Windows Server 2016 RTM ServerDatacenter Volume:MAK
    3765 = "KWFB7-HKNBJ-WC3HH-H3BP7-QPF67" # ServerDatacenter, Windows Server 2016 RTM ServerDatacenter Volume:MAK
    3765 = "P9M8C-N3G6B-9VPKQ-TVQ4K-P38T7" # ServerDatacenter, Windows Server 2016 RTM ServerDatacenter Volume:MAK
    3765 = "QHMN4-KF277-9HG9M-DJXV9-8QMKV" # ServerDatacenter, Windows Server 2016 RTM ServerDatacenter Volume:MAK
    3765 = "R8WNH-W7CGF-H69F2-M7728-HMJT7" # ServerDatacenter, Windows Server 2016 RTM ServerDatacenter Volume:MAK
    3765 = "RGNBM-H4QQK-P4BGK-GTJC4-CR467" # ServerDatacenter, Windows Server 2016 RTM ServerDatacenter Volume:MAK
    3765 = "RKNJ3-YY249-TXWWM-QBHX9-C7KQH" # ServerDatacenter, Windows Server 2016 RTM ServerDatacenter Volume:MAK
    3765 = "RTKNV-8B32B-MYXM2-GXGBF-KBVXV" # ServerDatacenter, Windows Server 2016 RTM ServerDatacenter Volume:MAK
    3765 = "TYNXK-3VBCR-KFK9C-TJMKP-D7BKV" # ServerDatacenter, Windows Server 2016 RTM ServerDatacenter Volume:MAK
    3765 = "VN9Q7-VTYTK-TY98Q-DG78J-33XQH" # ServerDatacenter, Windows Server 2016 RTM ServerDatacenter Volume:MAK
    3765 = "W33HN-PYRWB-PQR82-4JBFY-XBVXV" # ServerDatacenter, Windows Server 2016 RTM ServerDatacenter Volume:MAK
    3765 = "X4B74-8GNTG-8JGQD-FGQV3-YBJT7" # ServerDatacenter, Windows Server 2016 RTM ServerDatacenter Volume:MAK
    3766 = "GYT9N-JWV3D-26THF-7476P-MP3DJ" # ServerDatacenter, Windows Server 2016 RTM ServerDatacenter VT:IA
    3766 = "J8FBX-NT2GD-MXXWX-4W4MQ-FM63J" # ServerDatacenter, Windows Server 2016 RTM ServerDatacenter VT:IA
    3766 = "N6DG2-2PCW9-GQMWP-B6WHJ-J8G3J" # ServerDatacenter, Windows Server 2016 RTM ServerDatacenter VT:IA
    3767 = "7K6XX-N3TJW-X3QQD-D8VYG-C9YKX" # ServerDatacenter, Windows Server 2016 RTM ServerDatacenter OEM:NONSLP
    3767 = "BQBHN-XGDYC-8JWJ6-6KJFV-94T3K" # ServerDatacenter, Windows Server 2016 RTM ServerDatacenter OEM:NONSLP
    3767 = "C9NQB-KJYD8-T369X-FC7QG-4M63K" # ServerDatacenter, Windows Server 2016 RTM ServerDatacenter OEM:NONSLP
    3767 = "GQNMF-P92B6-BYPBP-2JCKD-BHBKX" # ServerDatacenter, Windows Server 2016 RTM ServerDatacenter OEM:NONSLP
    3767 = "GVWDY-HXNYK-2TTXH-36726-D3XQK" # ServerDatacenter, Windows Server 2016 RTM ServerDatacenter OEM:NONSLP
    3767 = "MGNKQ-MXJR3-79JT9-4GV6H-BDXQK" # ServerDatacenter, Windows Server 2016 RTM ServerDatacenter OEM:NONSLP
    3767 = "NP4Q4-GQ2QP-3XYTP-8BJ3W-J8G3K" # ServerDatacenter, Windows Server 2016 RTM ServerDatacenter OEM:NONSLP
    3767 = "RXRCP-8N2T6-CMBM3-G9WR8-F3MKX" # ServerDatacenter, Windows Server 2016 RTM ServerDatacenter OEM:NONSLP
    3767 = "YVP2R-N4WFK-YYH4V-YVPQQ-G839X" # ServerDatacenter, Windows Server 2016 RTM ServerDatacenter OEM:NONSLP
    3768 = "9YN7B-RVXWK-V68QG-3RCKM-RC3DM" # ServerDatacenter, Windows Server 2016 RTM ServerDatacenter OEM:NONSLP (MUI locked to zh-CN)
    3768 = "GN9JP-CQ9QD-MBMG6-DXRWH-G6QDM" # ServerDatacenter, Windows Server 2016 RTM ServerDatacenter OEM:NONSLP (MUI locked to zh-CN)
    3768 = "TNFC8-4CJQW-YGXKF-W2G4J-W447B" # ServerDatacenter, Windows Server 2016 RTM ServerDatacenter OEM:NONSLP (MUI locked to zh-CN)
    3769 = "6YVJQ-8NJ74-JK327-MMTFR-MWR7C" # ServerDatacenter, Windows Server 2016 RTM ServerDatacenter OEM:SLP
    3769 = "8T9BV-NQ4QH-T7HFW-4FW2G-V6D92" # ServerDatacenter, Windows Server 2016 RTM ServerDatacenter OEM:SLP
    3769 = "CDG7Q-74NJ2-9322V-7XMT4-3DCHC" # ServerDatacenter, Windows Server 2016 RTM ServerDatacenter OEM:SLP
    3769 = "D6BNR-VVGH3-C7XPJ-BPHWB-CWG3P" # ServerDatacenter, Windows Server 2016 RTM ServerDatacenter OEM:SLP
    3769 = "RCB4N-DF8VP-DFBQV-TW68M-MY63P" # ServerDatacenter, Windows Server 2016 RTM ServerDatacenter OEM:SLP
    3769 = "VCNJ8-2JGFY-MXG7R-7VT7D-63CHC" # ServerDatacenter, Windows Server 2016 RTM ServerDatacenter OEM:SLP
    3770 = "2FR83-X9NRV-KY98B-696H4-Q9PHD" # ServerDatacenter, Windows Server 2016 RTM ServerDatacenter OEM:SLP (MUI locked to zh-CN)
    3770 = "2P29W-6NTPX-9PVH2-T2QH2-W2Q93" # ServerDatacenter, Windows Server 2016 RTM ServerDatacenter OEM:SLP (MUI locked to zh-CN)
    3770 = "TD6TK-N3CBY-3GHHD-RRHG3-KKYK3" # ServerDatacenter, Windows Server 2016 RTM ServerDatacenter OEM:SLP (MUI locked to zh-CN)
    3771 = "MB6FD-NWGXT-FW9HF-47DD6-HFT3R" # ServerDatacenterEval, Windows Server 2016 RTM ServerDatacenterEval Retail:TB:Eval
    3771 = "QVTQ9-GNRBH-JQ9G7-W7FBW-RX9QR" # ServerDatacenterEval, Windows Server 2016 RTM ServerDatacenterEval Retail:TB:Eval
    3771 = "RB6DF-NHDTR-46V9Y-J6JQG-BP3DR" # ServerDatacenterEval, Windows Server 2016 RTM ServerDatacenterEval Retail:TB:Eval
    3772 = "3YKNF-67DBK-84WM7-7T7TV-YY63T" # ServerStandard, Windows Server 2016 RTM ServerStandard OEM:NONSLP
    3772 = "449DN-CR72K-4KPB6-CC876-H8R7G" # ServerStandard, Windows Server 2016 RTM ServerStandard OEM:NONSLP
    3772 = "7VYKK-NYY8X-Q292M-P24F8-4VWVG" # ServerStandard, Windows Server 2016 RTM ServerStandard OEM:NONSLP
    3772 = "8BFQP-9N4RP-DHHPP-F8WBH-8HWVG" # ServerStandard, Windows Server 2016 RTM ServerStandard OEM:NONSLP
    3772 = "HD28K-N489H-3WBT6-CPKJ4-F62HG" # ServerStandard, Windows Server 2016 RTM ServerStandard OEM:NONSLP
    3772 = "J2MKC-WNKRF-XR8HP-4HCMH-PWG3T" # ServerStandard, Windows Server 2016 RTM ServerStandard OEM:NONSLP
    3772 = "N24BP-QJX39-88GVJ-QTPPD-RJR7G" # ServerStandard, Windows Server 2016 RTM ServerStandard OEM:NONSLP
    3772 = "X7GYN-YXGYM-DMD8X-YMTJ9-XKYK6" # ServerStandard, Windows Server 2016 RTM ServerStandard OEM:NONSLP
    3773 = "7JTVJ-KNY9H-6Q726-RYGWJ-TQ8VH" # ServerStandard, Windows Server 2016 RTM ServerStandard OEM:NONSLP (MUI locked to zh-CN)
    3773 = "BNBB8-KKFF9-X7YW9-H29M8-XW397" # ServerStandard, Windows Server 2016 RTM ServerStandard OEM:NONSLP (MUI locked to zh-CN)
    3773 = "NR3R8-RC9VQ-VRJF8-B9KPC-8XDDV" # ServerStandard, Windows Server 2016 RTM ServerStandard OEM:NONSLP (MUI locked to zh-CN)
    3773 = "Y2836-H3N9P-27HJW-DCYBQ-YBJVH" # ServerStandard, Windows Server 2016 RTM ServerStandard OEM:NONSLP (MUI locked to zh-CN)
    3774 = "6HN62-BHYF6-639KW-RRFHG-GMVX8" # ServerStandard, Windows Server 2016 RTM ServerStandard OEM:SLP
    3774 = "6MNR6-9K3HQ-6K3K7-G6YX9-WT2HJ" # ServerStandard, Windows Server 2016 RTM ServerStandard OEM:SLP
    3774 = "GH8VN-CFKW3-47THH-JTWKW-78R7J" # ServerStandard, Windows Server 2016 RTM ServerStandard OEM:SLP
    3774 = "MV2WC-RHNGC-QTRG2-R2YX7-R9DDW" # ServerStandard, Windows Server 2016 RTM ServerStandard OEM:SLP
    3774 = "YKGW8-NMQMM-24VT7-94JMD-DV7X8" # ServerStandard, Windows Server 2016 RTM ServerStandard OEM:SLP
    3775 = "GPBGT-BNMY9-H39PY-MQTFK-FRHX9" # ServerStandard, Windows Server 2016 RTM ServerStandard OEM:SLP (MUI locked to zh-CN)
    3775 = "NCGW7-TYGP9-2B9XM-3X32T-WXDDX" # ServerStandard, Windows Server 2016 RTM ServerStandard OEM:SLP (MUI locked to zh-CN)
    3775 = "PR2VN-DTB7F-FVVRP-X7C7P-Q3XQX" # ServerStandard, Windows Server 2016 RTM ServerStandard OEM:SLP (MUI locked to zh-CN)
    3776 = "263NC-WD6PB-RVD74-G4RGB-39PHM" # ServerStandard, Windows Server 2016 RTM ServerStandard Volume:GVLK
    3776 = "TN2DT-HC3MB-MTD2R-H8C42-VFT3Y" # ServerStandard, Windows Server 2016 RTM ServerStandard Volume:GVLK
    3776 = "WC2BQ-8NRM3-FDDYY-2BFGV-KHKQY" # ServerStandard, Windows Server 2016 RTM ServerStandard Volume:GVLK
    3777 = "4TF8M-WNM9X-3HTVK-TH4VK-MHBMC" # ServerStandard, Windows Server 2016 RTM ServerStandard Volume:MAK
    3777 = "92GR4-NDRQX-VMWGY-CWRBJ-GVKQ2" # ServerStandard, Windows Server 2016 RTM ServerStandard Volume:MAK
    3777 = "9N9FF-M4RXX-Y3G28-Q9WX6-GMVYC" # ServerStandard, Windows Server 2016 RTM ServerStandard Volume:MAK
    3777 = "D74T9-BHNY9-WB94V-QJKTY-K77YC" # ServerStandard, Windows Server 2016 RTM ServerStandard Volume:MAK
    3777 = "DNM8B-KFWB6-7RW6W-8DRHV-8HWVP" # ServerStandard, Windows Server 2016 RTM ServerStandard Volume:MAK
    3777 = "GWW8N-V67JW-2XF94-PY2B3-KKYMC" # ServerStandard, Windows Server 2016 RTM ServerStandard Volume:MAK
    3777 = "H2W2N-F4WFQ-XFFTV-WV7J9-TF47P" # ServerStandard, Windows Server 2016 RTM ServerStandard Volume:MAK
    3777 = "JXGFG-9NH22-3PY2D-R8GV8-DGQD2" # ServerStandard, Windows Server 2016 RTM ServerStandard Volume:MAK
    3777 = "N8RQR-9XG2R-TGJQG-9KCMD-TCRBC" # ServerStandard, Windows Server 2016 RTM ServerStandard Volume:MAK
    3777 = "ND2VH-GJPX3-FFV4X-H893D-9D8VP" # ServerStandard, Windows Server 2016 RTM ServerStandard Volume:MAK
    3777 = "PVCTN-7JY77-XYVTY-GG3TR-2KDD2" # ServerStandard, Windows Server 2016 RTM ServerStandard Volume:MAK
    3777 = "QYY2N-9JX8W-R89KM-MRTHR-8447P" # ServerStandard, Windows Server 2016 RTM ServerStandard Volume:MAK
    3777 = "TWX6R-N8XMG-T3RQB-3GY46-KTQD2" # ServerStandard, Windows Server 2016 RTM ServerStandard Volume:MAK
    3777 = "VC63H-WHNKM-PWVXR-CTYVY-43MMC" # ServerStandard, Windows Server 2016 RTM ServerStandard Volume:MAK
    3777 = "VPGBB-RMNHK-TX8H6-XV78K-V23D2" # ServerStandard, Windows Server 2016 RTM ServerStandard Volume:MAK
    3777 = "VRVNB-6CKP7-VMPRW-V2JY8-JFHYC" # ServerStandard, Windows Server 2016 RTM ServerStandard Volume:MAK
    3777 = "W86DW-J6NCT-C3MWF-VJHKF-CR47P" # ServerStandard, Windows Server 2016 RTM ServerStandard Volume:MAK
    3778 = "6T9CB-NXX3G-8QPH8-M2334-VMJVQ" # ServerStandard, Windows Server 2016 RTM ServerStandard VT:IA
    3778 = "JQ2PK-NFQK4-F34TF-H8Y4K-4JR7Q" # ServerStandard, Windows Server 2016 RTM ServerStandard VT:IA
    3779 = "2TPNT-XFVDC-22WYJ-DR76P-HH7YF" # ServerDatacenter, Windows Server 2016 RTM ServerDatacenter Retail
    3779 = "9NTM4-YPK2B-8VBJ6-QT7WY-JK9Q4" # ServerDatacenter, Windows Server 2016 RTM ServerDatacenter Retail
    3779 = "BBJ99-8N29F-8P7TD-MQV24-K4T34" # ServerDatacenter, Windows Server 2016 RTM ServerDatacenter Retail
    3779 = "CR899-MDNQD-X922K-PXBXC-RVWVR" # ServerDatacenter, Windows Server 2016 RTM ServerDatacenter Retail
    3779 = "H97QD-CNVJ2-38J93-XGQM6-YHBMF" # ServerDatacenter, Windows Server 2016 RTM ServerDatacenter Retail
    3779 = "HF7YN-32BJF-GF9T2-H3V7B-HVBMF" # ServerDatacenter, Windows Server 2016 RTM ServerDatacenter Retail
    3779 = "J4HJ4-GWN46-B4Y32-PT2GX-FRHYF" # ServerDatacenter, Windows Server 2016 RTM ServerDatacenter Retail
    3779 = "JNQP4-7DB8M-P4BFK-7D7QT-QYJVR" # ServerDatacenter, Windows Server 2016 RTM ServerDatacenter Retail
    3779 = "JVNV2-VQ3CP-DKPMT-WWKGB-JK9Q4" # ServerDatacenter, Windows Server 2016 RTM ServerDatacenter Retail
    3779 = "K6KXM-9DNM4-B4V79-WH2WM-7MJVR" # ServerDatacenter, Windows Server 2016 RTM ServerDatacenter Retail
    3779 = "M97B4-RNPYH-9D7JG-YG6YR-Q9PHR" # ServerDatacenter, Windows Server 2016 RTM ServerDatacenter Retail
    3779 = "TGJ3X-7N98J-JYDTY-43QDG-YHBMF" # ServerDatacenter, Windows Server 2016 RTM ServerDatacenter Retail
    3779 = "WY6MN-PPHHG-VKXWP-VKJRG-TJG34" # ServerDatacenter, Windows Server 2016 RTM ServerDatacenter Retail
    3779 = "X22N7-3XYYC-V449C-7DXC7-GCRBF" # ServerDatacenter, Windows Server 2016 RTM ServerDatacenter Retail
    3779 = "YB3QV-7NXV6-7KF33-YT6FV-MBJVR" # ServerDatacenter, Windows Server 2016 RTM ServerDatacenter Retail
    3779 = "YQNFH-BDHQH-3M9DW-GQPRJ-MTFBF" # ServerDatacenter, Windows Server 2016 RTM ServerDatacenter Retail
    3780 = "9PBKX-4NHGT-QWV4C-4JD94-TVKQ6" # ServerStandardEval, Windows Server 2016 RTM ServerStandardEval Retail:TB:Eval
    3780 = "F68PR-FTNKB-G3KQ7-BP6YR-K4T36" # ServerStandardEval, Windows Server 2016 RTM ServerStandardEval Retail:TB:Eval
    3780 = "NYDJQ-4R94V-FT266-6VW8Q-977YG" # ServerStandardEval, Windows Server 2016 RTM ServerStandardEval Retail:TB:Eval
    3782 = "DCPHK-NFMTC-H88MJ-PFHPY-QJ4BJ" # EnterpriseS, Win 10 RTM EnterpriseS Volume:GVLK
    3782 = "H76BG-QBNM7-73XY9-V6W2T-684BJ" # EnterpriseS, Win 10 RTM EnterpriseS Volume:GVLK
    3782 = "TNCTG-TXKC2-BK8W3-MW3YJ-WB638" # EnterpriseS, Win 10 RTM EnterpriseS Volume:GVLK
    3783 = "QFFDN-GRT3P-VKWWX-X7T3R-8B639" # EnterpriseSN, Win 10 RTM EnterpriseSN Volume:GVLK
    3783 = "RW7WN-FMT44-KRGBK-G44WK-QV7YK" # EnterpriseSN, Win 10 RTM EnterpriseSN Volume:GVLK
    3784 = "4V7NJ-MQKCW-VYTFX-DX6JD-QRT4B" # ProfessionalEducation, Win 10 RTM ProfessionalEducation Volume:GVLK
    3784 = "6TP4R-GNPTD-KYYHQ-7B7DP-J447Y" # ProfessionalEducation, Win 10 RTM ProfessionalEducation Volume:GVLK
    3785 = "NWKXD-8HBCJ-TKC7X-DW3B4-R3MMP" # ProfessionalEducationN, Win 10 RTM ProfessionalEducationN Volume:GVLK
    3785 = "YVWGF-BXNMC-HTQYQ-CPQ99-66QFC" # ProfessionalEducationN, Win 10 RTM ProfessionalEducationN Volume:GVLK
    3786 = "KNBFC-HGRB4-HVV3Y-Q6CPG-V6FBQ" # ProfessionalEducation, Win 10 RTM ProfessionalEducation Volume:MAK
    3786 = "NHJ23-Q3MBT-9TW8K-R39KV-94T4D" # ProfessionalEducation, Win 10 RTM ProfessionalEducation Volume:MAK
    3786 = "VYQRY-NBMXC-X4XMJ-W8QXF-GXYMQ" # ProfessionalEducation, Win 10 RTM ProfessionalEducation Volume:MAK
    3787 = "JM8PN-694RH-VT977-37X34-84474" # ProfessionalEducationN, Win 10 RTM ProfessionalEducationN Volume:MAK
    3787 = "T9NFD-3RDH8-GF4RT-Q2K6F-KBVYR" # ProfessionalEducationN, Win 10 RTM ProfessionalEducationN Volume:MAK
    3788 = "9JQNQ-V8HQ6-PKB8H-GGHRY-R62H6" # ServerAzureNano, Windows Server 2016 RTM ServerAzureNano Retail
    3789 = "J76BD-NRH32-T3HP3-MMQ9M-92F77" # ServerAzureCor, Windows Server 2016 RTM ServerAzureCor Retail
    3790 = "9NVV6-PPYVR-Q6FRM-9JWDY-8FHYW" # EnterpriseSubscription, Win 10 RTM EnterpriseSubscription Volume:MAK
    3791 = "N8RDF-KR7J8-9W4M8-R6W7F-PPRBX" # EnterpriseSubscriptionN, Win 10 RTM EnterpriseSubscriptionN Volume:MAK
    3792 = "7CCNQ-M4PQ8-JKKQX-BH6VK-MHBMY" # ProfessionalEducation, Win 10 RTM ProfessionalEducation OEM:DM
    3792 = "8K2N2-G2R3X-BBKPT-J8VRJ-DGQFM" # ProfessionalEducation, Win 10 RTM ProfessionalEducation OEM:DM
    3792 = "DBXXP-6YNM8-MCTYH-WXVDG-FVWWB" # ProfessionalEducation, Win 10 RTM ProfessionalEducation OEM:DM
    3792 = "GKBNJ-MHH82-8436W-MJ4P4-6Q8WB" # ProfessionalEducation, Win 10 RTM ProfessionalEducation OEM:DM
    3792 = "JJ3BH-DN3XW-T2YF7-VMPX3-WQMMY" # ProfessionalEducation, Win 10 RTM ProfessionalEducation OEM:DM
    3792 = "JMGNM-VTCK8-VTP9W-CYHBD-TCRBY" # ProfessionalEducation, Win 10 RTM ProfessionalEducation OEM:DM
    3792 = "M6N3G-M747G-GHV4F-XTKFB-VQXRM" # ProfessionalEducation, Win 10 RTM ProfessionalEducation OEM:DM
    3792 = "MJ6W9-4NRC9-P74PQ-C4448-F3MMY" # ProfessionalEducation, Win 10 RTM ProfessionalEducation OEM:DM
    3792 = "VYNPY-876CT-3WG64-6WQ6P-RVWWB" # ProfessionalEducation, Win 10 RTM ProfessionalEducation OEM:DM
    3793 = "F28RV-NYFK4-FFHV7-QQYRH-462JC" # ProfessionalEducation, Win 10 RTM ProfessionalEducation OEM:NONSLP
    3793 = "HD3VD-G4NG6-QV8KD-8M783-DV7Y2" # ProfessionalEducation, Win 10 RTM ProfessionalEducation OEM:NONSLP
    3793 = "KH86N-T2W2H-YTKVC-7QDHC-YKPJC" # ProfessionalEducation, Win 10 RTM ProfessionalEducation OEM:NONSLP
    3793 = "MVY7X-7NMFG-3BPQ3-63TVF-FC3FP" # ProfessionalEducation, Win 10 RTM ProfessionalEducation OEM:NONSLP
    3793 = "TQWQJ-9NWJ4-46XRG-MQJX9-C7KRP" # ProfessionalEducation, Win 10 RTM ProfessionalEducation OEM:NONSLP
    3793 = "V4YDN-QP7WF-2499K-KDHD2-2DMM2" # ProfessionalEducation, Win 10 RTM ProfessionalEducation OEM:NONSLP
    3793 = "VW3XX-NY4T6-Q79C2-GC6M2-3YJWC" # ProfessionalEducation, Win 10 RTM ProfessionalEducation OEM:NONSLP
    3794 = "6YDB8-N9JVF-PWCX4-G9RQY-8FHY3" # ProfessionalEducationN, Win 10 RTM ProfessionalEducationN OEM:DM
    3794 = "D6YXN-73KK9-RRTG9-B3J7V-8HWWD" # ProfessionalEducationN, Win 10 RTM ProfessionalEducationN OEM:DM
    3794 = "FPKH3-NM8B6-GRBKP-4T42B-XBVY3" # ProfessionalEducationN, Win 10 RTM ProfessionalEducationN OEM:DM
    3794 = "HN338-K69PP-P3JWH-PPCG2-D7BM3" # ProfessionalEducationN, Win 10 RTM ProfessionalEducationN OEM:DM
    3794 = "MX7FN-8KYH2-834Q4-V3YBY-92F8D" # ProfessionalEducationN, Win 10 RTM ProfessionalEducationN OEM:DM
    3794 = "NQ2H6-X7Y93-H6RWK-PCTQC-3YJWD" # ProfessionalEducationN, Win 10 RTM ProfessionalEducationN OEM:DM
    3794 = "PVN2P-FR3KC-9FYPM-BXKDC-PG2JD" # ProfessionalEducationN, Win 10 RTM ProfessionalEducationN OEM:DM
    3794 = "QXVXT-N8VM3-VB8WD-3M9KP-76FB3" # ProfessionalEducationN, Win 10 RTM ProfessionalEducationN OEM:DM
    3794 = "W8JKB-NMX2R-RTYVM-9XMC8-RX9RQ" # ProfessionalEducationN, Win 10 RTM ProfessionalEducationN OEM:DM
    3795 = "2D3QM-TND8P-FCF2F-9239W-JFHY4" # ProfessionalEducationN, Win 10 RTM ProfessionalEducationN OEM:NONSLP
    3795 = "2PFGF-QKNVW-7C936-6PRD4-KBVY4" # ProfessionalEducationN, Win 10 RTM ProfessionalEducationN OEM:NONSLP
    3795 = "CNG9D-KCYWM-P6B4H-PG3GT-D3XRR" # ProfessionalEducationN, Win 10 RTM ProfessionalEducationN OEM:NONSLP
    3795 = "N7FD6-8GC8C-R7MG3-3Q44K-P38WF" # ProfessionalEducationN, Win 10 RTM ProfessionalEducationN OEM:NONSLP
    3795 = "NGQ8F-HFW9F-4B3DT-TKR7H-3J4B4" # ProfessionalEducationN, Win 10 RTM ProfessionalEducationN OEM:NONSLP
    3795 = "Q8NQG-W3WKV-BP27T-KXKHV-X77Y4" # ProfessionalEducationN, Win 10 RTM ProfessionalEducationN OEM:NONSLP
    3795 = "Y4WG2-WNJ29-GQFJV-PK3JM-MY64R" # ProfessionalEducationN, Win 10 RTM ProfessionalEducationN OEM:NONSLP
    3798 = "N9QCR-YMVJ3-VY847-8XPWQ-977Y8" # ProfessionalWorkstation, Win 10 RTM ProfessionalWorkstation Retail
    3798 = "R7MNG-P4B9K-YGFXV-9G7WY-PR48J" # ProfessionalWorkstation, Win 10 RTM ProfessionalWorkstation Retail
    3799 = "7WNQY-TJPFM-RXDB8-K4HTR-2KDFX" # ProfessionalWorkstationN, Win 10 RTM ProfessionalWorkstationN Retail
    3799 = "W9NV9-HCFTP-DB7WX-RMJ2V-BDXRX" # ProfessionalWorkstationN, Win 10 RTM ProfessionalWorkstationN Retail
    3800 = "4HGWB-MNV2D-YV8WV-RX83M-R62JM" # ProfessionalEducation, Win 10 RTM ProfessionalEducation Retail
    3800 = "87NXV-2PPW9-PXD29-Q7F8J-JFH2B" # ProfessionalEducation, Win 10 RTM ProfessionalEducation Retail
    3800 = "8BNTP-P8BGH-Y9KQ6-T7K2T-WXDFY" # ProfessionalEducation, Win 10 RTM ProfessionalEducation Retail
    3800 = "8PTT6-RNW4C-6V7J2-C2D3X-MHBPB" # ProfessionalEducation, Win 10 RTM ProfessionalEducation Retail
    3800 = "Q96PD-4NF2H-VJK87-43BWW-BWR8M" # ProfessionalEducation, Win 10 RTM ProfessionalEducation Retail
    3801 = "GJTYN-HDMQY-FRR76-HVGC7-QPF8P" # ProfessionalEducationN, Win 10 RTM ProfessionalEducationN Retail
    3801 = "KQ6BB-N4K6V-QWDT3-FRGGM-43MPC" # ProfessionalEducationN, Win 10 RTM ProfessionalEducationN Retail
    3801 = "KQNHM-C2RTJ-Q6JJY-M483Y-39PJP" # ProfessionalEducationN, Win 10 RTM ProfessionalEducationN Retail
    3801 = "PW2NH-XVVCX-JRHJF-YP429-8QMPC" # ProfessionalEducationN, Win 10 RTM ProfessionalEducationN Retail
    3802 = "2N9QF-MDMCC-6BW46-4WB7W-Q7BPD" # EnterpriseS, Win 10 RTM EnterpriseS Volume:MAK
    3802 = "3Y7P8-G4NCV-BMXY9-WM8R6-6F48Q" # EnterpriseS, Win 10 RTM EnterpriseS Volume:MAK
    3802 = "6MN8B-YBPRT-C2QR9-3KQ7G-QYJWQ" # EnterpriseS, Win 10 RTM EnterpriseS Volume:MAK
    3802 = "6Q3MN-WFHXQ-T92G9-84C3H-WK9R3" # EnterpriseS, Win 10 RTM EnterpriseS Volume:MAK
    3802 = "8V4TN-28CJ3-WR8JV-TQ3JW-YP3F3" # EnterpriseS, Win 10 RTM EnterpriseS Volume:MAK
    3802 = "C6WHW-BNH48-J2WWT-M2MYF-4X9R3" # EnterpriseS, Win 10 RTM EnterpriseS Volume:MAK
    3802 = "F6NCF-4QMYR-WCKW6-2V876-H8R8Q" # EnterpriseS, Win 10 RTM EnterpriseS Volume:MAK
    3802 = "G8CN2-T84CP-J2XPB-QPQ88-WB643" # EnterpriseS, Win 10 RTM EnterpriseS Volume:MAK
    3802 = "GJCNP-PTRG3-3X9QQ-M8VBM-43MPD" # EnterpriseS, Win 10 RTM EnterpriseS Volume:MAK
    3802 = "J8D2H-TNY4D-DQ7MY-G76WW-82RCD" # EnterpriseS, Win 10 RTM EnterpriseS Volume:MAK
    3802 = "KDJJN-D7PTM-9FJYV-K6RMQ-FM643" # EnterpriseS, Win 10 RTM EnterpriseS Volume:MAK
    3802 = "KXDCN-B3BYB-FD4FH-VF2FK-P38WQ" # EnterpriseS, Win 10 RTM EnterpriseS Volume:MAK
    3802 = "MQDGB-CBNDT-8DR8P-HWDXP-PG2JQ" # EnterpriseS, Win 10 RTM EnterpriseS Volume:MAK
    3802 = "N2XVQ-YYG9D-22C49-R36PG-KTQF3" # EnterpriseS, Win 10 RTM EnterpriseS Volume:MAK
    3802 = "N4YYJ-PW8PR-QQDRV-2W47K-66QF3" # EnterpriseS, Win 10 RTM EnterpriseS Volume:MAK
    3802 = "NB9JR-7RDFW-QQVRK-YXFBM-KD8WQ" # EnterpriseS, Win 10 RTM EnterpriseS Volume:MAK
    3802 = "NCFYX-JDGVV-WFCXQ-BFM7Q-H23F3" # EnterpriseS, Win 10 RTM EnterpriseS Volume:MAK
    3802 = "NMGGY-M8HW8-HD6D7-HTQ46-6F48Q" # EnterpriseS, Win 10 RTM EnterpriseS Volume:MAK
    3802 = "NRW47-VQ3HM-6MYKH-YH2XT-J2RCD" # EnterpriseS, Win 10 RTM EnterpriseS Volume:MAK
    3802 = "PN3KR-JXM7T-46HM4-MCQGK-7XPJQ" # EnterpriseS, Win 10 RTM EnterpriseS Volume:MAK
    3802 = "R2YPK-N8P74-FHWYT-JQGPG-KTQF3" # EnterpriseS, Win 10 RTM EnterpriseS Volume:MAK
    3802 = "R9C76-NCK64-J6H47-XQCHY-KD8WQ" # EnterpriseS, Win 10 RTM EnterpriseS Volume:MAK
    3802 = "RMFNH-FX8FQ-FW6W4-DHV77-B7WWQ" # EnterpriseS, Win 10 RTM EnterpriseS Volume:MAK
    3802 = "V4KXK-XNM63-HJ8KP-GBGG3-Y4H2D" # EnterpriseS, Win 10 RTM EnterpriseS Volume:MAK
    3802 = "XWN2T-T6DTF-MPWBW-TWVX7-3J4CD" # EnterpriseS, Win 10 RTM EnterpriseS Volume:MAK
    3803 = "2DBW3-N2PJG-MVHW3-G7TDK-9HKR4" # EnterpriseSN, Win 10 RTM EnterpriseSN Volume:MAK
    3803 = "4YTK6-BNJKT-TY7XJ-3DBC8-RX9R4" # EnterpriseSN, Win 10 RTM EnterpriseSN Volume:MAK
    3803 = "6NF8F-9QVK4-QB6WJ-X8X6F-QGQF4" # EnterpriseSN, Win 10 RTM EnterpriseSN Volume:MAK
    3803 = "73YVQ-7NB7G-T37XT-RCMFQ-KKYPF" # EnterpriseSN, Win 10 RTM EnterpriseSN Volume:MAK
    3803 = "7NJXR-RKJX9-DWBK8-X62BC-Q3XR4" # EnterpriseSN, Win 10 RTM EnterpriseSN Volume:MAK
    3803 = "7NWV9-9DH4T-4BQJT-C2FTV-GCRCF" # EnterpriseSN, Win 10 RTM EnterpriseSN Volume:MAK
    3803 = "9Q6NH-TT7QF-KF3KM-BH7K2-4RH2F" # EnterpriseSN, Win 10 RTM EnterpriseSN Volume:MAK
    3803 = "BWNMP-6WGXT-KFRY2-D4C3H-WK9R4" # EnterpriseSN, Win 10 RTM EnterpriseSN Volume:MAK
    3803 = "C73T8-FNJRG-FTQWK-2JP2R-VMJWR" # EnterpriseSN, Win 10 RTM EnterpriseSN Volume:MAK
    3803 = "D34GK-XNJH8-6W239-Y7RT7-WK9R4" # EnterpriseSN, Win 10 RTM EnterpriseSN Volume:MAK
    3803 = "D9NT2-6F7HV-BT7F9-8VTFB-43MPF" # EnterpriseSN, Win 10 RTM EnterpriseSN Volume:MAK
    3803 = "DPYCX-CN4CH-X8KX4-YGX9R-R3MPF" # EnterpriseSN, Win 10 RTM EnterpriseSN Volume:MAK
    3803 = "GMNTP-XRY98-G4X6F-FW499-C7KR4" # EnterpriseSN, Win 10 RTM EnterpriseSN Volume:MAK
    3803 = "H328B-HFNH8-6HXQ9-D26HV-8HWWR" # EnterpriseSN, Win 10 RTM EnterpriseSN Volume:MAK
    3803 = "HD8VP-N7JRQ-QFB82-CQB8R-TVKR4" # EnterpriseSN, Win 10 RTM EnterpriseSN Volume:MAK
    3803 = "HX4GN-J8VF6-2PTFW-GYYQM-3GQF4" # EnterpriseSN, Win 10 RTM EnterpriseSN Volume:MAK
    3803 = "N747F-YJ29C-Y2JYB-GMVQX-MHBPF" # EnterpriseSN, Win 10 RTM EnterpriseSN Volume:MAK
    3803 = "NHMBV-KKD8J-RPBMD-64CXM-CWG44" # EnterpriseSN, Win 10 RTM EnterpriseSN Volume:MAK
    3803 = "NQHWT-CXQXK-BG9DF-P3MHJ-82RCF" # EnterpriseSN, Win 10 RTM EnterpriseSN Volume:MAK
    3803 = "NVRXJ-FHHTF-GBMMW-TPR2G-6F48R" # EnterpriseSN, Win 10 RTM EnterpriseSN Volume:MAK
    3803 = "QK94W-NPX6B-X268H-22CDJ-D9PJR" # EnterpriseSN, Win 10 RTM EnterpriseSN Volume:MAK
    3803 = "QNY6B-YHK63-JXJBG-GPBQQ-63CJR" # EnterpriseSN, Win 10 RTM EnterpriseSN Volume:MAK
    3803 = "QRJNF-K4GVM-M8RPV-GQ42V-JQMPF" # EnterpriseSN, Win 10 RTM EnterpriseSN Volume:MAK
    3803 = "WNTW8-Q7TR2-CDC3G-YW79X-GJG44" # EnterpriseSN, Win 10 RTM EnterpriseSN Volume:MAK
    3803 = "WPN28-K22JG-QJ3G9-DRYPC-FX9R4" # EnterpriseSN, Win 10 RTM EnterpriseSN Volume:MAK
    3804 = "JBGN9-T2MH3-2YV7W-WBWHM-FGFCG" # EnterpriseSEval, Win 10 RTM EnterpriseSEval Retail:TB:Eval
    3804 = "N4DMT-RJKDQ-XR6H7-3DKKP-3YJWT" # EnterpriseSEval, Win 10 RTM EnterpriseSEval Retail:TB:Eval
    3805 = "7M88N-MTVMR-VC46G-4K4R6-KTQF7" # EnterpriseSNEval, Win 10 RTM EnterpriseSNEval Retail:TB:Eval
    3805 = "R34N9-HJ6Q3-GBX4F-Q24KQ-49DF7" # EnterpriseSNEval, Win 10 RTM EnterpriseSNEval Retail:TB:Eval
    3806 = "4QH7F-WNQHF-3KTGG-CV36V-YY648" # EnterpriseS, Win 10 RTM EnterpriseS OEM:DM
    3806 = "6PMN4-267CX-C9WCW-27X8M-DPF8W" # EnterpriseS, Win 10 RTM EnterpriseS OEM:DM
    3806 = "8NRXG-W8CHG-J676V-6KYMY-2PRCJ" # EnterpriseS, Win 10 RTM EnterpriseS OEM:DM
    3806 = "F3NCP-KW7R4-CRGT3-97YC6-PDMPJ" # EnterpriseS, Win 10 RTM EnterpriseS OEM:DM
    3806 = "KKNK3-P7VMD-FGJV3-2T9KC-RVWWW" # EnterpriseS, Win 10 RTM EnterpriseS OEM:DM
    3806 = "MDJNC-XWDXT-BQXBW-KQP33-M7WWW" # EnterpriseS, Win 10 RTM EnterpriseS OEM:DM
    3806 = "MDX8R-Q6N64-VQGXV-83V4K-8QMPJ" # EnterpriseS, Win 10 RTM EnterpriseS OEM:DM
    3806 = "N2JDG-89XTT-82QR8-F43YT-3V72J" # EnterpriseS, Win 10 RTM EnterpriseS OEM:DM
    3806 = "PHHBN-DCVHC-DQKD2-6RDQ2-2DMPJ" # EnterpriseS, Win 10 RTM EnterpriseS OEM:DM
    3806 = "V2V8N-FMGHR-H26FY-DTXVK-C7KR8" # EnterpriseS, Win 10 RTM EnterpriseS OEM:DM
    3806 = "XFDD2-BKN9P-X2QWR-YGKQP-VFT48" # EnterpriseS, Win 10 RTM EnterpriseS OEM:DM
    3806 = "YC4NT-39D46-C7MCH-BJR48-F3MPJ" # EnterpriseS, Win 10 RTM EnterpriseS OEM:DM
    3807 = "3N8WX-VT7WC-93PHB-2GY34-BY649" # EnterpriseS, Win 10 RTM EnterpriseS OEM:NONSLP
    3807 = "6B9C8-KN74R-XY9TM-YVPR4-37BPK" # EnterpriseS, Win 10 RTM EnterpriseS OEM:NONSLP
    3807 = "6W6BC-NBF6Y-49Q8P-PBPGX-BKPJX" # EnterpriseS, Win 10 RTM EnterpriseS OEM:NONSLP
    3807 = "72NB7-QKPMD-VPGM9-HDTYH-PWG49" # EnterpriseS, Win 10 RTM EnterpriseS OEM:NONSLP
    3807 = "7CC6N-C84BP-497BY-TV6DF-3DCJX" # EnterpriseS, Win 10 RTM EnterpriseS OEM:NONSLP
    3807 = "7NWT4-DR6KH-6GTBD-MHJBQ-FM649" # EnterpriseS, Win 10 RTM EnterpriseS OEM:NONSLP
    3807 = "8MC49-NKKCG-MGM67-7RWVW-GVKR9" # EnterpriseS, Win 10 RTM EnterpriseS OEM:NONSLP
    3807 = "9NR7H-P9MDM-Q83H2-RKDXP-PG2JX" # EnterpriseS, Win 10 RTM EnterpriseS OEM:NONSLP
    3807 = "B69NR-78QR7-2VM2J-VJV97-R9DF9" # EnterpriseS, Win 10 RTM EnterpriseS OEM:NONSLP
    3807 = "DBBKC-NGTTX-XT62K-R23V9-YDXR9" # EnterpriseS, Win 10 RTM EnterpriseS OEM:NONSLP
    3807 = "DKRCK-46NFC-6FCHB-B3RTB-TXYPK" # EnterpriseS, Win 10 RTM EnterpriseS OEM:NONSLP
    3807 = "FQ2N4-MD3X7-2VR2H-BT2DY-X4T49" # EnterpriseS, Win 10 RTM EnterpriseS OEM:NONSLP
    3807 = "FW4NH-C6TYD-DG9K4-VXWVH-3J4CK" # EnterpriseS, Win 10 RTM EnterpriseS OEM:NONSLP
    3807 = "G6P6C-MGNDW-3TMWF-BCD88-WB649" # EnterpriseS, Win 10 RTM EnterpriseS OEM:NONSLP
    3807 = "GN66R-PHR8P-93T4H-BTTCG-V6FCK" # EnterpriseS, Win 10 RTM EnterpriseS OEM:NONSLP
    3807 = "GTXHP-F4N82-9KTJ4-64BWR-37BPK" # EnterpriseS, Win 10 RTM EnterpriseS OEM:NONSLP
    3807 = "HKNCT-TBTYT-PP7JG-Y8GBV-462JX" # EnterpriseS, Win 10 RTM EnterpriseS OEM:NONSLP
    3807 = "HNJH7-DJY3B-28B6Y-9BJCP-KW4CK" # EnterpriseS, Win 10 RTM EnterpriseS OEM:NONSLP
    3807 = "K8NTT-VKR8F-M8YXB-WPMGX-4JR8X" # EnterpriseS, Win 10 RTM EnterpriseS OEM:NONSLP
    3807 = "KNBQW-WCH62-6DDCP-QWM4V-94T49" # EnterpriseS, Win 10 RTM EnterpriseS OEM:NONSLP
    3807 = "MCHGD-78NF7-W83XY-77FWF-DJ4CK" # EnterpriseS, Win 10 RTM EnterpriseS OEM:NONSLP
    3807 = "N78WT-PXH3C-FT3BJ-YM32Y-F9DF9" # EnterpriseS, Win 10 RTM EnterpriseS OEM:NONSLP
    3807 = "NFMJH-VK48T-6BDP3-B23YD-H23F9" # EnterpriseS, Win 10 RTM EnterpriseS OEM:NONSLP
    3807 = "NGFGY-FKYP3-8GBJJ-MF6YR-GXYPK" # EnterpriseS, Win 10 RTM EnterpriseS OEM:NONSLP
    3807 = "NK96Y-D9CD8-W44CQ-R8YTK-DYJWX" # EnterpriseS, Win 10 RTM EnterpriseS OEM:NONSLP
    3807 = "NRPCK-9MMXK-Y6JDM-VP64M-2PRCK" # EnterpriseS, Win 10 RTM EnterpriseS OEM:NONSLP
    3807 = "P98ND-PR2P6-KQYHG-H3DRB-B4H2K" # EnterpriseS, Win 10 RTM EnterpriseS OEM:NONSLP
    3807 = "Q8MT4-WN83B-D86JJ-KVC7K-MHBPK" # EnterpriseS, Win 10 RTM EnterpriseS OEM:NONSLP
    3807 = "QCP6H-NCVTF-7KVWJ-C3FKM-6VKR9" # EnterpriseS, Win 10 RTM EnterpriseS OEM:NONSLP
    3807 = "QD4VY-NRMXP-M46GF-72GVV-X772K" # EnterpriseS, Win 10 RTM EnterpriseS OEM:NONSLP
    3807 = "T2K9T-N434D-7WD2J-K23GH-4C3F9" # EnterpriseS, Win 10 RTM EnterpriseS OEM:NONSLP
    3807 = "X2D6X-4NJT7-7Q2V9-Y8FTX-JXDF9" # EnterpriseS, Win 10 RTM EnterpriseS OEM:NONSLP
    3807 = "X2XND-KGXCD-VHRY8-TYTXW-D9PJX" # EnterpriseS, Win 10 RTM EnterpriseS OEM:NONSLP
    3807 = "XMYPC-64NCD-9RYM7-F3X8Y-TXYPK" # EnterpriseS, Win 10 RTM EnterpriseS OEM:NONSLP
    3807 = "YC72N-RCBVC-FBYT4-CQ68G-FVWWX" # EnterpriseS, Win 10 RTM EnterpriseS OEM:NONSLP
    3807 = "YG8NF-DC7YC-3WQ2D-B2YVK-HCF8X" # EnterpriseS, Win 10 RTM EnterpriseS OEM:NONSLP
    3839 = "VP34G-4NPPG-79JTQ-864T4-R3MQX" # ServerAzureCor, Windows Server 2016 RTM ServerAzureCor Volume:GVLK
    3839 = "WNCYY-GFBH2-M4WTT-XQ2FP-PG2K9" # ServerAzureCor, Windows Server 2016 RTM ServerAzureCor Volume:GVLK
    3840 = "9PN47-646K8-68TVY-FPC8J-PKDHM" # ServerAzureCor, Windows Server 2016 RTM ServerAzureCor VT:IA
    3841 = "WH32N-PKDPK-FW7FB-GR8G4-MWTBC" # ServerDatacenterCor, Windows Server 2016 RTM ServerDatacenterCor Retail
    3842 = "8K9YK-NH86G-JR79G-8HX2P-9QCMD" # ServerDatacenterEvalCor, Windows Server 2016 RTM ServerDatacenterEvalCor Retail:TB:Eval
    3842 = "N8VXH-BP89R-DPWDK-HBMHM-X4T7Q" # ServerDatacenterEvalCor, Windows Server 2016 RTM ServerDatacenterEvalCor Retail:TB:Eval
    3843 = "CTB8X-F3NDH-KWF36-KF87X-7XPMF" # ServerStandardCor, Windows Server 2016 RTM ServerStandardCor Retail
    3844 = "3R2MY-N4RK2-DJFQV-XHF8P-BTFD6" # ServerStandardEvalCor, Windows Server 2016 RTM ServerStandardEvalCor Retail:TB:Eval
    3844 = "DH6TD-NRQK6-7JGDD-MD3JD-B99VT" # ServerStandardEvalCor, Windows Server 2016 RTM ServerStandardEvalCor Retail:TB:Eval
    3854 = "7CDNR-2XWJ3-FFK9H-YC8D7-FJTBW" # EnterpriseG, Win 10 RTM EnterpriseG OEM:DM
    3854 = "7TVXR-N8YTY-WWY2G-CX96R-9W4FJ" # EnterpriseG, Win 10 RTM EnterpriseG OEM:DM
    3854 = "GY7H2-PND3J-RDVPM-3WG74-2KDH8" # EnterpriseG, Win 10 RTM EnterpriseG OEM:DM
    3854 = "NGKG3-4JWK4-JRHMT-BDB2P-KW4FJ" # EnterpriseG, Win 10 RTM EnterpriseG OEM:DM
    3855 = "FV469-WGNG4-YQP66-2B2HY-KD8YX" # EnterpriseG, Win 10 RTM EnterpriseG OEM:NONSLP
    3855 = "M4FNP-HBDXD-WWP3B-DM2B3-KKYRK" # EnterpriseG, Win 10 RTM EnterpriseG OEM:NONSLP
    3855 = "N6738-PV7HR-YRW62-6QQ6P-W2RFK" # EnterpriseG, Win 10 RTM EnterpriseG OEM:NONSLP
    3855 = "N7XX3-MK2WP-J74DP-4MJK2-BTFFK" # EnterpriseG, Win 10 RTM EnterpriseG OEM:NONSLP
    3856 = "M9P2N-Y3YX6-4VXTK-MCT93-C38YY" # EnterpriseG, Win 10 RTM EnterpriseG Volume:GVLK
    3856 = "YYVX9-NTFWV-6MDM3-9PT4T-4M68B" # EnterpriseG, Win 10 RTM EnterpriseG Volume:GVLK
    3857 = "2NKDB-KJM3F-Y6KYT-CRC9F-WFH4P" # EnterpriseG, Win 10 RTM EnterpriseG Volume:MAK
    3857 = "C4NTJ-CX6Q2-VXDMR-XVKGM-F9DJC" # EnterpriseG, Win 10 RTM EnterpriseG Volume:MAK
    3857 = "F3D28-2NW8J-KXMG3-4XK3H-G6QJC" # EnterpriseG, Win 10 RTM EnterpriseG Volume:MAK
    3857 = "FNW8H-JCWQD-CJM8H-BR4F3-RJTB2" # EnterpriseG, Win 10 RTM EnterpriseG Volume:MAK
    3857 = "KNVVP-6PX6M-W9FDR-TQ496-9KYRP" # EnterpriseG, Win 10 RTM EnterpriseG Volume:MAK
    3857 = "N73CM-2VTCR-XFD8X-XCMBB-FGFFP" # EnterpriseG, Win 10 RTM EnterpriseG Volume:MAK
    3857 = "N9DYC-JVYJC-6R76G-Q6RP7-9BV4P" # EnterpriseG, Win 10 RTM EnterpriseG Volume:MAK
    3857 = "NKDHV-XJXBT-GMPRK-CC7BV-B7WY2" # EnterpriseG, Win 10 RTM EnterpriseG Volume:MAK
    3857 = "NVFT8-DCMQY-CT6RF-3BDHP-GQ8Y2" # EnterpriseG, Win 10 RTM EnterpriseG Volume:MAK
    3857 = "R8XF6-NJRHB-3Q4W8-WY92W-K2GB2" # EnterpriseG, Win 10 RTM EnterpriseG Volume:MAK
    3857 = "T9NFT-HQJ3J-YXFJ8-977DX-WT2M2" # EnterpriseG, Win 10 RTM EnterpriseG Volume:MAK
    3858 = "83XNG-JQFK8-KB3XG-PR3BP-HH74Q" # EnterpriseG;EnterpriseGN, Win 10 RTM EnterpriseG;EnterpriseGN Volume:CSVLK
    3858 = "G7KPD-PNC9B-C9C72-D7QXH-GCRFQ" # EnterpriseG;EnterpriseGN, Win 10 RTM EnterpriseG;EnterpriseGN Volume:CSVLK
    3859 = "B228C-4HNV4-KXB9T-Q62MF-KBV4R" # EnterpriseGN, Win 10 RTM EnterpriseGN OEM:DM
    3859 = "HBTND-PFQQ2-6G8VD-CV9XC-MP3JF" # EnterpriseGN, Win 10 RTM EnterpriseGN OEM:DM
    3859 = "RTKX8-9DNPD-3K8C9-FRDWW-QDCM4" # EnterpriseGN, Win 10 RTM EnterpriseGN OEM:DM
    3859 = "XXRW6-8QNPQ-M8MKC-DFBXG-XQCM4" # EnterpriseGN, Win 10 RTM EnterpriseGN OEM:DM
    3860 = "6XTN2-V4VBD-F6TCV-G6KKH-462M6" # EnterpriseGN, Win 10 RTM EnterpriseGN OEM:NONSLP
    3860 = "FW7NV-4T673-HF4VX-9X4MM-B4H4T" # EnterpriseGN, Win 10 RTM EnterpriseGN OEM:NONSLP
    3860 = "GVBQH-GN6BK-W9C7F-CV86D-DV74T" # EnterpriseGN, Win 10 RTM EnterpriseGN OEM:NONSLP
    3860 = "PNJTQ-7MFX9-CVF69-2BJCP-KW4FT" # EnterpriseGN, Win 10 RTM EnterpriseGN OEM:NONSLP
    3861 = "44RPN-FTY23-9VTTB-MP9BX-T84FV" # EnterpriseGN, Win 10 RTM EnterpriseGN Volume:GVLK
    3861 = "93PP7-NJXDM-TPQWM-YJV39-TF6B7" # EnterpriseGN, Win 10 RTM EnterpriseGN Volume:GVLK
    3862 = "46PN6-R9BK9-CVHKB-HWQ9V-MBJY8" # EnterpriseGN, Win 10 RTM EnterpriseGN Volume:MAK
    3862 = "7NFK4-8GG72-XH3G6-XC7TF-KBV4W" # EnterpriseGN, Win 10 RTM EnterpriseGN Volume:MAK
    3862 = "BTP36-XN8H8-DHX8Q-M3TYJ-9TQJJ" # EnterpriseGN, Win 10 RTM EnterpriseGN Volume:MAK
    3862 = "HKN62-QMXYP-F982Y-KB9Q8-GVKWJ" # EnterpriseGN, Win 10 RTM EnterpriseGN Volume:MAK
    3862 = "HNRBK-QTGCQ-TXR6R-7R9YJ-2G2M8" # EnterpriseGN, Win 10 RTM EnterpriseGN Volume:MAK
    3862 = "K98BW-7NY2F-XRKVV-VKW8J-33XWJ" # EnterpriseGN, Win 10 RTM EnterpriseGN Volume:MAK
    3862 = "MNCHX-GXHFC-22943-MRRRC-MP3JJ" # EnterpriseGN, Win 10 RTM EnterpriseGN Volume:MAK
    3862 = "MVRWT-69NTQ-GVC6B-H6Q23-JT2M8" # EnterpriseGN, Win 10 RTM EnterpriseGN Volume:MAK
    3862 = "W2VFP-NKXJB-3WVJP-4PKQK-QV74W" # EnterpriseGN, Win 10 RTM EnterpriseGN Volume:MAK
    3862 = "XR4ND-QXFBP-3GHF8-YFPYH-FJTB8" # EnterpriseGN, Win 10 RTM EnterpriseGN Volume:MAK
    3862 = "Y9YDN-7XCQV-WQVR6-FBHX7-3J4FW" # EnterpriseGN, Win 10 RTM EnterpriseGN Volume:MAK
    3863 = "634TH-NPJD4-J9YXR-8HMBY-6VKWK" # Cloud, Win 10 RTM Cloud OEM:DM
    3863 = "6V3WN-22J72-T379B-BHRKM-2PRFX" # Cloud, Win 10 RTM Cloud OEM:DM
    3863 = "CCK3N-T3T9P-XBTGX-79Q4H-9BV4X" # Cloud, Win 10 RTM Cloud OEM:DM
    3863 = "DRK49-VRNHF-7D8X2-B4B29-8QMRX" # Cloud, Win 10 RTM Cloud OEM:DM
    3863 = "GP77R-HNYT9-WHVBY-2K8W9-3RT8K" # Cloud, Win 10 RTM Cloud OEM:DM
    3863 = "HKHTJ-XNVJF-336GC-BHRPR-KBV4X" # Cloud, Win 10 RTM Cloud OEM:DM
    3863 = "HQ6CN-F8DT8-9MJ73-D2YYH-4C3JK" # Cloud, Win 10 RTM Cloud OEM:DM
    3863 = "JDNDQ-R6R4R-QGKP4-GT2GJ-Q7BRX" # Cloud, Win 10 RTM Cloud OEM:DM
    3863 = "N2MW7-767B3-Y494G-XXYD2-KW4FX" # Cloud, Win 10 RTM Cloud OEM:DM
    3863 = "N3M8J-W6GXC-4PF3R-X9BWF-HQXWK" # Cloud, Win 10 RTM Cloud OEM:DM
    3863 = "N848K-PMHMB-8Y8MB-JYW4B-YWTB9" # Cloud, Win 10 RTM Cloud OEM:DM
    3863 = "N8MR9-6HGKR-X3932-Q8DBX-JXDJK" # Cloud, Win 10 RTM Cloud OEM:DM
    3863 = "P3N4J-4Q2PV-RTV73-MKT9H-KHKWK" # Cloud, Win 10 RTM Cloud OEM:DM
    3863 = "PQTHT-N92VC-XCXTP-64BCF-PPRFX" # Cloud, Win 10 RTM Cloud OEM:DM
    3863 = "QN6PB-CVDPC-6RY9J-9PJJV-R9DJK" # Cloud, Win 10 RTM Cloud OEM:DM
    3863 = "TN9CV-MMTTR-CYM8Q-Q6DD8-CPRFX" # Cloud, Win 10 RTM Cloud OEM:DM
    3863 = "V82H3-XNDW4-M37HD-GK33J-33XWK" # Cloud, Win 10 RTM Cloud OEM:DM
    3864 = "8WPQN-FKKJC-86DJ7-V4CRV-WK9WM" # Cloud, Win 10 RTM Cloud OEM:NONSLP
    3864 = "KNHXK-DJ3BR-KQJT8-8YBMQ-JT2PB" # Cloud, Win 10 RTM Cloud OEM:NONSLP
    3865 = "CTD7B-PNC93-M7GYX-RWYK8-F3MR2" # Cloud, Win 10 RTM Cloud Retail
    3865 = "P3BR3-NM7TX-H78WY-JJFQ7-4C3JP" # Cloud, Win 10 RTM Cloud Retail
    3865 = "V3WVW-N2PV2-CGWC3-34QGF-VMJ2C" # Cloud, Win 10 RTM Cloud Retail
    3866 = "28N6Q-QMDHC-G76YJ-J36PM-PR6CD" # CloudN, Win 10 RTM CloudN OEM:DM
    3866 = "299NG-79KK4-FVVXT-Y7JCX-TF6CD" # CloudN, Win 10 RTM CloudN OEM:DM
    3866 = "2V2N6-686V6-DBYTT-7QKJB-CWG8Q" # CloudN, Win 10 RTM CloudN OEM:DM
    3866 = "3NWDB-X4RTX-H6WCF-C68MH-T3CPD" # CloudN, Win 10 RTM CloudN OEM:DM
    3866 = "B8CCB-M2NFM-G8TKG-DVXGC-2DMR3" # CloudN, Win 10 RTM CloudN OEM:DM
    3866 = "BM4WN-9GYXY-2YMF8-Q39GC-2DMR3" # CloudN, Win 10 RTM CloudN OEM:DM
    3866 = "BVFBN-7MRGR-W6GRY-D322D-C382D" # CloudN, Win 10 RTM CloudN OEM:DM
    3866 = "DN88H-X2GFV-6W6Y4-QR3G8-TQ82D" # CloudN, Win 10 RTM CloudN OEM:DM
    3866 = "JRKVY-6N2WP-8WRM6-2FFWD-9D82D" # CloudN, Win 10 RTM CloudN OEM:DM
    3866 = "NJC7X-3XC6D-F366F-TVRQG-FVW2D" # CloudN, Win 10 RTM CloudN OEM:DM
    3866 = "NJJPY-D7WMG-37JDJ-29JHY-QJ4F3" # CloudN, Win 10 RTM CloudN OEM:DM
    3866 = "NVKWM-FMCMX-TBRTR-J4V8C-D7BR3" # CloudN, Win 10 RTM CloudN OEM:DM
    3866 = "NXP64-M67TB-TB2C9-73Q3J-33XWQ" # CloudN, Win 10 RTM CloudN OEM:DM
    3866 = "PRN7C-J2VRV-J39YF-X2QWF-3DCPD" # CloudN, Win 10 RTM CloudN OEM:DM
    3866 = "QNPPQ-P6VBQ-WFV6G-7PVRM-CWG8Q" # CloudN, Win 10 RTM CloudN OEM:DM
    3866 = "RHP9X-FMNBV-F48DM-2MGDY-JK9WQ" # CloudN, Win 10 RTM CloudN OEM:DM
    3866 = "YNQJJ-6GV47-HWGMX-6GCRR-HQXWQ" # CloudN, Win 10 RTM CloudN OEM:DM
    3867 = "787HP-KNG82-WVFX8-CMXMB-TXYR4" # CloudN, Win 10 RTM CloudN OEM:NONSLP
    3867 = "TNK8W-QK4JY-VMCRT-8HJMY-K7744" # CloudN, Win 10 RTM CloudN OEM:NONSLP
    3868 = "3YBVN-4PK93-RVGY8-Y292M-X4T8T" # CloudN, Win 10 RTM CloudN Retail
    3868 = "NH9J3-68WK7-6FB93-4K3DF-DJ4F6" # CloudN, Win 10 RTM CloudN Retail
    3868 = "PG6NM-3W3D2-WG2FR-VHB6R-Q9PPG" # CloudN, Win 10 RTM CloudN Retail
    3892 = "N8FHW-G2P4G-DYVDY-BYHVQ-XHKXT" # ServerRdsh, Windows Server Next Beta ServerRdsh Retail
    3892 = "NJCF7-PW8QT-3324D-688JX-2YV66" # ServerRdsh, Windows Server Next Beta ServerRdsh Retail
    3893 = "DKNFQ-2YGFM-83D78-CJWXM-G3CQH" # ServerRdsh, Windows Server Next Beta ServerRdsh OEM:NONSLP
    3894 = "R33WN-HYW7C-96YWC-G8YQG-P7KXW" # ServerRdsh, Windows Server Next Beta ServerRdsh OEM:SLP
    3895 = "2NCTC-KX62G-72P7B-G7QYW-29YT9" # ServerRdsh, Windows Server Next Beta ServerRdsh Volume:GVLK
    3895 = "7NBT4-WGBQX-MP4H7-QXFF8-YP3KX" # ServerRdsh, Windows Server Next Beta ServerRdsh Volume:GVLK
    3896 = "NFPXB-HRPHT-998P2-WHK3P-FX9XY" # ServerRdsh, Windows Server Next Beta ServerRdsh Volume:MAK
    3909 = "3DQNH-TPH93-467TD-PTBDQ-9777V" # ServerDatacenter, Windows Server 2016 RTM ServerDatacenter OEM:DM
    3909 = "FNWD7-34F3W-43VK6-RGXTW-DGQMH" # ServerDatacenter, Windows Server 2016 RTM ServerDatacenter OEM:DM
    3909 = "KNRCD-QWGTG-6BWYR-D7KGY-RC3MH" # ServerDatacenter, Windows Server 2016 RTM ServerDatacenter OEM:DM
    3909 = "YN8VP-DRQR7-G3G4C-9HXPY-43MVV" # ServerDatacenter, Windows Server 2016 RTM ServerDatacenter OEM:DM
    3910 = "BD2NF-WW7YG-7DX3C-BYBRW-D9PQ8" # ServerStandard, Windows Server 2016 RTM ServerStandard OEM:DM
    3910 = "BJ8N2-QPC4B-TD64F-3DRTV-B7W38" # ServerStandard, Windows Server 2016 RTM ServerStandard OEM:DM
    3910 = "M6XX2-6VN9V-WF74C-HP6M2-XTQMJ" # ServerStandard, Windows Server 2016 RTM ServerStandard OEM:DM
    3910 = "YGRJJ-GNCKC-2VTQY-BW9WJ-PKDMJ" # ServerStandard, Windows Server 2016 RTM ServerStandard OEM:DM
    3913 = "233HW-86NW4-VMJJ9-B8XKR-7H772" # Cloud, Win 10 RTM Cloud Volume:MAK
    3913 = "2DFGW-NR8XY-7DQWQ-RGH43-MDXYP" # Cloud, Win 10 RTM Cloud Volume:MAK
    3913 = "2TXF2-MN3GX-XRYT9-CPQ3B-RC3MP" # Cloud, Win 10 RTM Cloud Volume:MAK
    3913 = "4N6MV-92FPX-DXRHY-YMV3Q-2WHBP" # Cloud, Win 10 RTM Cloud Volume:MAK
    3913 = "6J7N4-F4YFK-WRGB7-Y3PKG-H8TFC" # Cloud, Win 10 RTM Cloud Volume:MAK
    3913 = "7W8C3-N9B89-777GC-GWXMV-GCRH2" # Cloud, Win 10 RTM Cloud Volume:MAK
    3913 = "8N6XF-CTX9K-DG2C8-BB498-BWTFC" # Cloud, Win 10 RTM Cloud Volume:MAK
    3913 = "DMPHB-XNRC4-36Q4D-CM22J-J8HBP" # Cloud, Win 10 RTM Cloud Volume:MAK
    3913 = "FWX7X-FNQTM-F686R-PDMJ8-Q7BV2" # Cloud, Win 10 RTM Cloud Volume:MAK
    3913 = "J9WNQ-R9THF-FBY32-VCW7P-V8TFC" # Cloud, Win 10 RTM Cloud Volume:MAK
    3913 = "XGKGP-N78KM-2XWJ4-MRYBW-29YV2" # Cloud, Win 10 RTM Cloud Volume:MAK
    3913 = "YBNDV-XRWYD-PTK7X-4WVB2-PG2RC" # Cloud, Win 10 RTM Cloud Volume:MAK
    3914 = "69TDT-MNK98-CV3YP-KMY7W-K2GFD" # CloudN, Win 10 RTM CloudN Volume:MAK
    3914 = "8QPJQ-2NHM6-6VQTX-THMP4-9W4H3" # CloudN, Win 10 RTM CloudN Volume:MAK
    3914 = "98JN4-9G7FR-VVF6V-9FTPT-WXDMQ" # CloudN, Win 10 RTM CloudN Volume:MAK
    3914 = "9KNMQ-JMBV8-Q92VM-THWQ6-2384D" # CloudN, Win 10 RTM CloudN Volume:MAK
    3914 = "FBNFW-J88GY-V49P4-DXVBJ-WB7BQ" # CloudN, Win 10 RTM CloudN Volume:MAK
    3914 = "HTDKJ-TJN93-Q2447-8TJYR-6Q84D" # CloudN, Win 10 RTM CloudN Volume:MAK
    3914 = "N6JWW-KCR8F-4PK3W-2FD3R-JHW4D" # CloudN, Win 10 RTM CloudN Volume:MAK
    3914 = "NJTQV-CV78Y-W9G39-QG2D8-K2GFD" # CloudN, Win 10 RTM CloudN Volume:MAK
    3914 = "NKWDF-979XD-X7WBJ-DKXD6-HFVBQ" # CloudN, Win 10 RTM CloudN Volume:MAK
    3914 = "Q8JDN-GJKBG-2PRJJ-7P9FD-T6QMQ" # CloudN, Win 10 RTM CloudN Volume:MAK
    3914 = "XJ4BP-97N94-YTXD6-8GY46-GMV73" # CloudN, Win 10 RTM CloudN Volume:MAK
    3915 = "44VVN-KQQGY-2FR3C-XFFC4-9W4H4" # ProfessionalWorkstation, Win 10 RTM ProfessionalWorkstation OEM:DM
    3915 = "NTGMV-YWGFF-8R6R6-QB63X-2YV74" # ProfessionalWorkstation, Win 10 RTM ProfessionalWorkstation OEM:DM
    3915 = "TGMNB-2M6M7-39WWG-MT7JH-6XYV4" # ProfessionalWorkstation, Win 10 RTM ProfessionalWorkstation OEM:DM
    3915 = "V293R-HN3JK-D69PJ-4D2J7-8HW4F" # ProfessionalWorkstation, Win 10 RTM ProfessionalWorkstation OEM:DM
    3916 = "4NDDF-WMDXJ-C32YC-FJ7JC-76FH6" # ProfessionalWorkstation, Win 10 RTM ProfessionalWorkstation OEM:NONSLP
    3916 = "F8KCB-XNVH7-XJXH8-R782J-VH776" # ProfessionalWorkstation, Win 10 RTM ProfessionalWorkstation OEM:NONSLP
    3916 = "NX2BK-Y2GR2-XP7XQ-WFJPG-Y99YT" # ProfessionalWorkstation, Win 10 RTM ProfessionalWorkstation OEM:NONSLP
    3917 = "DXG7C-N36C4-C4HTG-X4T3X-2YV77" # ProfessionalWorkstation, Win 10 RTM ProfessionalWorkstation Retail
    3917 = "K9928-3NCFM-MV936-H8JWJ-JFH77" # ProfessionalWorkstation, Win 10 RTM ProfessionalWorkstation Retail
    3917 = "VN3YP-Y4PXW-WXM8K-YT9CD-C384H" # ProfessionalWorkstation, Win 10 RTM ProfessionalWorkstation Retail
    3917 = "WG9KW-BN636-QYD9H-GMM3B-G3CRH" # ProfessionalWorkstation, Win 10 RTM ProfessionalWorkstation Retail
    3918 = "NRG8B-VKK3Q-CXVCJ-9G2XF-6Q84J" # ProfessionalWorkstation, Win 10 RTM ProfessionalWorkstation Volume:GVLK
    3918 = "XNQ6Q-JMCQ9-JG299-3T7VJ-QDCRJ" # ProfessionalWorkstation, Win 10 RTM ProfessionalWorkstation Volume:GVLK
    3919 = "3GR3N-MTFRB-9GJ7M-MJ2BV-9BV79" # ProfessionalWorkstation, Win 10 RTM ProfessionalWorkstation Volume:MAK
    3919 = "3JNTK-VHBYK-6PMWK-VFWW2-V8TFK" # ProfessionalWorkstation, Win 10 RTM ProfessionalWorkstation Volume:MAK
    3919 = "3N66Q-GFMWG-98BD3-M36CW-9TQMX" # ProfessionalWorkstation, Win 10 RTM ProfessionalWorkstation Volume:MAK
    3919 = "7T9NV-W7MXB-WJB83-RBQCJ-BWTFK" # ProfessionalWorkstation, Win 10 RTM ProfessionalWorkstation Volume:MAK
    3919 = "BMNYP-GKTD4-PPFJB-CYK6V-462RK" # ProfessionalWorkstation, Win 10 RTM ProfessionalWorkstation Volume:MAK
    3919 = "C9GCN-GP33R-D34V9-M79TW-DGQMX" # ProfessionalWorkstation, Win 10 RTM ProfessionalWorkstation Volume:MAK
    3919 = "CHVC6-6NJD7-DF3R7-GV8HM-BBJ4K" # ProfessionalWorkstation, Win 10 RTM ProfessionalWorkstation Volume:MAK
    3919 = "DBGJD-HN3WP-V9VQC-4WXC7-B7W4K" # ProfessionalWorkstation, Win 10 RTM ProfessionalWorkstation Volume:MAK
    3919 = "J8PM9-JNW64-Y8F7T-TG9TJ-K2GFK" # ProfessionalWorkstation, Win 10 RTM ProfessionalWorkstation Volume:MAK
    3919 = "JCJ4B-NYGDQ-Y9MHG-XRYT7-2R6FK" # ProfessionalWorkstation, Win 10 RTM ProfessionalWorkstation Volume:MAK
    3919 = "KWG2N-RKXPK-FHHF9-QPFXM-RC3MX" # ProfessionalWorkstation, Win 10 RTM ProfessionalWorkstation Volume:MAK
    3919 = "NRH9D-RQDJM-GV2VR-42DWR-8B7BX" # ProfessionalWorkstation, Win 10 RTM ProfessionalWorkstation Volume:MAK
    3919 = "QNJWQ-KH7GC-GC7RG-RXJD7-JQMV9" # ProfessionalWorkstation, Win 10 RTM ProfessionalWorkstation Volume:MAK
    3919 = "QWKN2-3YTY9-PBQ7D-GKH9B-KD84K" # ProfessionalWorkstation, Win 10 RTM ProfessionalWorkstation Volume:MAK
    3919 = "V89G3-3WNCM-9B8T9-XYRC9-FRH79" # ProfessionalWorkstation, Win 10 RTM ProfessionalWorkstation Volume:MAK
    3919 = "VK6NF-PFH2Y-RHJQP-VRYYW-DGQMX" # ProfessionalWorkstation, Win 10 RTM ProfessionalWorkstation Volume:MAK
    3919 = "XCJDN-D6Y2W-7J79X-7P27B-DPGFK" # ProfessionalWorkstation, Win 10 RTM ProfessionalWorkstation Volume:MAK
    3920 = "24W89-MNYP4-9GFRG-WPQK6-CG2RM" # ProfessionalWorkstationN, Win 10 RTM ProfessionalWorkstationN OEM:DM
    3920 = "2GXNB-H7M3M-M3W32-H77XJ-7FVBY" # ProfessionalWorkstationN, Win 10 RTM ProfessionalWorkstationN OEM:DM
    3920 = "9VGNT-HMQQT-3PTB9-VDGRK-BKPRM" # ProfessionalWorkstationN, Win 10 RTM ProfessionalWorkstationN OEM:DM
    3920 = "MT992-NV4TV-3VPBY-T4FQJ-JFH8B" # ProfessionalWorkstationN, Win 10 RTM ProfessionalWorkstationN OEM:DM
    3921 = "Q6736-9NJ23-YKM8K-WHX2P-9QCRP" # ProfessionalWorkstationN, Win 10 RTM ProfessionalWorkstationN OEM:NONSLP
    3921 = "QYNMC-WQFWF-73V68-CG2FH-GCRJC" # ProfessionalWorkstationN, Win 10 RTM ProfessionalWorkstationN OEM:NONSLP
    3921 = "XQJXN-H6Y7K-6CJ2W-TJQ63-B99Y2" # ProfessionalWorkstationN, Win 10 RTM ProfessionalWorkstationN OEM:NONSLP
    3922 = "N7872-MMX3Y-FR3C4-6W9P2-HH78D" # ProfessionalWorkstationN, Win 10 RTM ProfessionalWorkstationN Retail
    3922 = "QHMY3-NMFJF-HYY3D-VRM3Q-2WHB3" # ProfessionalWorkstationN, Win 10 RTM ProfessionalWorkstationN Retail
    3922 = "QX6XR-WNWTF-PB4MQ-87R6B-FGFJD" # ProfessionalWorkstationN, Win 10 RTM ProfessionalWorkstationN Retail
    3922 = "WYPNQ-8C467-V2W6J-TX4WX-WT2RQ" # ProfessionalWorkstationN, Win 10 RTM ProfessionalWorkstationN Retail
    3923 = "9FNHH-K3HBT-3W4TD-6383H-6XYWF" # ProfessionalWorkstationN, Win 10 RTM ProfessionalWorkstationN Volume:GVLK
    3923 = "YXCN8-XDB97-8KDCC-DPQHB-XBV8F" # ProfessionalWorkstationN, Win 10 RTM ProfessionalWorkstationN Volume:GVLK
    3924 = "3PBTQ-9N4MQ-K6KVC-G28GJ-9TQM6" # ProfessionalWorkstationN, Win 10 RTM ProfessionalWorkstationN Volume:MAK
    3924 = "4FPCQ-NB9XF-6QR66-VF8HD-C384T" # ProfessionalWorkstationN, Win 10 RTM ProfessionalWorkstationN Volume:MAK
    3924 = "6MPNQ-BMVQQ-KK99H-J947Y-F9DM6" # ProfessionalWorkstationN, Win 10 RTM ProfessionalWorkstationN Volume:MAK
    3924 = "9JC6F-NQV39-VGD8Y-2YQRD-BHBWG" # ProfessionalWorkstationN, Win 10 RTM ProfessionalWorkstationN Volume:MAK
    3924 = "FX6NY-MGFWM-VK6TH-XPMPF-FC3M6" # ProfessionalWorkstationN, Win 10 RTM ProfessionalWorkstationN Volume:MAK
    3924 = "MF3K4-H6NGG-9QHHB-YD9R6-GMV8G" # ProfessionalWorkstationN, Win 10 RTM ProfessionalWorkstationN Volume:MAK
    3924 = "N29V6-V7GVV-HTX78-HPWDJ-XW4JG" # ProfessionalWorkstationN, Win 10 RTM ProfessionalWorkstationN Volume:MAK
    3924 = "N79J7-VMKVD-9XKD8-378K3-9778G" # ProfessionalWorkstationN, Win 10 RTM ProfessionalWorkstationN Volume:MAK
    3924 = "NHKY8-V4VGV-BT322-H2DBB-TXYWG" # ProfessionalWorkstationN, Win 10 RTM ProfessionalWorkstationN Volume:MAK
    3924 = "PRWQJ-K4NGT-8H2TM-PJXJ4-BY7B6" # ProfessionalWorkstationN, Win 10 RTM ProfessionalWorkstationN Volume:MAK
    3924 = "QNX6C-DKJMX-XDYCM-PX36T-H8TFT" # ProfessionalWorkstationN, Win 10 RTM ProfessionalWorkstationN Volume:MAK
    3924 = "QVNHR-WWCDT-72RDW-XDFV6-XQCRT" # ProfessionalWorkstationN, Win 10 RTM ProfessionalWorkstationN Volume:MAK
    3924 = "W3RKC-NC38G-WWMTD-PW6FB-YWTFT" # ProfessionalWorkstationN, Win 10 RTM ProfessionalWorkstationN Volume:MAK
    3924 = "WXHTN-3Y3RJ-BWP6P-TGBDQ-9778G" # ProfessionalWorkstationN, Win 10 RTM ProfessionalWorkstationN Volume:MAK
    3924 = "X4NPR-H8B8C-WVP34-CFY48-J8HB6" # ProfessionalWorkstationN, Win 10 RTM ProfessionalWorkstationN Volume:MAK
    3925 = "DTN2J-TRR4K-QJXC9-84QTV-462RV" # ServerStandardACor, Windows Server Next Beta ServerStandardACor Volume:MAK
    3926 = "9MNGH-VMTTV-X7XMB-26JPR-BY7B8" # ServerDatacenterACor, Windows Server Next Beta ServerDatacenterACor Volume:MAK
    3926 = "B69WH-PRNHK-BXVK3-P9XF7-XD84W" # ServerDatacenterACor, Windows Server Next Beta ServerDatacenterACor Volume:MAK
    3954 = "3VKCP-7QN23-D3GQV-MD2VH-XD863" # ProfessionalWorkstation, Win 10 Pre-Release ProfessionalWorkstation Retail
    3955 = "DPCNP-XQFKJ-BJF7R-FRC8D-GF6G4" # ServerStandardACor, Windows Server 2016 RTM ServerStandardACor Volume:GVLK
    3955 = "PTXN8-JFHJM-4WC78-MPCBR-9W4KR" # ServerStandardACor, Windows Server 2016 RTM ServerStandardACor Volume:GVLK
    3956 = "2HXDN-KRXHB-GPYC7-YCKFJ-7FVDG" # ServerDatacenterACor, Windows Server 2016 RTM ServerDatacenterACor Volume:GVLK
    3956 = "6Y6KB-N82V8-D8CQV-23MJW-BWTG6" # ServerDatacenterACor, Windows Server 2016 RTM ServerDatacenterACor Volume:GVLK
    3958 = "WNX64-WCH29-TMD2M-6RXGH-8HW68" # ServerStandardACor, Windows Server 2016 RTM ServerStandardACor Retail
    3959 = "VFNKW-XR3VK-9XQFX-X42YX-T84KX" # ServerDatacenterACor, Windows Server 2016 RTM ServerDatacenterACor Retail
    3960 = "F48RT-4N2GM-PF2TY-M6P96-V6FKY" # ServerStandardACor, Windows Server 2016 RTM ServerStandardACor Volume:MAK
    3960 = "HBN24-K6P86-QYQW2-DMDM7-MBJ7B" # ServerStandardACor, Windows Server 2016 RTM ServerStandardACor Volume:MAK
    3961 = "6NVRT-2GGHR-8GWFM-2Q27X-7XPVC" # ServerDatacenterACor, Windows Server 2016 RTM ServerDatacenterACor Volume:MAK
    3961 = "TBNPG-9V7CG-WR7C2-PT84R-HQX3P" # ServerDatacenterACor, Windows Server 2016 RTM ServerDatacenterACor Volume:MAK
    3979 = "C9PDN-TR2KB-MR4DF-3RQ7Y-88HFF" # Andromeda, Win 10 RTM Andromeda Retail
    3987 = "DVF29-DNY2R-XYQ2X-33FB6-4M7FR" # ServerARM64, Windows Server 2016 RTM ServerARM64 Volume:GVLK
    3987 = "K9FYF-G6NCK-73M32-XMVPY-F9DRR" # ServerARM64, Windows Server 2016 RTM ServerARM64 Volume:GVLK
    3988 = "NFDPX-3MV8X-THC2X-QQ9QP-P9YY6" # OneCoreUpdateOS, Win 10 RTM OneCoreUpdateOS Retail
    4232 = "K8TTN-69HY3-4M9R6-MRTTM-B4JRB" # CloudE, Win 10 RTM CloudE OEM:DM
    4234 = "2HN6V-HGTM8-6C97C-RK67V-JQPFD" # CloudE, Win 10 RTM CloudE Retail
    4244 = "NBTWJ-3DR69-3C4V8-C26MC-GQ9M6" # CloudE, Win 10 RTM CloudE Volume:GVLK
    4247 = "3QP4N-RC9JQ-XD9MD-7Q647-HXQB9" # EnterpriseS, Win 10 RTM EnterpriseS OEM:DM
    4247 = "6BY82-GNQ24-DMTP3-X9VQD-VXQB9" # EnterpriseS, Win 10 RTM EnterpriseS OEM:DM
    4247 = "JM4W4-RWN73-F367K-2YB8R-X2GY9" # EnterpriseS, Win 10 RTM EnterpriseS OEM:DM
    4247 = "RDN2C-39Y4C-RRFJB-YYPHH-XD9M9" # EnterpriseS, Win 10 RTM EnterpriseS OEM:DM
    4248 = "43TBQ-NH92J-XKTM7-KT3KK-P39PB" # EnterpriseS, Win 10 RTM EnterpriseS OEM:NONSLP
    4248 = "CFFNG-VMMJQ-VMKKQ-24RPX-TF62B" # EnterpriseS, Win 10 RTM EnterpriseS OEM:NONSLP
    4248 = "N2R73-C6TFF-VC8KP-8C2TY-2PR4Y" # EnterpriseS, Win 10 RTM EnterpriseS OEM:NONSLP
    4248 = "NB9QB-R69WQ-KPRQF-G87C8-W462B" # EnterpriseS, Win 10 RTM EnterpriseS OEM:NONSLP
    4248 = "PN44P-9W8RR-T3FVH-2J6PY-43PFY" # EnterpriseS, Win 10 RTM EnterpriseS OEM:NONSLP
    4248 = "QW889-26N3M-P2X9V-2RH7Y-YWT2B" # EnterpriseS, Win 10 RTM EnterpriseS OEM:NONSLP
    4248 = "RGTRV-HPNJ2-2CXMW-7FM8C-D7CFY" # EnterpriseS, Win 10 RTM EnterpriseS OEM:NONSLP
    4248 = "RKW9C-8NW8G-R4K3M-R664B-F9D8M" # EnterpriseS, Win 10 RTM EnterpriseS OEM:NONSLP
    4248 = "VH6KN-F9GXT-4B4DF-WG67G-6F62B" # EnterpriseS, Win 10 RTM EnterpriseS OEM:NONSLP
    4249 = "2H6HF-GNKW2-JB93P-BK6XC-W2R42" # EnterpriseS, Win 10 RTM EnterpriseS Volume:MAK
    4249 = "78CNT-C9JMM-K2WCJ-PJKXF-GX2F2" # EnterpriseS, Win 10 RTM EnterpriseS Volume:MAK
    4249 = "BCN6M-7KMX4-FDP6K-6BF4F-GX2F2" # EnterpriseS, Win 10 RTM EnterpriseS Volume:MAK
    4249 = "BN2C4-QQJD9-TG443-V3M7Y-QJ442" # EnterpriseS, Win 10 RTM EnterpriseS Volume:MAK
    4249 = "BXXKM-NGYKB-J3BHC-2MJ8D-QRVWP" # EnterpriseS, Win 10 RTM EnterpriseS Volume:MAK
    4249 = "DNCTQ-PJ8RY-99WYF-TDTY4-W8HWP" # EnterpriseS, Win 10 RTM EnterpriseS Volume:MAK
    4249 = "FD944-NBF4J-4DWHK-QQY3D-CBBJP" # EnterpriseS, Win 10 RTM EnterpriseS Volume:MAK
    4249 = "FJQP3-N2M94-M6DMT-J647K-WT3CC" # EnterpriseS, Win 10 RTM EnterpriseS Volume:MAK
    4249 = "GGR2P-Y9NDD-K8WGP-FCTBP-W2R42" # EnterpriseS, Win 10 RTM EnterpriseS Volume:MAK
    4249 = "GN6FF-PBWTQ-PQ73B-7B98T-GMWR2" # EnterpriseS, Win 10 RTM EnterpriseS Volume:MAK
    4249 = "JGP36-HCNXR-RG9F9-BYHGK-TF62C" # EnterpriseS, Win 10 RTM EnterpriseS Volume:MAK
    4249 = "JKC4X-CBNY2-Y9BGF-4PRTW-W462C" # EnterpriseS, Win 10 RTM EnterpriseS Volume:MAK
    4249 = "KCT8Y-N444Q-XTCGD-X99CG-GMWR2" # EnterpriseS, Win 10 RTM EnterpriseS Volume:MAK
    4249 = "KDGFF-N69CJ-DH4F3-JKQ26-H8T2C" # EnterpriseS, Win 10 RTM EnterpriseS Volume:MAK
    4249 = "KKYWJ-2NK8Q-BXBKM-Q886G-HFVWP" # EnterpriseS, Win 10 RTM EnterpriseS Volume:MAK
    4249 = "N7JY7-R7WX2-8FX4J-YVP4G-XQDCC" # EnterpriseS, Win 10 RTM EnterpriseS Volume:MAK
    4249 = "N8DYR-QG3CT-KKJYV-4R7VT-68442" # EnterpriseS, Win 10 RTM EnterpriseS Volume:MAK
    4249 = "N9M2Y-DFCFT-FHP3C-486W4-F63CC" # EnterpriseS, Win 10 RTM EnterpriseS Volume:MAK
    4249 = "NM762-99XWX-K47DD-H3668-XW442" # EnterpriseS, Win 10 RTM EnterpriseS Volume:MAK
    4249 = "NMB2K-JTQB7-B7GFY-8TXGT-H8T2C" # EnterpriseS, Win 10 RTM EnterpriseS Volume:MAK
    4249 = "P9NHK-M44VD-96RBX-DGX2F-X2G2C" # EnterpriseS, Win 10 RTM EnterpriseS Volume:MAK
    4249 = "RNQRB-3BXF7-X782H-4H4HM-JMBJP" # EnterpriseS, Win 10 RTM EnterpriseS Volume:MAK
    4249 = "VBX36-N7DDY-M9H62-83BMJ-CPR42" # EnterpriseS, Win 10 RTM EnterpriseS Volume:MAK
    4249 = "WF32N-224KM-4CK7R-PRPCJ-82R42" # EnterpriseS, Win 10 RTM EnterpriseS Volume:MAK
    4249 = "WNXY8-KV4JY-6QYBW-TMWCD-63DCC" # EnterpriseS, Win 10 RTM EnterpriseS Volume:MAK
    4250 = "M7XTQ-FN8P6-TTKYV-9D4CC-J462D" # EnterpriseS, Win 10 RTM EnterpriseS Volume:GVLK
    4250 = "PG7H6-7RNT3-R4MGR-HMJK2-J462D" # EnterpriseS, Win 10 RTM EnterpriseS Volume:GVLK
    4251 = "N37VK-3DQBV-KGKPC-WYDHP-GQ9PF" # EnterpriseSEval, Win 10 RTM EnterpriseSEval Retail:TB:Eval
    4251 = "N7HMH-MK36Q-M4X93-76KQ2-6JHWR" # EnterpriseSEval, Win 10 RTM EnterpriseSEval Retail:TB:Eval
    4252 = "2FNQG-3WH7P-QJXMT-7YPJX-MHCF6" # EnterpriseSN, Win 10 RTM EnterpriseSN Volume:MAK
    4252 = "2N694-4XJDK-MGDCF-3V623-YBKPG" # EnterpriseSN, Win 10 RTM EnterpriseSN Volume:MAK
    4252 = "3NJKG-28PB8-XMC64-QHMX2-FYBJT" # EnterpriseSN, Win 10 RTM EnterpriseSN Volume:MAK
    4252 = "42HRM-9NF7J-8QV86-KR3XH-B7XPG" # EnterpriseSN, Win 10 RTM EnterpriseSN Volume:MAK
    4252 = "4N96H-6GK4Q-Y6CFF-7XMTD-7VCF6" # EnterpriseSN, Win 10 RTM EnterpriseSN Volume:MAK
    4252 = "7YFMF-NHXBD-4HD26-GW2TQ-T6Q8T" # EnterpriseSN, Win 10 RTM EnterpriseSN Volume:MAK
    4252 = "8PYNV-8RJ8R-7K93C-RGPJX-RM7WT" # EnterpriseSN, Win 10 RTM EnterpriseSN Volume:MAK
    4252 = "9GG6K-VNMDP-DXDHT-MJCY8-JFJR6" # EnterpriseSN, Win 10 RTM EnterpriseSN Volume:MAK
    4252 = "CDD8N-7MBXW-7XFH9-R388M-7MKPG" # EnterpriseSN, Win 10 RTM EnterpriseSN Volume:MAK
    4252 = "CKCFC-NMDR2-QG2XC-QWFCV-4C38T" # EnterpriseSN, Win 10 RTM EnterpriseSN Volume:MAK
    4252 = "GM227-FNBQ9-9CWGV-7GYY8-33YJT" # EnterpriseSN, Win 10 RTM EnterpriseSN Volume:MAK
    4252 = "HRN83-JPXFJ-84J9B-4XJP4-Q9QCG" # EnterpriseSN, Win 10 RTM EnterpriseSN Volume:MAK
    4252 = "JWFPN-GFH6H-6D3HH-DGDTP-W2R46" # EnterpriseSN, Win 10 RTM EnterpriseSN Volume:MAK
    4252 = "KBJNW-C3PCT-9D7MX-R949M-RC38T" # EnterpriseSN, Win 10 RTM EnterpriseSN Volume:MAK
    4252 = "M33WV-NHY3C-R7FPM-BQGPT-239PG" # EnterpriseSN, Win 10 RTM EnterpriseSN Volume:MAK
    4252 = "N2WHR-HQJ72-WX9PY-62G3P-P92F6" # EnterpriseSN, Win 10 RTM EnterpriseSN Volume:MAK
    4252 = "NBD82-BBRYC-P7XDD-G6844-37CF6" # EnterpriseSN, Win 10 RTM EnterpriseSN Volume:MAK
    4252 = "P4Q9B-KN4TJ-W464W-67F2D-2WHWT" # EnterpriseSN, Win 10 RTM EnterpriseSN Volume:MAK
    4252 = "PWDHN-MX39J-9HW2X-XHHFD-BHCF6" # EnterpriseSN, Win 10 RTM EnterpriseSN Volume:MAK
    4252 = "QKN2D-TFQD7-9Q469-RBMGX-4JT2G" # EnterpriseSN, Win 10 RTM EnterpriseSN Volume:MAK
    4252 = "QYN4C-H2QP3-TF69T-FVY2F-FC38T" # EnterpriseSN, Win 10 RTM EnterpriseSN Volume:MAK
    4252 = "R6VGT-8N4QF-CH23Y-D2F22-RVXPG" # EnterpriseSN, Win 10 RTM EnterpriseSN Volume:MAK
    4252 = "XK7N6-RKB6X-MM7WD-XMXCB-DPG2G" # EnterpriseSN, Win 10 RTM EnterpriseSN Volume:MAK
    4253 = "2D7NQ-3MDXF-9WTDT-X9CCP-CKD8V" # EnterpriseSN, Win 10 RTM EnterpriseSN Volume:GVLK
    4253 = "92NFX-8DJQP-P6BBQ-THF9C-7CG2H" # EnterpriseSN, Win 10 RTM EnterpriseSN Volume:GVLK
    4254 = "MHN9Q-RD9PW-BFHDQ-9FTWQ-WQPF8" # EnterpriseSNEval, Win 10 RTM EnterpriseSNEval Retail:TB:Eval
    4254 = "VXDNG-W2YFG-H224H-CGTKM-CWHWW" # EnterpriseSNEval, Win 10 RTM EnterpriseSNEval Retail:TB:Eval
    4256 = "3JMPN-B7BMV-6WHBF-WQT32-6JHWY" # Andromeda, Win 10 RTM Andromeda OEM:DM
    4256 = "GTF7R-4NQ6M-CVCDM-TH442-4RJTB" # Andromeda, Win 10 RTM Andromeda OEM:DM
    4256 = "JFJ6N-XWR98-8F389-WBV6G-6846B" # Andromeda, Win 10 RTM Andromeda OEM:DM
    4256 = "KJ3FR-NJFPH-RMYB4-KVBH7-QPG2M" # Andromeda, Win 10 RTM Andromeda OEM:DM
    4256 = "NQWWD-8T2J9-K8HCG-9W6YB-TX2GB" # Andromeda, Win 10 RTM Andromeda OEM:DM
    4256 = "V2Y4T-NKJDQ-9FVF4-FWD2F-PPR6B" # Andromeda, Win 10 RTM Andromeda OEM:DM
    4257 = "3T4FN-F8BBV-YHYY3-MY7DP-FYBJ2" # HubOS, Win 10 RTM HubOS OEM:DM
    4257 = "4NF4Y-PY6TP-8GC66-66Q6H-FJT2P" # HubOS, Win 10 RTM HubOS OEM:DM
    4257 = "7R436-NJWQX-TJRKQ-THVC6-TJHW2" # HubOS, Win 10 RTM HubOS OEM:DM
    4257 = "DGTNQ-XKH93-VVG23-QCM3W-YP382" # HubOS, Win 10 RTM HubOS OEM:DM
    4257 = "NJ8QT-677VQ-9DBXG-8MHPH-3J46C" # HubOS, Win 10 RTM HubOS OEM:DM
    4257 = "NTBVJ-QQ2TW-MHD26-2M77M-JMBJ2" # HubOS, Win 10 RTM HubOS OEM:DM
    4258 = "3DCBV-3N6KK-7YWF4-V9YQ4-QGQ83" # Andromeda, Win 10 RTM Andromeda Retail
    4258 = "N8HYM-T3P4J-C3B93-G9FQJ-JFJTD" # Andromeda, Win 10 RTM Andromeda Retail
    4259 = "F3NGF-8BK3B-CRXW9-CWDG6-P7MJ4" # HubOS, Win 10 RTM HubOS Retail
    4259 = "X4JNT-7CWP3-PW82B-XDRVJ-F3PGF" # HubOS, Win 10 RTM HubOS Retail
    4290 = "2VQHK-NR3BF-H9R4D-RFKRT-8T3D3" # ServerStandard, Windows Server 2019 RTM ServerStandard Retail
    4290 = "3THRB-KNFHD-FMFXG-PR6W6-WXFBD" # ServerStandard, Windows Server 2019 RTM ServerStandard Retail
    4290 = "4CDNC-P7DQY-8CM42-3K3Y7-G6RBD" # ServerStandard, Windows Server 2019 RTM ServerStandard Retail
    4290 = "7XCPY-PNC97-D9GTD-QCGVD-MDYMD" # ServerStandard, Windows Server 2019 RTM ServerStandard Retail
    4290 = "9CRJN-CHQPC-G36KV-QG9MD-3PG33" # ServerStandard, Windows Server 2019 RTM ServerStandard Retail
    4290 = "9Y2NC-7KJT6-87XB6-P2XJ6-WXFBD" # ServerStandard, Windows Server 2019 RTM ServerStandard Retail
    4290 = "DMRN9-MH9B4-XYKKF-4C7PK-66RBD" # ServerStandard, Windows Server 2019 RTM ServerStandard Retail
    4290 = "G8F6N-HMHDW-43WFY-39GPX-XK2HQ" # ServerStandard, Windows Server 2019 RTM ServerStandard Retail
    4290 = "HM3NG-HXCBR-B3BCG-X9MVG-GMWVQ" # ServerStandard, Windows Server 2019 RTM ServerStandard Retail
    4290 = "KMK9N-CDWRR-C2CRQ-HVFKJ-DGRBD" # ServerStandard, Windows Server 2019 RTM ServerStandard Retail
    4290 = "KRRWH-NCC6V-4FTR3-D92KX-Y7XQ3" # ServerStandard, Windows Server 2019 RTM ServerStandard Retail
    4290 = "MDNDV-QWCB8-7WQ74-G3RJG-FVXQ3" # ServerStandard, Windows Server 2019 RTM ServerStandard Retail
    4290 = "MVTXD-8N8H9-X2RY8-C28V8-W4633" # ServerStandard, Windows Server 2019 RTM ServerStandard Retail
    4290 = "MYQYY-DNY4T-C2FYR-JCHCC-YKQD3" # ServerStandard, Windows Server 2019 RTM ServerStandard Retail
    4290 = "NG3GB-YJ48Y-KDMP4-MB6W8-CPR7Q" # ServerStandard, Windows Server 2019 RTM ServerStandard Retail
    4290 = "NHFJ4-T79B2-CYF82-38MMX-8QPHQ" # ServerStandard, Windows Server 2019 RTM ServerStandard Retail
    4290 = "PNB7X-9KT7Q-CWGMQ-XCBFT-P7MMD" # ServerStandard, Windows Server 2019 RTM ServerStandard Retail
    4290 = "Q76NR-WVVPQ-3MVF8-PBHPQ-7VCHQ" # ServerStandard, Windows Server 2019 RTM ServerStandard Retail
    4290 = "Q83QN-XJCBD-J3G4M-DYK34-84633" # ServerStandard, Windows Server 2019 RTM ServerStandard Retail
    4290 = "QFTNX-FDYJD-FQ938-J2VFK-8QPHQ" # ServerStandard, Windows Server 2019 RTM ServerStandard Retail
    4290 = "QNMJH-GPTXD-98M6R-26YM6-YHCHQ" # ServerStandard, Windows Server 2019 RTM ServerStandard Retail
    4290 = "QQM23-NR3XQ-FY37P-FW92Q-TCR7Q" # ServerStandard, Windows Server 2019 RTM ServerStandard Retail
    4290 = "QTGH6-N9B3D-T4QV6-DRY3Y-BBKQ3" # ServerStandard, Windows Server 2019 RTM ServerStandard Retail
    4290 = "R3NYR-9XDM2-XMMH2-333QJ-78T33" # ServerStandard, Windows Server 2019 RTM ServerStandard Retail
    4290 = "RWMRW-NQ787-92WMM-HWFJF-MWT33" # ServerStandard, Windows Server 2019 RTM ServerStandard Retail
    4290 = "YMWTH-NH2QC-HD97K-TP3KP-3YKQ3" # ServerStandard, Windows Server 2019 RTM ServerStandard Retail
    4291 = "4TRN3-CJ6MQ-GCYX2-JHVWT-CG3D4" # ServerStandard, Windows Server 2019 RTM ServerStandard OEM:NONSLP
    4291 = "8JKQN-CYCPT-PW8R8-CTWHY-VQYMF" # ServerStandard, Windows Server 2019 RTM ServerStandard OEM:NONSLP
    4291 = "9BWN3-937V7-KXK8H-FB78C-JB7YF" # ServerStandard, Windows Server 2019 RTM ServerStandard OEM:NONSLP
    4291 = "H9NDH-3KJ74-TVB33-R67MG-MKQD4" # ServerStandard, Windows Server 2019 RTM ServerStandard OEM:NONSLP
    4291 = "KCNPH-BQTCW-CG2QQ-9FHM9-KQDD4" # ServerStandard, Windows Server 2019 RTM ServerStandard OEM:NONSLP
    4291 = "MN2TG-DRF79-MY969-498RR-W8HYF" # ServerStandard, Windows Server 2019 RTM ServerStandard OEM:NONSLP
    4291 = "NFKHD-4MFXJ-V8DMX-V8XC2-DDDD4" # ServerStandard, Windows Server 2019 RTM ServerStandard OEM:NONSLP
    4292 = "DMWTN-T4MT3-T4FV6-9RGC2-HH8VT" # ServerStandard, Windows Server 2019 RTM ServerStandard OEM:NONSLP (MUI locked to zh-CN)
    4292 = "MQNTW-4GRYT-YTQJ4-VKPBP-7CG36" # ServerStandard, Windows Server 2019 RTM ServerStandard OEM:NONSLP (MUI locked to zh-CN)
    4292 = "NDDBP-M3KRG-6HHBX-GFHRD-BHCHT" # ServerStandard, Windows Server 2019 RTM ServerStandard OEM:NONSLP (MUI locked to zh-CN)
    4292 = "YMBMN-JM3KY-VVT26-9X2DJ-D9QD6" # ServerStandard, Windows Server 2019 RTM ServerStandard OEM:NONSLP (MUI locked to zh-CN)
    4293 = "3X99J-PND6M-WWTJQ-TQGXY-HVCHV" # ServerStandard, Windows Server 2019 RTM ServerStandard OEM:SLP
    4293 = "849MD-N9J4D-282Q4-CVC3Q-RJT37" # ServerStandard, Windows Server 2019 RTM ServerStandard OEM:SLP
    4293 = "HRP6Q-NVBG7-PFYKR-R6JHJ-BWT37" # ServerStandard, Windows Server 2019 RTM ServerStandard OEM:SLP
    4293 = "QQH2N-2KTDV-44K2Y-XBXQ6-WXFBH" # ServerStandard, Windows Server 2019 RTM ServerStandard OEM:SLP
    4294 = "3C7PC-PRNW9-BBHJ9-D3GQW-BWT38" # ServerStandard, Windows Server 2019 RTM ServerStandard OEM:SLP (MUI locked to zh-CN)
    4294 = "43TWJ-BN9D2-7D7MW-DPBTB-39QD8" # ServerStandard, Windows Server 2019 RTM ServerStandard OEM:SLP (MUI locked to zh-CN)
    4294 = "KHFM3-NW7PC-GYV6D-6YBQB-RC4BJ" # ServerStandard, Windows Server 2019 RTM ServerStandard OEM:SLP (MUI locked to zh-CN)
    4295 = "GNM93-YKYXR-WTVC4-RY9BC-CKFBK" # ServerStandard, Windows Server 2019 RTM ServerStandard OEM:DM
    4295 = "JN3PQ-GHR33-HKW3D-9XBV3-8MBMK" # ServerStandard, Windows Server 2019 RTM ServerStandard OEM:DM
    4295 = "NX92Y-XF98H-83XKV-4X22Y-88HYK" # ServerStandard, Windows Server 2019 RTM ServerStandard OEM:DM
    4295 = "YDCV7-PXNB9-XJCPP-TGY9B-F9FBK" # ServerStandard, Windows Server 2019 RTM ServerStandard OEM:DM
    4296 = "88GNY-7733F-RM7MM-KY2XT-J2R7Y" # ServerStandard, Windows Server 2019 RTM ServerStandard OEM:DM (MUI locked to zh-CN)
    4296 = "CNRGM-9V26B-KVV9T-2KWCH-DRVYM" # ServerStandard, Windows Server 2019 RTM ServerStandard OEM:DM (MUI locked to zh-CN)
    4296 = "N878H-93RJD-4T9MG-K9BFW-TQ9RB" # ServerStandard, Windows Server 2019 RTM ServerStandard OEM:DM (MUI locked to zh-CN)
    4296 = "PD9BN-KTQRG-2GH6T-3BT96-KTRBM" # ServerStandard, Windows Server 2019 RTM ServerStandard OEM:DM (MUI locked to zh-CN)
    4297 = "N69G4-B89J2-4G8F4-WWYCC-J464C" # ServerStandard, Windows Server 2019 RTM ServerStandard Volume:GVLK
    4297 = "N76RK-Y8DB4-TCGMV-TB6JB-RC4BP" # ServerStandard, Windows Server 2019 RTM ServerStandard Volume:GVLK
    4298 = "6V2XT-NYHDP-FX4G6-B663R-X2G4D" # ServerStandard;ServerStandardACor, Windows Server 2019 RTM ServerStandard;ServerStandardACor Volume:MAK
    4298 = "76WN9-FYMPD-D4D2F-8V3JG-FVXRD" # ServerStandard;ServerStandardACor, Windows Server 2019 RTM ServerStandard;ServerStandardACor Volume:MAK
    4298 = "7N9G2-J9WYB-V4D9W-V4H6P-HH8V3" # ServerStandard;ServerStandardACor, Windows Server 2019 RTM ServerStandard;ServerStandardACor Volume:MAK
    4298 = "8G762-CNJ38-3BWB9-8PXC4-CR64D" # ServerStandard;ServerStandardACor, Windows Server 2019 RTM ServerStandard;ServerStandardACor Volume:MAK
    4298 = "B7T86-NDGHJ-M7J2H-767KR-W8HYQ" # ServerStandard;ServerStandardACor, Windows Server 2019 RTM ServerStandard;ServerStandardACor Volume:MAK
    4298 = "BDFPV-YNCQW-H9WRJ-9T7GF-QGRBQ" # ServerStandard;ServerStandardACor, Windows Server 2019 RTM ServerStandard;ServerStandardACor Volume:MAK
    4298 = "CQGKN-F7X3F-CPH37-BPHY6-8T3FD" # ServerStandard;ServerStandardACor, Windows Server 2019 RTM ServerStandard;ServerStandardACor Volume:MAK
    4298 = "HK38N-M79BP-C7GMX-8MDT8-PKFBQ" # ServerStandard;ServerStandardACor, Windows Server 2019 RTM ServerStandard;ServerStandardACor Volume:MAK
    4298 = "JGKTN-69CHM-2RG3R-VHHG8-PKFBQ" # ServerStandard;ServerStandardACor, Windows Server 2019 RTM ServerStandard;ServerStandardACor Volume:MAK
    4298 = "JGVJ6-F2NQQ-KT6VT-684KV-CYWV3" # ServerStandard;ServerStandardACor, Windows Server 2019 RTM ServerStandard;ServerStandardACor Volume:MAK
    4298 = "JN9WX-28CF8-YV7CK-WDHHM-8FJV3" # ServerStandard;ServerStandardACor, Windows Server 2019 RTM ServerStandard;ServerStandardACor Volume:MAK
    4298 = "MYHRY-CN8HD-MXF2X-W8Q97-3J473" # ServerStandard;ServerStandardACor, Windows Server 2019 RTM ServerStandard;ServerStandardACor Volume:MAK
    4298 = "N2TJ6-23GWD-H9FW8-WD3P3-T6RBQ" # ServerStandard;ServerStandardACor, Windows Server 2019 RTM ServerStandard;ServerStandardACor Volume:MAK
    4298 = "RRBN6-CDB7X-RWGKM-993BD-XHMMQ" # ServerStandard;ServerStandardACor, Windows Server 2019 RTM ServerStandard;ServerStandardACor Volume:MAK
    4298 = "TXNW4-97MDB-HDGX7-CD6WD-KK2H3" # ServerStandard;ServerStandardACor, Windows Server 2019 RTM ServerStandard;ServerStandardACor Volume:MAK
    4298 = "WTTFN-W2MVP-H2DB9-R7XRD-PYWV3" # ServerStandard;ServerStandardACor, Windows Server 2019 RTM ServerStandard;ServerStandardACor Volume:MAK
    4299 = "TNK62-RXVTB-4P47B-2D623-4GF74" # ServerStandard;ServerStandardACor, Windows Server 2019 RTM ServerStandard VT:IA
    4300 = "PR3DM-NGHRJ-RXJQT-FFJPV-JQPH6" # ServerDatacenter, Windows Server 2019 RTM ServerDatacenter Volume:GVLK
    4300 = "WMDGN-G9PQG-XVVXX-R3X43-63DFG" # ServerDatacenter, Windows Server 2019 RTM ServerDatacenter Volume:GVLK
    4301 = "BGB7N-PBQJ3-7T889-4699K-JXFBV" # AzureStackHCIAddOn, Windows Server 2019 RTM AzureStackHCIAddOn Volume:MAK
    4301 = "C6R9P-FVN2Y-MT2GY-M99DK-Y7XRH" # AzureStackHCIAddOn, Windows Server 2019 RTM AzureStackHCIAddOn Volume:MAK
    4301 = "C743N-RYHH2-YV4JV-GP4HJ-J8HYV" # AzureStackHCIAddOn, Windows Server 2019 RTM AzureStackHCIAddOn Volume:MAK
    4301 = "FFDJH-N7B4Y-V94KY-B7CF8-F3PH7" # AzureStackHCIAddOn, Windows Server 2019 RTM AzureStackHCIAddOn Volume:MAK
    4301 = "JN63M-337XK-M337F-9JMXV-CYWV7" # AzureStackHCIAddOn, Windows Server 2019 RTM AzureStackHCIAddOn Volume:MAK
    4301 = "JWBTN-M49F6-6RFC3-BFR3Y-X4VYV" # AzureStackHCIAddOn, Windows Server 2019 RTM AzureStackHCIAddOn Volume:MAK
    4301 = "KT4VW-NR4D6-87QD6-8VTHC-P92H7" # AzureStackHCIAddOn, Windows Server 2019 RTM AzureStackHCIAddOn Volume:MAK
    4301 = "N78Q7-C2CCM-2RPCK-9WHYY-2PR77" # AzureStackHCIAddOn, Windows Server 2019 RTM AzureStackHCIAddOn Volume:MAK
    4301 = "QJFNK-JWT88-68VJ7-HFXFB-VQYMV" # AzureStackHCIAddOn, Windows Server 2019 RTM AzureStackHCIAddOn Volume:MAK
    4301 = "RFTH7-4NMFT-HXXVP-FMPMF-KBWV7" # AzureStackHCIAddOn, Windows Server 2019 RTM AzureStackHCIAddOn Volume:MAK
    4301 = "TD97P-9TNMT-J8QRH-348HQ-H24BV" # AzureStackHCIAddOn, Windows Server 2019 RTM AzureStackHCIAddOn Volume:MAK
    4301 = "WBNFF-YWRVT-HCKD3-GXV3G-VCG4H" # AzureStackHCIAddOn, Windows Server 2019 RTM AzureStackHCIAddOn Volume:MAK
    4301 = "WJF7T-NW437-T74PD-FR6JJ-33YMV" # AzureStackHCIAddOn, Windows Server 2019 RTM AzureStackHCIAddOn Volume:MAK
    4301 = "XPDNH-BD66B-HG77G-F79HF-FC4BV" # AzureStackHCIAddOn, Windows Server 2019 RTM AzureStackHCIAddOn Volume:MAK
    4301 = "YNV7D-VDW9Q-FJDFR-WF94G-H8T4H" # AzureStackHCIAddOn, Windows Server 2019 RTM AzureStackHCIAddOn Volume:MAK
    4302 = "H3RNG-8C32Q-Q8FRX-6TDXV-WMBMW" # ServerDatacenter;ServerDatacenterACor, Windows Server 2019 RTM ServerDatacenter VT:IA
    4303 = "8QC6Y-6NQ7G-R24PQ-WJYW3-DV8V9" # AzureStackHCIAddOn, Windows Server 2019 RTM AzureStackHCIAddOn OEM:NONSLP
    4303 = "F2YM7-NC42F-GF8H3-3GYK7-7QYMX" # AzureStackHCIAddOn, Windows Server 2019 RTM AzureStackHCIAddOn OEM:NONSLP
    4303 = "MTPN6-JVPFW-H778D-PB8FY-DPG4K" # AzureStackHCIAddOn, Windows Server 2019 RTM AzureStackHCIAddOn OEM:NONSLP
    4303 = "XRC2X-2RN9M-F6BT9-V9BX7-R9FBX" # AzureStackHCIAddOn, Windows Server 2019 RTM AzureStackHCIAddOn OEM:NONSLP
    4303 = "Y6NXQ-GY9CW-J96YV-QV98H-94VYX" # AzureStackHCIAddOn, Windows Server 2019 RTM AzureStackHCIAddOn OEM:NONSLP
    4304 = "B3DHV-RNWWQ-RH2QP-TQDGT-D3YMY" # ServerDatacenter, Windows Server 2019 RTM ServerDatacenter OEM:NONSLP (MUI locked to zh-CN)
    4304 = "VCB9N-R7JFT-3FG3C-8WJQY-39QFM" # ServerDatacenter, Windows Server 2019 RTM ServerDatacenter OEM:NONSLP (MUI locked to zh-CN)
    4305 = "8PNQX-RF873-CXRPY-8J42B-XBWWC" # AzureStackHCIAddOn, Windows Server 2019 RTM AzureStackHCIAddOn OEM:SLP
    4305 = "QMNY4-DG2PG-X94QM-TXYHM-39QFP" # AzureStackHCIAddOn, Windows Server 2019 RTM AzureStackHCIAddOn OEM:SLP
    4305 = "YNF2T-4KM28-YBHHT-FY8FY-DPG4P" # AzureStackHCIAddOn, Windows Server 2019 RTM AzureStackHCIAddOn OEM:SLP
    4306 = "P3NRG-H2HT7-DD6YP-KHY4P-76F8D" # ServerDatacenter, Windows Server 2019 RTM ServerDatacenter OEM:SLP (MUI locked to zh-CN)
    4306 = "TCNK7-X7QH9-HQ38C-8DDJW-YP4B3" # ServerDatacenter, Windows Server 2019 RTM ServerDatacenter OEM:SLP (MUI locked to zh-CN)
    4307 = "23NF7-RXCKW-Q74PG-KJ6QW-4VXRR" # AzureStackHCIAddOn, Windows Server 2019 RTM AzureStackHCIAddOn Retail
    4307 = "6P7N3-CV6HQ-JRYTB-3TMFG-D3YM4" # AzureStackHCIAddOn, Windows Server 2019 RTM AzureStackHCIAddOn Retail
    4307 = "76WDM-TN9D3-JTBH4-FCR4R-3DDFR" # AzureStackHCIAddOn, Windows Server 2019 RTM AzureStackHCIAddOn Retail
    4307 = "8KQ9N-H2TQK-39DHB-9RCD8-9TRB4" # AzureStackHCIAddOn, Windows Server 2019 RTM AzureStackHCIAddOn Retail
    4307 = "9YDXY-4N3FG-8RBT3-JC8B3-VXQFR" # AzureStackHCIAddOn, Windows Server 2019 RTM AzureStackHCIAddOn Retail
    4307 = "CBN96-JWHWX-YPB7D-HV2J8-WB7Y4" # AzureStackHCIAddOn, Windows Server 2019 RTM AzureStackHCIAddOn Retail
    4307 = "CWTJ3-WN9XB-62M3X-W6J6T-724B4" # AzureStackHCIAddOn, Windows Server 2019 RTM AzureStackHCIAddOn Retail
    4307 = "F93BG-2NQGW-3FKT3-7P8MK-3RVY4" # AzureStackHCIAddOn, Windows Server 2019 RTM AzureStackHCIAddOn Retail
    4307 = "G3QW2-NCPJF-XBP9J-9X63K-GJHY4" # AzureStackHCIAddOn, Windows Server 2019 RTM AzureStackHCIAddOn Retail
    4307 = "G73TC-N66D3-JFPR8-XQ4CJ-YP4B4" # AzureStackHCIAddOn, Windows Server 2019 RTM AzureStackHCIAddOn Retail
    4307 = "GP8X9-NBGDK-GYV4G-C3HP4-Q9QFR" # AzureStackHCIAddOn, Windows Server 2019 RTM AzureStackHCIAddOn Retail
    4307 = "HQWMX-NXFQQ-GX443-3FHX9-RM7Y4" # AzureStackHCIAddOn, Windows Server 2019 RTM AzureStackHCIAddOn Retail
    4307 = "K82NG-3HJRX-VKBCG-9QYDR-JHXRR" # AzureStackHCIAddOn, Windows Server 2019 RTM AzureStackHCIAddOn Retail
    4307 = "KM4GN-DQFRK-DXYDC-MVWPX-PBBM4" # AzureStackHCIAddOn, Windows Server 2019 RTM AzureStackHCIAddOn Retail
    4307 = "N28W9-K6H3D-3VT87-TJVDK-GJHY4" # AzureStackHCIAddOn, Windows Server 2019 RTM AzureStackHCIAddOn Retail
    4307 = "N8H97-CWYJ8-DP622-88WFC-DDDFR" # AzureStackHCIAddOn, Windows Server 2019 RTM AzureStackHCIAddOn Retail
    4307 = "N9X39-4Y3VW-39X2Y-YQK86-MKQFR" # AzureStackHCIAddOn, Windows Server 2019 RTM AzureStackHCIAddOn Retail
    4307 = "NFJ77-RMF62-V89VY-G4B7Y-VQYM4" # AzureStackHCIAddOn, Windows Server 2019 RTM AzureStackHCIAddOn Retail
    4307 = "NFKT9-6CR6P-4MMBR-K82FG-3V8WF" # AzureStackHCIAddOn, Windows Server 2019 RTM AzureStackHCIAddOn Retail
    4307 = "NPTRB-CFYFD-DGFPG-DY9GJ-CPR8F" # AzureStackHCIAddOn, Windows Server 2019 RTM AzureStackHCIAddOn Retail
    4307 = "PN3MY-MGD8B-4XKHQ-BX494-37CJF" # AzureStackHCIAddOn, Windows Server 2019 RTM AzureStackHCIAddOn Retail
    4307 = "WW83G-M2NJ7-7J8CP-82XRF-2KFB4" # AzureStackHCIAddOn, Windows Server 2019 RTM AzureStackHCIAddOn Retail
    4308 = "26K99-N2H9H-VMBQB-6FMXX-GJHY6" # AzureStackHCIAddOn, Windows Server 2019 RTM AzureStackHCIAddOn OEM:DM
    4308 = "BXX9H-RKNX6-DQFRR-3737W-9TRB6" # AzureStackHCIAddOn, Windows Server 2019 RTM AzureStackHCIAddOn OEM:DM
    4308 = "RJD2N-BHQBB-4MTQK-788W2-V8T4T" # AzureStackHCIAddOn, Windows Server 2019 RTM AzureStackHCIAddOn OEM:DM
    4308 = "W374N-CR9R2-G36CB-MBY8K-QV8WG" # AzureStackHCIAddOn, Windows Server 2019 RTM AzureStackHCIAddOn OEM:DM
    4309 = "D42FN-YGMP6-92CFJ-6XDCJ-J8HY7" # AzureStackHCIAddOn, Windows Server 2019 RTM AzureStackHCIAddOn OEM:DM
    4309 = "J7728-RHNBP-X8XYD-H9P7R-VMKRV" # AzureStackHCIAddOn, Windows Server 2019 RTM AzureStackHCIAddOn OEM:DM
    4310 = "3PFM8-GN437-GW6KP-FVXXK-YDYM8" # ServerDatacenter, Windows Server 2019 RTM ServerDatacenter OEM:DM (MUI locked to zh-CN)
    4310 = "CNRK2-QQ89Q-7P4X3-HGTDQ-C39RW" # ServerDatacenter, Windows Server 2019 RTM ServerDatacenter OEM:DM (MUI locked to zh-CN)
    4310 = "G68RM-Q6NMD-X9JPK-7VXC9-JXFB8" # ServerDatacenter, Windows Server 2019 RTM ServerDatacenter OEM:DM (MUI locked to zh-CN)
    4310 = "NFF4H-MMXBC-P46DX-4GYT4-3DDFW" # ServerDatacenter, Windows Server 2019 RTM ServerDatacenter OEM:DM (MUI locked to zh-CN)
    4311 = "J4WNC-H9BG3-6XRX4-3XD8K-Y7XRX" # ServerStandardEval, Windows Server 2019 RTM ServerStandardEval Retail:TB:Eval
    4311 = "X6B8W-TN3XG-6F22Q-RQG6Q-BHCJK" # ServerStandardEval, Windows Server 2019 RTM ServerStandardEval Retail:TB:Eval
    4312 = "4WX3D-NPGJF-F4X7B-X9PRX-V24CB" # ServerDatacenterEval, Windows Server 2019 RTM ServerDatacenterEval Retail:TB:Eval
    4312 = "KNW3G-22YD2-7QKQJ-2RF2X-H6F8M" # ServerDatacenterEval, Windows Server 2019 RTM ServerDatacenterEval Retail:TB:Eval
    4313 = "N2KJX-J94YW-TQVFB-DG9YT-724CC" # ServerStandardACor, Windows Server 2019 RTM ServerStandardACor Volume:GVLK
    4313 = "PHN2T-WHKP4-X8RTQ-TD9TT-D3YPC" # ServerStandardACor, Windows Server 2019 RTM ServerStandardACor Volume:GVLK
    4314 = "6NMRW-2C8FM-D24W7-TQWMY-CWH2D" # ServerDatacenterACor, Windows Server 2019 RTM ServerDatacenterACor Volume:GVLK
    4314 = "TX3M3-HN6CW-2D8RM-QKCVK-WT3F3" # ServerDatacenterACor, Windows Server 2019 RTM ServerDatacenterACor Volume:GVLK
    4315 = "N3P28-TW9C9-69PWP-YQVC3-YBKR4" # ServerStandardACor, Windows Server 2019 RTM ServerStandardACor Retail
    4315 = "VFFNY-J46DH-MDD2F-RCFMY-RC4CF" # ServerStandardACor, Windows Server 2019 RTM ServerStandardACor Retail
    4316 = "NY48Y-K9DDM-VT896-8VW3H-6X2JT" # ServerDatacenterACor, Windows Server 2019 RTM ServerDatacenterACor Retail
    4316 = "RC4VN-4GQBW-WYPTV-3BD66-FVXR6" # ServerDatacenterACor, Windows Server 2019 RTM ServerDatacenterACor Retail
    4317 = "4YGRN-GMPC8-GG84C-4BTFR-MWT47" # ServerStandardACor, Windows Server 2019 RTM ServerStandardACor Volume:MAK
    4317 = "NH6RH-D3DK6-KXRCV-GH8YV-9BWWV" # ServerStandardACor, Windows Server 2019 RTM ServerStandardACor Volume:MAK
    4318 = "C9G9V-2NPKQ-TC2FF-KKPVC-P92JW" # ServerDatacenterACor, Windows Server 2019 RTM ServerDatacenterACor Volume:MAK
    4318 = "RQ2HY-JWN2P-MDT3J-JHRCC-FYBPJ" # ServerDatacenterACor, Windows Server 2019 RTM ServerDatacenterACor Volume:MAK
    4319 = "2NM93-FP46J-PRBPG-XRR67-MBKR9" # ServerAzureCor, Windows Server 2019 RTM ServerAzureCor Retail
    4320 = "FDNH6-VW9RW-BXPJ7-4XTYG-239TB" # ServerAzureCor, Windows Server 2019 RTM ServerAzureCor Volume:GVLK
    4320 = "VNJG3-QDK8Q-C3DPY-6HKRM-2PR8Y" # ServerAzureCor, Windows Server 2019 RTM ServerAzureCor Volume:GVLK
    4321 = "NCQMH-7JRF3-32PVY-R92K6-9K2J2" # ServerAzureCor, Windows Server 2019 RTM ServerAzureCor VT:IA
    4322 = "DYNQ8-H7BQB-YCF8K-PM77M-PR66D" # ServerDatacenterCor, Windows Server 2021 RTM ServerDatacenterCor Retail
    4323 = "84NDK-M3JW4-PHYFH-CM7GR-6Q9TF" # ServerDatacenterEvalCor, Windows Server 2021 RTM ServerDatacenterEvalCor Retail:TB:Eval
    4323 = "T49Q4-NV8XR-WRXD9-4Y78C-D7CJ4" # ServerDatacenterEvalCor, Windows Server 2021 RTM ServerDatacenterEvalCor Retail:TB:Eval
    4324 = "8GTN9-WP4GG-33HFG-7J66H-4C4CT" # ServerStandardCor, Windows Server 2021 RTM ServerStandardCor Retail
    4325 = "D32CM-X4NMM-648WF-MGVDK-CDPJ7" # ServerStandardEvalCor, Windows Server 2021 RTM ServerStandardEvalCor Retail:TB:Eval
    4325 = "NX6TT-WH4BH-CJC2P-M98B8-33YPV" # ServerStandardEvalCor, Windows Server 2021 RTM ServerStandardEvalCor Retail:TB:Eval
    4326 = "2M3WR-NQW7W-7MX3H-TYCRD-8MBPW" # ServerARM64, Windows Server 2019 RTM ServerARM64 Volume:GVLK
    4326 = "GRFBW-QNDC4-6QBHG-CCK3B-2PR88" # ServerARM64, Windows Server 2019 RTM ServerARM64 Volume:GVLK
    4327 = "CPWHC-NT2C7-VYW78-DHDB2-PG3GK" # ServerRdsh, Windows Server 2019 RTM ServerRdsh Volume:GVLK
    4327 = "VMKVQ-3MN6B-BVM9F-YWV97-R9FCX" # ServerRdsh, Windows Server 2019 RTM ServerRdsh Volume:GVLK
    4328 = "99NWR-W7HT9-HYD3X-3DX7V-FJT6M" # ServerSolution, Windows Server Essentials 2019 RTM ServerSolution OEM:NONSLP
    4328 = "GYYPN-QTM8C-HCKBG-YY394-X2G6M" # ServerSolution, Windows Server Essentials 2019 RTM ServerSolution OEM:NONSLP
    4328 = "ND8Y2-Y3FKK-6Q7FJ-9WXGM-KD9TM" # ServerSolution, Windows Server Essentials 2019 RTM ServerSolution OEM:NONSLP
    4328 = "Q3DTQ-T6N3Y-YKRF7-8CB94-FC4CY" # ServerSolution, Windows Server Essentials 2019 RTM ServerSolution OEM:NONSLP
    4329 = "N4XM6-FYMQM-8K2CG-D6DDH-RGF9C" # ServerSolution, Windows Server Essentials 2019 RTM ServerSolution OEM:SLP
    4329 = "VMHQW-YDN62-2RW7J-VDGY7-2R66P" # ServerSolution, Windows Server Essentials 2019 RTM ServerSolution OEM:SLP
    4330 = "3DB6N-YXFXK-PFHGQ-C8QB2-TMWXD" # ServerSolution, Windows Server Essentials 2019 RTM ServerSolution Retail
    4330 = "3N7M4-4RGV9-B4T2Q-HFFJ3-DV8XD" # ServerSolution, Windows Server Essentials 2019 RTM ServerSolution Retail
    4330 = "3R7NT-MTX6X-WJ3X8-KJY2B-7MKTQ" # ServerSolution, Windows Server Essentials 2019 RTM ServerSolution Retail
    4330 = "3T6XG-9ND39-RBXH6-8J9W3-7VCKD" # ServerSolution, Windows Server Essentials 2019 RTM ServerSolution Retail
    4330 = "4NKRR-W36Y4-48PGV-RHQYQ-4GF9D" # ServerSolution, Windows Server Essentials 2019 RTM ServerSolution Retail
    4330 = "4T46G-NQ67T-GPQCW-FCKP4-Q9QGQ" # ServerSolution, Windows Server Essentials 2019 RTM ServerSolution Retail
    4330 = "68NFG-HXR36-VXCVJ-46M6J-6MWXD" # ServerSolution, Windows Server Essentials 2019 RTM ServerSolution Retail
    4330 = "6N62D-BCQ2K-4V422-BMF68-78T6Q" # ServerSolution, Windows Server Essentials 2019 RTM ServerSolution Retail
    4330 = "7H6FN-6Q2MV-XXRFM-3XYY4-3DDGQ" # ServerSolution, Windows Server Essentials 2019 RTM ServerSolution Retail
    4330 = "8HXHN-MWBDG-XFHG4-P3GDT-2BBP3" # ServerSolution, Windows Server Essentials 2019 RTM ServerSolution Retail
    4330 = "8V9NR-4XFTH-BFTY4-XKH7D-C39TQ" # ServerSolution, Windows Server Essentials 2019 RTM ServerSolution Retail
    4330 = "C4DNC-F83WW-PFBDJ-YXXT2-D7CKD" # ServerSolution, Windows Server Essentials 2019 RTM ServerSolution Retail
    4330 = "DG2GN-G3Y26-6VH26-F7JVP-9QDGQ" # ServerSolution, Windows Server Essentials 2019 RTM ServerSolution Retail
    4330 = "JN47C-TRMVV-9BQJB-JVP8X-RM723" # ServerSolution, Windows Server Essentials 2019 RTM ServerSolution Retail
    4330 = "K7W38-GPNHQ-8VCJG-F7FXQ-Y4JXD" # ServerSolution, Windows Server Essentials 2019 RTM ServerSolution Retail
    4330 = "NMB98-MKJBC-FTVQ9-J3XK6-QYKTQ" # ServerSolution, Windows Server Essentials 2019 RTM ServerSolution Retail
    4330 = "P2YPC-TTN7G-YQ9GR-4TQDW-YP4C3" # ServerSolution, Windows Server Essentials 2019 RTM ServerSolution Retail
    4330 = "PN3YY-92KRG-DDVBJ-2GW7K-WT3GQ" # ServerSolution, Windows Server Essentials 2019 RTM ServerSolution Retail
    4330 = "RN2XG-M3YRY-XJ49M-24RMM-YWT6Q" # ServerSolution, Windows Server Essentials 2019 RTM ServerSolution Retail
    4330 = "VJNG4-JVRBV-QQ2TM-TX3DX-66RC3" # ServerSolution, Windows Server Essentials 2019 RTM ServerSolution Retail
    4330 = "Y2NKR-W8M87-2PW2Y-XBRTQ-8MBP3" # ServerSolution, Windows Server Essentials 2019 RTM ServerSolution Retail
    4331 = "N768D-V2R7C-VRBQM-YCJQQ-MDYP4" # ServerSolution, Windows Server Essentials 2019 RTM ServerSolution Retail:TB:Eval
    4332 = "TBNX2-VFP7M-JT6GH-FV2FF-GX2KG" # ServerSolution, Windows Server Essentials 2019 RTM ServerSolution Volume:GVLK
    4332 = "WVDHN-86M7X-466P6-VHXV7-YY726" # ServerSolution, Windows Server Essentials 2019 RTM ServerSolution Volume:GVLK
    4333 = "4N6B6-2XBB7-38FK2-YVR3C-76F9H" # ServerSolution, Windows Server Essentials 2019 RTM ServerSolution Volume:MAK
    4333 = "6JMN3-D29DX-BDKKX-TDWXH-B7XTV" # ServerSolution, Windows Server Essentials 2019 RTM ServerSolution Volume:MAK
    4333 = "7YNQP-BP4FG-J2QQB-WHMJK-6CR9H" # ServerSolution, Windows Server Essentials 2019 RTM ServerSolution Volume:MAK
    4333 = "8N3M3-KQXF4-HHQ4Y-WRGXH-463GV" # ServerSolution, Windows Server Essentials 2019 RTM ServerSolution Volume:MAK
    4333 = "HW4NG-K68YX-W6CXY-9YGRR-DJ49H" # ServerSolution, Windows Server Essentials 2019 RTM ServerSolution Volume:MAK
    4333 = "N6WXW-FBTF4-T87CB-KXMRC-W2R9H" # ServerSolution, Windows Server Essentials 2019 RTM ServerSolution Volume:MAK
    4333 = "NQXXQ-DXW8K-B2GTB-KJ4QM-R63GV" # ServerSolution, Windows Server Essentials 2019 RTM ServerSolution Volume:MAK
    4333 = "RP2X2-C2NFW-RGFM7-VGWQW-VH8XH" # ServerSolution, Windows Server Essentials 2019 RTM ServerSolution Volume:MAK
    4334 = "2CTP7-NHT64-BP62M-FV6GG-HFV28" # ServerSolution, Windows Server Essentials 2019 RTM ServerSolution VT:IA
    4335 = "9R69H-NM9K8-72CKY-R7P8B-G3DGX" # ServerSolution, Windows Server Essentials 2019 RTM ServerSolution OEM:DM
    4335 = "FYGFT-4RNJV-8TWCQ-946FX-V24C9" # ServerSolution, Windows Server Essentials 2019 RTM ServerSolution OEM:DM
    4335 = "H9VNF-3MFR9-MHFKK-FKHHD-WQPKK" # ServerSolution, Windows Server Essentials 2019 RTM ServerSolution OEM:DM
    4335 = "T9DFN-TBX82-V7K77-3RY48-VH8XK" # ServerSolution, Windows Server Essentials 2019 RTM ServerSolution OEM:DM
    4361 = "9DN2B-8B4HC-YFKWM-TCPW9-TF672" # Holographic, Win 10 RTM Holographic OEM:DM
    4361 = "DQ9NR-PK7CQ-42CYF-RQ7HM-39QH2" # Holographic, Win 10 RTM Holographic OEM:DM
    4361 = "GM2HV-PNMX9-7KF44-HWB79-BKQH2" # Holographic, Win 10 RTM Holographic OEM:DM
    4361 = "H4MND-KF7J8-PWBTV-2P3JG-BP4FC" # Holographic, Win 10 RTM Holographic OEM:DM
    4362 = "2K98T-2NYMC-FT4VT-XH8GX-FRJYQ" # IoTEnterprise, Win 10 RTM IoTEnterprise OEM:DM
    4362 = "6V268-4N9HR-2YD74-XTGTT-H8T73" # IoTEnterprise, Win 10 RTM IoTEnterprise OEM:DM
    4362 = "7XXPF-NF6M3-VYGHV-F337T-239V3" # IoTEnterprise, Win 10 RTM IoTEnterprise OEM:DM
    4362 = "N8HD3-9HMFQ-TVJGC-V6HBQ-4GGBQ" # IoTEnterprise, Win 10 RTM IoTEnterprise OEM:DM
    4362 = "NPDT2-BJ44P-WJ2BP-DB467-G6RFD" # IoTEnterprise, Win 10 RTM IoTEnterprise OEM:DM
    4362 = "NYR6B-CPMMK-RTJQQ-XH2GG-MKQH3" # IoTEnterprise, Win 10 RTM IoTEnterprise OEM:DM
    4362 = "TTYX6-G2NDY-H3HRB-MQP77-9BWYQ" # IoTEnterprise, Win 10 RTM IoTEnterprise OEM:DM
    4362 = "WNT9D-KBW3Q-7RVW8-3FVB9-Y7XV3" # IoTEnterprise, Win 10 RTM IoTEnterprise OEM:DM
    4362 = "XMGYY-R8NRP-DV4CM-7QYP4-9W6BQ" # IoTEnterprise, Win 10 RTM IoTEnterprise OEM:DM
    4362 = "XQQYW-NFFMW-XJPBH-K8732-CKFFD" # IoTEnterprise, Win 10 RTM IoTEnterprise OEM:DM
    4362 = "YG37V-VYNTJ-4CY9P-JVQQ9-7XQH3" # IoTEnterprise, Win 10 RTM IoTEnterprise OEM:DM
    4363 = "3TNB2-FBW3G-2M6TH-8RCRV-MBKV4" # IoTEnterprise, Win 10 RTM IoTEnterprise OEM:NONSLP
    4363 = "433KJ-8N6G7-6D8FV-XT6KF-2KFFF" # IoTEnterprise, Win 10 RTM IoTEnterprise OEM:NONSLP
    4363 = "8NT82-JYHPQ-9TDH4-V3C4M-6VMRF" # IoTEnterprise, Win 10 RTM IoTEnterprise OEM:NONSLP
    4363 = "C92DR-NKFCM-QQV84-P9HBG-RRJYR" # IoTEnterprise, Win 10 RTM IoTEnterprise OEM:NONSLP
    4363 = "CHCDD-NBFKY-M8DJM-MHYBQ-T6RFF" # IoTEnterprise, Win 10 RTM IoTEnterprise OEM:NONSLP
    4363 = "FMRXN-7HQ8Q-QGPRR-4QVMG-HFV4F" # IoTEnterprise, Win 10 RTM IoTEnterprise OEM:NONSLP
    4363 = "H6NQT-9MFM7-9XH8W-W69CD-MDYRF" # IoTEnterprise, Win 10 RTM IoTEnterprise OEM:NONSLP
    4363 = "RN72X-8QMJ9-M9KTQ-RRQK2-8XFFF" # IoTEnterprise, Win 10 RTM IoTEnterprise OEM:NONSLP
    4363 = "WGF3G-P9N2H-WM8XV-FP3HV-JQPMR" # IoTEnterprise, Win 10 RTM IoTEnterprise OEM:NONSLP
    4364 = "2H4TJ-N8GXJ-B4MHC-QD8DD-CBBRG" # IoTEnterpriseS, Win 10 RTM IoTEnterpriseS OEM:DM
    4364 = "B24K7-DTNV9-D9F6Q-YCRHW-WB74G" # IoTEnterpriseS, Win 10 RTM IoTEnterpriseS OEM:DM
    4364 = "D84GB-NYPBY-HTBMR-3QP6T-H8T76" # IoTEnterpriseS, Win 10 RTM IoTEnterpriseS OEM:DM
    4364 = "HJPNG-DXCKX-6MW43-G848R-PPTBT" # IoTEnterpriseS, Win 10 RTM IoTEnterpriseS OEM:DM
    4364 = "HTN4V-QRMBR-JM63Q-HP7Q2-KW6BT" # IoTEnterpriseS, Win 10 RTM IoTEnterpriseS OEM:DM
    4364 = "JDXNH-JX773-P2KT4-RCC66-YHCMT" # IoTEnterpriseS, Win 10 RTM IoTEnterpriseS OEM:DM
    4364 = "KRHTN-9GC3F-7XD2R-KTTM2-XTRFG" # IoTEnterpriseS, Win 10 RTM IoTEnterpriseS OEM:DM
    4364 = "KYD92-NHTVH-JWHRP-PKVBJ-WB74G" # IoTEnterpriseS, Win 10 RTM IoTEnterpriseS OEM:DM
    4364 = "NHM9J-9PKG9-TB687-XXM9B-B4JYT" # IoTEnterpriseS, Win 10 RTM IoTEnterpriseS OEM:DM
    4364 = "T397X-YQNX7-GH3FW-67JBH-4C4FG" # IoTEnterpriseS, Win 10 RTM IoTEnterpriseS OEM:DM
    4364 = "TXYJ3-T6NX9-RBCPT-MH4VQ-DV8YT" # IoTEnterpriseS, Win 10 RTM IoTEnterpriseS OEM:DM
    4365 = "3J8N7-H99R3-W8FY3-F3YBY-6VMRH" # IoTEnterpriseS, Win 10 RTM IoTEnterpriseS OEM:NONSLP
    4365 = "8N9J7-D88VF-DGGF4-F68X8-82TBV" # IoTEnterpriseS, Win 10 RTM IoTEnterpriseS OEM:NONSLP
    4365 = "FFR36-QYNV7-VFV68-XGF9J-DGRFH" # IoTEnterpriseS, Win 10 RTM IoTEnterpriseS OEM:NONSLP
    4365 = "GNKQW-9BFF8-DRJ3P-T6C8B-K78YV" # IoTEnterpriseS, Win 10 RTM IoTEnterpriseS OEM:NONSLP
    4365 = "J8NK8-34GGP-4YDCC-3J8JB-6VMRH" # IoTEnterpriseS, Win 10 RTM IoTEnterpriseS OEM:NONSLP
    4365 = "JWGMH-8NJK8-JJMXG-6X98Y-PR677" # IoTEnterpriseS, Win 10 RTM IoTEnterpriseS OEM:NONSLP
    4365 = "N2TFR-XMMJP-KQ36M-JQ296-KTRFH" # IoTEnterpriseS, Win 10 RTM IoTEnterpriseS OEM:NONSLP
    4365 = "QPM6N-7J2WJ-P88HH-P3YRH-YY74H" # IoTEnterpriseS, Win 10 RTM IoTEnterpriseS OEM:NONSLP
    4365 = "R7NG3-7R8W8-KMKJR-TR6H3-BHCMV" # IoTEnterpriseS, Win 10 RTM IoTEnterpriseS OEM:NONSLP
    4366 = "MMNXW-37YYP-RV6PQ-WVD4Y-R63H8" # Lite, Win 10 RTM Lite Retail
    4367 = "29NVR-6CTYD-4CJ9D-XYTG6-8T3H9" # Lite, Win 10 RTM Lite OEM:DM
    4367 = "6NTQ8-YGP9M-B7GVF-P3G4B-F9FFK" # Lite, Win 10 RTM Lite OEM:DM
    4367 = "98NKH-VW7G3-6K3BF-22TVH-DRV4K" # Lite, Win 10 RTM Lite OEM:DM
    4367 = "HVYNB-XGJ47-FJYM2-7XM7H-7QYRK" # Lite, Win 10 RTM Lite OEM:DM
    4367 = "NVGV7-7T64T-XHYK8-G44V8-292MX" # Lite, Win 10 RTM Lite OEM:DM
    4367 = "XXJN6-VCHX7-99BCX-T2GJ4-VMKV9" # Lite, Win 10 RTM Lite OEM:DM
    4368 = "TDGXG-2NPXR-4QYG9-PDMVW-6MWYY" # Lite, Win 10 RTM Lite Retail
    4368 = "TVDC8-KNMC7-C3T67-B6XFQ-9D9WB" # Lite, Win 10 RTM Lite Retail
    4456 = "MG6N8-PJPK3-DP9BV-2XYWK-QV86M" # ServerAzureStackHCICor, Windows Server 2019 RTM ServerAzureStackHCICor VT:IA
    4458 = "K7FX8-NKP88-BDPD9-89V37-JQPTQ" # ServerAzureStackHCICor, Windows Server 2019 RTM ServerAzureStackHCICor OEM:NONSLP
    4459 = "BYHV8-BN93J-7VDMQ-644MY-K786R" # ServerAzureStackHCICor, Windows Server 2019 RTM ServerAzureStackHCICor OEM:SLP
    4459 = "N96HQ-B4VXQ-HT3D6-QYHW6-RRJ6R" # ServerAzureStackHCICor, Windows Server 2019 RTM ServerAzureStackHCICor OEM:SLP
    4460 = "RR3NQ-8JM6Q-6MWTY-86769-6CTGT" # ServerAzureStackHCICor, Windows Server 2019 RTM ServerAzureStackHCICor OEM:SLP
    4462 = "TJHRN-QWP2G-QFB27-94MDJ-33YXJ" # ServerAzureStackHCICor, Windows Server 2019 RTM ServerAzureStackHCICor Retail
    4463 = "6Q7NV-P49YG-97QWK-WRJV3-JT3P9" # ServerAzureStackHCICor, Windows Server 2019 RTM ServerAzureStackHCICor OEM:NONSLP
    4463 = "C6GNJ-4BHR6-6M6KY-TPGC7-KHMXK" # ServerAzureStackHCICor, Windows Server 2019 RTM ServerAzureStackHCICor OEM:NONSLP
    4463 = "N7M9C-84286-JMTPP-9WRQJ-JFJ6X" # ServerAzureStackHCICor, Windows Server 2019 RTM ServerAzureStackHCICor OEM:NONSLP
    4463 = "PDYPN-P8HJ7-7XPHP-GKCD8-6MW6X" # ServerAzureStackHCICor, Windows Server 2019 RTM ServerAzureStackHCICor OEM:NONSLP
    4464 = "DN8YJ-4D6P9-PK2WY-R49Y4-HQYXM" # ServerAzureStackHCICor, Windows Server 2019 RTM ServerAzureStackHCICor Retail
    4464 = "N23XM-M2DHV-KW6CG-972GY-92HDB" # ServerAzureStackHCICor, Windows Server 2019 RTM ServerAzureStackHCICor Retail
    4464 = "Q6G74-NT87J-Y8MWG-9F6QR-37CTY" # ServerAzureStackHCICor, Windows Server 2019 RTM ServerAzureStackHCICor Retail
    4464 = "VH6MG-P2N63-QCPKH-7D99V-RGGGY" # ServerAzureStackHCICor, Windows Server 2019 RTM ServerAzureStackHCICor Retail
    4464 = "WN6TK-X87WK-FFXPP-P2397-XD93B" # ServerAzureStackHCICor, Windows Server 2019 RTM ServerAzureStackHCICor Retail
    4464 = "WTW4N-3DP88-JMDXD-K9DHR-F63QB" # ServerAzureStackHCICor, Windows Server 2019 RTM ServerAzureStackHCICor Retail
    4464 = "YP2N4-KHPFV-F2D34-PXFJH-MBK3B" # ServerAzureStackHCICor, Windows Server 2019 RTM ServerAzureStackHCICor Retail
    4468 = "BGN68-MMRQW-43WD8-6XF8G-4M79T" # ServerTurbine, Windows Server 2019 RTM ServerTurbine Retail
    4469 = "NTBV8-9K7Q8-V27C6-M2BTV-KHMXV" # ServerTurbine, Windows Server 2019 RTM ServerTurbine Volume:GVLK
    4470 = "F7TB6-YKN8Y-FCC6R-KQ484-VMK3J" # ServerTurbine, Windows Server 2019 RTM ServerTurbine VT:IA
    4471 = "7NWBW-92K7D-BDWHG-G6RJ2-9QDQK" # ServerTurbine, Windows Server 2019 RTM ServerTurbine Volume:MAK
    4536 = "7VQVH-WN3GR-J6TQC-9CCJX-MHCXY" # ServerStandard, Windows Server 2021 RTM ServerStandard Retail
    4536 = "8TNHR-FFK27-FYK6J-2HMV6-XQDVB" # ServerStandard, Windows Server 2021 RTM ServerStandard Retail
    4536 = "F8R42-NGCXQ-DJ32F-336GQ-PYW9Y" # ServerStandard, Windows Server 2021 RTM ServerStandard Retail
    4536 = "H2PN7-TKQC2-KXW32-Y7FHT-RRJ9Y" # ServerStandard, Windows Server 2021 RTM ServerStandard Retail
    4536 = "HQ7D8-RGN38-H6K3R-GVTKC-DDDVB" # ServerStandard, Windows Server 2021 RTM ServerStandard Retail
    4536 = "J7CG2-7NJ6R-734MQ-K2HQ8-GVM3M" # ServerStandard, Windows Server 2021 RTM ServerStandard Retail
    4536 = "KNPYQ-DD9CG-YMC77-QPDWQ-C397B" # ServerStandard, Windows Server 2021 RTM ServerStandard Retail
    4536 = "KPN86-6QM4M-HYDBR-WBYQ2-KW6KY" # ServerStandard, Windows Server 2021 RTM ServerStandard Retail
    4536 = "MGHPN-C2Y94-BBFXF-F7C89-H6GKY" # ServerStandard, Windows Server 2021 RTM ServerStandard Retail
    4536 = "NPYF4-TCBBR-V2Q4Y-B44QG-8T3VB" # ServerStandard, Windows Server 2021 RTM ServerStandard Retail
    4536 = "RGN6B-MCPWX-6K6GK-HKM33-7VCXY" # ServerStandard, Windows Server 2021 RTM ServerStandard Retail
    4536 = "W2NVH-C7XF7-BT2DF-BQH9Q-GF7HB" # ServerStandard, Windows Server 2021 RTM ServerStandard Retail
    4537 = "FJ2NR-W8KQQ-43CB3-334YR-6Q97C" # ServerStandard, Windows Server 2021 RTM ServerStandard OEM:NONSLP
    4537 = "M2NYV-GVQY7-YXJP8-RGFY6-J2TK2" # ServerStandard, Windows Server 2021 RTM ServerStandard OEM:NONSLP
    4537 = "MD7HM-NK4P7-QW7B2-R6CXF-2KFQP" # ServerStandard, Windows Server 2021 RTM ServerStandard OEM:NONSLP
    4537 = "N2YKT-TKV3W-K362C-MQXDH-RGGK2" # ServerStandard, Windows Server 2021 RTM ServerStandard OEM:NONSLP
    4537 = "QQPN8-4X7RM-36P76-W92XC-7CHHC" # ServerStandard, Windows Server 2021 RTM ServerStandard OEM:NONSLP
    4537 = "WBQNF-2PXT3-KPQM3-RQRMT-D3Y3P" # ServerStandard, Windows Server 2021 RTM ServerStandard OEM:NONSLP
    4538 = "CXJNR-DHJQF-R6B43-PMYMW-RYB3Q" # ServerStandard, Windows Server 2021 RTM ServerStandard OEM:NONSLP (MUI locked to zh-CN)
    4538 = "HG69N-RBH6D-RDBF4-2TGDK-6CTK3" # ServerStandard, Windows Server 2021 RTM ServerStandard OEM:NONSLP (MUI locked to zh-CN)
    4538 = "JN784-D4977-TW24C-M8MJ8-Q7CX3" # ServerStandard, Windows Server 2021 RTM ServerStandard OEM:NONSLP (MUI locked to zh-CN)
    4538 = "N68DG-T62WY-739X6-VW2HR-847HD" # ServerStandard, Windows Server 2021 RTM ServerStandard OEM:NONSLP (MUI locked to zh-CN)
    4538 = "PDK8P-7NB39-BBHXD-Q4FPG-9K2X3" # ServerStandard, Windows Server 2021 RTM ServerStandard OEM:NONSLP (MUI locked to zh-CN)
    4538 = "WTGKV-7NM3M-VD2PC-FGFY6-VCHHD" # ServerStandard, Windows Server 2021 RTM ServerStandard OEM:NONSLP (MUI locked to zh-CN)
    4539 = "N3W2V-3VV4X-XPJF3-H8VKB-43PX4" # ServerStandard, Windows Server 2021 RTM ServerStandard OEM:SLP
    4539 = "P9KVN-MF987-CCFW4-TV7R3-63DVF" # ServerStandard, Windows Server 2021 RTM ServerStandard OEM:SLP
    4539 = "T7DWT-NQPJX-XX62J-YG93D-49FQR" # ServerStandard, Windows Server 2021 RTM ServerStandard OEM:SLP
    4540 = "NP7CW-B37XX-W4DBP-H98GX-P397G" # ServerStandard, Windows Server 2021 RTM ServerStandard OEM:SLP (MUI locked to zh-CN)
    4540 = "PG3P6-H8N26-4F86W-XXT4B-F9FQT" # ServerStandard, Windows Server 2021 RTM ServerStandard OEM:SLP (MUI locked to zh-CN)
    4540 = "YXTWN-R83WM-963FK-G2QM2-D7CX6" # ServerStandard, Windows Server 2021 RTM ServerStandard OEM:SLP (MUI locked to zh-CN)
    4541 = "NHB69-V77PJ-F86MF-2DHCK-66RQV" # ServerStandard, Windows Server 2021 RTM ServerStandard Volume:GVLK
    4541 = "VDYBN-27WPP-V4HQT-9VMD4-VMK7H" # ServerStandard, Windows Server 2021 RTM ServerStandard Volume:GVLK
    4542 = "2834W-NFFFF-W9498-H8YCC-VFWDW" # ServerStandard;ServerStandardACor, Windows Server 2021 RTM ServerStandard;ServerStandardACor Volume:MAK
    4542 = "297RH-2NQPC-2MQ7W-PKB7F-37CX8" # ServerStandard;ServerStandardACor, Windows Server 2021 RTM ServerStandard;ServerStandardACor Volume:MAK
    4542 = "6R3NJ-HKC2W-XVGTR-9VPG9-KQDVJ" # ServerStandard;ServerStandardACor, Windows Server 2021 RTM ServerStandard;ServerStandardACor Volume:MAK
    4542 = "8JV7X-4N83C-TV2XQ-36HY3-Y4J98" # ServerStandard;ServerStandardACor, Windows Server 2021 RTM ServerStandard;ServerStandardACor Volume:MAK
    4542 = "8NJXT-2BB2W-TCK44-QCB4V-6X2X8" # ServerStandard;ServerStandardACor, Windows Server 2021 RTM ServerStandard;ServerStandardACor Volume:MAK
    4542 = "HMND6-WBK9D-VF7Y7-W4DJT-QYK7J" # ServerStandard;ServerStandardACor, Windows Server 2021 RTM ServerStandard;ServerStandardACor Volume:MAK
    4542 = "J7RJ8-J4NJY-BWDT7-66VYT-PDPX8" # ServerStandard;ServerStandardACor, Windows Server 2021 RTM ServerStandard;ServerStandardACor Volume:MAK
    4542 = "JBTGN-HV2MF-3P6FK-X8JR8-BWVHJ" # ServerStandard;ServerStandardACor, Windows Server 2021 RTM ServerStandard;ServerStandardACor Volume:MAK
    4542 = "K887N-DT3GV-C3XVJ-D9DDX-2YW98" # ServerStandard;ServerStandardACor, Windows Server 2021 RTM ServerStandard;ServerStandardACor Volume:MAK
    4542 = "M7JRN-YRJDV-MCYM2-QCVJQ-C397J" # ServerStandard;ServerStandardACor, Windows Server 2021 RTM ServerStandard;ServerStandardACor Volume:MAK
    4542 = "P2V3B-YNKF6-2B78M-FHHH4-K4WDW" # ServerStandard;ServerStandardACor, Windows Server 2021 RTM ServerStandard;ServerStandardACor Volume:MAK
    4542 = "PY7P6-N2TRX-RQFGK-76FVT-HFWDW" # ServerStandard;ServerStandardACor, Windows Server 2021 RTM ServerStandard;ServerStandardACor Volume:MAK
    4542 = "PYFP6-H4NTH-6CW29-DD7FJ-HMK7J" # ServerStandard;ServerStandardACor, Windows Server 2021 RTM ServerStandard;ServerStandardACor Volume:MAK
    4542 = "PYXGB-7NCCP-WJ6BM-24P4M-6VM3W" # ServerStandard;ServerStandardACor, Windows Server 2021 RTM ServerStandard;ServerStandardACor Volume:MAK
    4542 = "TTNVD-BVVX2-9G9WR-2PRHW-WB8DW" # ServerStandard;ServerStandardACor, Windows Server 2021 RTM ServerStandard;ServerStandardACor Volume:MAK
    4542 = "WBKVN-P3VGM-C2T4W-GFJXF-9W6K8" # ServerStandard;ServerStandardACor, Windows Server 2021 RTM ServerStandard;ServerStandardACor Volume:MAK
    4543 = "YDFWN-MJ9JR-3DYRK-FXXRW-78VHK" # ServerStandard;ServerStandardACor, Windows Server 2021 RTM ServerStandard;ServerStandardACor VT:IA
    4544 = "7PBJM-MNVPD-MBQD7-TYTY4-W8JDY" # ServerStandardEval, Windows Server 2021 RTM ServerStandardEval Retail:TB:Eval
    4544 = "C6NT2-9VP7V-64KKG-CT2GW-7FWDY" # ServerStandardEval, Windows Server 2021 RTM ServerStandardEval Retail:TB:Eval
    4545 = "C2DBY-6WNJ6-6WHK3-HW332-KW6MC" # ServerStandard, Windows Server 2021 RTM ServerStandard OEM:DM
    4545 = "MNX9Y-RT3CW-T3QTC-M4VF4-FC4Q2" # ServerStandard, Windows Server 2021 RTM ServerStandard OEM:DM
    4545 = "PXF2X-NBGXT-KW8JK-J26WM-R63VP" # ServerStandard, Windows Server 2021 RTM ServerStandard OEM:DM
    4545 = "Q4HNG-3WYDQ-PKBWT-79QBJ-6MXBC" # ServerStandard, Windows Server 2021 RTM ServerStandard OEM:DM
    4546 = "WX4NM-KYWYW-QJJR4-XV3QB-6VM33" # ServerDatacenter, Windows Server 2021 RTM ServerDatacenter Volume:GVLK
    4546 = "X93C6-JNQJY-CC77M-6YKVG-6F7HQ" # ServerDatacenter, Windows Server 2021 RTM ServerDatacenter Volume:GVLK
    4547 = "6RJJ9-NKCTF-76GV7-DGG8Y-X4WD4" # ServerDatacenter;ServerDatacenterACor;AzureStackHCIAddOn2021, Windows Server 2021 RTM ServerDatacenter;ServerDatacenterACor;AzureStackHCIAddOn2021 Volume:MAK
    4547 = "7VQJT-N23WT-2HMP9-7W4D9-PBB34" # ServerDatacenter;ServerDatacenterACor;AzureStackHCIAddOn2021, Windows Server 2021 RTM ServerDatacenter;ServerDatacenterACor;AzureStackHCIAddOn2021 Volume:MAK
    4547 = "9BMYB-GN7RV-G489D-7BWGJ-2G3VR" # ServerDatacenter;ServerDatacenterACor;AzureStackHCIAddOn2021, Windows Server 2021 RTM ServerDatacenter;ServerDatacenterACor;AzureStackHCIAddOn2021 Volume:MAK
    4547 = "B2QD7-NXJHP-4QWDC-QHDR9-C7M34" # ServerDatacenter;ServerDatacenterACor;AzureStackHCIAddOn2021, Windows Server 2021 RTM ServerDatacenter;ServerDatacenterACor;AzureStackHCIAddOn2021 Volume:MAK
    4547 = "CBN9J-VBJDY-Y746C-682YV-QPHHR" # ServerDatacenter;ServerDatacenterACor;AzureStackHCIAddOn2021, Windows Server 2021 RTM ServerDatacenter;ServerDatacenterACor;AzureStackHCIAddOn2021 Volume:MAK
    4547 = "KYHMJ-2NWHP-46BHJ-TGKYG-RRKBF" # ServerDatacenter;ServerDatacenterACor;AzureStackHCIAddOn2021, Windows Server 2021 RTM ServerDatacenter;ServerDatacenterACor;AzureStackHCIAddOn2021 Volume:MAK
    4547 = "MGVMN-Q7H2G-QD434-JR9R7-R9FQ4" # ServerDatacenter;ServerDatacenterACor;AzureStackHCIAddOn2021, Windows Server 2021 RTM ServerDatacenter;ServerDatacenterACor;AzureStackHCIAddOn2021 Volume:MAK
    4547 = "MGWQP-KNTBJ-7CRKH-8739G-3V9BF" # ServerDatacenter;ServerDatacenterACor;AzureStackHCIAddOn2021, Windows Server 2021 RTM ServerDatacenter;ServerDatacenterACor;AzureStackHCIAddOn2021 Volume:MAK
    4547 = "MTNJV-6MHH7-V33CQ-K44BJ-CPTMF" # ServerDatacenter;ServerDatacenterACor;AzureStackHCIAddOn2021, Windows Server 2021 RTM ServerDatacenter;ServerDatacenterACor;AzureStackHCIAddOn2021 Volume:MAK
    4547 = "NJ68J-BG2FR-P7KKR-4XX68-JFKBF" # ServerDatacenter;ServerDatacenterACor;AzureStackHCIAddOn2021, Windows Server 2021 RTM ServerDatacenter;ServerDatacenterACor;AzureStackHCIAddOn2021 Volume:MAK
    4547 = "TYQ8N-4HKJW-B7XDK-K399H-B7X7R" # ServerDatacenter;ServerDatacenterACor;AzureStackHCIAddOn2021, Windows Server 2021 RTM ServerDatacenter;ServerDatacenterACor;AzureStackHCIAddOn2021 Volume:MAK
    4547 = "W6CKN-HP9DY-T4W27-WKX4Y-3GRQ4" # ServerDatacenter;ServerDatacenterACor;AzureStackHCIAddOn2021, Windows Server 2021 RTM ServerDatacenter;ServerDatacenterACor;AzureStackHCIAddOn2021 Volume:MAK
    4547 = "XGMFN-4FDR6-JRKJD-T8XXC-DDDVR" # ServerDatacenter;ServerDatacenterACor;AzureStackHCIAddOn2021, Windows Server 2021 RTM ServerDatacenter;ServerDatacenterACor;AzureStackHCIAddOn2021 Volume:MAK
    4547 = "YFQ8B-X4NXY-K3Q8V-8GD99-2YXBF" # ServerDatacenter;ServerDatacenterACor;AzureStackHCIAddOn2021, Windows Server 2021 RTM ServerDatacenter;ServerDatacenterACor;AzureStackHCIAddOn2021 Volume:MAK
    4547 = "YW9YN-7P4DB-78C9Q-GR9KY-DPHHR" # ServerDatacenter;ServerDatacenterACor;AzureStackHCIAddOn2021, Windows Server 2021 RTM ServerDatacenter;ServerDatacenterACor;AzureStackHCIAddOn2021 Volume:MAK
    4548 = "W3GNR-8DDXR-2TFRP-H8P33-DV9BG" # ServerDatacenter;ServerDatacenterACor, Windows Server 2021 RTM ServerDatacenter;ServerDatacenterACor VT:IA
    4549 = "3CX3Q-2TNR7-YKMKF-D2XXK-P397V" # ServerDatacenter;AzureStackHCIAddOn2021, Windows Server 2021 RTM ServerDatacenter;AzureStackHCIAddOn2021 OEM:NONSLP
    4549 = "D62JN-WX6RW-GTF74-66MXB-KD97V" # ServerDatacenter;AzureStackHCIAddOn2021, Windows Server 2021 RTM ServerDatacenter;AzureStackHCIAddOn2021 OEM:NONSLP
    4549 = "FGWXN-HFG3G-RP8QP-K2PP7-KHM37" # ServerDatacenter;AzureStackHCIAddOn2021, Windows Server 2021 RTM ServerDatacenter;AzureStackHCIAddOn2021 OEM:NONSLP
    4549 = "KRNFJ-J9C2X-RTKXJ-HTYQM-XBXBH" # ServerDatacenter;AzureStackHCIAddOn2021, Windows Server 2021 RTM ServerDatacenter;AzureStackHCIAddOn2021 OEM:NONSLP
    4549 = "N9MQH-QXDTG-T8BJH-4TVTF-BY8D7" # ServerDatacenter;AzureStackHCIAddOn2021, Windows Server 2021 RTM ServerDatacenter;AzureStackHCIAddOn2021 OEM:NONSLP
    4549 = "RWNK2-CCDP7-MRFWG-7X2GB-FGGMH" # ServerDatacenter;AzureStackHCIAddOn2021, Windows Server 2021 RTM ServerDatacenter;AzureStackHCIAddOn2021 OEM:NONSLP
    4549 = "XNPCT-46K89-H76TG-P2JMY-K79BH" # ServerDatacenter;AzureStackHCIAddOn2021, Windows Server 2021 RTM ServerDatacenter;AzureStackHCIAddOn2021 OEM:NONSLP
    4550 = "NWQC7-66H9M-KCFVW-4MV3D-VXQVW" # ServerDatacenter, Windows Server 2021 RTM ServerDatacenter OEM:NONSLP (MUI locked to zh-CN)
    4550 = "TQX9B-QNRMT-MMG6M-29W8J-XW6MJ" # ServerDatacenter, Windows Server 2021 RTM ServerDatacenter OEM:NONSLP (MUI locked to zh-CN)
    4550 = "XWD34-NHHD6-9YT86-FHT6H-X79BJ" # ServerDatacenter, Windows Server 2021 RTM ServerDatacenter OEM:NONSLP (MUI locked to zh-CN)
    4551 = "JNQWG-JJ4VK-834KQ-PMDRB-F9FQ9" # ServerDatacenter;AzureStackHCIAddOn2021, Windows Server 2021 RTM ServerDatacenter;AzureStackHCIAddOn2021 OEM:SLP
    4551 = "MJHNM-FY74T-324GW-BRVX2-P92YK" # ServerDatacenter;AzureStackHCIAddOn2021, Windows Server 2021 RTM ServerDatacenter;AzureStackHCIAddOn2021 OEM:SLP
    4551 = "NQYW3-6CPQY-X6PC3-9TWYP-RVX7X" # ServerDatacenter;AzureStackHCIAddOn2021, Windows Server 2021 RTM ServerDatacenter;AzureStackHCIAddOn2021 OEM:SLP
    4552 = "C7NK6-D4VT2-DCXVQ-74WWH-CYXBM" # ServerDatacenter, Windows Server 2021 RTM ServerDatacenter OEM:SLP (MUI locked to zh-CN)
    4552 = "NKXF6-2QQCR-XG833-M7MBB-BBK7Y" # ServerDatacenter, Windows Server 2021 RTM ServerDatacenter OEM:SLP (MUI locked to zh-CN)
    4555 = "8HFYN-J9P27-4CPWF-8YJYF-F63V4" # ServerDatacenterEval, Windows Server 2021 RTM ServerDatacenterEval Retail:TB:Eval
    4555 = "PK7JN-24236-FH7JP-V792F-37CYR" # ServerDatacenterEval, Windows Server 2021 RTM ServerDatacenterEval Retail:TB:Eval
    4556 = "4PV9K-NRWQ6-HJ8FV-B68XJ-DGRRG" # ServerStandardACor, Windows Server 2021 RTM ServerStandardACor Volume:GVLK
    4556 = "67KN8-4FYJW-2487Q-MQ2J7-4C4RG" # ServerStandardACor, Windows Server 2021 RTM ServerStandardACor Volume:GVLK
    4557 = "QFND9-D3Y9C-J3KKY-6RPVP-2DPYV" # ServerDatacenterACor, Windows Server 2021 RTM ServerDatacenterACor Volume:GVLK
    4557 = "YNVYH-P6CR8-GKP9K-29KYD-M7X77" # ServerDatacenterACor, Windows Server 2021 RTM ServerDatacenterACor Volume:GVLK
    4560 = "8772M-RNXMH-7T8MF-W8DHV-JQPYY" # ServerStandard, Windows Server 2021 RTM ServerStandard OEM:DM (MUI locked to zh-CN)
    4560 = "CPW9C-XKN3K-CPDPH-C3D2F-PPTMY" # ServerStandard, Windows Server 2021 RTM ServerStandard OEM:DM (MUI locked to zh-CN)
    4560 = "HPKV9-N2QDD-VCJCF-7KDYY-6VM4M" # ServerStandard, Windows Server 2021 RTM ServerStandard OEM:DM (MUI locked to zh-CN)
    4560 = "XMH43-CNGJC-66WGR-FXY82-9QDWB" # ServerStandard, Windows Server 2021 RTM ServerStandard OEM:DM (MUI locked to zh-CN)
    4561 = "GPR6M-GNJYJ-79F9R-FGVJG-BP4RP" # ServerDatacenter, Windows Server 2021 RTM ServerDatacenter OEM:DM (MUI locked to zh-CN)
    4561 = "MK2NQ-Y6D2R-WDWCY-VD7DG-8T3WC" # ServerDatacenter, Windows Server 2021 RTM ServerDatacenter OEM:DM (MUI locked to zh-CN)
    4561 = "P3VG3-6N9Y8-6YPRP-YDCWD-QRWFP" # ServerDatacenter, Windows Server 2021 RTM ServerDatacenter OEM:DM (MUI locked to zh-CN)
    4561 = "YKVRV-6MN28-VKQ8Q-3VY7T-HFWFP" # ServerDatacenter, Windows Server 2021 RTM ServerDatacenter OEM:DM (MUI locked to zh-CN)
    4562 = "6N379-GGTMK-23C6M-XVVTC-CKFRQ" # ServerAzureCor, Windows Server 2021 RTM ServerAzureCor Volume:GVLK
    4562 = "FD8RN-MHFGM-VM69M-H9D67-94WFQ" # ServerAzureCor, Windows Server 2021 RTM ServerAzureCor Volume:GVLK
    4563 = "4Y4VW-JNWTF-V7MB8-9CCWT-9K2Y4" # ServerAzureCor, Windows Server 2021 RTM ServerAzureCor VT:IA
    4565 = "2BNVX-7P2HB-GD6QV-GQ9R9-MHCY7" # ServerDatacenter;AzureStackHCIAddOn2021, Windows Server 2021 RTM ServerDatacenter;AzureStackHCIAddOn2021 Retail
    4565 = "6N8G6-HY8KT-HYXXJ-2BJX6-9K2Y7" # ServerDatacenter;AzureStackHCIAddOn2021, Windows Server 2021 RTM ServerDatacenter;AzureStackHCIAddOn2021 Retail
    4565 = "BY2FC-RNHV6-6KFVH-BKR83-XHM4V" # ServerDatacenter;AzureStackHCIAddOn2021, Windows Server 2021 RTM ServerDatacenter;AzureStackHCIAddOn2021 Retail
    4565 = "DNVBD-FCT8Y-TQT8Q-HGQ34-QGRRV" # ServerDatacenter;AzureStackHCIAddOn2021, Windows Server 2021 RTM ServerDatacenter;AzureStackHCIAddOn2021 Retail
    4565 = "DXPGX-NYMVJ-T7XJK-GFFVC-YKQWH" # ServerDatacenter;AzureStackHCIAddOn2021, Windows Server 2021 RTM ServerDatacenter;AzureStackHCIAddOn2021 Retail
    4565 = "DXVNR-HHTTP-MQHWH-3G72R-VMK8H" # ServerDatacenter;AzureStackHCIAddOn2021, Windows Server 2021 RTM ServerDatacenter;AzureStackHCIAddOn2021 Retail
    4565 = "FHBMM-XN22J-WWQF2-R9XQH-G6RRV" # ServerDatacenter;AzureStackHCIAddOn2021, Windows Server 2021 RTM ServerDatacenter;AzureStackHCIAddOn2021 Retail
    4565 = "K8YNX-H7JD4-X72P9-4H39M-92HJH" # ServerDatacenter;AzureStackHCIAddOn2021, Windows Server 2021 RTM ServerDatacenter;AzureStackHCIAddOn2021 Retail
    4565 = "KHHCJ-FNXM6-F477D-6MYTK-7XQWH" # ServerDatacenter;AzureStackHCIAddOn2021, Windows Server 2021 RTM ServerDatacenter;AzureStackHCIAddOn2021 Retail
    4565 = "NFMH6-V6FRQ-3MPDY-WG6QG-J2TM7" # ServerDatacenter;AzureStackHCIAddOn2021, Windows Server 2021 RTM ServerDatacenter;AzureStackHCIAddOn2021 Retail
    4565 = "NJY4Y-229CH-H2QP4-TBB2J-J8JFV" # ServerDatacenter;AzureStackHCIAddOn2021, Windows Server 2021 RTM ServerDatacenter;AzureStackHCIAddOn2021 Retail
    4565 = "TFTJM-B3N6H-84Y3Q-MCJ8G-VCHJH" # ServerDatacenter;AzureStackHCIAddOn2021, Windows Server 2021 RTM ServerDatacenter;AzureStackHCIAddOn2021 Retail
    4565 = "WJ9QN-KX4WR-CKR4M-8RV7B-DPHJH" # ServerDatacenter;AzureStackHCIAddOn2021, Windows Server 2021 RTM ServerDatacenter;AzureStackHCIAddOn2021 Retail
    4565 = "WXNM4-KRMYT-9JKWG-MG467-MBK8H" # ServerDatacenter;AzureStackHCIAddOn2021, Windows Server 2021 RTM ServerDatacenter;AzureStackHCIAddOn2021 Retail
    4565 = "Y4MQV-MDNT4-3PW39-GJX7X-DYK8H" # ServerDatacenter;AzureStackHCIAddOn2021, Windows Server 2021 RTM ServerDatacenter;AzureStackHCIAddOn2021 Retail
    4572 = "7TD79-NPMYW-H68D6-MY4YK-XK22G" # ServerDatacenter;AzureStackHCIAddOn2021, Windows Server 2021 RTM ServerDatacenter;AzureStackHCIAddOn2021 OEM:DM
    4572 = "FCJJ4-DNVYT-YF7W2-KVQMG-RRKCG" # ServerDatacenter;AzureStackHCIAddOn2021, Windows Server 2021 RTM ServerDatacenter;AzureStackHCIAddOn2021 OEM:DM
    4572 = "N284D-FB9T9-C9MFC-P3JGB-X4WF6" # ServerDatacenter;AzureStackHCIAddOn2021, Windows Server 2021 RTM ServerDatacenter;AzureStackHCIAddOn2021 OEM:DM
    4572 = "Q7ND4-CDF3J-DRRVX-KHJB8-XW6PG" # ServerDatacenter;AzureStackHCIAddOn2021, Windows Server 2021 RTM ServerDatacenter;AzureStackHCIAddOn2021 OEM:DM
    4573 = "PFNQH-YMP9J-P26QP-828RK-JXFR7" # ServerDatacenter;ServerStandard, Windows Server 2021 RTM ServerDatacenter;ServerStandard Volume:CSVLK
    4573 = "TP6TK-PNGYM-X9H6Y-739QX-2YXCH" # ServerDatacenter;ServerStandard, Windows Server 2021 RTM ServerDatacenter;ServerStandard Volume:CSVLK
    4574 = "HWCCP-TN49X-DPFMT-6X7H9-T86PJ" # ServerDatacenter;ServerStandard, Windows Server 2021 RTM ServerDatacenter;ServerStandard Volume:CSVLK Azure Only
    4575 = "4PN6V-F66TT-4B8KW-2KP6C-2DP2K" # ServerDatacenter;ServerStandard, Windows Server 2021 RTM ServerDatacenter;ServerStandard Volume:CSVLK VL Additional Lab
    4757 = "8NKR4-H749K-MHX6C-4XW8J-XW6Y7" # CloudEdition, Win 10 RTM CloudEdition OEM:DM
    4757 = "B3GWG-NCWYM-HXH3F-4237X-DYMJH" # CloudEdition, Win 10 RTM CloudEdition OEM:DM
    4757 = "CGGNM-K8W6H-MRFVK-WD6F2-VFWRV" # CloudEdition, Win 10 RTM CloudEdition OEM:DM
    4757 = "F2MNX-VHBBM-2GBJ7-GYVPY-B4KM7" # CloudEdition, Win 10 RTM CloudEdition OEM:DM
    4757 = "GKHVJ-FKN6Q-VRP6G-XBCW9-TF7WH" # CloudEdition, Win 10 RTM CloudEdition OEM:DM
    4757 = "GW7NY-WJT96-3KBC8-DF9DV-7Q2FV" # CloudEdition, Win 10 RTM CloudEdition OEM:DM
    4757 = "PGNCQ-9XTMD-322KW-HCVHB-MY8RV" # CloudEdition, Win 10 RTM CloudEdition OEM:DM
    4757 = "PNWFF-78XV6-DCG2W-GXF9J-DGR4V" # CloudEdition, Win 10 RTM CloudEdition OEM:DM
    4757 = "QNB64-9P2V3-2D4VV-T6WTB-FGGY7" # CloudEdition, Win 10 RTM CloudEdition OEM:DM
    4758 = "2NMRJ-FQ887-3WHBX-83WMC-KW6Y8" # CloudEdition, Win 10 RTM CloudEdition Retail
    4758 = "3QPC2-84NB3-464D9-TTHPK-WT38J" # CloudEdition, Win 10 RTM CloudEdition Retail
    4758 = "7G7DB-RNHQT-VTG2X-QXVGV-4638J" # CloudEdition, Win 10 RTM CloudEdition Retail
    4758 = "7N993-QCW69-R88QH-XYRDW-82TY8" # CloudEdition, Win 10 RTM CloudEdition Retail
    4758 = "8N7D9-Y2MRR-GBFBH-BMBJC-PG38J" # CloudEdition, Win 10 RTM CloudEdition Retail
    4758 = "8ND2F-393R6-9WHTM-B2WD7-BD2FW" # CloudEdition, Win 10 RTM CloudEdition Retail
    4758 = "J82Q8-N869X-K63RQ-JVDBR-CR7WJ" # CloudEdition, Win 10 RTM CloudEdition Retail
    4758 = "KY7PN-VR6RX-83W6Y-6DDYQ-T6R4W" # CloudEdition, Win 10 RTM CloudEdition Retail
    4758 = "N7HPV-JW748-BT6FG-GCKRQ-Y4KM8" # CloudEdition, Win 10 RTM CloudEdition Retail
    4758 = "TCKDQ-NV4P6-MP6R9-DDWQT-KTR4W" # CloudEdition, Win 10 RTM CloudEdition Retail
    4758 = "VPHNR-VDBBX-VGV8K-CB2H3-JT38J" # CloudEdition, Win 10 RTM CloudEdition Retail
    4758 = "XRX7G-NK6GM-PW94R-8KM9Q-VXQ8J" # CloudEdition, Win 10 RTM CloudEdition Retail
    4758 = "YNVGW-3XJ9P-YHYFF-F2JPR-KBXM8" # CloudEdition, Win 10 RTM CloudEdition Retail
    4759 = "37D7F-N49CB-WQR8W-TBJ73-FM8RX" # CloudEdition, Win 10 RTM CloudEdition Volume:GVLK
    4759 = "3VPNT-B47BK-J8CXP-QXDHR-F638K" # CloudEdition, Win 10 RTM CloudEdition Volume:GVLK
    4761 = "4NV34-327HC-GC7DD-862X6-6F7WP" # CloudEditionN, Win 10 RTM CloudEditionN OEM:DM
    4761 = "G3HMQ-GNVMW-TT8T2-7K43T-KTR42" # CloudEditionN, Win 10 RTM CloudEditionN OEM:DM
    4761 = "J6MNB-MWGW6-26MY2-GWJVR-847WP" # CloudEditionN, Win 10 RTM CloudEditionN OEM:DM
    4761 = "KN7K3-XXXFV-8CXTF-TR762-TMXPC" # CloudEditionN, Win 10 RTM CloudEditionN OEM:DM
    4761 = "NBH76-BYRPT-QKD6T-YG7PC-J47WP" # CloudEditionN, Win 10 RTM CloudEditionN OEM:DM
    4761 = "PRNY6-YFBV8-PCXH7-XT3D2-6JJR2" # CloudEditionN, Win 10 RTM CloudEditionN OEM:DM
    4761 = "TFWVX-NCTJ8-CQFHT-J4BYW-HMMJP" # CloudEditionN, Win 10 RTM CloudEditionN OEM:DM
    4761 = "YNR6W-9CDQ8-GFB3H-7RB6D-TCT2C" # CloudEditionN, Win 10 RTM CloudEditionN OEM:DM
    4761 = "YNVMC-JYBV7-B2F6C-FTGWW-4VYJP" # CloudEditionN, Win 10 RTM CloudEditionN OEM:DM
    4762 = "9CN8H-R3RG2-X28T6-R6GGG-C93CD" # CloudEditionN, Win 10 RTM CloudEditionN Retail
    4762 = "CT6HN-KWV4Y-4BD3Q-8KWTT-3V9PD" # CloudEditionN, Win 10 RTM CloudEditionN Retail
    4762 = "D6NDV-Y93J2-J8W66-29884-KBXPD" # CloudEditionN, Win 10 RTM CloudEditionN Retail
    4762 = "DNDBV-QTP9D-778BB-PCG6W-DGR43" # CloudEditionN, Win 10 RTM CloudEditionN Retail
    4762 = "FYN3J-D8V3H-7RTVW-C9G3K-KQD8Q" # CloudEditionN, Win 10 RTM CloudEditionN Retail
    4762 = "GWN6K-QCP7G-JTKG9-7KQK3-G862D" # CloudEditionN, Win 10 RTM CloudEditionN Retail
    4762 = "JGW88-YTN24-PBFC9-KT4VW-K2HWQ" # CloudEditionN, Win 10 RTM CloudEditionN Retail
    4762 = "K9VKN-3BGWV-Y624W-MCRMQ-BHDCD" # CloudEditionN, Win 10 RTM CloudEditionN Retail
    4762 = "KT3NR-YCDP9-QX7D4-FT74K-4JVWQ" # CloudEditionN, Win 10 RTM CloudEditionN Retail
    4762 = "N4RTP-FVTKW-PH3DG-D483H-2R7WQ" # CloudEditionN, Win 10 RTM CloudEditionN Retail
    4762 = "XPNHM-48KQY-2JTV9-G4KX6-CG38Q" # CloudEditionN, Win 10 RTM CloudEditionN Retail
    4763 = "6XN7V-PCBDC-BDBRH-8DQY7-G6R44" # CloudEditionN, Win 10 RTM CloudEditionN Volume:GVLK
    4763 = "FKFNJ-TCP9X-9GCHD-CV9XC-DDD8R" # CloudEditionN, Win 10 RTM CloudEditionN Volume:GVLK
    4769 = "4JNQW-WKVVT-CCRV9-WB7QD-VXQ82" # EnterpriseS, Win 2021 RTM EnterpriseS Volume:MAK
    4769 = "4MQ46-NCMGJ-X9H43-6KJCB-3GR6C" # EnterpriseS, Win 2021 RTM EnterpriseS Volume:MAK
    4769 = "8FGYJ-KNDR4-F74FY-KYQVG-V6G2P" # EnterpriseS, Win 2021 RTM EnterpriseS Volume:MAK
    4769 = "8JWTD-ND2GK-JT8GB-RXF4P-PG382" # EnterpriseS, Win 2021 RTM EnterpriseS Volume:MAK
    4769 = "BBD87-NGJR6-DTJ8J-323T6-FVYJ2" # EnterpriseS, Win 2021 RTM EnterpriseS Volume:MAK
    4769 = "BDX8K-KFNWV-7C74Y-8CVD4-YTG2P" # EnterpriseS, Win 2021 RTM EnterpriseS Volume:MAK
    4769 = "G9J6W-RQNGR-27GRP-XCQVD-RJVW2" # EnterpriseS, Win 2021 RTM EnterpriseS Volume:MAK
    4769 = "GNX33-YFGPD-JRGHP-X23CT-MKQ82" # EnterpriseS, Win 2021 RTM EnterpriseS Volume:MAK
    4769 = "HJ7GN-4KGM2-R2PQK-8Q663-KK3CP" # EnterpriseS, Win 2021 RTM EnterpriseS Volume:MAK
    4769 = "HQ78G-9N72F-7KXHD-TXBHB-DPHW2" # EnterpriseS, Win 2021 RTM EnterpriseS Volume:MAK
    4769 = "J4C9R-DPN23-R34HV-P93C8-7FWTC" # EnterpriseS, Win 2021 RTM EnterpriseS Volume:MAK
    4769 = "J7QXR-WN7VD-T7JFX-QQM8K-GJJTC" # EnterpriseS, Win 2021 RTM EnterpriseS Volume:MAK
    4769 = "JN3RP-H2MMQ-6CM7W-F6Y6V-B7YJ2" # EnterpriseS, Win 2021 RTM EnterpriseS Volume:MAK
    4769 = "K3J7N-HM466-6T72W-8QF8P-YKQ82" # EnterpriseS, Win 2021 RTM EnterpriseS Volume:MAK
    4769 = "KCNVH-YKWX8-GJJB9-H9FDT-6F7W2" # EnterpriseS, Win 2021 RTM EnterpriseS Volume:MAK
    4769 = "KN9Y8-T98MW-TXQFB-7X3B9-Y7YJ2" # EnterpriseS, Win 2021 RTM EnterpriseS Volume:MAK
    4769 = "KTQFW-N9DK2-2C63C-JVTYX-JXF6C" # EnterpriseS, Win 2021 RTM EnterpriseS Volume:MAK
    4769 = "MKNJG-J94J7-7YC98-69RT2-JB8TC" # EnterpriseS, Win 2021 RTM EnterpriseS Volume:MAK
    4769 = "MMP62-6NQ7X-4H2MB-YQP44-PPT2P" # EnterpriseS, Win 2021 RTM EnterpriseS Volume:MAK
    4769 = "N466W-WJXHV-HPRD4-624W4-4YCGC" # EnterpriseS, Win 2021 RTM EnterpriseS Volume:MAK
    4769 = "N8VP3-BGR7J-3HF3F-WDG2T-24BJ2" # EnterpriseS, Win 2021 RTM EnterpriseS Volume:MAK
    4769 = "NTX8X-FY2D7-B69Y4-JYCGQ-YBMJ2" # EnterpriseS, Win 2021 RTM EnterpriseS Volume:MAK
    4769 = "NWBT3-W2JH2-Q83PT-BG6QV-7Q2GC" # EnterpriseS, Win 2021 RTM EnterpriseS Volume:MAK
    4769 = "NWYPH-VFG9F-4QYTH-JY7VD-G862P" # EnterpriseS, Win 2021 RTM EnterpriseS Volume:MAK
    4769 = "PK3N8-48M34-FFXJP-HQ4R6-GMXPP" # EnterpriseS, Win 2021 RTM EnterpriseS Volume:MAK
    4769 = "PV8NQ-XPMVM-9B2QG-J64H9-BKQ82" # EnterpriseS, Win 2021 RTM EnterpriseS Volume:MAK
    4769 = "RMN46-66F39-G3WXV-XJHWF-R3QCP" # EnterpriseS, Win 2021 RTM EnterpriseS Volume:MAK
    4769 = "VRNH8-CTRD8-HD2CX-98QH4-WFKPP" # EnterpriseS, Win 2021 RTM EnterpriseS Volume:MAK
    4769 = "VRPVK-97N94-37MGM-DD8F3-C4BJ2" # EnterpriseS, Win 2021 RTM EnterpriseS Volume:MAK
    4769 = "W3GHN-PW36G-2FWB8-MGFCK-MHDCP" # EnterpriseS, Win 2021 RTM EnterpriseS Volume:MAK
    4769 = "W44NH-Q6Y9P-YDY3J-VVRR3-C4BJ2" # EnterpriseS, Win 2021 RTM EnterpriseS Volume:MAK
    4769 = "X2NTW-KDV76-PHKQT-4CCK3-979PP" # EnterpriseS, Win 2021 RTM EnterpriseS Volume:MAK
    4769 = "YBR2F-8JN4R-CWPWM-JJQ3J-332GC" # EnterpriseS, Win 2021 RTM EnterpriseS Volume:MAK
    4769 = "YY2YD-RMNY3-BHTJ4-2HCDH-94WTC" # EnterpriseS, Win 2021 RTM EnterpriseS Volume:MAK
    4771 = "6QKRP-NX39T-BQTMH-HDHXM-92HW4" # EnterpriseSEval, Win 2021 RTM EnterpriseSEval Retail:TB:Eval
    4771 = "9V4NK-624Y3-VK47R-Q27GP-27PGF" # EnterpriseSEval, Win 2021 RTM EnterpriseSEval Retail:TB:Eval
    4772 = "2T72N-RBB4R-XDVD9-PK4MC-V8VW6" # EnterpriseSN, Win 2021 RTM EnterpriseSN Volume:MAK
    4772 = "3DPN6-TRF6V-QVGWB-4DYD4-QGR6G" # EnterpriseSN, Win 2021 RTM EnterpriseSN Volume:MAK
    4772 = "3HGJF-N7PPJ-TR2X9-VF77T-RRKPT" # EnterpriseSN, Win 2021 RTM EnterpriseSN Volume:MAK
    4772 = "3N6WD-3P8RX-D7WPX-C6Q79-JXF6G" # EnterpriseSN, Win 2021 RTM EnterpriseSN Volume:MAK
    4772 = "7F6DW-3NH9Q-H46WY-8VTXC-MP46G" # EnterpriseSN, Win 2021 RTM EnterpriseSN Volume:MAK
    4772 = "7VN49-M367R-KTCT8-7HMWC-D7DCT" # EnterpriseSN, Win 2021 RTM EnterpriseSN Volume:MAK
    4772 = "83NRW-B4K4B-P4KVP-679CD-C4BJ6" # EnterpriseSN, Win 2021 RTM EnterpriseSN Volume:MAK
    4772 = "8VJN8-22826-BQRJ7-DHQP8-W47W6" # EnterpriseSN, Win 2021 RTM EnterpriseSN Volume:MAK
    4772 = "BT7N8-B74YP-HT6X2-JRMQM-XBXPT" # EnterpriseSN, Win 2021 RTM EnterpriseSN Volume:MAK
    4772 = "C9NVC-FWY3D-WM97C-P2TCJ-VH9PT" # EnterpriseSN, Win 2021 RTM EnterpriseSN Volume:MAK
    4772 = "D8KNH-97F7M-C3HXR-2W27K-HCHW6" # EnterpriseSN, Win 2021 RTM EnterpriseSN Volume:MAK
    4772 = "DBCP8-RCNTK-H6KMC-MC674-WFKPT" # EnterpriseSN, Win 2021 RTM EnterpriseSN Volume:MAK
    4772 = "DH9CD-TKNQH-W3H7G-GD6JT-9K3CT" # EnterpriseSN, Win 2021 RTM EnterpriseSN Volume:MAK
    4772 = "DK9J7-48N4D-8BBWJ-8F3TK-TF7W6" # EnterpriseSN, Win 2021 RTM EnterpriseSN Volume:MAK
    4772 = "GD4TT-HKNR7-PT36K-FF64G-PDQCT" # EnterpriseSN, Win 2021 RTM EnterpriseSN Volume:MAK
    4772 = "K9FXH-4MNKM-PVHJX-XGDPW-GVPGG" # EnterpriseSN, Win 2021 RTM EnterpriseSN Volume:MAK
    4772 = "MWQWD-RBNQY-MHR6D-KBDWT-GMXPT" # EnterpriseSN, Win 2021 RTM EnterpriseSN Volume:MAK
    4772 = "N9VRJ-XP7GQ-87PGB-Y8QDV-7Q2GG" # EnterpriseSN, Win 2021 RTM EnterpriseSN Volume:MAK
    4772 = "NC6G4-8B8VK-6V9JR-MFQ2R-4YCGG" # EnterpriseSN, Win 2021 RTM EnterpriseSN Volume:MAK
    4772 = "NP7GF-CD2DT-C89MP-YP69F-GX3CT" # EnterpriseSN, Win 2021 RTM EnterpriseSN Volume:MAK
    4772 = "NQJWP-FG6GT-HBP7G-K3M2R-KBXPT" # EnterpriseSN, Win 2021 RTM EnterpriseSN Volume:MAK
    4772 = "NXF6T-26DJ6-MM67Y-HY7FD-BHDCT" # EnterpriseSN, Win 2021 RTM EnterpriseSN Volume:MAK
    4772 = "PFFMJ-JNFFD-KDBF9-JFCTJ-GVPGG" # EnterpriseSN, Win 2021 RTM EnterpriseSN Volume:MAK
    4772 = "RQFNW-9TPM3-JQ73T-QV4VQ-DV9PT" # EnterpriseSN, Win 2021 RTM EnterpriseSN Volume:MAK
    4772 = "TGC6C-KDN6P-XM9TV-F2WDD-CBCGG" # EnterpriseSN, Win 2021 RTM EnterpriseSN Volume:MAK
    4772 = "TXCNR-VQXDP-CTD8Q-XKHB2-D7DCT" # EnterpriseSN, Win 2021 RTM EnterpriseSN Volume:MAK
    4772 = "W8RN8-HHVD6-KHW3M-3GMHM-TX3CT" # EnterpriseSN, Win 2021 RTM EnterpriseSN Volume:MAK
    4772 = "XN9X7-77FQ7-KHV7R-4K4XY-7MMJ6" # EnterpriseSN, Win 2021 RTM EnterpriseSN Volume:MAK
    4772 = "XNG4T-XTCJK-WWR6C-X89QP-P93CT" # EnterpriseSN, Win 2021 RTM EnterpriseSN Volume:MAK
    4772 = "XQ8WW-N6WGD-67K88-74XDH-RGG2T" # EnterpriseSN, Win 2021 RTM EnterpriseSN Volume:MAK
    4772 = "Y448K-RN4Y2-GDPWQ-VH2GT-3V9PT" # EnterpriseSN, Win 2021 RTM EnterpriseSN Volume:MAK
    4774 = "2KWQN-4F3QX-WQDHH-WRCQF-W8JTJ" # EnterpriseSNEval, Win 2021 RTM EnterpriseSNEval Retail:TB:Eval
    4774 = "XCN62-29X92-C4T8X-WP82X-DYMJ8" # EnterpriseSNEval, Win 2021 RTM EnterpriseSNEval Retail:TB:Eval
    4842 = "6283C-4NH4W-GD3CJ-8JBCV-8HYP3" # IoTEnterpriseS, Win 11 RTM IoTEnterpriseS OEM:NONSLP
    4842 = "64N32-XGPP8-4PGVT-3RRGJ-9TR9D" # IoTEnterpriseS, Win 11 RTM IoTEnterpriseS OEM:NONSLP
    4842 = "7DVN6-RCJPQ-CX3HF-WJKB9-9HPKD" # IoTEnterpriseS, Win 11 RTM IoTEnterpriseS OEM:NONSLP
    4842 = "CGK42-GYN6Y-VD22B-BX98W-J8JXD" # IoTEnterpriseS, Win 11 RTM IoTEnterpriseS OEM:NONSLP
    4842 = "FHMN4-R6982-6T84H-CXTKF-2KF9D" # IoTEnterpriseS, Win 11 RTM IoTEnterpriseS OEM:NONSLP
    4842 = "JFXC9-GNK8B-DYXMR-MDFTG-WXF9D" # IoTEnterpriseS, Win 11 RTM IoTEnterpriseS OEM:NONSLP
    4842 = "N23DB-8RT33-334B2-PR6KH-464C3" # IoTEnterpriseS, Win 11 RTM IoTEnterpriseS OEM:NONSLP
    4842 = "N7G7Y-W494C-4YGKC-V78WR-FC49D" # IoTEnterpriseS, Win 11 RTM IoTEnterpriseS OEM:NONSLP
    4842 = "P43KT-N9FRG-BMX4Y-WP3D2-6JJXD" # IoTEnterpriseS, Win 11 RTM IoTEnterpriseS OEM:NONSLP
    4842 = "PNC4P-B6FCM-K47DW-WCV2P-Q32KD" # IoTEnterpriseS, Win 11 RTM IoTEnterpriseS OEM:NONSLP
    4842 = "Q8NCJ-PJF8P-6F2FD-24HK4-37DGQ" # IoTEnterpriseS, Win 11 RTM IoTEnterpriseS OEM:NONSLP
    4842 = "V6NCK-JTQF8-2Q2K3-2RWKJ-MTG6Q" # IoTEnterpriseS, Win 11 RTM IoTEnterpriseS OEM:NONSLP
    4842 = "W49VK-NX9TT-77629-6KGWW-4VYP3" # IoTEnterpriseS, Win 11 RTM IoTEnterpriseS OEM:NONSLP
    4842 = "X7MKN-23MQJ-GVM46-32JV8-293GQ" # IoTEnterpriseS, Win 11 RTM IoTEnterpriseS OEM:NONSLP
    4842 = "XY8N7-GPTQ2-GHP38-BQ762-TMXTQ" # IoTEnterpriseS, Win 11 RTM IoTEnterpriseS OEM:NONSLP
    4843 = "2DY2N-VTHHQ-XX988-YMRG9-6CT6R" # IoTEnterpriseS, Win 11 RTM IoTEnterpriseS OEM:DM
    4843 = "2KXYG-R3N44-TD3JP-R9DXR-MWV24" # IoTEnterpriseS, Win 11 RTM IoTEnterpriseS OEM:DM
    4843 = "4KRN2-9B6KQ-PT2K3-Y7QJC-76G6R" # IoTEnterpriseS, Win 11 RTM IoTEnterpriseS OEM:DM
    4843 = "7CX6X-NK2PX-VWK2W-HRBWR-X2H24" # IoTEnterpriseS, Win 11 RTM IoTEnterpriseS OEM:DM
    4843 = "9M3WW-6NCDD-JH69V-YBWJ2-9QFC4" # IoTEnterpriseS, Win 11 RTM IoTEnterpriseS OEM:DM
    4843 = "DPPPN-XKDK4-BXMWF-2PTT6-YHDGR" # IoTEnterpriseS, Win 11 RTM IoTEnterpriseS OEM:DM
    4843 = "GKFGK-VPND4-QRPJ3-DY7CY-KFBP4" # IoTEnterpriseS, Win 11 RTM IoTEnterpriseS OEM:DM
    4843 = "JDTN9-QQ7B9-K326Y-8QCV3-BHDGR" # IoTEnterpriseS, Win 11 RTM IoTEnterpriseS OEM:DM
    4843 = "MX83N-TT37H-G39K7-B9XCD-C4BP4" # IoTEnterpriseS, Win 11 RTM IoTEnterpriseS OEM:DM
    4843 = "N9RGT-Q7Y6K-8P2JP-3Q37T-24BP4" # IoTEnterpriseS, Win 11 RTM IoTEnterpriseS OEM:DM
    4843 = "NKJ76-X2K84-X28PJ-M2MQM-XBXTR" # IoTEnterpriseS, Win 11 RTM IoTEnterpriseS OEM:DM
    4843 = "NX68V-BH876-8PYYX-MRCGY-92H24" # IoTEnterpriseS, Win 11 RTM IoTEnterpriseS OEM:DM
    4843 = "T4JG2-TNFYM-VFCB8-WFFYH-T3FC4" # IoTEnterpriseS, Win 11 RTM IoTEnterpriseS OEM:DM
    4843 = "V63RY-RKNRT-QBQBH-H4Y6J-2G4C4" # IoTEnterpriseS, Win 11 RTM IoTEnterpriseS OEM:DM
    4843 = "VNB6H-PDPXJ-Q9Y83-WMK7X-DYMP4" # IoTEnterpriseS, Win 11 RTM IoTEnterpriseS OEM:DM
    4843 = "VQHG4-WNB29-RTM7J-WBGHK-RM8XF" # IoTEnterpriseS, Win 11 RTM IoTEnterpriseS OEM:DM
    4843 = "XQNV9-8FYFK-CDXX3-TJDW6-WXF9F" # IoTEnterpriseS, Win 11 RTM IoTEnterpriseS OEM:DM
    4844 = "KBN8V-HFGQ4-MGXVD-347P6-PDQGT" # IoTEnterpriseS, Win 11 RTM IoTEnterpriseS Volume:GVLK
    4844 = "KTN9J-WJR3G-2RF9K-3FCVX-7XRC6" # IoTEnterpriseS, Win 11 RTM IoTEnterpriseS Volume:GVLK
    4845 = "338XK-7NFGJ-CV9J4-8YP9F-Q9RC7" # IoTEnterpriseS, Win 11 RTM IoTEnterpriseS Volume:MAK
    4845 = "4TQ8V-NPP26-WXBQT-HRCD3-XHPKH" # IoTEnterpriseS, Win 11 RTM IoTEnterpriseS Volume:MAK
    4845 = "6FCYP-MN8QK-9GW2G-B3849-66R9H" # IoTEnterpriseS, Win 11 RTM IoTEnterpriseS Volume:MAK
    4845 = "6RN2Y-2FRMC-CF7V3-HBF7C-P93GV" # IoTEnterpriseS, Win 11 RTM IoTEnterpriseS Volume:MAK
    4845 = "7XWJG-NV49V-CWYK6-32HJM-HVDGV" # IoTEnterpriseS, Win 11 RTM IoTEnterpriseS Volume:MAK
    4845 = "BGVD8-XJN7M-9PWH3-7QXM7-WMCKH" # IoTEnterpriseS, Win 11 RTM IoTEnterpriseS Volume:MAK
    4845 = "BNGHR-9BCDM-QK4GB-9TYFY-R64C7" # IoTEnterpriseS, Win 11 RTM IoTEnterpriseS Volume:MAK
    4845 = "CBNB6-D4V4X-PDWTT-2QP2M-PR727" # IoTEnterpriseS, Win 11 RTM IoTEnterpriseS Volume:MAK
    4845 = "FD8VN-H7V76-3WH8W-HCPDY-TX3GV" # IoTEnterpriseS, Win 11 RTM IoTEnterpriseS Volume:MAK
    4845 = "GMGNX-DKTYJ-T7X83-TKT63-KK3GV" # IoTEnterpriseS, Win 11 RTM IoTEnterpriseS Volume:MAK
    4845 = "HN98J-842H3-PKKMG-2Y326-H8V27" # IoTEnterpriseS, Win 11 RTM IoTEnterpriseS Volume:MAK
    4845 = "JN7FP-MBWTT-V84RD-738VK-2YXTV" # IoTEnterpriseS, Win 11 RTM IoTEnterpriseS Volume:MAK
    4845 = "K369T-BN786-BJK3M-32YHG-KTR9H" # IoTEnterpriseS, Win 11 RTM IoTEnterpriseS Volume:MAK
    4845 = "KGVNB-BB29K-YR7XQ-X7T47-HXRC7" # IoTEnterpriseS, Win 11 RTM IoTEnterpriseS Volume:MAK
    4845 = "M2CGB-YJNV4-VYBXF-39J3Y-JMCKH" # IoTEnterpriseS, Win 11 RTM IoTEnterpriseS Volume:MAK
    4845 = "MK63C-8TN7C-Y833G-X3TYX-JXF9H" # IoTEnterpriseS, Win 11 RTM IoTEnterpriseS Volume:MAK
    4845 = "N7XTQ-92687-XW3WW-8GG2C-4RKTV" # IoTEnterpriseS, Win 11 RTM IoTEnterpriseS Volume:MAK
    4845 = "NGK3Q-YM829-T2F47-R98V8-RYCKH" # IoTEnterpriseS, Win 11 RTM IoTEnterpriseS Volume:MAK
    4845 = "P9CR3-MN3DW-MKGYH-WMRQW-YP49H" # IoTEnterpriseS, Win 11 RTM IoTEnterpriseS Volume:MAK
    4845 = "QTYNY-3MCQ8-XBRP4-FG2Q8-WB8XH" # IoTEnterpriseS, Win 11 RTM IoTEnterpriseS Volume:MAK
    4845 = "R68XN-R242F-2P7HT-4PJ47-3J66V" # IoTEnterpriseS, Win 11 RTM IoTEnterpriseS Volume:MAK
    4845 = "T8NT7-4C9KT-KYCR3-DDK9B-43QGV" # IoTEnterpriseS, Win 11 RTM IoTEnterpriseS Volume:MAK
    4845 = "TG8QT-MNTR6-BMDRW-PVYM6-4M8XH" # IoTEnterpriseS, Win 11 RTM IoTEnterpriseS Volume:MAK
    4845 = "XMPKT-JCNHF-QX2KC-XXTD6-RRKTV" # IoTEnterpriseS, Win 11 RTM IoTEnterpriseS Volume:MAK
    4845 = "XNFTF-X9BXW-Q4TTH-MV3DX-2YXTV" # IoTEnterpriseS, Win 11 RTM IoTEnterpriseS Volume:MAK
    4845 = "XXHKN-GJC28-CDQC3-X4M8X-WT4C7" # IoTEnterpriseS, Win 11 RTM IoTEnterpriseS Volume:MAK
    4845 = "YCTKP-NX9W4-WHCG9-3HQP8-W4727" # IoTEnterpriseS, Win 11 RTM IoTEnterpriseS Volume:MAK
    4845 = "YGX6Q-8NDBM-FYD6J-39GTH-8HYP7" # IoTEnterpriseS, Win 11 RTM IoTEnterpriseS Volume:MAK
    4869 = "7TY39-NGD29-RDHK8-VM48J-78V37" # IoTEnterpriseSK, Win 11 RTM IoTEnterpriseSK OEM:DM
    4869 = "9HWN4-2KWKG-KJKYB-96HXV-G6TBH" # IoTEnterpriseSK, Win 11 RTM IoTEnterpriseSK OEM:DM
    4869 = "B4FNW-WQVP7-QBPTY-MB3DH-RGG7V" # IoTEnterpriseSK, Win 11 RTM IoTEnterpriseSK OEM:DM
    4869 = "B7TN7-FTR79-YJJ88-F86PY-43QHV" # IoTEnterpriseSK, Win 11 RTM IoTEnterpriseSK OEM:DM
    4869 = "FJ67F-B6NT2-7HC78-4QCP2-DDFD7" # IoTEnterpriseSK, Win 11 RTM IoTEnterpriseSK OEM:DM
    4869 = "GN3WJ-72MX7-3948P-V6B4K-T867V" # IoTEnterpriseSK, Win 11 RTM IoTEnterpriseSK OEM:DM
    4869 = "GYW3W-2NM26-MCVDJ-HRDFB-F9GBH" # IoTEnterpriseSK, Win 11 RTM IoTEnterpriseSK OEM:DM
    4869 = "HVYNK-VGJCY-9337W-FRD3Q-979VV" # IoTEnterpriseSK, Win 11 RTM IoTEnterpriseSK OEM:DM
    4869 = "N979K-XWD77-YW3GB-HBGH6-D32MH" # IoTEnterpriseSK, Win 11 RTM IoTEnterpriseSK OEM:DM
    4869 = "PTHMB-N8Y72-G4DYP-DGDP8-W4737" # IoTEnterpriseSK, Win 11 RTM IoTEnterpriseSK OEM:DM
    4869 = "R4J48-89N2T-3TGVJ-RQFXD-FM8YH" # IoTEnterpriseSK, Win 11 RTM IoTEnterpriseSK OEM:DM
    4869 = "V8N73-HTJRJ-78JBG-76BHJ-QDFD7" # IoTEnterpriseSK, Win 11 RTM IoTEnterpriseSK OEM:DM
    4869 = "VXNW7-3WCRB-GQC66-P4PG9-KQFD7" # IoTEnterpriseSK, Win 11 RTM IoTEnterpriseSK OEM:DM
    4870 = "2D8N6-BP489-W6DGF-3B73W-82T7W" # IoTEnterpriseSK, Win 11 RTM IoTEnterpriseSK OEM:NONSLP
    4870 = "2J9KQ-TN3FT-R92VC-D4PRB-YWV38" # IoTEnterpriseSK, Win 11 RTM IoTEnterpriseSK OEM:NONSLP
    4870 = "2NMPG-FM34D-MPQ66-PG9MG-24BQ8" # IoTEnterpriseSK, Win 11 RTM IoTEnterpriseSK OEM:NONSLP
    4870 = "6FTF6-NYGPR-JHFK4-DCT7G-6F738" # IoTEnterpriseSK, Win 11 RTM IoTEnterpriseSK OEM:NONSLP
    4870 = "9XDJ4-N8TQ7-M4PT9-PC39D-YBMQ8" # IoTEnterpriseSK, Win 11 RTM IoTEnterpriseSK OEM:NONSLP
    4870 = "BVGN6-PDMXX-34RY6-8T6MC-CKGBJ" # IoTEnterpriseSK, Win 11 RTM IoTEnterpriseSK OEM:NONSLP
    4870 = "DNBYG-WX23D-8YVQQ-M8PX8-YP6BJ" # IoTEnterpriseSK, Win 11 RTM IoTEnterpriseSK OEM:NONSLP
    4870 = "J7NJW-V6KBM-CC8RW-Y29Y4-HQ2MJ" # IoTEnterpriseSK, Win 11 RTM IoTEnterpriseSK OEM:NONSLP
    4870 = "KKRQN-PWC3V-768W3-WC2WB-K79VW" # IoTEnterpriseSK, Win 11 RTM IoTEnterpriseSK OEM:NONSLP
    4870 = "N47HG-86WPQ-V9R99-F83YJ-K2H38" # IoTEnterpriseSK, Win 11 RTM IoTEnterpriseSK OEM:NONSLP
    4870 = "N4J4X-D7CV3-MVWC7-H7VDR-JHYQ8" # IoTEnterpriseSK, Win 11 RTM IoTEnterpriseSK OEM:NONSLP
    4870 = "NC36D-M39KC-YVGPJ-CD74K-4JV38" # IoTEnterpriseSK, Win 11 RTM IoTEnterpriseSK OEM:NONSLP
    4870 = "NT2HR-2PKM6-TY3KQ-WWCCB-R64D8" # IoTEnterpriseSK, Win 11 RTM IoTEnterpriseSK OEM:NONSLP
    4870 = "NW62P-8Y4YC-6DFB3-FHYRH-YY8YJ" # IoTEnterpriseSK, Win 11 RTM IoTEnterpriseSK OEM:NONSLP
    4870 = "RR2N9-TTWD6-YRRQP-9FT8Q-MD2MJ" # IoTEnterpriseSK, Win 11 RTM IoTEnterpriseSK OEM:NONSLP
    4870 = "T2VBN-J7PRT-KBDPW-6B8BH-4C6BJ" # IoTEnterpriseSK, Win 11 RTM IoTEnterpriseSK OEM:NONSLP
    4870 = "VV2NJ-PYHY9-PX2MM-HQMMC-6JJYJ" # IoTEnterpriseSK, Win 11 RTM IoTEnterpriseSK OEM:NONSLP
    4870 = "WWJVF-8N4PG-K8XQP-J8CK6-6F738" # IoTEnterpriseSK, Win 11 RTM IoTEnterpriseSK OEM:NONSLP
    4870 = "XCNHT-C6C7R-4GC4C-T6KPJ-BWV38" # IoTEnterpriseSK, Win 11 RTM IoTEnterpriseSK OEM:NONSLP
    4871 = "26QN8-828KP-V62WD-C86V7-9BXVX" # IoTEnterpriseSK, Win11 RTM IoTEnterpriseSK Retail
    4871 = "6MYHY-3NDY4-3RPFV-WGVCW-GVPMK" # IoTEnterpriseSK, Win11 RTM IoTEnterpriseSK Retail
    4871 = "C6DNK-JP49D-F7PRH-TDDHG-6F739" # IoTEnterpriseSK, Win11 RTM IoTEnterpriseSK Retail
    4871 = "JCNKV-6343V-YPFHD-DGQ67-94WYK" # IoTEnterpriseSK, Win11 RTM IoTEnterpriseSK Retail
    4871 = "KN6X7-TJ39B-9Q9CG-KTYKV-G6TBK" # IoTEnterpriseSK, Win11 RTM IoTEnterpriseSK Retail
    4871 = "MTGNK-W2FKC-XJGXY-96P4X-GJJYK" # IoTEnterpriseSK, Win11 RTM IoTEnterpriseSK Retail
    4871 = "Q6NRQ-TBV8X-Q4J3Q-QRR6G-WXGBK" # IoTEnterpriseSK, Win11 RTM IoTEnterpriseSK Retail
    4891 = "29JFN-6JV42-BWKVC-7QG9H-KHPPF" # IoTEnterpriseS, Win 10 RTM IoTEnterpriseS Volume:MAK
    4891 = "9NRYC-PPYBD-MPK9C-2P6TH-8HYR4" # IoTEnterpriseS, Win 10 RTM IoTEnterpriseS Volume:MAK
    4891 = "F2632-ND2MD-DBC6X-9W399-2YXWR" # IoTEnterpriseS, Win 10 RTM IoTEnterpriseS Volume:MAK
    4891 = "H2NCB-TKWJX-XMHKX-B42JR-FC6CF" # IoTEnterpriseS, Win 10 RTM IoTEnterpriseS Volume:MAK
    4891 = "NDB9K-PJH64-R2GHT-3D32Y-B4KWR" # IoTEnterpriseS, Win 10 RTM IoTEnterpriseS Volume:MAK
    4891 = "PCGQD-MMN83-2KCVY-TDPX8-YP6CF" # IoTEnterpriseS, Win 10 RTM IoTEnterpriseS Volume:MAK
    4891 = "QXW7R-6N84V-MFJB2-HJRJH-MBMR4" # IoTEnterpriseS, Win 10 RTM IoTEnterpriseS Volume:MAK
    4891 = "XNKMB-9YCRC-QKQGC-MGR4B-88J2F" # IoTEnterpriseS, Win 10 RTM IoTEnterpriseS Volume:MAK
    4891 = "YGN86-6JRBP-379X4-KRC7B-7MMR4" # IoTEnterpriseS, Win 10 RTM IoTEnterpriseS Volume:MAK
    4895 = "4YMNX-7FJ8P-9DRD4-VRJ63-49GCK" # ProfessionalCountrySpecific, Win 11 RTM ProfessionalCountrySpecific Volume:MAK
    4895 = "BVR6M-VDNKD-QMXT8-JQG2W-Q7DJX" # ProfessionalCountrySpecific, Win 11 RTM ProfessionalCountrySpecific Volume:MAK
    4895 = "F6N2F-GVMGC-9XXYK-6G3WK-9HPPK" # ProfessionalCountrySpecific, Win 11 RTM ProfessionalCountrySpecific Volume:MAK
    4895 = "WNKGV-FX6WT-KW4XW-KTYG3-CBCPK" # ProfessionalCountrySpecific, Win 11 RTM ProfessionalCountrySpecific Volume:MAK
    4896 = "3XP6D-CRND4-DRYM2-GM84D-4GG8Y" # ProfessionalCountrySpecific, Win 11 RTM ProfessionalCountrySpecific Retail
    4896 = "7GGNC-H89BD-F48P3-6XHW8-Q7DJY" # ProfessionalCountrySpecific, Win 11 RTM ProfessionalCountrySpecific Retail
    4896 = "BDNCG-TM3GY-KJXY6-QFWHC-8XGCM" # ProfessionalCountrySpecific, Win 11 RTM ProfessionalCountrySpecific Retail
    4898 = "GFMWN-WDHVB-4Y4XP-42WKM-RC6CQ" # Windows Server ESU 2012/2012 R2 RTM Extended Security Updates Year 1 TBA Volume:GVLK
    4899 = "XN3XP-QGKM4-KT7HM-6HC6T-H8V6F" # Windows Server ESU 2012/2012 R2 RTM Extended Security Updates Year 2 TBA Volume:GVLK
    4900 = "QCQ4R-N2J93-PWMTK-G2BGF-BY82T" # Windows Server ESU 2012/2012 R2 RTM Extended Security Updates Year 3 TBA Volume:GVLK
    4901 = "28NY3-J8XHB-4PQBG-BCDVG-V6G87" # EnterpriseS, Win 2024 RTM EnterpriseS Volume:MAK
    4901 = "4DPGN-6MJ7P-TT66Q-YQJGJ-2G4GH" # EnterpriseS, Win 2024 RTM EnterpriseS Volume:MAK
    4901 = "68R8C-NP6VV-RPTHY-FGHPV-8HYTH" # EnterpriseS, Win 2024 RTM EnterpriseS Volume:MAK
    4901 = "6BBNV-4HWH7-GVMB3-3KHJK-9HPPV" # EnterpriseS, Win 2024 RTM EnterpriseS Volume:MAK
    4901 = "93RG8-N7WWR-XX4HK-HP429-YD2PV" # EnterpriseS, Win 2024 RTM EnterpriseS Volume:MAK
    4901 = "B4MN4-63FFV-QD68V-M7QTX-8QQJ7" # EnterpriseS, Win 2024 RTM EnterpriseS Volume:MAK
    4901 = "CCM7R-2NPYK-PG4RJ-4CQP6-TJJ2V" # EnterpriseS, Win 2024 RTM EnterpriseS Volume:MAK
    4901 = "CMPKN-WXXCD-YJ2P3-8MGTC-2DQJ7" # EnterpriseS, Win 2024 RTM EnterpriseS Volume:MAK
    4901 = "D69Q3-VN28Y-6GK7H-V9F9F-9W687" # EnterpriseS, Win 2024 RTM EnterpriseS Volume:MAK
    4901 = "DNV6J-G8XMV-DDFWK-DPRG2-TMXW7" # EnterpriseS, Win 2024 RTM EnterpriseS Volume:MAK
    4901 = "FC82N-43JGP-DRQTG-JFBQ4-F64GH" # EnterpriseS, Win 2024 RTM EnterpriseS Volume:MAK
    4901 = "H9YGD-NQ4YC-Q4WXM-9MKH2-27PPV" # EnterpriseS, Win 2024 RTM EnterpriseS Volume:MAK
    4901 = "HQT9C-N4FQX-VTH4Q-YVMWF-HQ2PV" # EnterpriseS, Win 2024 RTM EnterpriseS Volume:MAK
    4901 = "JPFF2-GXNWQ-4T2JW-RV6C2-DDFGH" # EnterpriseS, Win 2024 RTM EnterpriseS Volume:MAK
    4901 = "N2TTF-JW6VT-XK7CW-B4PPW-9TTCV" # EnterpriseS, Win 2024 RTM EnterpriseS Volume:MAK
    4901 = "N7KQ7-VCJ2F-X8TDH-B2KCD-C4BTH" # EnterpriseS, Win 2024 RTM EnterpriseS Volume:MAK
    4901 = "NKPYY-HWKG9-BFPKJ-99J6C-9QFGH" # EnterpriseS, Win 2024 RTM EnterpriseS Volume:MAK
    4901 = "NV66V-3WBQM-BXMRF-743DR-37DJ7" # EnterpriseS, Win 2024 RTM EnterpriseS Volume:MAK
    4901 = "PBV8N-MX89H-Q4QMR-7DXRG-PDQJ7" # EnterpriseS, Win 2024 RTM EnterpriseS Volume:MAK
    4901 = "PJB47-8PN2T-MCGDY-JTY3D-CBCPV" # EnterpriseS, Win 2024 RTM EnterpriseS Volume:MAK
    4901 = "Q6J28-PYNBR-C6H49-TX663-KK3J7" # EnterpriseS, Win 2024 RTM EnterpriseS Volume:MAK
    4901 = "TN2V3-GMC72-WD6RV-CVHKD-8MCPV" # EnterpriseS, Win 2024 RTM EnterpriseS Volume:MAK
    4901 = "TVHN8-RPWXR-XKHW3-XHVYM-F9GCV" # EnterpriseS, Win 2024 RTM EnterpriseS Volume:MAK
    4901 = "VBP3F-4NW7W-X4DDH-R6T6W-DGTCV" # EnterpriseS, Win 2024 RTM EnterpriseS Volume:MAK
    4901 = "X6NQ6-CWYRK-689VH-6KMMF-8476H" # EnterpriseS, Win 2024 RTM EnterpriseS Volume:MAK
    4901 = "XTRHF-7BN82-HDR7D-7RYR3-MD2PV" # EnterpriseS, Win 2024 RTM EnterpriseS Volume:MAK
    4901 = "YNT74-WVMVJ-878V7-JC4K2-FYCPV" # EnterpriseS, Win 2024 RTM EnterpriseS Volume:MAK
    4902 = "CYPB3-XNV9V-QR4G4-Q3B8K-KQFGJ" # EnterpriseSEval, Win 2024 RTM EnterpriseSEval Retail:TB:Eval
    4902 = "Y22YQ-HNV92-HWMXQ-PMDQ9-7XRGJ" # EnterpriseSEval, Win 2024 RTM EnterpriseSEval Retail:TB:Eval
    4903 = "3JGQM-KNG2W-PCTGR-883GY-G3FGK" # EnterpriseSN, Win 2024 RTM EnterpriseSN Volume:MAK
    4903 = "4TNWM-9DQ4Q-C6QQY-KG6Q8-K2H6K" # EnterpriseSN, Win 2024 RTM EnterpriseSN Volume:MAK
    4903 = "769N3-3T7JV-X67DP-CF3TK-TF76K" # EnterpriseSN, Win 2024 RTM EnterpriseSN Volume:MAK
    4903 = "84VNJ-2GDWY-CD2W9-8XB7T-HFW2X" # EnterpriseSN, Win 2024 RTM EnterpriseSN Volume:MAK
    4903 = "8FKRX-YNF7F-78WRH-RGQFB-F9GCX" # EnterpriseSN, Win 2024 RTM EnterpriseSN Volume:MAK
    4903 = "CMNMQ-8Q3TT-KTPVJ-XPMPR-VMMTK" # EnterpriseSN, Win 2024 RTM EnterpriseSN Volume:MAK
    4903 = "DFTNG-32PYT-T6V7T-WGM9Q-VXRGK" # EnterpriseSN, Win 2024 RTM EnterpriseSN Volume:MAK
    4903 = "F9XHX-TNM2G-GDJVM-HJDBB-TX3J9" # EnterpriseSN, Win 2024 RTM EnterpriseSN Volume:MAK
    4903 = "FM97N-VV9F4-9T2DC-7YP27-B7YTK" # EnterpriseSN, Win 2024 RTM EnterpriseSN Volume:MAK
    4903 = "FR6P2-NPDPT-9FYRM-KK7RW-XW689" # EnterpriseSN, Win 2024 RTM EnterpriseSN Volume:MAK
    4903 = "H2DQQ-3NCCB-H8CMR-CJM9Q-VXRGK" # EnterpriseSN, Win 2024 RTM EnterpriseSN Volume:MAK
    4903 = "N283D-JVYMF-HBD6W-V9KPC-4RKW9" # EnterpriseSN, Win 2024 RTM EnterpriseSN Volume:MAK
    4903 = "N3DX6-M97TQ-HVCG8-RXK2H-3J689" # EnterpriseSN, Win 2024 RTM EnterpriseSN Volume:MAK
    4903 = "NXQVX-XY8FP-33GTF-VJP6Y-RC6CX" # EnterpriseSN, Win 2024 RTM EnterpriseSN Volume:MAK
    4903 = "P3KJ9-N8JQB-832W8-XJX39-7XRGK" # EnterpriseSN, Win 2024 RTM EnterpriseSN Volume:MAK
    4903 = "PCCDT-FTNJX-49GWW-T4YD2-KW689" # EnterpriseSN, Win 2024 RTM EnterpriseSN Volume:MAK
    4903 = "PPB3Q-BNPXY-J96P6-PF73G-P7PPX" # EnterpriseSN, Win 2024 RTM EnterpriseSN Volume:MAK
    4903 = "QPQYQ-VNMY3-8CQHY-RWCVP-V8V6K" # EnterpriseSN, Win 2024 RTM EnterpriseSN Volume:MAK
    4903 = "RJ9N4-VGV2M-4XTYC-4WGR9-WT4GK" # EnterpriseSN, Win 2024 RTM EnterpriseSN Volume:MAK
    4903 = "RNPB6-TWB6R-4G6CG-KVGKW-JFKW9" # EnterpriseSN, Win 2024 RTM EnterpriseSN Volume:MAK
    4903 = "V33MJ-9NGQH-J9DVP-B343V-M4KW9" # EnterpriseSN, Win 2024 RTM EnterpriseSN Volume:MAK
    4903 = "V8N79-KXTJR-W6VH7-6RHP8-MTG89" # EnterpriseSN, Win 2024 RTM EnterpriseSN Volume:MAK
    4903 = "WYTJN-J8FPH-X3YX7-KJQYY-6VPPX" # EnterpriseSN, Win 2024 RTM EnterpriseSN Volume:MAK
    4903 = "XBNHQ-4TXKH-B6YHG-CJGMP-HH9W9" # EnterpriseSN, Win 2024 RTM EnterpriseSN Volume:MAK
    4903 = "XDNKF-GHRC8-9337M-PKFD9-PBCPX" # EnterpriseSN, Win 2024 RTM EnterpriseSN Volume:MAK
    4903 = "Y8XN4-WKQVG-B4VXJ-FB6WW-4VYTK" # EnterpriseSN, Win 2024 RTM EnterpriseSN Volume:MAK
    4903 = "Y9Q4C-NC4MG-94QXC-3GDQK-CDQJ9" # EnterpriseSN, Win 2024 RTM EnterpriseSN Volume:MAK
    4904 = "VW76H-NXCYD-PPWKF-JG63K-KQFGM" # EnterpriseSNEval, Win 2024 RTM EnterpriseSNEval Retail:TB:Eval
    4904 = "Y8DJM-NPXF3-QG4MH-W7WJK-KQFGM" # EnterpriseSNEval, Win 2024 RTM EnterpriseSNEval Retail:TB:Eval
    4905 = "D9QGP-NWPDT-HXC73-F63PP-9QFGP" # EnterpriseS, Win 2024 RTM EnterpriseS Retail
    4905 = "W2W9T-N7XFW-XD883-Y6YKV-RGG9C" # EnterpriseS, Win 2024 RTM EnterpriseS Retail
    4906 = "HB6CV-NDYQ4-8JP9T-HFP9H-VVDKD" # EnterpriseSN, Win 2024 RTM EnterpriseSN Retail
    4906 = "NMBYH-7QR93-XRKYB-WQRWX-66TC3" # EnterpriseSN, Win 2024 RTM EnterpriseSN Retail
    4907 = "BXP39-KNMHM-Y6KBW-V6FRH-YY824" # IoTEnterpriseS, Win 11 RTM IoTEnterpriseS Retail
    4907 = "GQ3VV-N6PT7-YG78K-GT4B6-4M824" # IoTEnterpriseS, Win 11 RTM IoTEnterpriseS Retail
    4908 = "KN4HV-CK2DJ-M84DD-WJ7XV-G6TC6" # ServerDatacenter, Windows Server 2025 RTM ServerDatacenter OEM:DM (MUI locked to zh-CN)
    4908 = "Q64HJ-N6VJ7-6D274-FGTCB-HVDKG" # ServerDatacenter, Windows Server 2025 RTM ServerDatacenter OEM:DM (MUI locked to zh-CN)
    4908 = "RTNF4-XV837-R2XBK-HM8H3-4GG9G" # ServerDatacenter, Windows Server 2025 RTM ServerDatacenter OEM:DM (MUI locked to zh-CN)
    4908 = "VRFBN-MF3BG-YKKQD-V36VV-T3FGT" # ServerDatacenter, Windows Server 2025 RTM ServerDatacenter OEM:DM (MUI locked to zh-CN)
    4909 = "F7RPC-NR47Y-BKXT9-V6BJK-Y7YTV" # ServerDatacenter;AzureStackHCIAddOn2025, Windows Server 2025 RTM ServerDatacenter;AzureStackHCIAddOn2025 OEM:DM
    4909 = "G47X7-NMG2T-GKYP8-BDG74-WFKXH" # ServerDatacenter;AzureStackHCIAddOn2025, Windows Server 2025 RTM ServerDatacenter;AzureStackHCIAddOn2025 OEM:DM
    4909 = "VBQVD-RN6BQ-83C93-QMM8H-MBMTV" # ServerDatacenter;AzureStackHCIAddOn2025, Windows Server 2025 RTM ServerDatacenter;AzureStackHCIAddOn2025 OEM:DM
    4909 = "WNQPF-FPF27-6QY3F-CBPXC-W2T9H" # ServerDatacenter;AzureStackHCIAddOn2025, Windows Server 2025 RTM ServerDatacenter;AzureStackHCIAddOn2025 OEM:DM
    4910 = "2WYYD-4NF8C-JCFX8-4GMPQ-TCT9J" # ServerDatacenter;AzureStackHCIAddOn2025, Windows Server 2025 RTM ServerDatacenter;AzureStackHCIAddOn2025 OEM:NONSLP
    4910 = "4C9CG-NTRHV-F6GRT-YXJTV-464GW" # ServerDatacenter;AzureStackHCIAddOn2025, Windows Server 2025 RTM ServerDatacenter;AzureStackHCIAddOn2025 OEM:NONSLP
    4910 = "6YNJY-DXBHW-RPG79-HK6D4-YTG9J" # ServerDatacenter;AzureStackHCIAddOn2025, Windows Server 2025 RTM ServerDatacenter;AzureStackHCIAddOn2025 OEM:NONSLP
    4910 = "92N9G-YGKVW-698M4-CF9X8-F3QKJ" # ServerDatacenter;AzureStackHCIAddOn2025, Windows Server 2025 RTM ServerDatacenter;AzureStackHCIAddOn2025 OEM:NONSLP
    4910 = "BWR8K-YPN67-4K8M3-3TYHK-RM828" # ServerDatacenter;AzureStackHCIAddOn2025, Windows Server 2025 RTM ServerDatacenter;AzureStackHCIAddOn2025 OEM:NONSLP
    4910 = "HF33N-MDHBY-76P92-8J6GX-YD2P8" # ServerDatacenter;AzureStackHCIAddOn2025, Windows Server 2025 RTM ServerDatacenter;AzureStackHCIAddOn2025 OEM:NONSLP
    4910 = "M39NT-J3YDX-V69K6-MM2T7-94W28" # ServerDatacenter;AzureStackHCIAddOn2025, Windows Server 2025 RTM ServerDatacenter;AzureStackHCIAddOn2025 OEM:NONSLP
    4910 = "V6W2N-PPP84-WYC29-GP3K3-979XJ" # ServerDatacenter;AzureStackHCIAddOn2025, Windows Server 2025 RTM ServerDatacenter;AzureStackHCIAddOn2025 OEM:NONSLP
    4910 = "YFKCN-KKM6Y-BG9X8-W4BKY-MY828" # ServerDatacenter;AzureStackHCIAddOn2025, Windows Server 2025 RTM ServerDatacenter;AzureStackHCIAddOn2025 OEM:NONSLP
    4911 = "HK6V9-PN3HD-KPRPM-W8B4F-WFKXK" # ServerDatacenter, Windows Server 2025 RTM ServerDatacenter OEM:NONSLP (MUI locked to zh-CN)
    4911 = "XB8F8-NKVBC-TTQYG-V7BT7-2R76X" # ServerDatacenter, Windows Server 2025 RTM ServerDatacenter OEM:NONSLP (MUI locked to zh-CN)
    4911 = "XG3CN-D298Q-8R8RY-WTJ4X-QV9XK" # ServerDatacenter, Windows Server 2025 RTM ServerDatacenter OEM:NONSLP (MUI locked to zh-CN)
    4912 = "2X8Y7-JNTYJ-C3VMJ-W47KQ-KK3KM" # ServerDatacenter;AzureStackHCIAddOn2025, Windows Server 2025 RTM ServerDatacenter;AzureStackHCIAddOn2025 OEM:SLP
    4912 = "G3Y4K-N2C4R-9J662-GJ6TR-GX3KM" # ServerDatacenter;AzureStackHCIAddOn2025, Windows Server 2025 RTM ServerDatacenter;AzureStackHCIAddOn2025 OEM:SLP
    4912 = "JF3VQ-XNDVH-PRQ93-9HPVH-M4KXM" # ServerDatacenter;AzureStackHCIAddOn2025, Windows Server 2025 RTM ServerDatacenter;AzureStackHCIAddOn2025 OEM:SLP
    4912 = "NPX2K-GTW7W-FC9PW-6QRVJ-F3QKM" # ServerDatacenter;AzureStackHCIAddOn2025, Windows Server 2025 RTM ServerDatacenter;AzureStackHCIAddOn2025 OEM:SLP
    4912 = "V8VN9-7T8CW-TMH6G-CHBF8-4VYTY" # ServerDatacenter;AzureStackHCIAddOn2025, Windows Server 2025 RTM ServerDatacenter;AzureStackHCIAddOn2025 OEM:SLP
    4912 = "X9R84-NXCDQ-HY73P-6V9K3-G869M" # ServerDatacenter;AzureStackHCIAddOn2025, Windows Server 2025 RTM ServerDatacenter;AzureStackHCIAddOn2025 OEM:SLP
    4913 = "2HN4X-2TPJT-JP9FD-TBGDK-6CT9P" # ServerDatacenter, Windows Server 2025 RTM ServerDatacenter OEM:SLP (MUI locked to zh-CN)
    4913 = "VW8QW-NHGBW-7WP6Q-44FT2-TMXXP" # ServerDatacenter, Windows Server 2025 RTM ServerDatacenter OEM:SLP (MUI locked to zh-CN)
    4914 = "7NVFR-M97HT-HR24Y-MWFFV-CYXXQ" # ServerDatacenter;AzureStackHCIAddOn2025, Windows Server 2025 RTM ServerDatacenter;AzureStackHCIAddOn2025 Retail
    4914 = "9DYFC-FNGM2-KQGHQ-BTRK4-JHYT3" # ServerDatacenter;AzureStackHCIAddOn2025, Windows Server 2025 RTM ServerDatacenter;AzureStackHCIAddOn2025 Retail
    4914 = "D33FR-N4KJV-T7PCB-4QY23-YBMT3" # ServerDatacenter;AzureStackHCIAddOn2025, Windows Server 2025 RTM ServerDatacenter;AzureStackHCIAddOn2025 Retail
    4914 = "KVMDN-BJF9J-H98W9-FRX9H-KHPQD" # ServerDatacenter;AzureStackHCIAddOn2025, Windows Server 2025 RTM ServerDatacenter;AzureStackHCIAddOn2025 Retail
    4914 = "M7W7N-6WYDX-MVWX2-DQ9YB-JMCQD" # ServerDatacenter;AzureStackHCIAddOn2025, Windows Server 2025 RTM ServerDatacenter;AzureStackHCIAddOn2025 Retail
    4914 = "RQHGN-GY4TC-Q2T2Q-2DBBC-CKGDD" # ServerDatacenter;AzureStackHCIAddOn2025, Windows Server 2025 RTM ServerDatacenter;AzureStackHCIAddOn2025 Retail
    4914 = "RWT84-NRD9P-PQDQV-HCG9G-H8V63" # ServerDatacenter;AzureStackHCIAddOn2025, Windows Server 2025 RTM ServerDatacenter;AzureStackHCIAddOn2025 Retail
    4914 = "VMRHW-BNY2K-VQKRM-44888-Q7DKQ" # ServerDatacenter;AzureStackHCIAddOn2025, Windows Server 2025 RTM ServerDatacenter;AzureStackHCIAddOn2025 Retail
    4915 = "CNFDQ-2BW8H-9V4WM-TKCPD-MD2QF" # ServerDatacenter, Windows Server 2025 RTM ServerDatacenter Volume:GVLK
    4915 = "D764K-2NDRG-47T6Q-P8T8W-YP6DF" # ServerDatacenter, Windows Server 2025 RTM ServerDatacenter Volume:GVLK
    4916 = "2P4J7-MNWGW-MH988-MCF68-JFKXT" # ServerDatacenter;AzureStackHCIAddOn2025, Windows Server 2025 RTM ServerDatacenter;AzureStackHCIAddOn2025 Volume:MAK
    4916 = "6NGCR-XJ9R6-FKFGX-7QMQD-KK3KT" # ServerDatacenter;AzureStackHCIAddOn2025, Windows Server 2025 RTM ServerDatacenter;AzureStackHCIAddOn2025 Volume:MAK
    4916 = "B9NQD-G67B4-7D2PB-B27CJ-4VYT6" # ServerDatacenter;AzureStackHCIAddOn2025, Windows Server 2025 RTM ServerDatacenter;AzureStackHCIAddOn2025 Volume:MAK
    4916 = "BVJ4M-XQNFW-B42CQ-T8Y2F-8B83G" # ServerDatacenter;AzureStackHCIAddOn2025, Windows Server 2025 RTM ServerDatacenter;AzureStackHCIAddOn2025 Volume:MAK
    4916 = "FGVNH-MRCYB-JJMPR-M3WV2-HH9XT" # ServerDatacenter;AzureStackHCIAddOn2025, Windows Server 2025 RTM ServerDatacenter;AzureStackHCIAddOn2025 Volume:MAK
    4916 = "GDDNX-86JVT-T9P6B-CYKQG-FVYT6" # ServerDatacenter;AzureStackHCIAddOn2025, Windows Server 2025 RTM ServerDatacenter;AzureStackHCIAddOn2025 Volume:MAK
    4916 = "HN2WP-KT4YH-X93C2-8BGJF-R3QKT" # ServerDatacenter;AzureStackHCIAddOn2025, Windows Server 2025 RTM ServerDatacenter;AzureStackHCIAddOn2025 Volume:MAK
    4916 = "JYDNG-PCCC2-36B3P-VBG3Q-RJV66" # ServerDatacenter;AzureStackHCIAddOn2025, Windows Server 2025 RTM ServerDatacenter;AzureStackHCIAddOn2025 Volume:MAK
    4916 = "JYWBC-D2NGH-69664-HKCQ4-QGTDG" # ServerDatacenter;AzureStackHCIAddOn2025, Windows Server 2025 RTM ServerDatacenter;AzureStackHCIAddOn2025 Volume:MAK
    4916 = "N27K3-9CVGX-87B9J-JVG4J-RYCQG" # ServerDatacenter;AzureStackHCIAddOn2025, Windows Server 2025 RTM ServerDatacenter;AzureStackHCIAddOn2025 Volume:MAK
    4916 = "NCJK4-DQF37-PKWRT-VTR8F-3DFG6" # ServerDatacenter;AzureStackHCIAddOn2025, Windows Server 2025 RTM ServerDatacenter;AzureStackHCIAddOn2025 Volume:MAK
    4916 = "NKKMJ-QDKRX-DQXY7-T37B3-GF766" # ServerDatacenter;AzureStackHCIAddOn2025, Windows Server 2025 RTM ServerDatacenter;AzureStackHCIAddOn2025 Volume:MAK
    4916 = "NPR43-R78QP-4G7KX-2CPPM-8FKXT" # ServerDatacenter;AzureStackHCIAddOn2025, Windows Server 2025 RTM ServerDatacenter;AzureStackHCIAddOn2025 Volume:MAK
    4916 = "T7MDT-2YNY6-XDM2Q-8TVKT-P7PQG" # ServerDatacenter;AzureStackHCIAddOn2025, Windows Server 2025 RTM ServerDatacenter;AzureStackHCIAddOn2025 Volume:MAK
    4916 = "TXMMB-PN89W-XYQ98-GHC8D-GF766" # ServerDatacenter;AzureStackHCIAddOn2025, Windows Server 2025 RTM ServerDatacenter;AzureStackHCIAddOn2025 Volume:MAK
    4916 = "V9CF7-NV2HJ-P43YX-WKVXK-8QQKT" # ServerDatacenter;AzureStackHCIAddOn2025, Windows Server 2025 RTM ServerDatacenter;AzureStackHCIAddOn2025 Volume:MAK
    4916 = "WR8N3-VPMDX-GG4F7-JBVG7-G6TDG" # ServerDatacenter;AzureStackHCIAddOn2025, Windows Server 2025 RTM ServerDatacenter;AzureStackHCIAddOn2025 Volume:MAK
    4916 = "YNF2F-XFXTF-6BHFH-R9TX4-JHYT6" # ServerDatacenter;AzureStackHCIAddOn2025, Windows Server 2025 RTM ServerDatacenter;AzureStackHCIAddOn2025 Volume:MAK
    4917 = "YQB4H-NKHHJ-Q6K4R-4VMY6-VCH67" # ServerDatacenter, Windows Server 2025 RTM ServerDatacenter VT:IA
    4918 = "K4NPK-2W93K-FGWQD-QCV9X-CDQKW" # ServerDatacenter;ServerStandard, Windows Server 2025 RTM ServerDatacenter;ServerStandard Volume:CSVLK Azure Only
    4919 = "9T4DC-NT7QF-8B4RY-FF8KW-332QK" # ServerDatacenter;ServerStandard, Windows Server 2025 RTM ServerDatacenter;ServerStandard Volume:CSVLK
    4919 = "BYXKD-GNTFP-97TDH-P3878-HMMT9" # ServerDatacenter;ServerStandard, Windows Server 2025 RTM ServerDatacenter;ServerStandard Volume:CSVLK
    4920 = "9QPDN-YQYXT-JTDCH-44MQ2-CKGDM" # ServerDatacenter;ServerStandard, Windows Server 2025 RTM ServerDatacenter;ServerStandard Volume:CSVLK VL Additional Lab
    4921 = "K4NJQ-WBJ89-PJGPP-9MTY4-R3QK2" # ServerDatacenterEval, Windows Server 2025 RTM ServerDatacenterEval Retail:TB:Eval
    4921 = "M4RNW-CRTHF-TY7BG-DDHG6-J2T92" # ServerDatacenterEval, Windows Server 2025 RTM ServerDatacenterEval Retail:TB:Eval
    4922 = "4WPWP-7NT38-2HQF4-PKKR7-R9GDQ" # ServerStandard, Windows Server 2025 RTM ServerStandard OEM:DM
    4922 = "8H338-NWK4K-XPTTF-G9Q4H-9BXX3" # ServerStandard, Windows Server 2025 RTM ServerStandard OEM:DM
    4922 = "KV3BC-6NW3P-3DTCP-XKXY7-MBMVD" # ServerStandard, Windows Server 2025 RTM ServerStandard OEM:DM
    4922 = "NQQW7-BQYQR-9BYH4-W4GYD-XHPQQ" # ServerStandard, Windows Server 2025 RTM ServerStandard OEM:DM
    4923 = "4KNVB-RBCPG-Q3HYG-G6PP4-GX3K4" # ServerStandard, Windows Server 2025 RTM ServerStandard OEM:DM (MUI locked to zh-CN)
    4923 = "CWNP7-BYHG9-RKB76-3X6C7-KHPQR" # ServerStandard, Windows Server 2025 RTM ServerStandard OEM:DM (MUI locked to zh-CN)
    4923 = "KR24N-JCYRM-GMTRT-DMBCP-2DQK4" # ServerStandard, Windows Server 2025 RTM ServerStandard OEM:DM (MUI locked to zh-CN)
    4923 = "YH2P2-V3NB4-8RKQG-JV3B7-6X3K4" # ServerStandard, Windows Server 2025 RTM ServerStandard OEM:DM (MUI locked to zh-CN)
    4924 = "2BKDX-HKNXV-YHJ6F-G8J86-MKRHG" # ServerStandard, Windows Server 2025 RTM ServerStandard OEM:NONSLP
    4924 = "2XF3Y-RN7H6-PK46Y-73384-KBXX6" # ServerStandard, Windows Server 2025 RTM ServerStandard OEM:NONSLP
    4924 = "FNDVP-YVKDP-C9DB3-8HQV4-K4W3T" # ServerStandard, Windows Server 2025 RTM ServerStandard OEM:NONSLP
    4924 = "H7NP7-Q3Q2C-WTRWH-6HB33-DV9X6" # ServerStandard, Windows Server 2025 RTM ServerStandard OEM:NONSLP
    4924 = "MN3X9-6R9PJ-F98G8-TYC9X-CDQK6" # ServerStandard, Windows Server 2025 RTM ServerStandard OEM:NONSLP
    4924 = "WJWHM-NWX4R-9D6R3-TV9YY-CWJ3T" # ServerStandard, Windows Server 2025 RTM ServerStandard OEM:NONSLP
    4924 = "Y9FB9-N4TGV-8HR4G-X3KB8-78V7G" # ServerStandard, Windows Server 2025 RTM ServerStandard OEM:NONSLP
    4924 = "YD3NP-WGJ3H-9RMWG-J9CT4-7H9X6" # ServerStandard, Windows Server 2025 RTM ServerStandard OEM:NONSLP
    4925 = "7YGG2-XNTVP-TKY3H-3YJVK-2YXX7" # ServerStandard, Windows Server 2025 RTM ServerStandard OEM:NONSLP (MUI locked to zh-CN)
    4925 = "BVNVB-84WK3-TDC8G-3YVCW-GVPQV" # ServerStandard, Windows Server 2025 RTM ServerStandard OEM:NONSLP (MUI locked to zh-CN)
    4925 = "CK39N-4W6KC-4BKKK-6BJ3P-8XGDV" # ServerStandard, Windows Server 2025 RTM ServerStandard OEM:NONSLP (MUI locked to zh-CN)
    4925 = "HMNRD-WFGC6-PJ67R-MQKYV-GCT97" # ServerStandard, Windows Server 2025 RTM ServerStandard OEM:NONSLP (MUI locked to zh-CN)
    4925 = "JTKPN-XY2G8-D6MCC-893QB-2PT97" # ServerStandard, Windows Server 2025 RTM ServerStandard OEM:NONSLP (MUI locked to zh-CN)
    4925 = "NQ8VM-8G2DV-J8GGP-MYTH8-HMMVH" # ServerStandard, Windows Server 2025 RTM ServerStandard OEM:NONSLP (MUI locked to zh-CN)
    4925 = "P6NTJ-CCW2K-DJRYC-8YDPC-VFW3V" # ServerStandard, Windows Server 2025 RTM ServerStandard OEM:NONSLP (MUI locked to zh-CN)
    4925 = "PQN6M-CRWXV-D8BKX-J266Y-G3FHH" # ServerStandard, Windows Server 2025 RTM ServerStandard OEM:NONSLP (MUI locked to zh-CN)
    4925 = "PX3PN-HJP2G-VXKRD-T6R6D-H26DV" # ServerStandard, Windows Server 2025 RTM ServerStandard OEM:NONSLP (MUI locked to zh-CN)
    4925 = "RTCWN-2K788-C9B4W-T8KG3-VXRHH" # ServerStandard, Windows Server 2025 RTM ServerStandard OEM:NONSLP (MUI locked to zh-CN)
    4926 = "8NVQ2-PGD26-B8M9V-628DM-MY83W" # ServerStandard, Windows Server 2025 RTM ServerStandard OEM:SLP
    4926 = "8PNXK-H4CVM-K69KR-GCRTB-PR77J" # ServerStandard, Windows Server 2025 RTM ServerStandard OEM:SLP
    4926 = "HH29P-D2NDD-FQMCV-YJPXW-JFKX8" # ServerStandard, Windows Server 2025 RTM ServerStandard OEM:SLP
    4926 = "KC9Y2-GKNY8-4DPQC-BCXDK-6CT98" # ServerStandard, Windows Server 2025 RTM ServerStandard OEM:SLP
    4926 = "WJHQV-9MNVR-Q4Y66-KVB22-W2T98" # ServerStandard, Windows Server 2025 RTM ServerStandard OEM:SLP
    4926 = "XFJPW-7N888-RDM8P-69GFD-4GG98" # ServerStandard, Windows Server 2025 RTM ServerStandard OEM:SLP
    4926 = "YG73N-WF2RB-B3774-Q372P-Q32QW" # ServerStandard, Windows Server 2025 RTM ServerStandard OEM:SLP
    4927 = "4WHHX-NCPYP-6XMVF-77BJK-Y7YVK" # ServerStandard, Windows Server 2025 RTM ServerStandard OEM:SLP (MUI locked to zh-CN)
    4927 = "D9CX3-2HNH7-82XBM-FBMF8-4VYVK" # ServerStandard, Windows Server 2025 RTM ServerStandard OEM:SLP (MUI locked to zh-CN)
    4927 = "K2KBB-T6NXH-T3KFD-VTK2R-BY83X" # ServerStandard, Windows Server 2025 RTM ServerStandard OEM:SLP (MUI locked to zh-CN)
    4927 = "PNHKC-TXC4B-GQH2K-RDX7G-6F77K" # ServerStandard, Windows Server 2025 RTM ServerStandard OEM:SLP (MUI locked to zh-CN)
    4927 = "WTNWQ-R727G-9V3PG-29WV3-JT4HK" # ServerStandard, Windows Server 2025 RTM ServerStandard OEM:SLP (MUI locked to zh-CN)
    4927 = "XNQRR-384WT-F7GHK-MYW6J-GVPQX" # ServerStandard, Windows Server 2025 RTM ServerStandard OEM:SLP (MUI locked to zh-CN)
    4928 = "67XMN-GRBHQ-HYY6H-HP7B9-QV9YB" # ServerStandard, Windows Server 2025 RTM ServerStandard Retail
    4928 = "8N4KC-9GJ8X-C392G-WG9TX-FRKYB" # ServerStandard, Windows Server 2025 RTM ServerStandard Retail
    4928 = "GRTMW-YN4WF-DPK8K-X8HXB-VQ2QY" # ServerStandard, Windows Server 2025 RTM ServerStandard Retail
    4928 = "GX2P7-NH39F-3KPDV-GFTYM-88J3Y" # ServerStandard, Windows Server 2025 RTM ServerStandard Retail
    4928 = "J768X-NXC7R-GFB9Q-BHF4H-GCVBB" # ServerStandard, Windows Server 2025 RTM ServerStandard Retail
    4928 = "K8J32-DN8PK-BWHP9-TBP77-9BXYB" # ServerStandard, Windows Server 2025 RTM ServerStandard Retail
    4928 = "PN9PY-6894Y-P4KC3-DY6WW-4VYVM" # ServerStandard, Windows Server 2025 RTM ServerStandard Retail
    4928 = "PRYNJ-W693T-PRC8T-2FYVQ-M7YVM" # ServerStandard, Windows Server 2025 RTM ServerStandard Retail
    4928 = "TWG7N-WY6T2-3GG4H-YTWFV-6X3MB" # ServerStandard, Windows Server 2025 RTM ServerStandard Retail
    4928 = "VHD4N-BR6D2-96VMV-DBR3M-MY83Y" # ServerStandard, Windows Server 2025 RTM ServerStandard Retail
    4929 = "DPNXD-67YY9-WWFJJ-RYH99-RM832" # ServerStandard, Windows Server 2025 RTM ServerStandard Volume:GVLK
    4929 = "TVRH6-WHNXV-R9WG3-9XRFY-MY832" # ServerStandard, Windows Server 2025 RTM ServerStandard Volume:GVLK
    4930 = "28N9C-JVGTH-4DKB9-GP7CB-R64HQ" # ServerStandard, Windows Server 2025 RTM ServerStandard Volume:MAK
    4930 = "2V7PC-HNXR2-RK29J-QCFVB-XBXYD" # ServerStandard, Windows Server 2025 RTM ServerStandard Volume:MAK
    4930 = "3947N-TWK3X-RXY4H-WRYBC-CKGD3" # ServerStandard, Windows Server 2025 RTM ServerStandard Volume:MAK
    4930 = "4N7X8-3MQRT-K2CX2-T8BT3-VXRHQ" # ServerStandard, Windows Server 2025 RTM ServerStandard Volume:MAK
    4930 = "7C7NQ-YBX44-2W2FP-FMWQ8-6MXYD" # ServerStandard, Windows Server 2025 RTM ServerStandard Volume:MAK
    4930 = "7NJQ2-D3B2B-6XWM7-RF6GF-BY833" # ServerStandard, Windows Server 2025 RTM ServerStandard Volume:MAK
    4930 = "FF2W4-CYNYY-3W2WY-964FM-6VPQ3" # ServerStandard, Windows Server 2025 RTM ServerStandard Volume:MAK
    4930 = "HDCNJ-RY3TF-M3WC6-DX26X-P4BVQ" # ServerStandard, Windows Server 2025 RTM ServerStandard Volume:MAK
    4930 = "JJNKW-G24GP-3XT88-KCWH9-BKRHQ" # ServerStandard, Windows Server 2025 RTM ServerStandard Volume:MAK
    4930 = "KPN22-68C83-V8W6P-HXF92-YKRHQ" # ServerStandard, Windows Server 2025 RTM ServerStandard Volume:MAK
    4930 = "MNM2B-9MFPJ-7Y8HV-MPT4W-78V7Q" # ServerStandard, Windows Server 2025 RTM ServerStandard Volume:MAK
    4930 = "N2QVF-QBYQH-V6GB9-XHDKK-P4BVQ" # ServerStandard, Windows Server 2025 RTM ServerStandard Volume:MAK
    4930 = "NPWRX-KWTJH-7FQM8-PTGHJ-QDFHQ" # ServerStandard, Windows Server 2025 RTM ServerStandard Volume:MAK
    4930 = "NTVQW-7BXBC-88QFH-Y79TP-7CH7Q" # ServerStandard, Windows Server 2025 RTM ServerStandard Volume:MAK
    4930 = "NWP8R-7YJG3-XJC9H-8KY98-F3QMD" # ServerStandard, Windows Server 2025 RTM ServerStandard Volume:MAK
    4930 = "PRHT2-JBNHV-33HQM-6HJMQ-4GHBD" # ServerStandard, Windows Server 2025 RTM ServerStandard Volume:MAK
    4930 = "Q9KRP-N6YR9-Y364W-BDM28-7FW33" # ServerStandard, Windows Server 2025 RTM ServerStandard Volume:MAK
    4930 = "WNJRG-CFGWM-M2TJM-34PBY-CWJ33" # ServerStandard, Windows Server 2025 RTM ServerStandard Volume:MAK
    4930 = "WQ8DQ-NJWVH-DC3XM-YKWX2-YKRHQ" # ServerStandard, Windows Server 2025 RTM ServerStandard Volume:MAK
    4931 = "WWVGQ-PNHV9-B89P4-8GGM9-9HPQ4" # ServerStandard, Windows Server 2025 RTM ServerStandard VT:IA
    4932 = "BGHNQ-64HFC-WD7WG-K2T34-8477T" # ServerStandardEval, Windows Server 2025 RTM ServerStandardEval Retail:TB:Eval
    4932 = "YPBVM-HFNWQ-CTF9M-FR4RR-7H9YG" # ServerStandardEval, Windows Server 2025 RTM ServerStandardEval Retail:TB:Eval
    4933 = "DCXHG-67NR6-6CRMW-2PYFW-PKGD7" # ServerDatacenterCor, Windows Server 2025 RTM ServerDatacenterCor Retail
    4934 = "QWKRN-BQCJ6-RYFXF-Q92XW-PKGD8" # ServerDatacenterEvalCor, Windows Server 2025 RTM ServerDatacenterEvalCor Retail:TB:Eval
    4934 = "RNJ27-KR4TJ-DX6FB-XFJJ2-2DQMJ" # ServerDatacenterEvalCor, Windows Server 2025 RTM ServerDatacenterEvalCor Retail:TB:Eval
    4935 = "B2NYV-R6JT2-H9YTQ-VQ4X3-979YK" # ServerStandardCor, Windows Server 2025 RTM ServerStandardCor Retail
    4936 = "G7M49-K8N7M-TMP7F-QDMRT-FVYVY" # ServerStandardEvalCor, Windows Server 2025 RTM ServerStandardEvalCor Retail:TB:Eval
    4936 = "KGKTQ-NWWW9-Q8KKW-4M2R9-66TFB" # ServerStandardEvalCor, Windows Server 2025 RTM ServerStandardEvalCor Retail:TB:Eval
    4937 = "NQ8HH-FTDTM-6VGY7-TQ3DV-XFBV2" # ServerTurbine, Windows Server 2025 RTM ServerTurbine Volume:GVLK
    4937 = "XGN3F-F394H-FD2MY-PP6FD-8MCRC" # ServerTurbine, Windows Server 2025 RTM ServerTurbine Volume:GVLK
    4938 = "HD82H-7N6HW-836B7-MXWV6-PDQMQ" # ServerTurbine, Windows Server 2025 RTM ServerTurbine Volume:MAK
    4939 = "6NMQ9-T38WF-6MFGM-QYGYM-88J4F" # ServerTurbine, Windows Server 2025 RTM ServerTurbine VT:IA
    4940 = "VK6GV-24NHF-W97PV-3JQV2-HH9YT" # ServerAzureCor, Windows Server 2025 RTM ServerAzureCor VT:IA
    4941 = "FCNV3-279Q9-BQB46-FTKXX-9HPRH" # ServerAzureCor, Windows Server 2025 RTM ServerAzureCor Volume:GVLK
    4941 = "QN7G3-4RM92-MT6QR-PR966-FVYV7" # ServerAzureCor, Windows Server 2025 RTM ServerAzureCor Volume:GVLK
    4999 = "3Y8N7-3R679-4XFFH-6BTCM-X4W7X" # ServerTurbine, Windows Server 2025 RTM ServerTurbine Retail
    5001 = "TMP2N-KGFHJ-PWM6F-68KCQ-3PJBP" # WNC, Win 11 RTM WNC Retail
    5047 = "2NFPD-V8TKJ-2DG42-B3JPX-H6HG9" # IoTEnterpriseK, Win 11 RTM IoTEnterpriseK OEM:DM
    5047 = "43GHN-GXB7P-FBYC6-BHJQ3-XHPXX" # IoTEnterpriseK, Win 11 RTM IoTEnterpriseK OEM:DM
    5047 = "4KNYV-MDBBW-JPQTQ-JYHXV-G6TKX" # IoTEnterpriseK, Win 11 RTM IoTEnterpriseK OEM:DM
    5047 = "B7NG3-8P7CQ-Q3MYX-MPJP2-W2VG9" # IoTEnterpriseK, Win 11 RTM IoTEnterpriseK OEM:DM
    5047 = "F2NX7-7RJCQ-DKMG6-WFXPF-8B89X" # IoTEnterpriseK, Win 11 RTM IoTEnterpriseK OEM:DM
    5047 = "FH4CF-T9N99-7248H-MKH9B-KFB3K" # IoTEnterpriseK, Win 11 RTM IoTEnterpriseK OEM:DM
    5047 = "KCFDQ-NK6TR-KY7QX-WJQGC-Q32XX" # IoTEnterpriseK, Win 11 RTM IoTEnterpriseK OEM:DM
    5047 = "NFBCF-GRRPG-KRWXM-G9KVJ-82VG9" # IoTEnterpriseK, Win 11 RTM IoTEnterpriseK OEM:DM
    5047 = "NXCGX-6FQ8R-7BWMD-K9GF9-66TKX" # IoTEnterpriseK, Win 11 RTM IoTEnterpriseK OEM:DM
    5047 = "P8NQ8-Q6FKB-YFQXV-WJ2JV-HXRQK" # IoTEnterpriseK, Win 11 RTM IoTEnterpriseK OEM:DM
    5047 = "P8Q7T-WNK7X-PMFXY-VXHBG-RRK69" # IoTEnterpriseK, Win 11 RTM IoTEnterpriseK OEM:DM
    5047 = "RN8QD-66KC4-KB46X-CCTMK-DYM3K" # IoTEnterpriseK, Win 11 RTM IoTEnterpriseK OEM:DM
    5047 = "VJTJ2-ND2PJ-HRBW7-YMPFF-CR8DK" # IoTEnterpriseK, Win 11 RTM IoTEnterpriseK OEM:DM
    5048 = "2CNX7-BCW8W-WJRCB-6T9BP-HH97B" # IoTEnterpriseK, Win 11 RTM IoTEnterpriseK OEM:NONSLP
    5048 = "3QRTG-HNB9P-78BPR-JHVF6-9K3VB" # IoTEnterpriseK, Win 11 RTM IoTEnterpriseK OEM:NONSLP
    5048 = "9T2N4-GHKTJ-PTR67-DYH4F-WFK7B" # IoTEnterpriseK, Win 11 RTM IoTEnterpriseK OEM:NONSLP
    5048 = "BQNJ7-7RWYX-KM9VD-DQC2J-J8J9Y" # IoTEnterpriseK, Win 11 RTM IoTEnterpriseK OEM:NONSLP
    5048 = "C4NF7-QQMQ4-F7DXJ-YBXM2-XTTKY" # IoTEnterpriseK, Win 11 RTM IoTEnterpriseK OEM:NONSLP
    5048 = "C6NT7-4VY2G-MM2J8-R2J9F-2KGKY" # IoTEnterpriseK, Win 11 RTM IoTEnterpriseK OEM:NONSLP
    5048 = "C8KWR-PDNKF-KR7X8-K6FTB-PR8DM" # IoTEnterpriseK, Win 11 RTM IoTEnterpriseK OEM:NONSLP
    5048 = "DYMK4-GVNGK-8K2C6-8FH9J-W48DM" # IoTEnterpriseK, Win 11 RTM IoTEnterpriseK OEM:NONSLP
    5048 = "HKMQN-942P9-KK33C-CDPW9-TF8DM" # IoTEnterpriseK, Win 11 RTM IoTEnterpriseK OEM:NONSLP
    5048 = "HND82-QBGCB-P93GH-M2R4B-88J9Y" # IoTEnterpriseK, Win 11 RTM IoTEnterpriseK OEM:NONSLP
    5048 = "MFRNJ-8GF2P-GMDH9-8QY43-C4B3M" # IoTEnterpriseK, Win 11 RTM IoTEnterpriseK OEM:NONSLP
    5048 = "NXM8B-D3W9X-BYY4X-GXTYR-CR8DM" # IoTEnterpriseK, Win 11 RTM IoTEnterpriseK OEM:NONSLP
    5048 = "PWWN4-46TJD-67V78-WK29K-YD2XY" # IoTEnterpriseK, Win 11 RTM IoTEnterpriseK OEM:NONSLP
    5048 = "PY848-2CNXR-284G9-43Y6J-2G4QM" # IoTEnterpriseK, Win 11 RTM IoTEnterpriseK OEM:NONSLP
    5048 = "Q8NRB-BB7VB-TBB66-JHMXB-KFB3M" # IoTEnterpriseK, Win 11 RTM IoTEnterpriseK OEM:NONSLP
    5048 = "QJXDJ-ND9BB-X2FC6-QJK9H-B7Y3M" # IoTEnterpriseK, Win 11 RTM IoTEnterpriseK OEM:NONSLP
    5048 = "VCRGN-V97FW-HGRTG-X7WT7-G6TKY" # IoTEnterpriseK, Win 11 RTM IoTEnterpriseK OEM:NONSLP
    5048 = "YCT2R-WN2TY-JR6FT-9YYPV-X797B" # IoTEnterpriseK, Win 11 RTM IoTEnterpriseK OEM:NONSLP
    5048 = "YMHXR-NVTR6-FHJR7-PGKPC-4RK7B" # IoTEnterpriseK, Win 11 RTM IoTEnterpriseK OEM:NONSLP
    5049 = "2KNDH-VWWJ4-37BX6-P7V99-RM892" # IoTEnterpriseK, Win 11 RTM IoTEnterpriseK Retail
    5049 = "3GPNC-67VM9-QBK6H-4QR7Y-F9GK2" # IoTEnterpriseK, Win 11 RTM IoTEnterpriseK Retail
    5049 = "46CQC-7N7JM-4KXHD-V3BGB-8FK7C" # IoTEnterpriseK, Win 11 RTM IoTEnterpriseK Retail
    5049 = "DH93J-6NDVM-269FH-RPHYG-HFW92" # IoTEnterpriseK, Win 11 RTM IoTEnterpriseK Retail
    5049 = "HHVBM-J9N9Q-4GF6Q-RBTCM-X4W92" # IoTEnterpriseK, Win 11 RTM IoTEnterpriseK Retail
    5049 = "NKXGK-PC3V7-HP62F-FK6BR-WFK7C" # IoTEnterpriseK, Win 11 RTM IoTEnterpriseK Retail
    5049 = "NTVVQ-QHTH8-QGW4W-D39CJ-J8J92" # IoTEnterpriseK, Win 11 RTM IoTEnterpriseK Retail
    5050 = "HNJPM-BJYHT-9DXB8-GMG3R-TVPX3" # IoTEnterpriseSEval, Win 11 RTM IoTEnterpriseSEval Retail:TB:Eval
    5050 = "R63DV-9NPDX-QVWJF-HMR8V-M4K7D" # IoTEnterpriseSEval, Win 11 RTM IoTEnterpriseSEval Retail:TB:Eval
    5053 = "2TNJY-GCXC6-9PKGP-C9BHY-88J97" # ProfessionalCountrySpecific, Win 11 RTM ProfessionalCountrySpecific OEM:DM
    5053 = "9JRFJ-NY4F6-FWR9J-Y23C8-7FW97" # ProfessionalCountrySpecific, Win 11 RTM ProfessionalCountrySpecific OEM:DM
    5053 = "BXNC3-X7RK3-GQ2MJ-8MGJT-9K3VH" # ProfessionalCountrySpecific, Win 11 RTM ProfessionalCountrySpecific OEM:DM
    5053 = "F8YNR-WCQ9M-QTVJG-RVKKF-2KGK7" # ProfessionalCountrySpecific, Win 11 RTM ProfessionalCountrySpecific OEM:DM
    5053 = "NQBCR-WJ29Q-VMPMJ-CWR8P-BTHHH" # ProfessionalCountrySpecific, Win 11 RTM ProfessionalCountrySpecific OEM:DM
    5053 = "PNJFT-VH9RP-677H2-JQKYG-RRK7H" # ProfessionalCountrySpecific, Win 11 RTM ProfessionalCountrySpecific OEM:DM
    5053 = "Q7F66-N8HYB-BH7D2-T2VVQ-XHPX7" # ProfessionalCountrySpecific, Win 11 RTM ProfessionalCountrySpecific OEM:DM
    5053 = "WPCJN-VHHPG-T4HQF-63P89-H6HHH" # ProfessionalCountrySpecific, Win 11 RTM ProfessionalCountrySpecific OEM:DM
    5053 = "YKTNF-36QFD-J9X34-M2K2K-66TK7" # ProfessionalCountrySpecific, Win 11 RTM ProfessionalCountrySpecific OEM:DM
    5054 = "9467W-N8H33-WJXHP-H8VTX-YD2X8" # ProfessionalCountrySpecific, Win 11 RTM ProfessionalCountrySpecific OEM:NONSLP
    5054 = "C2N7C-GMDQD-PYQ8W-2RR9Y-XBX7J" # ProfessionalCountrySpecific, Win 11 RTM ProfessionalCountrySpecific OEM:NONSLP
    5054 = "G9R7G-DNFKJ-DMQW7-C22HW-CPVHJ" # ProfessionalCountrySpecific, Win 11 RTM ProfessionalCountrySpecific OEM:NONSLP
    5054 = "HD82Q-G2NYW-HP8FX-9RR9Y-XBX7J" # ProfessionalCountrySpecific, Win 11 RTM ProfessionalCountrySpecific OEM:NONSLP
    5054 = "KKJDF-QMN77-V98QG-48BMW-293VJ" # ProfessionalCountrySpecific, Win 11 RTM ProfessionalCountrySpecific OEM:NONSLP
    5054 = "MPCXM-GKNBP-9X389-8F2M8-D9RQW" # ProfessionalCountrySpecific, Win 11 RTM ProfessionalCountrySpecific OEM:NONSLP
    5083 = "6DP7X-TNX92-KV2QY-4HMR8-YP6PF" # ServerStandard, Windows Server 2025 RTM ServerStandard PGS:TB
    5083 = "VK4TM-PNGMV-BHK24-YYQ8Y-FGHJR" # ServerStandard, Windows Server 2025 RTM ServerStandard PGS:TB
    5084 = "6KN7D-77DG2-CJKTP-WWCTY-6VP2G" # ServerDatacenter, Windows Server 2025 RTM ServerDatacenter PGS:TB
    5084 = "DPNMD-GWY43-89QF8-GKR78-RYC2G" # ServerDatacenter, Windows Server 2025 RTM ServerDatacenter PGS:TB
    5085 = "6JM4N-QPP6J-G22BM-6QW47-3J7JV" # ServerStandardCor, Windows Server 2025 RTM ServerStandardCor PGS:TB
    5085 = "YXQBN-WFMYH-HCV9T-CTBMC-9QFR7" # ServerStandardCor, Windows Server 2025 RTM ServerStandardCor PGS:TB
    5086 = "FGXCN-MMQ29-B3D33-QX36P-RVY48" # ServerDatacenterCor, Windows Server 2025 RTM ServerDatacenterCor PGS:TB
    5086 = "YDNPJ-7YRQ3-G66B6-CQQ7D-G87JW" # ServerDatacenterCor, Windows Server 2025 RTM ServerDatacenterCor PGS:TB
    100030 = "2MP7K-98NK8-WPVF3-Q2WDG-VMD98" # Win Next Enterprise Volume:GVLK
    100034 = "MTWNQ-CKDHJ-3HXW9-Q2PFX-WB2HQ" # Win Next Professional Volume:GVLK
    100054 = "C3PVB-FNPQD-WR76V-FBYR7-PDG4W" # Starter, Win Next Starter Retail
    100054 = "D6RD9-D4N8T-RT9QX-YW6YT-FCWWJ" # Starter, Win Next Starter Retail
    100055 = "3NFXW-2T27M-2BDW6-4GHRV-68XRX" # StarterN, Win Next StarterN Retail
    100055 = "744NM-C4FXY-YGM8B-7MVJC-BBFB9" # StarterN, Win Next StarterN Retail
    100062 = "G2DR7-7N9C8-KBK9V-D4W3M-H49R8" # Win Next ProfessionalN Volume:GVLK
    100063 = "N8BR7-D8XB9-939VB-FMFWD-KWXR9" # Win Next EnterpriseN Volume:GVLK
'@ -split "`n" | % {
    # Trim any leading or trailing whitespace
    $line = $_.Trim()
    
    # Split the line into key and value
    if ($line -match '(\d+)\s*=\s*"([^"]+)"\s*#\s*(.*)') {
        $key = $matches[1]
        $value = $matches[2]
        $description = $matches[3]

        # Create a PSObject for each entry
        $obj = [PSCustomObject]@{
            Key         = $key
            Value       = $value
            Description = $description
        }

        # Add the PSObject to the array
        $KeysRef += $obj
    }
}

# Start #
# LibTSforge.dll Libary DLL
# https://github.com/massgravel/TSforge
# Begin #

# Tsforge Part -->
$base64EncodedDll = @"
H4sIAAAAAAAEAOS9CXgcxdEw3DO7O7OndmdX2tW9K59rryTrPoxtrBOEL2HJxieybK0tGVkrZmUMGDkmQMJpcLjNZQgkQAgEwg0JkBASEkjIwZEEDLyQQBJykBBCCLH/quq5VloZ8v1fvv/5n8+P1dPVXd1dXVVdXd3T07ts3WXMxhizw9+RI4w9zPi/xezT/+2Fv5zooznsftfzZQ8LS58v6x0cSsdG1dQ2tX9HbEv/yEhqLLY5GVN3jsSGRmLtK3piO1IDyUqfzz1Dq6O7g7Glgo099MHJB/V632DTYh6hirGYwJjE0y5shHgMCRMQDFBc5HQzZj7ZXoHS8Z+NLT4PUfG/+TQe9K8R6l3BeL1Vtiyd3CQwLzyWNgis9zPwxPgH9DktoBPg4y1w5Vjy9DF4flSq9Stm0m2pYlOlmla3QJxow75jR6cJGXiL4X+lmhxOAaJXo5nqmjUJr3Uimac0chykTWQOZr8J4lczJkxE/Iz/QkDopYzKK9FZlyyE2MwXdgPZcT9j7r0yxGI3Qr6Wc5aR48Sct82c040cF+bYBSNn3MhxQ2w6FDl85MjrLXEQq9sdZHEFszyQFa2KVqWDCAFX7HOBNjubTv1kChNTIchJ5UIw5OaAlLRF1vZtj6TyAJg1l/oyk6EeAX48DImiLRXBUvkQRC4B1RXyUwUQDx9wJ5g0l/pvZ8VmG4WWNnj1cQfq9NzVTAzb4tCpRBxQE6kSwGFz9zExXgoxWyqKBSlRtNtSoAnutVpJzmPIQlVQmA1ZIUHtOra0b8hEBVyBhXVcTs8Y0CekypBbnOgiqK8LcByI8wLQVBSfBrnx6YgiEdc9ckEchqzby8SLESEoxmdiv+OzsFF2yMMgZTbFX5V9CebCtoUA8iHG8puYh+uGyIAAHNJASzpO1YupOcge4qsnwWTkQXh7mMtAtO0b2p6aSx2zhQFIJYhPvK7iTNlYpJIq13uHvCrS+8/xVOjAaLwCGRw1mIB4WwFPRrw8aM4T9iaWyc79Pia5ovmb+93hkD1RziQQBdvbFz5sCzkUR3kOkyKbYw+VPGXvd7OEhBCwQLFH1oTsir30sD0kKVLFs8wZWeN1yvuGar4ubQ3JCabIWh+AULQTClOB+6P58Uokax5xRq1FOsEMuitsUsKhHgsgcQjLnQ3lXNSnaixRg0EtFYvtBckctocPg9DK7YXexHopNgrcrfFJsTQ8D4uQlRDCPle5Hfq4UIp9o4Tn3ldi5iL55faIN1Eixf4CinBYoP7a870Jj3ocUJKug9bOdM7V5AriQuErbI8PmA11uKVyWYzXk7imifEGTW5FgPsg4HoQN90IqekmIjuSaiYx7w5qw1vySMAwnirJXLshGwaqPTUfVTGxHHTuGIj5WNAWX4Aai8VCdoAWGpBDUuxGNYrDjNp5lZCm1Q21LUJm33HIHxQPh0GzilLHYs6rUtyJVUkgNxwvXK+PZesPML9u805jZHthPKYXY6e4cqdaUIv5wyNKchwqlcaxh4kaxpO9/OGTnJQZsksuHnHwvip2ILCVCJRMkwVDoXTtdk29Hpiriuk2SB3HAhqvYcCguoMVWJklE3TIwTbAQPDRWNxdjFzFgbgHytihYq+z3NG0COcRyovOMIYkwdQ/D5NT7ZjGH+6wr+kQ8oODITt/RlB1tCRJe8ra0xkm6xJyKY6QW3GXL4Gy2EdFisbWjGgtargexaPIhwVQrZBX8ZZ7mXoJqmEHqqEcjZEBmSUrMkVCLr0mezTXqEncXYS0AwOlmXLs80AqF0gOpM6USzngR0BxjQfo6RhXkDWdxDVXZI3PtQfqtwPnfYpvvnLkyBHejqS3wSS0DTlKzvxDMC3NLQI+/wbqzTH03S2RxofsYCb25GLlx2HlABQgUMIBy8yBA690DUjaQcJZE5LDIWfTLTjBK07epRRM326gCXkYYjxNcaa6OCcS8xn1GVmoCgIbpQ7rcT/Fw9RPeJJAqPOKB8pqlCgOXf6kj82cyLAe4TiSBUfSsxTXbqy5whZOCJEsiSJIbGJqXsIFcaRBH66fnold4iKVUespDbtWqsNWjkpabaRJo0YHZLMDGcLI1h4mxGcITJqApIN7CqeQpgxSi6whLdpYIStOUBe0t6BOzd9nWWQaUALlUVMOhWssXNZYl00Ce/KRQIel76YMSY+isbV88OVISk5YT0qdQMVzqGshv1GUqx4gWFr3a92TJ2soo06GnBmdoT6v1/q+DrqmKMr8pn8fOQIFtVmeHfLBvOOEZjXLS36KRy7EsZmQozPidnSZHLrfRGR6ZbK5bs00NZE5JQsVCmr2K5xpviSydbxJlxIs5F4d701QtyUuJ08BBCXITS+5KoVrLehIcBAIDmoE43zYUsfdb5wcIkD3LBvZWfqH6WMAo0//siV9kTZqbdzUzDXh5QTjvLmV16kwLS+1gtyXY8Dn7ebmmEaBjXyG8hyZ9N9OEGgYWPSAVlBOnYgdPFTEoOhKnPMehzmPHQ5L5pxnzHM57PjVfJ5DP/F8RusnsGU92LiVEk9icVAgSrzMaaWkwGmhpNzjpKFnOCEwBTs1+8qgPJHzEJAjZJAj8oakuIRSB/1KjCM8l9OYy5b16zSKTGXEpIl8WvyZ+ZQHGBqNQKCYkOSQ/VDMYNZDk5iVC74hDDMLz5atN30DXFsFaZ61qTYwuegoSwYQR/ddyj0sQMPA1nycnGzkI3hYAvxLsirouElAOLnWuMa4FuvGOsPuRK/WT4kMviejd2Fr78qdvF+8l/lMdpCh10rLqdXYmUQ7eLFrwDG3WiGfq+KAdfaM0HQBdNLUaeeTJq9NU+A7RdIQkpLpkhQWhOMnYXIxJU/T10K41pB0P2QNM3389dr4KNibqy8d9+ZhLAZDfi9aGzI5ezBt/V40LNGte9H0RVdFY+b6ai+a89idUDojtVBbF4qsVPdfxd0x5F5Vjk3cXYYzveYQ0zLBdGRRrl+EMrm8TALpXgtZ3O0G58QDsk2vQ+dE3D2X6xLw3K3h+hIreGTP55BzFZFZe/ZgY9I8sGdp6LR75l7MQcczEQdHPwHOpFY/uebQwhxB98IlvuIKVUlsKdCURzShxCV3eiOqhCTz0qmTMejDISo7qaNO6mRqE9pMF1hJTqzoTDeTM0pabXHfYXxJ7HKwwWG+9uxDtRR3V5JR6adKwG/cCQhyHOqUvM70Zu7spLfgEyYKsO0DZGgdqSQ801vJMVQk1S2yUTUAQWob5UvqykkpqzFlg5niSA1icXD71LshFdyOIYSd8e04azlTp8AjPsy0Jbt70vTCqXNp1IH7pLg06twW6tBv2mWDlnfbjJbd6lsAKJ7UDsTwArzRbsI+gL9rgXPSI/jwp1P4CKRHUcJqhYONhlOnYn0z1SQAEQ6EFKbkpFSawBLLYW5JQ3RsJk7WIaaE1BscVDN2lfdwDFFzFb+SC1NqSH1gQn5qJwancQ0PpnYxWuWEleDOQqwzT8kDnuRpPGGKjzcdbvoQDWnY0nqEKRH1xQm1h/KVgJKfOl3TzkKlEOwYJqXPQJQzqdn0PDQbUPpf2Wgfj5GzHVH9UrbcMi03OiF3fJqW0TwxY7qWcdKEjNRuCNSUpC2sx2egE1hA9J+FGlOQGudcChOX5h8GHx4YFc7OKC9nVFFTG253FVkYVcyUYvWMCY2HSoKlSkl8DzZUrF6brauhKNBSEoylPocTtBKDaSFUppSVS6zpdRRGjBuB6qC4uwJd9NLUXs52dCGnKdOaaf8WFCEanJ46G+tI1xDjo+MziSXF6kMTeTVLy/j5xIzZWoYgT8iIT5ExkbtzCG/6+Fx6xsYT9CwdL0euz9C7oMxIfZ5P/8BC4vq9nOtFWbkOQ9gFsEt3DDTjcw63UC1ncR8L91UugL8HWKbvlQRJ4ZzypEA2zEh/A2AX/P1OzEx3gY+2GtL77JnpP4S/uyHvdLtZP/oeOEFFNN8Du5c6F/lyHjkg/eBAfEFzQFAaNpoSwOGW+fzxRbSfiWjQFj+faQtEe6qS9gIUB6iAHJIOteJexwU4gF8BL8R2OBwwvRD0MuIXYt5V3EPxm3nqbJBV+iKcLfgeRjH2o5mVJ7mfIoI3MXK26UPBJM7yqR+2+ABuPVxMXSiCFi6hLjBRjtfSXt4hB2jQIWp8Hzb+Km9cyfQli2kWZ96ZzIEg+kgwq1B7Z4rpS1FdkF9i+jKMVppeA5+fZxl7mLurcF7cD1ni7mo9aq4IaJ6eZdnnkNi/qWWmGG5IjoP4P16DrdjGa/FhH6/Dh2O8Hh859vEGekq70caMN2oA2pV82mKcGY7Ov2FmJHrMDakv4RA8MN5EOI7dOJ7GmzUAh8r4fA1AvR8/hlqLHQHWbO+L1my2bY8dOXLkWIjnbt4k7kaaMMUPuZvGq4imCli/JMTI9mj1Zns0Z6AM8I+AgWCAUE2MAvIk3P+WYkdAJ/vcImeNNBKdvZnjzNV80Tp9z1S9ExRC3I29LI/wZ6RSVn8FqQmH+nv++EDWdkq1vVSZ3Q/lC7F8YdonoOO6G8yWveASMKTizHBagrSZ+eOn4kBXD0Pp1IeoIzPF1OU4Dj5C4JaZEcKDVR0hymqVU0eUtf2HNKbfMjM/s8KTnWaF8fmolbzC1BUoVynlBGRaEUYDtF4khUhfie5OgjlJFyK4ew30p6uQetCmBVBz7mEbOVU5GhxyNP0FdxIyt1Y9ohxjIM95M2XaY50XlmlrdJ6s7nMSuw7wx1f44z54jGN16rchFr8KbeMrGLsaCXLGr4FHORhyVBX1PewaOPWwAomgN1TuMWhJbJPUv2A5GFESR6cqxvei/xY/AFHpsFSNjuN1OBRAwxM+F/YJ3KLyGBNdEV1jF3JljRxI3YAVYP1mM+BNcR9yBHhUzMfaQs4dt1Tu0yBP04m4K8j3jhbS6qFBd2+bK/C1kYh7sZJP3I2DRhVd2myAmwHlzYwSQnau6PnrowMbYwGYaNaJu3EYxg5+QWDr1+DmpwFuDEkssYJpKYtb/Wx9yBV0qW6s+UaylJa8jVjWrPtd0IN15ARTlBzgNVBhOCSzoCN+E7l94ZAnMQN8P0/qIDlzTJGD3vjN+qSM+xmKJ7KGtiDd9DKm5qclilyycW1IFtUA0FF0SYA47ALlVuyguIrjYnD+hVtmFiiyFitUJB6L34LMX8iZTzzFXX3z3VnJxL3x2K2Qqu1bF2hPEfe4pWg+Logl1Avss563G20RDAKeFx3m+0B8G9sjxz3G9gnajK3xW7GnRqJX0jY+OL6+trCx54CK0km0fWQ3aCs0aFuMtmivsRsHFKHZ8+CivhTfz6A1sOYDrQ4NEfU75hQtRdEi6yYwdRu1EO028LGrmU3Nn5TSOCGFOqbZBAfND1G+ZlpA79IsmuaxqpY37qVV0QTDEHLEv0IKHnTGv4oRyYRvx4jMKcD1RciluMwxUREAqNWApIQz35dwFvgS9jCwXe2GnKhLUy0JVItLWdOnfF2xCpy6hrm0SJFiv3gjxYoNRSzR1W9mqa6SpIig+6Dd+vzwFqP3zrC2i2grTdyJokkpOmezuBsnyWgUJypky/YIxqzy2YS+Ck3JIanparQGFmZaObvRY2qRV5uHZPUFF5nOQjcb9Tld6T3EvaAcv4PpG25Oq6Y7tW1mp7YR6tSIsWw2OznNXG+cGS9y0NYNg8Uqo/kQDZqbVx5jPzxwjGaR1qTvJNtvWrnyNqYOAIFukFGcSXvm4VwVzedrazIg9qCdWw+aOvlrg6LDdmRNxY9Z07PEFppxgcdg7JsfQjcITBKfyUPOaH7IldgBKe5oDsinBpabMXylvo6WqE7Fs39NiJ6KO5q//mfX42MjqRdZqrVoqcL0DhB3uCueJBqVCdRJGnmKCwqAWmoFfIqv4jwposipr+GMtQ96KilyZI1Ehk+R10bWUk78LipdFMpJhJmk5KhfAszU13mVOcVr8B0ILwM99yv+il9JoQAwPjC3Ur0KUPciTXNxP+Ex6Pw0sis1NClLu2FqtPvZnruhcG5QCIrx5eRpOuP3oIuMb2KHmEux//xwMchYXLfmVHwge3d/CccZsBR3maQ930A672V8h6BcTFRAxkbiMMxFYqLUVuGFMpdzSeASCtiA+32KFHIfiuuvcbfLI9AFYGnFhYyqhEyPVC5LmnuruOdq+34y+8rX+btu3CuFDuJ5A6NfuR69Z0EhvgTIKLflJgTZm1GZ06yraJpel0RnT2ZM4lHEzwqJP8vQULsqJJmWghEauG6NWMehIo1zp6LtBTiDeMdcvb1jO/X27AymZDz7MEkmNnt8KU4iGXXIJs2hQl7HLBbGzVZp1lxOfxWlTa5P/QGoAnYBljUnIj7LqNmgrWSGyVe0VbMn1aW+ATX5Wbw3Sy3MoC9S+hl4Gv5v8FSifeB4Nh7A3DsKHBA0HmBL4ZocxR4L/sX+JL3yRN2cso3a+Z/WpwI/y//v9AnfY8zJ1qcFngy5YksVklNrFh1cvVn50PSgwxW/D4cqbY044idjATmzeYuOLV9l6iksd1EfYO42Bzt4qx51wKPvvxJluObWxh6StJLx97R8YZ0LC+sOJ38bZge7EnbGv8n4Sz17dAFO+gn+3gndI5j+aXPRTluKUNIjl8uyTqZ5PqCMrT/L5NPiqWT/4GTZm2KfWgYwJxh1QzmWyFb3u6YMuibJwOx6Huc+dsXamGSe4ZHZgjazvR6+vzLZNkzoR4VXLnc5I5oCf7YW9fYWdZjt4dmKis8wP9DWgU/T4ZAdRkyiDKcJxWFMFDQ/8L0iWO6AeQeauHnHgxQ/Y64samfQ1D9o2qCp7KNfiPd8FvuI/QKSWKWlDtJgbY4Q8YyLxJfNYehj/Dj0WCfOFCZtM8v1ekU6szbZPoJpPD6raTTqCBaYdWyG5zy+j2Xd/2k09n9kmmG9TnPY0auysMwnWDQsYsLpjG+jmVvfG3oy696Q9s6sfSXfD2pVP8LBi8Zg7yJt7wJ5vgY8oCoa6+AptnrJU+yGBxCTfoDGfepBRgdO8C3Ea+W4GD0UC9mZugGw5PhDfNg+rHtm6UfQPKgXGpnxEBIb9qLmDGKnsboCPhLRZAHXHqXlR2Q6bfgt/tzi+GPo9T1OCnUoAcydCy6YeidUCQ6U0RKvOPYBUBT/FuIeskW8mgI6KzyKI9Zkx0NbaObBNak4BwcpOSOKmuvTyUt/m+id78ukV6yQ4zBEJCyMB0AamToCKFpn4ru0kx/g3ukHZ66A7PQTVNl3DEw2V4hjpxRWUsliFXSEcxurPcDslXr8RjYb01EWRwCzmmRBZ72a3yOGkDhIFh6ZmFeoyeLnmHuoEGXxCbSYRQqVOQbJOv95FfkW/supJ5F7cuGn8H9lzn/K/0EhO/896qNQl8b53xo0svhafsKS88zHyipZIefZela7T+cZxL+k80xkpwJmDZ3Zo8J7nkL/utQPXvN3yGsGhfsusi7sTSRk5wEfc6l1mPs0mTMYUAFI6fRrG0UwN8wwzxX+JHNYqyf4je1ehznGI6xljX4W085gxcNqSYY+l9cZaRATs6Iz499Dqv4NxePPIOd8MLfMrJBm0fooZG96HsV8VYCNqssUCDA1/gNAHGuBRuLP0jBUt0BW/IdkzeI/wnHvkWm7yzIR7GKFl7TQwlbdCdiwuFUvoGe+ehs9C9Tv4jMkwVqNjjwlmhVZcR4IuZhGpeKiNiyt8VZoFDhkWCVMN46hKMikJ/CIJqZ71N8pBn/s+rndcAY/yp0JYG9lSaJBTQShAeyaujCoNQWceBc5YWb93pL1mZh0R+j/JJPM1j47k54IZTAJ9wdguY57yLhXsoP2SrxO8H+AVXKk0pvIlWzpH9OeUR7E/kwxj2QT0/foG0l4HhlGEKvndYzQ4Yd0AqdM2gRDnw7WkKyBn21w5NL79JDWXMAWcYvofsEIdGhMc1iYBlKLMPVfQLZDXZILHcY1Ku8BFCiIROjwAQws3CSFSQoGlU2Mz8Jt4+e4CfG4ymX91ZJ6IlRhNyvShv6hkPZGxgVUncK/UODzKL1TWcuKd/IxJrLlbMm11F2av6CzrBH7ZddIt1tIB6cVSL+UWrwjk3Stx6ItnuKnQOzx59HqXc7JsfqfGkHq87m6pbKcV1W69bEv4xoBZQkygBU6ezJMvlQBf8TTUDCCgtT3/Z3QE4b+isJUXx5UPYZyi8R/Qtobc25ie6lkWI4ERV7HTvQ15PgL1EGbT47/lGbO1M/w4TLOy2Ddq6Du+RPqLtTqhsktZj/I9iYcMXbQaKVwQis/R6lmb8JyeAF1DzwP/v5D3L0MN9JzsDHs5HzkL54YHsf0uRNwl0+Bu5zjini+h94xabjh+C907hEy7rByZDaJjhVT1L0iS90rpqqbkBeJ4fGl1jdnk9rqmaKtnixt9UzVVk/2fvROUXdvlrp7p6q716hbZP1M+2cTd3cz/aAsACdaAaRm35AB9maCKyei8l1EDVH77IJx2zYEz2P4dxJ0npk/PPzh5Q+fqB1uFp38oLFDdPGIlD6Ib9qlcSR1pjyORM5U7OMrGT9H3ENPzg7tE4AJ5+I/hvYXTNxfF3evMggFYDUCL+LofwkDfvzTmvwyktyEr75h0fAKo082KNuZ+iXS79QOyWcci9frd6V+ZdQqFeKaFwyMK/Vr6miiOOiIv0pdhdlGSt1IW+k6FuS9hkbt1+DhOw6H8y2vpYGQQxCbf8qRI0f4wb7wpLP1+jcR3IZezeY8qb+XbmXXHzLP0sHYZgsnnrMXpVKSwTiyqukqxJW47MCVOlOL+yQuKFJR6D+XowM6IPKzZ8gkxZ5+HTnwBtIWDkmJOUYGsU/CN0ZS6k2NQVQSmBHBw6/SdsWBK0lZkfUvPvjSEmbW+bug7xMO8BfSAX5wMucvh8y53AcBg6+fQ8NmbakzsL3/4dMEzBEFGRkWYjMLIK1cH227T8C3zqSUtt1LMH4ij6Ol4NppI5vFNdRGNoa0lHdzLukm+K1sET8PkHqLhq0ipd5GFuNBgC8THyR+suid7HtvLlYyy1w/H4DnsdZ+IsVovFHXPIlNoDOvkvI6UyBPiZ9fhKVEJ0ufg91ykkUYx75BHHs0voTIN204pGOPyOxCHHtEZpKf5RS4ul7NFdKirhPPcobZjnPM869XH53ujRa6r0G6af3zv5voA1MTrdO8fa85ZtCOLp5Ec9iTqMYPa36D5E7gcog5HaQCkuxM/RZbSOSCh7fGA2JFCwF6i/s7T2oVSlwFdTt68lTtVVraM7nzGRv77oTGOmHOsDuIc/jWTTJS6G1mRgrh3D4J53bNP0K57gGaW6w0a0MOnCsbS2zNJm1vYnZQJGmDQ2nhHy3VPGhM3wFoVsKNXxaR3F7gXxZZ5DaJgVx+5axuk6lzu49K25bstM2w0KbxemrCfv6phOl0VW/U9crBktr0LGqHNtD6iul30RCvZllP/Z6EyeJufJAHDpIg5/sWboEx3Typ7xhfw+hgzlpmnl/BfalWzgvETv2OJsnyE8EVvxk3zHYjsrgbS8ZnC3Q4FfHkffpnhBMa4bn48lsngB8/1r+zhPUgazPbI6ozGkH63RNq1dYyWB7P4/LvNCeRppWSjkqaNJm0ubhGAgmydvIVfs/4OfyJLsCtU7oA+oxuTwwG7XxGd+BRWlRhG99bwN2WE2B+IbOlOCx2CwDTcDnxdKfEMNG0WgAYZiv1B8YP9tu5ol0KimbP7h10Z/UOdMeA+wUL2c77dL+ggD30gj5G7OztT+XHzZ+BH8kMfuCwsWlbT/8NZnxpamb0HI0ZOi/Ue0xe3P+8Pi4zfPINU/jkG7L45Bum8sk3ZPf3N05R98YsdW+cqu6NFn/f+L4exso6q9++3gpsYOaXWDZeswXcYHXxN5ouPo5FGH+sI5t/T99h8odP9+vtul/vwJ1S9OvXcb9+vebXb9D8emxEO1EwwZ/fBu11TvbnTzaoAsb0IfAe+Q6FIPw/ct9BSn0r07kW4n9CjXmN60TJRPeZn9HhNnoWm73MnPvxXc1xZH/2DbktPrNHlDWfGclJFGukyPFvox/3Z0a7rJp/K5tuqxTNXUtfh1b8mH9P36bLjJfnvNJ8znUWn3O9xc/cYPEzSUR//qx+5nf+Qz9TZFcwuttAyeC1O7E5yIjX+AnrA8bM7XWWH89dNZ9LJhWkYQ7x9food2lz3TKevkEf6BDfqI9zl/61EMnsSv7Ko2Sys6a/90iNm+du92ent89C70N8Nv+vEHvNlMQy8z3N8JmZ+tWlfYd0jEazlPoLozcAGZylz4020hRISHLqffL1IvrnRtTdvzLtc6Nv8vmz21J/08T6TU78h5U/mOEZPjPJM8xIIZzvT8LhKSgz3L86YbLM5k6lYwF9sKX+xozP8Ij9z09iv5XvjR2mnqzM3ubsrHoydYMvZGtQb6+u1fT1zprg651Mvt4HaED6svt6mzDZps7OY6PqPAhSf4dUI7efu3abuUO4yXAIw9whfIo7PZusDhHZ8K+a/t8m3f8r94m7+3UAP9WSms8hWuNPkre2mSYfzRvclOkN9meCGQ3yXAu4yeor9luBTYZ3ppGiO5FIc6XpQxod1anS3MeMdiXLedA9Fv/R7IdWQsrsh/Sf9EOy9kM6ej+0NdJtQMuSDB/LMnvtMGcv0nbuSMLyrkfznHD14TTtFAKGoVLsFkuFOYapQsCwVYrpQmkT4oWTJ0T9JLOux7nszH3mWuqWo/Vhu6UPD3Hn77/dgUuO0gGd/l0XZfXtklP4X0k2ef966xS4W7P4alun8tW2ZvcDt01R97YsdW+bqu5tFj9w1OIHbrG6fgNWIJnp+G3NBLdlgkmrW7jVCmzL9BHT0OzST/UR6ZFtD1gECVNMTr/BvcYt3Gsc0LzFJOO7wFvpKVO/Q04QuNP0HnXfcdlk33HQ6jsOIfCh4Tv+Q/cdD030HT+y+I7R/52+46DuOw6RMXwdfbN/fmbfcYXpO2J5zjHNd9xi8R0HeByHFuef5kdutfiRJMZ/flY/8q3/eL/yIDyXa/OtwXd3YhQm0n9o8+0v0GLo35Tj9rxk/aa8Q9sDlEml+fJRJo3mq0eZdJTvAcqkonwBKZOGkvXwHYrixE3S/CKfuC3SzCVB6nP3+EWmzbshO+07stMOftUr3HP4rxB+4RSEW/ycM883dRDaQT0h/2+pRr+U+pj7f0fnOPmE28gnHOI+4b8yfULixSe6T3jLXH2vVG+v6yjtTeTSf9jYbRnO5TuTnMuMFMJ5dxLOu9r2JdPvhuieLONjPrN+BvRRnPq36SOSxB6fJDGLj2jeDSHSWdAsNDR9Nj2bmoAnshCgt9/RM7WPOkg+6mE0VEPZfdTtR/VRT+E+6jD3UbcbPmqE+6j/w12m7UfzUbdbfdRTsvqob5I3iI1EdB91e6ZTekommNEgz7WA261u6SlWYLvFtzvlKD6q0VGdKs1HzWh3Kh/V7IdWQsrsh/Sf9EOy9kM6ej/m8n3A64GWEzP8O8ssOWDOkqT/ho9q7O45LUbOaTFyTouRc1qMnNM0chbPjrT28snzbca6P5edep65f3nt0ejut9D9iuGX/jeIvmpKoi3+9Mjns/qj6hR+oJrFH01PgZvO4jOmp/IZCTnjfIdI7554OTQjkhtU8lTTawwbDqGa6R+mraBk+Jiq1VNMm54ibwt0HdfhoPfcV+SPWfzh4Q8vf/hs2r1kdpvhM0r0VSt4jMQhEZxDbIHT7TIPPXqZ2gimKX0ESp1p8NHCG/qIT7+e5DDT74jkc0IGL8yOWXhydF5k8KCUu5QZvNATtTZ3ZuXJRGboe6xQmNxEm77XqieI8lGYI03FHG39gOc4eib6zmHj20iz71Jm36XMvkvWvkvWPnPHmfhOZjCD7/wdVW82vznRACLbyfSLhdwsLeL1VSzhZPShsxc/ZPuEWzn8rNqZYgIOzwwnOkDHBvCN6H3aPvMZ0N6qCf3VakgJArbbCOMbmqIXH2b7CnOOTYchLaGvgvcq+SFhhiUBzYJN0I5tg1mITTq2McE2FLD2jaY/gP79as0fMIhxJ6IwryMx6A/83fAH8MJBJmueIjX6Cp/2Y5M8RX3uL5+fuVY5ybIPOUZ+m10gvy2jFfDU7FyZOJKccggZnhqRCuIw9iH1Pb41k/syd6q+BDQ8OSULhjdD3Xp+Urey7fHtE9NOwB4fszou9vGd5LDEoU7QtpFsODbCIT8EHBR856Ew9dQ8/Tig+nP0dXrCbNSWwg+I4y7sPE/dRqmLJqReQKnHmqlfD2s15NKZVv55eLslPaNmSp1UM6VOrJnZ6NNdtSmifRBb7hL1r0fCHhkkp66ELNWTz0Yj9AWrVo7GgZO95GBsnX4mXTu9PTtfvyTJbvkaEM++etSb8o1PhBoYfShhT2lXWgRnoXe8AdeI9TyFSXSfhz0opNwoURmvZvEonvKZ6qwCNmoPeYNey8fNanuBfoaTWpBT1VCP105fTfhcnBaPQFcF+cplF/9Owml8FZqj5JQfz5zxrTjK/OrpUJtT8dNHvfTxP5em4g9rNwSCIXwVcNJegQ7TF+rybnoarLN6oQE7OYvfK9RZLInap4+KogBP7EU6v0S64AENDSly1PVpdzw4s9zxYOANF1nw8CtrHU+74qFQw7vMirfQgleQifegFW+R7jrcMrMwE+1VK9qxJlpRJnVisYlGDNJbLc7Em2HFa7bglWQ0K+JNGr3F9IHKhZYitG+kk1BKRUJBJchLKUHLPRhK0HIRhhLUbrjgGhlyOFPH4DNT40KgsPTpjWxXvw2Nxrcw+tDVsQe/oSG9L5cVWfuYMKSEyvH+rPggqXfmEeNQLiSMYiSPqc8V67oj5lf6xYJKj1gI3cMz7dC9WSVsNBRWwmpliXZVSCgyRZOlSmn5MFObAFFxctSokqdE8RthKRRTYnTfrfr5ErrHi6681dO+DWl+0dJZLRtK0yV6SgyXDXRZJJDpjOegfWTqR1hVhDeVD8j5vKkCpYBfrSs56Ssro7J8XlmBpbKJ41qvrhDQC3l1RUwp4tcSw4Bxp3JwUJcl5gXL4n6MTmPKNLWhVP+OY7oyvTyol1CmpQKCdhSnLK7g9PADmB7KDoenmdODhqt2lloYo6X1WtOAIt6BIksH1O2I4rgYe2CnkOxHqFjJVYqh6D5St1y+kojwRQQI2JafcMREsB18KaEU64cbJLwoCyN2um6FryK+QHyn0/z0oYF6fqm2mA6VKCX8e4MZyoxyJwBBMtmHfJNudcoFOFeD7fF1RPztpZZz7C0DfH2P3yDgPfftjO5VpGNTeCfTuXY6P8uetPO7N2l9jfu5eAcIRL7iyLwLqg3S0xB50GG9w8lG74zX8+8TaFSoHxtUaAMEZrC6KBv1gPNwBU5fOXhtBizOQgLe4BQL2uK5At3ghEdr8UAmPHajSIjbeIVTHsr6ZX6F03TLAZCMvUj9NH931OACP/vRyCoG9LMfRWz9aeY+JV7ZtsH8LitjBpyyOx6WDgt4Id0z0FAqggKaqf7ViHtpTeqD/uVTr8CDs8cLBDom45IVh8mDVCEJF7KLdA/Ofjg809I/F/EoJAGTJM4kmeGlzcQkOYNJkskkaSKTLJ88qKUx67cOceTJBlZ+vs6fg6zieT1eye59XeeVzPCupI30PcYE16CckQGLxMHrkwKiNRtnfJhr1ZjOVMan9Phm1H3yXIoFuhCQvrR71MDjttsdrfFEC7x78HcQfKq7jI1KfEw+ROshfm+IL+iLlxB7teuxJe2p3Y4UcpqOfshFzg64C83fxn4prmg5IWm32brC4VQpmhjFpd+z7Io9ebt+ZQugx4xYroHq/FkqKmjZWRLD+TwtHPInqgGOx5DaQDBguadDcSmOqFvxR9as2742VUZ6gRBeBeHkd/9WPA1FaRnhZE24AcLCoSBVSEWDlqLZ22CIgzMoVggzmlmhZOUQ9CKewZPCbB3Nz5KonU2f2hDgTInfkcMM2FxKlx9xrymiRMhrKs5wmnSvJFZm+AQuzRvg7hLMUvkR7g3kaw6ASoCMW9Bgp/N1h2lKzBhz377IxC44OrbTxCw0MAuzYSrcb0HMok/BlHVM7rUoEZopQMhieVBdmqnz4ELcCCmhPJiO7DAdTDUdhfEDIHM6suvTUZ4+HTktM5H6LlTJL8WxfCc7cY7RrOtc1lLM54OFEHwdhPh7m3U+sDMY0LivdNT5QORXw+SBEaibBtI1TKKHJapE/klyHv16hJulrrRkhqDEngklcMHPLe0YmNJcbmlFfc+jgH6zgAymw2owE53YDt10ErWijMOjlOv/RRyxZGINWvb52qrfzi3vOdx8Wyyv+uNpxhewE+7pIB6q7Oy/mfPS3wOCcU/DmXiHoj4vAaOmWJkBl6q48XVL2cyvdvUtmd9puNRhCZfmFrs1S+yZerA6uDckTXKGgA+KlHE5Fd7bKCEv9WXeLKYWT8+yzts7XV/n0R6UItP7SBEXYqDyaIGkmTn8qsGZOQ66a3BmjkSXDc500CWDM8N05yBY8gnLBrrix624+LIBl50wNCYSqjhpdGmyAxV3gIo7dHmdO33Sd4B72Fv9gk/fo8E7jDd9Bt2GGTcAmvoM1hcm7zpRg+pGWx0S2mYWj/D0QsALzNDxJHWrEWfq4zOy648xFjmNRWztmP6too3e5fYDjel6unFQHIe5Alyr3fiwmeNGOiw14CV409ELnyHo+7S8/GYs36iVP8DLH6DyV1rKN00qj7pbLdB97f//1F3cBoFW3TP1VidoqOJUGyAv5flf0K5NUFAOuYNuSwnL9/bmvtYedp6N65z+uz0DxE8yO9od1aALM5Hp/F425DtwBL8xUBi+gcJPG2yp2YQRScXpmZ+aQ08pNRee4WjA8oNKCdr6E8PivqFUOW59On0ZGucy7+RoO8G8T+b/VZsV/ytt2vBeGNyrV1i6krcppuZRG7ZwqgqrnHCZiF5HbtFnq6P6M9Uh0vnobdnqwHtEoGPqM6gotTTW6wQ6OG9L1dO2csZ307Iz1UDTV+ZVKnyfmOaJOcxbr38jLbP2JWY/YM5mg1lpaLTQ0PQZaLCnmqcgIhsNHUvN36jKhecQ6Wd6PhIh8Ra0316y0Qfdblo3wOCM4atgv37xLJWHSZ5tJx1CCt2AZNxOiytGopbfPTihrmmZdaFMopB/CtW1QOdHfRZxGnrlCfJ+vBTrFY1fTDuT6b+YdhrErDlnGDm7GNO/8Ud/Z5jeX1TIezA94diDBd2i5V0GfycRDehvbGW6X5Fe43gtcZ/kcsbBm5bCpi16wbBFkgtXS1LILsuWH9iIBYAA/iMbCq0k6XN7652uaPQAxjuZormWZFiMRuOWq5qcdnTOcUk3gykSXnAQL9No0RZyubP0t0csMU3Hma7haIu4000cxRnyJZjio99gAMrYDtLVhbh6hlXRIlo6R4q0SH5EixToWYUFPOKewFoP3Smlvg0t0Y+SeaF3sMKWfLITl4LIIWBFKbHCXuFyiaQrCRkiqIDmClGRXaRtikSPcPxYQbsdWTS1ENGc8ULuoWQslCR7arGgfwEM6x+iSpqtUWWu7IyY3Yg59RhfNIEK4714uM5WQEAjNJ4KK11igWVHH5gbm51lKoVJtlKfSsOTp1Kfa8IafNJEypfj587Wl+Pa3HvZ7E/dCznqRKv+DCpQZ8SBHzjHap/jt9A2hp77hWy5TpxZ1T9ly3LhhR1rFNeakDveigmhYIgv/0FF6W7c7RtC3j0eHLka5NNWmbDqn3z9cihXydXWZbnWdVmu4qF7OfniLNdYcgJ6fjZ0tXUOUPsRX48Zy84psbut2NrCL4cv/PzBvMN5MJrFYF54+3g74AfzFPd4B494xzt5xDd+HFaVFwqoe+dkE4CiPpM1PYjMVRRt7YjxoB7Pv6SAc8a6nrQuJCV9IanoC0k/LSSRPVSmgJcpnIgf1PED+B44wQvhFe6T/SR+3Y8UX08a551rccmNtSeeGWqHyB9E69rTyfJg0KYm7FHBwKk8iqMJg+czjQ56B4Sjgw+n1XM/fWzYpxobjvD2kMTVF9xBrr5O0llY1ujvmCJkdEN43yr/cVQwW9tDMkucwRT7UYaWV8/NOrR8eMFb9qGVo3gV3xolZw2MTqc+eJyKS4+6+KLar/ibo7h5E8w9nJePepqrOMePR63MpT6Md5GOg2LeOjerYiIJhgJCPPNdBSVb7GxQCe5xWg4aaKD++1O0OagD3JiGFHumJmtaGda00jFJiwN4W3giU5Uj2QtlEquVD2UodNMg6igRFsoTcU8/VKwUR9Z22LWtdPQ5crW/RBF1JxROlOxx8UjuHjePeNSP5k54wahvlWUasVKlVDNipVY7U6qEuf0qNewXYOZnw1RnJQyLVDrpPaNlC07J43tw3GiJhaARUSVafirTCMufSFj25jZkNPdpxJ1uxeYtGxtl+cGYZi9jisTtZUyRub2MgWZ28oiL28tYqED9fCKbWhaqP8yaXkTqWmiqq1Kkx7Payyz7b4bCFeoKk5/VbIqRSlshzPUTixXpxQomW8+JP9Kj7Q3o9jNYns1+4j7GNqDvT5bf45iWcQ+Oje5bHCU/xLYHfxE4vgZtorquHJm0MXOzEG8H5Q7K9ZDN76ibq703+Aq0ceoEm2xd/GfxWDIW/1mscj/jHideKwVovyg3Xxusxn0Bbre9FlPKr1C1y/GEYHmBm8Vmy9q4dao1Fbh/lQezcdblurqyAi8WtCScBgnOqQuQ8Qwr4fISJvNDyhN/ewF/fLKZdiVhlJcrVjTMKmUy/RgvlwZdsWXNn2KucYPD5A6KkzY8YHLBDY98Jd/crMukfdJmnce6FeKl/hQoBc0v0psUr3oN9D/lgjw6+4UnNWL4M920wODXyRs95bfKFALGwaNiFClFxq8xVOi/xhAsjrfRq4dipADfk4MO3F+h/7op0FJoFJqlF6KftQrH23GiK4ExA33+0CiilCjFI9E5mzfR+1e6jt3HEg0kCjRuEeweHU2wdI8l8jC5d2IypM2vNLaIJjJf8Vq2iCyzHDinisuY4iCuTWk5itOSqq8acvhE5/9MFfgsqb7MCgJ4N+iaStpD3QSPkCKW25wJwR4KqoMAK4oStOhSSH1ycmIu9lEJaTYR47l6PKt91K2bW7duoSl8yanwc41Ze6IbKYMdNO52sx6HwvMSmeM/w0iG51nfm9dxezgk0p21bJ/mYwa09+boez4GerrZYjsrcf9F2os/SmcesV1po1/DUTfP0+6gBFrM3AabuHsvui6YM3e1cSLtLLx9Nt5OxKxmIl1GG+8gAxLv0LZZwa4K5Dzwf2K8Fnt1yCniqDHvAaeTds4M275V1PaB8XWGzfI+xCRsj6ht9XKUie9D5rb2nACeK//FezxXcFpNZVVlfVVjTSOmOOic73O1jE0HbjQBL18BB3Z6z5g6NLINPxdjATDRw/MgbVUPO+s84iubftyqLjyfcDHAj4MrNr11OLVZ7x00fdKRW4514Y8OfizU4g9LYetYWQv84d1ITZBwv8AdK2AS/d47ogvaH5h0uk8U50v8XaqElg5ipLuJ87Q8gXrA5YpxRXsCVUH+dLO2nJ8WSOwXFM7yY5ifM7MgxN4vwDp8/mdyJfZADoarKUxT+AGF5RQ+lPtykcSuzcHwsO+eMok9GKoNSWxrCYZPU7wycp5DYg9T+CcPppzrvg/aej+IKaNCTO5jY/jrl6wf4hJLuhGngOKe0HmOlJYbcmH65VTnW76fFrjZOgHj06HmHJYqfSmYw/ZGMPyGC8N49KUg1Jb/t6I+9gqo2Je1ej7Ow1LnASVBdl0kWSyxF/Iw7g1j/JFYuSCxr7mPL4SeMqTtXSj7I62sB6hys7sL3opJ7EAIw9YIhr+k8G6GoZKP4Z0UXyFieLwfW5xZjBwWYxi/hPr4TgBDJYR8+BeFfYELo/hj8rUh6J37LfypUS/iPEr4ySDy7U0PhltKMeVzxOe5xJPWXAwvpd7NJj7/nuLTPFhz2oXhumIMHV4Mw8S3Bjfyqr0UeSVHEb+XuHpbHuI8F8F4F6U8lo9c+lUxcikUxpTbnfUBCfiG8RHCv7isXJgnrI8gr8rLMGWPguFBkHiYnUk4jxFVItU5n3h4hQvD8ylcRikfED8HKF5J/PyNrZbu0/wWKjrDUYu32M7KzXcvJOhsMBTnFue7W2CEcKg3ipAPRh1CAxpkJ2hMg1wEdWqQm6DbijjkJeiKCIdCUGuArSkb97awHLBYCP1KQigIY+5mgC73jntxIVRAeZ1hzMtl04jO00KXOhbCWK6kvH+5LnW0sJgG5QUQmsmqCJpOUAWrJeiGGELzWCPR8mUFoUWsnaCrihA6lm0nTFbCoTS19y9PwrsQoDOYCzDviyS8J0IpDn2doOMBwnLvKAmg8wSAsA/t3oQXv+U6l9MSxLxudhXUGWA1YYRWAR7m/ZnKrWMPUN7bEkInsycp7ynK28J+QXkfiggNsjeJso+Ish3s7+xswPwRYZ4KEJb7B9RyPhtjRwg6Kcwhm4DQb/2IOcZkAft+TTBQ3MJOYzkEXVvCoQBBd/s4pBDkdnMoSNCdGmaIoK8VcSiXoO9o5fIIukmD8jlUdGUYoQKCFpdwaCZBXw0jdDqbRdD9Sl0xQnGi+jENmkN5ITuHEjTpPGNDq386qxBsZQFWLCO0ByHAjNKMsJdVAcTYL+149+HZrIagHxN0EUAewPzEgd8PfQnzoL1bo1juGsIM4F27AF3L6gk6gaADrFHIE/hvU5/IrmPNBLVlQM4MCGcLE7pa1CFJOk260bd67xHpZghtNgy/RuEyP4Zbwzf7GtgvlNsgbPdhuJLCTRS+HL0DwpD9Ll+YHRO9xyexEz13QZiTi+EL0m0QvujU02dByn2+arbJ8SiEuY4bIXRRWEXhx3YM73XcBuHTEAqspPBbvjJW7PmeT6fzXuFZCL9hexbq/KD0RginuTC8j9r1RDB0u7DFdiemt+VhSkkYw8uCGP6F6DkzhDWECp+HMO78kmMW2138IrR1ctHr0HpAugviP4PelTGvcgfgvBzG2nYEMXywDFNOcOn1zKLWZ1Hrs6jFWdTWLKpZYC3yXdCX84S7gFdF9i85sC+PQi+etb8D4Uc2DP9C8W873oE6R8NYf0zA8EIKi6jFCzxmnHkRs6voUcLH8KkYcnuv/zaD85NxzFyBvV14G/TuBekPEB5yfw/C1tybIazIu2dC2cmlzi/6CEKlDEs5KJxcaiI9ZlmWk6WsxpMCyZmzem/UgWEPxCX2LQ+G1trOL/LlcGob2JkO1MM5UH+t0G8L59QKq8UiCHMofFSIQfhNNhPCB8S5OQ3sEdu8nDDrY3VQZ3PsLkOvBh2LoMVKCcO77Rj+D4WLKeV3lPtTCpdTWArpetmn7G2Qsk7C8ByKL6F4ksJWRxu0tQM0QWJPFiNnRjwYhkownENyuSX3DtCWl90XII73+BweduOrSLY//7z8pTkCe4+gq9jfQ90AFZdx6PzASTk21l2m552c42Cna9DKwMk5MtunQTcHkjkudr8G/UtI5njZGxr0t8IdOX5mn8ahT6JjOQE2rEHPFp6Vo7AvadBLhefkBMnz3Muuih22XZSTa0D+vEsBeljDvC9wRU4ee0ODngjcawsz53QOzRIO5ETYWRr0N++V9nx2vwYtyD2Yk8/aZ3Bon6dZyGdJgr6Q/7l8AWbmUQ6xb/hvwm+WcFEEdvVR/4UAPTNTx7yQFbK3ZprlijT//RnHo34r9I0MqK3sthwTKiz8Wk6xAS0tu85WYkBbAIoa0FjZfTllBtRQ9kjOdAMaL3siZwb7iGj5rYCtz2abZnPoGwSdn+AQtj6bXaNB2Hqc3a5B2PocVl7OIWw9wV7QIGy9gm2q4BC2Po/dr0HYehVbW6lzIgBeybmVPO80GJV17PpKU8/qmH0e5+6Pi74PUOU8k4P1rGke57W38Lmcevachrky9iJAM6qsmFUcYu7AryBvaT2HHi56A8ZgbgOHVhT9KqeJndtglmtmt3LIKRXdBNBLGXlvGNA7Oc3svUZeyx1KnnAsK2/i0AXOD3KOZe9p0B9tmBeYz6FxAaGLj+HQZcJN4FvhbwZSLQTh5cQI/cuJmN5FHPqB9E+o8xOCnmHPBfKExWxsscmzxZqk98deCzG/CY34FsgtFN8L0H675G81IJvP5283oGJfof8EA7okd5p/qQHtKKn1rzSgW+U2/1oDekde5t9gQIXRk/ybjNZX5g75txp5/QW7/MMG9EDJOf5RA1KhvVMNqNG3y7/LpDp2vn+3Ad1Qerl/D9tLXQT7Yr/efzZb08KhufZb/eewWzVo1H6n/1yW28qhBfZ7/eexNRr0zeKlOeezAQ1a73nEfz77hgZ9sfQR/wXsIw2qd94Jo3qwjUNS7hP+i9hzGrROvtN/MVvQzqFTALqEPa5B+4pv9e9jAx0cOtX9hP9S9qQGXRC81X8Zq+rk0Hfyv+ffzw5qUFPBc/7LWd1xHLo89rL/Cna6Bp0Se91/FXtBg8Zjj/ivZrnHc6ii5BH/NeyK402duJbdruXd6PiN/1pWdwKHvgLQATa4hEO3x/7gv459pEFzlD8D5FzGoZMAup6VL+fQQ96/+29goxp0k/ffYPsu06Cve+2Bg2xwBYfKvL7AraaeefICX2UfUN5+9rIrFrjbyHszODtwD5vRzcsNBv7gf5jt1SCppCHwMHuTID7+HmHvccgpF+QJjzDXiRzKLQhAXr4G/S4/T3iU1WvQR2BtHmXtGpRX+pDwGNusQTNK3wVoTIOeh3KPs/0a9Gso9zg7qEH/LHlI+Bb7tgbJUO5b7PkTTcq+ren8M455wWMCVqg18KQBfax0Bb5jQGcWrQh814Cagk/kPG2B1gW+b4H6Az+0QIOB5y3QaOAFC7Qr8HMDsgWvs71kgfYEXjEgnLl+ZUA4c5nQ3dGb2K8N6MHohRbo3KJzA69aoEsDr7E3LJw/xP5t4fwh5l1pcv51NnelyfnX2YKVJuffYGtXmpx/gw2uNDn/JvvCSpPzb7JrOMR+5DoQ+B/mxE93QV8edh0MvMXGe0ypvM3OJwjnuJsAuquXQ9jbt9nFqziEUvkNm7GaQyiV37IxDUJpvsPKT9Kh1sDv2BsahBL7A+teo0ODgT+xRw1oXeB99pwB9Qc+YIcMaDTwD/YXA9oV+JjZ13IIJfZvdtCA9gSOsKZ1eo++GhCEu9bxPJw37ULxeg6hxOzCBg1CidmF+zUIJeYQnt6gQ5cGJOGFjabEZOGPG02JycInG02JOYXCk02JOYXyk02JuYSuk02JuYQ1J5sScwunnWxKzC2cT9A5JDGP8C5Bl4PE7gl4hWV9psR8wpo+U2I+4dU+U2I+YcEmU2I5wsWbTIn5hVc3mRILCBf3mxILCgs2mxLLFa43oMFARPjIgNYFCgX3FlNiJUKxAY0GYkKlAe0KTBcWbzElNku434D2BOLCjAG9Rw8G5gp3DZgSKxc2JU2JlQvXJ02JlQvxrabEKoT3DOjSQKVw1zaNn2D55gnPahBavnnCK9tMaVYJf99mSrNKsA+a0qwWpg2a0qwW6gZNadYIJw6a0qwRNg2a0qwV9gya0qwVLhs0pVkneId0aT4eqBcuGjKl2SBcMWRKs0HI325Ks0E4fbspzUbhF9tNaTYJM04xpdksvGFArYFjhOuHTWkuFLw7TGkuFs4woHWBNuEiA+oPdAo3GNBooEu4x4B2BZYKT+8wpblCOH7ElOaJwg9GTGn2CN0pU5qrBPuoKc1VwuJRU5qrhOdGTWmuFs491ZTmScIC1ZTmGmGtakpzjTComtJcK5ynmtJcK1yhmtJcJ9ynmtJcxzfjwSajVNYb0MOu7wY2GNAHtoeEjcJTVO5cktFG4TmCniFpbhSa0hzCcicL39AgLNcnPJ82ZdsnvJI2y/UJS8fMcpuEF8bMcv1Cx06zXL/QTRBfLfULT/I8WkltFtacxqF5wWcDm4WnNagp+EJgizBjF4dswQBLCtfs0ut8ObBVeNyAXg8MCq8QtJ+VFv0mMCT84HSErmLO2B8DpwiBz3HonpIPAyPCcxr0E9+HgVHho70cUtx/DKhC7DwTc6cw8AUOPV3078Au4ZMvcmhh0YeBPcLB83l7f/V7lL3CGxr0b39Q+bwQu4BjfkH+Y+BcYfRCDi2OCd4vCtdo0O9KC5TzBe9FHPo5QBcKezXoBwBdLDytQYcA2ic4L+bQ26EC5TLhYg16yTtN+ZIQuIRD70HelUKVBr0Sm6ZcLXRr0Ncg74Bwlgb9EPKuF67XoKBSrtwkvEIQ9yMPCoF9PK/HW6scFJou5dAgQF8WNl3Goat8fwx8Rbj+chO6Q3j1GlPudwnvXsP58lrJQuUuoepaE/NuIf9Gs717hRk3muXuFSoIOocNsnblXqHVknefsETL28Nus98nrLXkfVNIEcRH6jeF8wl6mv3Yj9DDGZhPabVcxLoC3xR+bcm7X3hby7se8u6nXcxj8GQNezpsxn8Wwvj3LOk8/ktLelkBvlt7/igpAntRwnB+kR6KWsqHuWYultLjX/eYcR5+oQzDmYUYrvZgDXdGPy1uTbH9b64nqWC4h3iy1Inha2HEGQtifBGlYFxkT5RhqZV43oudG8J3jpV4PQ6zuxHnhFx8d/uujRnhImprr19PEZkawhpeD2ANt+Dvu7EH8I5GNuY0cazxtBPx53tEwH8MQgfr84uAP2ipM0k4eySs8zKqc28Y61yWj29Q/dGJmE/LE1O+J9O3QpZ2f+HB9AN4xI09Q+12FWC7qwpMnCE74iQJ53jC+WYp4vyg2Fq/CDjjBUj/JVT29PDE1o/euyUy1vAbN+J84J5YdreF5pWUcqWsS01krztNmZqhyF6REbPAkr5oEmaHbMY/Z4lfbqnnC/7MsqKW+72YiclzT8idOhRZU162FBtbrCBva5Vs6QKbR9p1QjGmnEU6eWMhSn8N3ovALihE6eeQzre56HMNend4jEuAUusgtLGhCPjn7HI/cn6MPmy72Y/fVzzsFJiT/YAo/7iUxpr/aOEzMZMb1ngLjaBLizLT9XH3fyIlM261Qkwxw6n6xS3eMRa7l71HU8X/v+vpqGJqywm5/7f0epfR6/+kv/+39dra06niZouT2+W5YhY7xu2e1VItdWamTBU/OibP1efc12h2wxlZphk5s9STXow7AhPjk9ving/vi7VfPD47Zvo2nx63sd95TV5Z5WXN/U2JmWvGbeyxkMlzTsPEkZuZcjS+2TJmupOnyJ1OczH3zbietwS9bIj5WBX8DbFC+CsGb7YYnqXwLIVnDJ4xeM6HPxdDz1OB0MEKKF4GoZtVM3xz0kxhC4VdFJ5I4VoKhyDMY6dSKUHA8GzyeN8X3ovG2AXsm4VzIRwtqmIu8XP5deCNfxJcxBRxSV4VhMcF21mZ+ISrG9KfKFwN8RcDGwDz5ZLN7FrCrBaXlmyHkMXOgpTXfBcCzixHN4R/K7wMMM9RrmJvMha7iTWLz7nvZV3iy/5H2R3sGPkpCNeV/BBS7sr/McR/BrPkfqDzVWj3HAVb36e8BeFrvnehnn2hv0DYUfIhWyu2uX2CS6wtzYPwyrICYa2YnztHGBKrcucJp4r5rqvYGSL2/WwR39SdTX1/k8JrqX6k04G3peafLBSz3aWjwgwWiX0ewlX+L0LK2dGLhZ8yXCVgqQuBqm7hKsAvC10n5FI9+9kC4SHhAmqlnN3v/I6Adb4rlLM7Sq+ClPzQHwVF/LLzb0K1ON39LwifD2PYUZIjlrO/umZDeGr+IrEOWv88lLrYvxzi2G451V8tPlWaI1aLddFTALMsdIO4X3w9dKuoiKNA1QJq5UQBW28H/BcB0+/9tfhPKvtPdl7UbVtANGDcb1vKfly0XLyXqC0gHSgQ7nF+0VYgxN37bGWQcgWEla7rIGVF6c22OcJNrq/aysRbbN1sjnBVNE94VtwVuBfSWeFDtl5qZQOFA1p4v/M6oVo4Nf81W7Owu/Qt20/Fs33v2AaAhvcAH/kGcoDebWB9seXiAq0GTHeJG/PzIB0xFxAn3ye93cBO9f/NNkz4vVoc8ZcSzjALFUXtY8DDevtZwMMvCguIn+cSP88lTp5F4S+p10sp92LKvZjSh4mGpVw3QFcH7KjVI/az6V3aFSSj90n6a8VpZVdCbk/Jtfb94s3FByH+46LbIH5W4Z326zX+/77kYTtqaZ7wU/G5wJt2DFE/peLf2udo8Z6SP9irxS/6/m3HFv0O1JlSx1rhiWgdhB+Fr2JrhT9D+D57I3oT+yeNd5f4p8DJDtT8AQhZ9BTH++Jl4Qsg/FHJxY732QtlX4LwyrKrHF3iQ+F3IWRlHzv+KRzy26R+0pB+4fbiUyVsfZck2H7ryhOGtPSfhQUY+zcUzIX4X4vHJZft++EvSIqN9MTGcT4oBWtjO+i5UzpDqIzdA+GOwgehtmuU2+xrxS7leanaNlD4Cwk58GupzDbmf1daK1YU/llqtl3j+RDo/0HZQeDVS4V+eb/4bOG9trOh9Wlyl7g0WANhu78RwrXBBXKLDXW7S+wWlshviscJ3fKtbEbJlfJdpO13gQTvlu8nCd5K2vI4pT9Okn2a0p8myd5P4eMk2VtJZx4nnbmVdOk5wP+H/AvCf5zGyOM0vh6nMXgrt7TiS76LhVcp/iqVfZtaeY9KvUf1v62lYw1vUw1vEz1vUz1vU1mXOMv1c+cHVPYTKvsJlf2Ayn5AZT+gsh9Q2Q+o7AdUtov4fwVhXkE12AWswU7j6AoqewWVvYLKXkFlr+Czg23c/6RrmEbN++xm0I0TqbZc4qdXQE7mUm25VCqX6twv/sTXDL3Gtoopt5jSZ5DFmCEgJTMEzC2n3Fe5HSMcl3gz2mHhTE8VWNfjghe4Ubf3u99nAddVFH+LCURDnYDj5VX2UeB19z/ZJ4UXsjuES31Fnn5bNHYh67dtd5VBvDMQhzACs0a/7fr8eZ57BX+wGVIuhvgjRM8jQo58IYQvlZ4AKe9B+BSkb/acbesPBdizUOeQ5wJbiZKClGe8Kc9PKXc/5e63/dJ7nueXAo7uanF38ErPm4D/qGcB1bxAQGuGI1TwLhBQ094UbxYS3rXC92Gc/k7c47vT+6Z4jXCv91rbM/6HvU5Yvf0EQi/7BYQB9ksIc9khCPPZWxCeTrlnQS4sG4WfQGgXMO4UfgmhVzgE4cOU8jilPClgKadIdYpUp0h1ilSniLnF4rsQxsQ/QjhD/CuEcfEfEFZRqToq1USlFlCpxVSqHUrNxtOT3krmoTDETlIqWRHbBOF09jkIE+x8CGvZNRAew74MYRv7BoRLKL0HwsVUdhOFeyk8h8KDFH6Zwicp/C6Fb1D4FoVMwDBG4WIKN1F4jnQKlqXwuxRukTE8h8I+4XqfE7zQT7x82zrC+DMfnrMYHpAQGG7KLWIC/WrjsQzfhDG2GJ54M0EL9HA+2PoDYA9eZJ8A56NCvbBIuEz4svADoUbsFc8SLxKvFL8pfizm2Rz2lfbt9p328+0/tf/VnueY7pjvON5xquNGx1cc9zkecTzt+KHjZccfHT6pSJojtUlLpfXSRdKN0mPSB9JhyS6H5WI5LrfIJ8lJ+UX5LdnlLHEmnIuc7c4lzj3Oi5y3O+9xPuH8vvOXzg+cdleZa56r0dXm2uAadI24znBd7rrV9XXXY67vu3Ldde4+93Xu+9w/dP/U/Xv3X9wOT46n1bPSc5rnEs/tnvs8T3p+7ZG9jd6093RvkOEpJLznRmYlwOso87Np9P2Du+gEWJvkF6yA8JN8DOOlPRC+TnEPxf/T9KPXNjEXbxe0MbxV2gFUngmhyHbTaeqzIBTZOHi4AtsDocg+B7QLDPVKBE/VB/HP00nrq6A/ArsaQpFdA74w+nIKxA/Q+enrIBTZ9SwP4jdAKLIHSEsehFBkD9HJ6YeJP48AhwT2KIQieww4JcAMUoJ7cMAx8P4hFNlL4F8L7GUIRfYKjAtYvUAosl+xmRD/NYQizAuzIf4ahCL7O5sD8Q8hFNk/YAQJ7CMIRZjBKyD+MYTz2aBYwr4avD/4o+Dd7CSYgXcLjwnHid8TnxP32p6yPWt70faJLWFvsS+xb7TvtX/DfoF8s/yo/H35x/KfZcG5y3nAebMz5Cp0XeSyu73uCnePe637Zfc/gVkF7DAe3hWKmD8P9f4C9lpIhOdFbMSHz0vYfjs+L2U2gvezYnpezi7JxeeVbEeJDZ5Xs1tlhK9l79DzOlYYxecNbCXhgS3GnUXhZvZACT6/zFRKv401Un1fZftj+LyD3VAqsk7hHWbzCPD8A3szKLDLGgWwhKc3CaAFL8xHLYgvFEALuheiFvwFwnFm38u0ka3/y3fzbzH1f9/yOvAzFdAmhyUtDz+xmYD3UnBi2jPeZPFkPH72vx7sdgMLgp6GWBP8NcPffPg7Bnz5BfC3kNWBdakDy1IHVqUOLEod2Z8QK5caoV/N8Hc1/F0Lf9fB3x1sq/g1+HuE/R2efxebheftxwmnsyH4uxTiX2Nx9y7xdGixBkbuCNi1EzlBfX09Y/1jQ1taVLX/jK6RobHeM0aTPUNnJhfWNFSxBYu29PW1D6VHh/vPaBvuT6drqvuypGZNrKHE5r6+JowclxzrPiV5xsr+kW3J9KLNZuqy7jYEAWhPDifHkp3D/du0hJ7kmAkdv6ylref4lmrWWtfaUdPc3t5UV93W1NrZ3NLZVt/UVN1U09bW3FjVWdPRWtfc2lBd29Le0FZfVVXXUdNQ01LT0llV19Te0N5Rzbo6RnbuSKr9m4eTm6pZy5axodTIJjN5LKUCtHQoPQaP3qEdyWrWtrKttoYtG9qiptKprWOVJw2NALwy2T+wqmtkDKK9KS2CaTzWuXNky6YatiR5xur+4Z3J7v4hFcD2IWquXz0DAOTJ0EANG8UAW9KTarUKG+ogwp88o451L+lYW1NVVc+aWjpbqjpbm2rrWhuqmlvqGxvrm6vq69vaO5pbq6qrWhsbq1o6azvbqprr6xobOzrb69s765obO6trG2sbqhrr2UnqEHB76PTkAP8OrLqB1be3ttTXtDQ3NLVXN3dWAdPamuvra5qr2qqb6muagOcd9VWNzR1QeX1rTX1dczvwu7Glsb6ptr6htbaBgYBq6qGe+tamppr2ls6G9va21vaOzo7aprbGuvqGpo6q6s7mxurqzrqm2vaahtbWpqrW5rqa2ubGWmigsaW1tbm5qeEoWlnf3MBAuk3QmYaqNiCktaMWZN/UAd1uamzrbKmr6mzqbGipq2usranqbGxoqW7qrKup6mipaWhsbWjvbGlrYN2DZ6SHtvQP94CskyDMxqMNg5qmo+TWHi2zur6J1dV0NLbWNtbXdta2NTZW1zfXV9W117W1VdfX17Y31jY1t0BOdWd7c21VY21LdWNzbXttWwsIqQ44Ud3exLYlx/pW9XY2MaCzSRd/M44stmBZamDncHIRW9CtDp3WP5bs2jE6nNyRHEF6UiPtybH+oeH0InZcGxvsWdrG+GhDbWbLW5Z1tGNCzxnpseSO9uTW/p3DY0vbutrZuqSawudJXcvbV5zU09fS3d3XRbhdI+mx/uFhqhxS2pOjqfTQWFtqZOuQukNPBTytNhxZp+nJoy2joxm1JAfQHkBSz9K+9pbelr72k1asRAhQoKsDqV3prpGtKa1iPRMo6Vva1daxvKejr7NraYdRevmK5QhgvHdtN0a72rWIpQxr6e1d2dW6qreDtS5d0bakr7ulva+na50OUrRjee/KtTzaA9jLjyMZtPS0dXVRXldHT193x8o+KmIQ0LNqmdZWT++KlR19vSuWdCxnqztW9nStWK7lACuBkJZeTOleuaJ9VRtFuQwqu1aA1dnc2wOd3pas7OnuZkuGhofxuTIJLFPHMNq2YnlvT9/xHS3tHStZb9cyCHlS54oVvQBoDS1dmsGmnsnplMTj0EUguqV3VQ9rWdp9fEtrRy9b1bW8V+ddS08v6+3o0WGN8r6eJav0FNBKgxGtXctbVppgzzojumzV0t4uTDgNLWJfH9uyGbSiZzS5ZWjr0Jb2/rF+NnraxJQtm7vBhmYiTU5C8ziYGkkSMIBBb+qU5MgyGAKZo3012PV+HAKtw6ktp3BoR3pLSh0e2sxg/KTUsbb0KH3pCjOaLpq2FCgsWe505XHJkaQ6tIW1DEMNbMfoFjY8tKVrgI0uHdqSHEmDSR1OAggUTUpAjafhsk1L28offOZbNTJ06k4EcaxAnXzoDNCQGMGJKbli69bhoZFkxjgE9NFd6TMnpA1lgjAw+GDVasgYs1ADVDAhaUsmaBnL1BMczQOsn8Lj1NROgraMaXV1nAY2SKMCk7pVMFRbxnpO2UkQCM+SyiGNO5iuPU7cmVQxglMq6x1U8bE0BUHLwAAbHm09YyyZXpkc26mOJBFecVpSHQaCAOhOje6ErieRgC3DOweSGvWQAP7HQGoHGGdqseP0seTIAFiioQEGszSEy5O7jtsJTxzxrTuHhgdYxwiSAF7NliS2vLx/RzI9isBge/I0EDAb4I9Vo9vU/oEk26k9B3Z1pYCnY2pquC0FcBpqXIYRFD1FBnb1DParPN7dPzAAczDF24ZGB5MqRXuSqHY9kDOcXI4Ja3YM07M9uQUfNDmMDFG8Y4QenWoSqgBujZHi9fRv5WjLkul0/zbqAzlh6JnwiMrBZT3Hp9JjbUASQKYhYr39p/AasOu96DURFQaAfBw5bUhNjeDMs7pfHaJk08liXegWptI8nqZxqkmEV9B2PEgFIit3joyBF9Q5lBwe0JKQfEsUe5SJjJOtlgKEINSppnZoKb09WICNbtlsGYowXjJAk1dssDcJM6gOkQVJcxwY+Cl4Do8iiH0nPSfPzoBWDm0bHCNoBIOVya1qMj3Yq+4EEzKA7h1I/DgVVIfivSmsiqJgtHiEXLKlMD6hwR2b8bk0BYZrWf+WQQRw5LIOUG3sJhslY0fRJB8HXQMc0kYOATpzCSB6KaYbQAJIT1AV2UmgeEnT6KlJGnFkOK1zU4ZFZV2ZIKimesboWGYiKOfkREuNxGutOkscRWpC7Tt3jBrpPJKmkIuwZ2jbSD/wAVjf07IabPTWM8yktBFD66UCQ8dgZCEMngI3lv9Pe18CH2V19X1nssxMQobMYDAIgSCiUMlOFigUskFSEhKYhKUNhUlmkoyZTMZZCFGoE18oWHfrWhWXWu2rtYqWulUtrVZqW5VXLWBFRcXKq75o3RXx+59z7zPzTDIJar/fr9/v+75J8jx3Pffcc8492zOZgT7q62zqbA6j1xmkDhytkbpi6p1OzvrZMNH+Pq1WGlcri9bghHn7cJfnATIQGGh2BoIkK9BeQW0jmraFUlEmQRoIOrI4nzitEIse1dbi7PWDaS6KlIKqjU5rtdPH4kSi5AeDA5oRcVWG4O+3hxn8eiITH1hSUrGeGnd7uKuL2mNtlcGgu7fdO9DiCembWYkGYRmGjyTBAiMSd+q8O6d32CiHuyMM9Aea3YFeTzAxBGlKwwGGEeuWG+bG5W6vcwOXgsOnK/uTCG6v3+kbiHUoXcPtIU+7xwvEdL2wTGSNyEOvwgFj8vNRI82jCn5VAMshOrLs0ArsDwFOb996KI96X1W4s9MdoBhC+JrCIV3VAX7BUJ1FHApGy46w3w9dA13lUw24NHWKehi3DbhrSrnK2SViUbZQ8bXopAsddElQoQij1ZZoTot0Cro0/SBtMmwT2zZlwaQO0ypsk6hQH3T4MQ2E9FGVdHQVDlLZbBl7Mg2Xhr3eFmK3j6RUdQyNUpXlUxVp81SlpU8VWDtwidQy+4qy6gi3B2VpUV+gFlpVUt7hduJci55uKHAVwtY5g90sSGAwl8k/cTQ7Q93CDVVGgs2VTq2A/kV9Xpc7oNWk9eBaSFeUN3/A0+ukw48ySUuD29eFIhiilcjfD670ULGh0u9hreXt6msNeETlisbK2T2kWnCl6JU1eVSlk9IgbeL01q2sr5FNzQ55Z39XFuEHyIIUCFlugS8QpGPJkiTbyBEJ+GQZWMiCQyu0q6q7RzrEdYvhOju97IZo5UbouG7cpfAKKbeoQbX5Oty1Z4ZRI/oq9eZzU9XHbqJUv6IHGLi9JcX5LlSC3g6+68yHanZvCHFRCSjcFCGdtKgrJm1dCILbK308CKGqNuL4BQZ0ffWAwaLNhSY/aU/IjgSONXp73RCmDmILhLS7F/pjeBsIRfITa9BEMtbijJZaIBbKRRX11WQw+6Icgf/jDUE4HeFe9q1ER7e7oyeIArkODigs0Q7hEb3ODXTz4s/RAKR9ZA3JDsoMGhUqvXQlnjUFPF0eH04npKHPF1PlvP8mh9LKEB+txKpNlWvcZEK12np115lGIlYIRlcfyMt+XUAwrIvZHms8s589c2jc2g1+T0CNVNZBJu80fsPjUlGa9HRiURtbzlhtZV9/2exFwVofKcXlbpcnoO+QzWqMvldhTUV/rFgL3DTSNFOMRRVXP5tyylywrZet9U21Gzrcfln2rad9kQ8Xa1zaFyJdjiDU7Yq1ss/ZB/0S9uladUHiMKhKWPU9i5iiuumBrjA57LEWkqO+sK4BJqYj4JHl7gBUdJCIoHfhpG4QMR9NNWi6SFWhpFSp1dfj6+v3ibC6+3WBJZjOySf9wZaHgBdl+Fo9FNC0fWUYdYfX7fYLR48Hl1CfX4akoouvSjjgVp/JPFoNbc+FGudAUyfXKOhBCBYILQ33trsDQkImm4RKC7SKKlZ5KHOrKgF5w+mSSEG7kaqBkKz3UAfnJ5xeaRUQOWhmnWJVzaZrkRRHlI1OHwK0ACxxF90UPKW44MBJ7U1c0jBh4xgQ/fJWxbk4nMOQRKt5SbWjKOoBS/5TV0xNJegcNq/G3TnaTH03q7ZA34YBQp0o19fQ14+7LrMuo8VoLb9DXvkmnV8VPkTrKnLoY66E2WVv6QP/IeohulFS0x1yolMxNeSsDFItGFeL+mSxTl2VekknR/tiFfwpCarxOLt8CJE9HUE2x7qUSFD4fVoMhrI/VmadFkt56lIeNGdI3R9fJy+p0eP1eoLweXxoqHQHo7pOuqT5oAKOjF8Jy7BuzfmP9kvHXqUagirBsJTLcY9oyD+oheR5UHSrOxQwbFOCYD849NlIfixuZ7ikwbgADwybY5Fnnw8+A8W7QShMDmAqfbHwJIiTElX0sUZJFR+XNdc7CkxW+FxEa80Bdx2fVVklH4YLS3GwZUmxP1Zh0VBwiCb0xGW5uwvnLzCg+jqDynOSARhjz0401pXuMvBHVea5tRYC3uKB3Y76X9iQx6cV2+XN0dzcGvJ4g0JqFlmGJ1FfXwMt5ewFvZ2hjm5VRocqka5wImTVpECjXn4sigomSGnKeBE6MKhXvRAQhIaw6lr4U+f2+t3xY9QZ6AsQA2EuYCpdlR2QsyAbLVWMYqMpSG5Vss5Y43j4QkFdzpR24qam2g0gusRQ+hJaXkUNVI1+/xCXY7j6VO0rnR5YUq3maAZyQg3iEAUbaenDaeVMDUxEVDqCIpoOqOSMgDqpPB12mLKEUFjK0BJ/A02dzR64s66m9jNAavLkVWCvZosEZ6mF8m8hwcuDbZ4+13JEegTdGeiVRUcDkQxKVD0n4cST6POvxQGFS+DBCNxD2gMagVAAaHkCwVBTQD2b0elKaBCdrqSaTldqnbpqS1+rH3JAngYwRgNsWK187CSh9nVIx0K16fZIQ7VuKXThQIDKQI456ZbpDRcnkLFPapdlHg0HKAStKXkna9JbIbOlDIeorHVoRbQq80GtWpFjK8FPVGBEEI2EhLKbop/NVzP8L6m46SkSPQnW8q5chlmjWx2sPAw5IkRdUAEPOs5LiNWlreY61Aw/LKRKI0J+UkTRoJrKHH1AcAJcY3aHqEQwlzv7pV6iAqdl++S9NdRBxR4vLuwkNDo3ANfoaoKeTcqEgaxXO4OIUrU+FmwVdmkir5lCgWiSbhROSA1Ozz3opiWVZNAiW0KxiqaQqBzLsqmDI/TpNa3N0QB1psRC1yxjDdVODZo2pjI9MdDCI5n341hHFYfqQqlTuwJOfzch6B8QLQ4HG1hwCeVmGZsLDjckKdRDUg4EECNqPgfZxwHNUA4ocyDL7BHrm1t9/j6/bGAXiAoOreDmq7YlPskUFANbKtf73FptyF7AH1WoD1L2pClQ2+tHTcgPUc1rFstFk6gWtcKBnybU1opKXKtFnagXLWivxrUVLbVCpFeKRlEjyuidJqZV8l7bKnzCKdqFV7hFroCSwdUpwlzKEy60hvDXgWuuWI8SHCbhQZ+P/5fAJzpRNgRrMCeEv1yGg1AJtW41QkLt4fYgah08O8T1EI8JqpGyJ8gtsf5+1CU02RIQAyKf3tZj2iB66XNvc5Yy1rTCAO4B4EEYuAEF4yIvO4Sft+ABsh6UXBhUyVvyYEtOvssN1YM8GkJhXGOEoX4vg6cNB3BfySi7UOvn8ZWoDTCsXp7RilW7GBkiYj5amhmWE6PdCr6biZ2LmQQ/DzDpQyuPh51PkYcg5wtDSoC+EKsyjLV8Yi5Wp9126UrFogi1YlGInxKUClHPY5Fo4HueWArhMSQFhEgJ0ZcFLesGfOhhjC3ATz//5KPHA7wCwCaIv06MyGeW9WJMDeA04r4K/Y2AW4xyC7esp6+2izxRIAKMlJeBSFlwi8UMLoylqH9or2zrY+6T5NUreSsQhObcqPy1RBkVHNbXoKRpaHsVl74vFrL8E8vmi5OBh5SiaiY5iUuX0GT7ZPoe3iS/EF3fnDzNYgnIvhol/QphFhON0QUgWD6YJAYIOq3SzFBdGEdisWQYhkPn05yR+4PHHSHc/8rKctRy3SlM3C48/8oqzWhtV/IiZwRH7BHlvegljswFJOKHE/1dfJClbunluZL3BeqolH7DeXOEODFf4RKT73r6NsEpWnvlMDjcP13rXw6InUoN6CnBo8ZpoxwslwFcxVitrZaVkpgQq4exlhNnZIDVgcjJj9JJzl2KEb2gGJ2wGOb12PkK3q+H4FlI74Zpvm4PCbHLid/DEApMjOHl4r1LnnJfXn5CeahhGepgWvljMjo98WjJ8ehuI4OLsAkPKwdX1MB1Kt2di0H6ybkgBAlaB1jiYTHNxdKEvJ8J4U44RzM8fiaoVCYhZSphgAq+nhCJsWSSe9gm9NNGLVGxskQFs8jBODWrWVVqPxLnRAQReaPNaGQl2RFVdaJgtNHDhVekl9KHIcKhKEKZMJyNw1DGZXIzClV7CWpFZA8mnI22TaINUPpY9NrE2ejZBOEOMvWI5qQ+O8m2JX1bCJucka/GzYcL0wQhaoTNqgFcUST781Q/3YtBcXJ3NqFcotpmc1spaoaMFVjby8IPQTlHP18bE4OizS+JwoxBK1a1Uq7NVrWyaC2fuUY/1F4ehXe2qIiOMdSXYQZRqxzwasUijC1HP/E9DyOq0VKDUgVjNpvbisCXcrTTtQQ9c/BXAUhVuFJLEUbOwV8eOFaMcWU8qwQwq7itHL0EnSAs4msF5lTyGjTfMLMO41ehVCNGL4mkpfjLE4aiKmBaA1iL0ftdyF4jZGgZVEELlMlKjF4NTEowr4x3R6qyhRWL9GhcGCf9J7F46Klxs/vpY1OudxOkTAZZbqWr2h01MaQsSX34eawLo5roRJ2WyMw3xLkerJCWxbcNdV01Z5YUrEt5caQP2nlsgOU4wFpjPeMCXVAU21UQswrA6VasTI5BHXBbijqVW8GLBuBQDW1QrfbjAww4u/V00jpAuWLm0Wx20stAy2Lmrgut5N2RLJRghuwlqpRg3SKWMZKKTsh/kM94ENh14HQSPqqclzgo6GBaBHnf8rTMpc+lmOLgEQRL05naWaUf4VnJetGnemnO8Bl6XEg/x3T2LB0tB9R48qZruE2OC0pMpifS9UG1loaVKJH3WI9fjQ+yxtT22Ml89cpgY3or+/997HPrcQ6y46F2mpdo/bBupn6OmBMrx486LjZFx+dPjJtMmWkxVyGGvTZCYd+VmE8jzfrGXDp9JC7JlfRriHL9erExx6VQlgOaxsEBcCNsy0qcqUrYENJsFBIXoraIbFJSM1yEHYkQ0mLg+AhYM/Uh5V/MUizVwkvpBnQzU0l1kKnXBC3AzNIgxKLagqhDkatCywJeMcgrOjlukkZKKh2Kaa8qh4YoxjkuY71dyF/CUI5aFWuBOSjT2a9iy1vM+qAa7WSja5XdKGENkie+Jegf8srRW8H6pJTtBFmMCmV7SnB3se0pYpuSx1qEdAnBqFE+SSV9KURkZ52KcNZCgVFmohL3tWBCpcpJkIpr41zFIrBnJWcrqKVxWPTUNizEXooZbYBD8UBA0WNFXE6CIMvZ/Uw5t3KGNA7KUc3sEYdUKA/3JaslmqFwRHklbC7lDuULWSLnhNRFm46jYuLwtjYtgssZ3rc2ylsxfbTeKIzKRNJJqqJDGbzRJQ7SYpsOShLla3BdTt+uFLnDwWRbr+ybJFKnWiaIxZey2PczkB4RP7oNTCPENW+xDUD72O+V5z4xM4cyRm9btXn6RFGU6JGH//3IfhUpGgH9rISt3z4+V2PzhvCzKSajuXw63Hw6NPfDLTaonEcuw5ItfoW7FsI4lfY5TRhSTqM00vx4qGGVPhpN0Wp4A8YE/WyNN9wz7bTjYIm1FzQMMX2JYI2i7ie0gfr5zDc/mxyN+8KUhzOEFXAvovscyiGtj8a1udAmlC3VMpXrmd8enXFtR5lMmXCuVAGPZgoJvy61hwBTQ9MXIycJE4eOygCf8+/VnWJcfODILvDUGnaOPbwvr0gwYtrxRszGET7vf+fW6pUPHmCfmMhYywLuVUIT4EOuZ44utTVBH/VREswBMjQAOxG5L4ZkK5prAcTBSOWxS02GjwLw/9Osl2HiEkFhRR2vHp+REf0tnMoIsky6eV5YnSxP3HnU0hx9OgdLpp2H7mOFIqsTfoqma90s7TI9UcEeypbRcti9KuLTYiW9C6VlWbQj1MWkcisujp6B0XLjTlYNQCNnNCxESWz7nRzHyZyQVAXNCRKRgNhRH7eGpgy+Dpb6+EMyREZUlHdYRRHKskTGIX5vX2dFYP19x4gqnJSun0XHE4XztWA7l4ihD1404dLS3VreitzlDhY/p06RUhzRE+ccxxwvVownxp/ZxdqJ7VoUnam1DcU99qjqmwl7Oa0/bfTcWTPF6dNHz8iRsSn+SqNKvtIoKNWp8aPi8wSsmkfN4iVIwJbGj28GxD6Gl+gURXOFJfGzHDyL6FrJIVS3UnUe5dpQn8hYpFwwkkGxeqhplRI/eiDlVKd1JDeJJce0Fko7Txgsa1VWVtTrMzB+fvAUg1DAYVmM/wVDpF7ukOhfABcufizpiV6WKZ/acTyFNfowped8vbkOzA3LmfNHx1/TWjS2lanaCErJHAfoPtavw2It+KCviyx9TXtwJnIcgNrMdrKa87Qyc6vytVM6OPPQza52rBx1dJd9Pc0T0wUj6ps5Q6UlPoMY78bG6ZGJQ7Nv2tNaUCY8Mp4BbnMrh1rTvgHeq14S3cqxDMdpHkl5jwrwYytyIH96Im7KEeR4BnlHBThJVV95LOVfhWP03fQCm/VR69Idp3v1+VMtJOkhXBfLx+zO6NOQDp2b7BzRzgbjrCuFL0uFfNo9kif2Ve27zKkashLJpzhdaqV4nRefz41qsGXDKdvDLlUB6zL5+FiG4wU6HVOgsr+aN0rj1er11XCDFnF2ZhFnmvI4205v1Mjj5yGU0af8TBHnZCgHP0fl44tUZreG5xmWOJTkSb4EFF9iK2vaMuZVjBgm1Zfz2pTdp2sFZ3Jmc+aHsGrHyp2cKyrk3E4efyxJOX80SRk/uyErXg2MDU1roT2m4SfmKNeCB/JdBbJlBa41PIbGnoIf6qvkB+F5gNKEueQSU4+h8eudPulBkPObO4wH5KMl8p+6FIyRZGt48DayTMN3TMI6lSNjrWFcr8aP8GywnjJ2taA/PS8r5exdLShdzc9/ZmNchcrGlXHGkoKQCuZFLUtINWbIp0aG1m/KkWrFlxbuJUlsQG2x5Mu/ALWJe5YngjoKtzvUe2QCQ7RTiGnnV4FG7GkP6dClyltIzNc43TMz3ldp5Wz3mfxgu56fPmmWVLi/ugbVQ9HkQ5OhkbBSUmRxIGyrpEx0dSKZdXFUFOBkc+g4HtFIcr9e2R+ZnK5TMbd8P9Jo/pX0mDu4HmB/mVI1ouf4a0gPgKxGkLX7N15rai/btaCytuuVX0F2Nhe6Gp7yBKlDlrN8tvBfk3yzW0cl5I/2mjvkTUVBkavkKxYPOPmMeziw1iyaxsFQNICO5yXwS1+B9eitEpXQBTGrprV9TTu2LPFZo5Y2Pjdrh506ed4oAUpv7aO+ZuZuLZ9F4fwmp3cxZ2iqOEOTp9MO9fx8Mo9LtBaf5K5/fYUWfs65RGcR8nBvjl/H8U3WaeURGpw8fvbTgHqlhJmhSchsiiULCtkqz1GpntgTe61UxHqYNDH9GGqH+wweTom0K4+jgBOOQz0GaaULNO/5a0CJeY7DoNTHx2fyZIajeXV6P6G2057RPYTGxL7Z4m/mmTlG9rcLGKLM23lE/Nu7VkASGsC9Rn4aPmSv/Gw6UfwuPUB9Og37Kf0q773p5qiPaD1bPnKZOLLeEZYyfuo2J+4dCkO9xhj3EnmNQ3b0teCMIgWLjycF9G4Mx/FloLImLi4bnqWpVtZraP6qUMtflY9ky2JQh8PDymtiGYehWjv2rlzfN9XWU0bOBcpn5PGZvYRjpjYPkX8t9xUdMVGLwKtYhmgP2ttWRSXJu3z3iCsqtZKW3TxaniP94wktyeuUe6jW1kvkc3xFGDnxPtAKPn8hjlq9QpjK5Rkwlcn7yph0xufGYvIX4xpFn1oGgKS2Tp2sqmgcGZXW1n8FbizLob0hWEFdcrwz8D0+O306GR7xHJjku7Hxqv18/KRg25dLH/jommd2HjkpVyTlCkNyrsFgTsHFlkVFKxeLkk0GW61FGA32yBe2QUOKQDUDw9NSco2GJHOSieYI+6DFlGtMS7MNZqDFmiLQYgOAnBSCaM1JQW+ONSfJnJFpMGbZI48bJovJwpyUZkhBiyFnslCNtGhOCs+0YhUzls9JSc4VOSkWU7I5J8XWmpNixExhsA/m2AanpgqDGSWzMNpaJ9kGZ2JOdqpIMkzKNqaajPb6nJRUQAR6tKU0U24SoSRxSkoRRqvVmm4yWwhNs9FoSTahxUTNtsEigMJGjKhYTKlmow0DjLyxUt7wHGzUmCxAqGyTyd6Yk5Jlc2Jsls2Na04K/aRm2degkpYrqG+cGGdIlYO4xa210ARscZygiwHLGtMAsd5sNlutRhDOQOPGmcZa7PVGs8VosQBfowXYYKgFa/Qa7DOIbuPEFNM4+5m0sr3R3oj5ZvsMI36N1GQENYgIFgwdJ8wghZlIYY8xRN3M2cOa1C0N07k4TqSbkrJsYSwM8GbaTRiNqbIJC2BrNlOyRC06LjkN98xMgtEbA2o1pURHAFmwGcVZRvssExhObamggHmcsIpk+2rwpdE2uMw22GrDNAI/z2hUd0mJeWbA3WJEnQR0UvaERJvZAhFidOaN1cDYN2GqvQ4UIvEwgnZnmKZbbQNWoz1ynj1yoT1yqT1yBf9Gq9fIX+Ky2VbBzJbAuGirsEeuxwSz3SMLViClSrYBs4Y9hi1k1G0DLKqR81i81ki5XUO7sFq5yWnJNTKYyKU4hjggXL+G6iaFQ7oOCZPCguZGroesTIK0mq2AO44EINcIJmWOM5hpmG3AvnCCyZRli/ycy/aFRmbKPEJ5YXouEe0mllcLl2gMtdJ42arNlDIwL83EAGwD2JUsMMrpODQWYEC6IM2UZI9cbo9cYhswMcaRbWNMZntkH4m9FdIthBVH2WqdRIgbcURwISg4osxDq/EEMHcYX6FUrGNNGei2WsFGo9lqTsJcOmNQWKl0unMmpUHMGuUptWUqqY4pIULVYgZ+jbYBUj8GQ3qmaQxBs+DPFrkTegOqAIUME52yRqsxHYAGskw2q32T0ZxkNPLhgsowA+dcI6byVqyyYj3RNMYeedOSPdYWeR3wXrcN4DjTJTUbi481ZCelgiqC2nAnQr1JmiqVJ1nQSsoNZdpG5E1b5BVLdooJFHxzjByDFgzLJHLKXguA2wZAR2v2GJOcmw2dYDWLZEM2oWoBKc05pJUzoHy0WUarrCmA1gkM0ZIt5ZWxN8qymZG0DVjUeSbEaUNZpgx7ZAfYaY/sNNPFSDSBTNoGN7ECngRJNKBiqyVlarab0jBqh3487/vhHJDNaEymIgQIV9KZOVabKR3a2mxDJ4SKxsAkQE1cAUZDUqxjwN0oY8GDSViRyAClnszz7N0p0Pr2wjRTKlCzrwZVMJVsFtqN1IvFdtExzDZaTCkoZ4OtAJFtxiUlm7DO1jrM1GaGBTKSTYFwWCysrqGRvdNAu0ack7+qA+pVtxyp/7xU0p1frzx1f+LzNYZLug4CIzt0AFO1G8PLMKXZ6y1mi9VClivdRGpwj8HusrtMTA67y8Ir7IE2MKm+cUodejWUjHZXhtZmRtVo12rG6BCiE4ydic3M6Sap2VwJdhqdodaX+LogkBacK6ZSyEoHkweG7CE2oRgSklsKpZqSzDCCY5XJwAgj74csRYj2mBRtp3NmtZ5kStWwiY5Xi4/FonSapRKwb4wtvNG+UVt4o1x4YwaMmeoyqvU2xtaj1mxFF1e0Ra2TTruTMkCUsjfi0KZgF1B3ON6QG7loZBs1wFFStUy1omzHn5kWpTkZalXZA5cFWgMeD+R6nmm6vQbKuw6KOHI52S6rUisWOk+XQJrthaCKfRb9otc+S3IJZaNJipjVpJogCvZuq25PIDSZTJckiWuyCcezm/p1g8j/kUOZGlbmk3WmaQIUBChtTVPUbiS8InfCZA0YCQxZWTIF5ESa4USSyk1JhoYdGI9T0y0XMBo14EbjiaYMqV9oMpowu87KejHJ3g0/jQ7t29jS4J2YIP0WFMcJ7nj3BFP6kNlG1mDAbFNOyhhSqs/bI/sJVfL4Is+TMbYN7pS3B9jucq85N4lvZtapB6SfS5weSwrhgD1yECAjhzQv9GGGdogMIAZZ1ZjDPIY8PZ7LoN5BGzTyENfFQkr2UHTQewq9904yQV2Rs6v/we4Inol1ik0T9NgP2T+T6mOLZ55mGs9EIaqkpaWl4wXSwLC1QcVG7iRT3QbVBiaaIQm2tjLTVI2INJYYimlG2zorwbat41WiAEjXQgZtbTR3HeTWYiwiAFZtTaYJc0Mihxp6VTcUdjpLOoqZFtzSCQvo3knm+85qWzFh9ivnme9esPYc2/Npc5MpxqFvtxDJ9En2yfSfxcnUmEwfiZ+cShf6jPxkMy6R7fmGyOZRPn4if5QP9puVq30S76xc9bFS84vzC+lnVm512Euf/TLf5w6HAk7vrNzmcLvXQ/+Ezv9rPb+9vNxZ2lFaVjSnZLa7sGJOlqHFmEmfCMT/Bq4+KMkAIUg1wx3AH5mmdGMqTJzRpGILY6pFqbgZSan21RhXoerzLKmaZ2dS/iV6V41J1ZkYNTSk7huTU22RzeZU5Y1R7Sgug8lU+oAun1BVkBF+jsBLR5s6XqTLK0Chm75olgwoAhjyteTNgHDEBCUFTwlVA/HXRHFfCtlkqq420SAYX0y3kLuHUIttsDBAdZIm4NDUPoMOUg7dECuQN2WAJqOwjmIu8hDNFI3w/uEe2Os4iB2g0QvN5jG5qQZzOnvc3M0eN6STxN+QyVbbmmkeI1It2RC3nJRM9sEs2bhnUiPu1kxsM9OSmT1WmLhBniWrySKS5ECrRSTLoVYbTQJtUKErZmWIVAP1ZVuplq5GUhl7tljSNCDQRlS0SgxYVxE9gLBgzwq0tNAKhDi71qT6QG20pQmD5LZEnu5ERJCCxprpm2kZFPiBM4eoFiDthdABODGoUfybxIU0Ycq2WuAEWrJpSGSX1SrII9tlyTZnmzPNhLKZojO7y2qVNwvzyBWNE2EsmDVWebMwoyykDekuWy0WDnEsmKTmWGNFCbCR1vfa63k61BVVQ/Z6nsfob6QKBtazZ7iNsFFJB8leEgLaL672OrPcHxOMChnCJOu2CrM5nYW12ypvFrMwSgaDvarE8soNrGRtLN6gO0W9kKoZAjI8Q1jxZ+FvraXXZAN/zc74lQGnf6nuI85augN9/UEDxplIW4mxBpGm+xxjkWYQKfzxR0KMwZgiqVlke5Es8mvB4+MOCUNjM2k7P/5uLDOIG7MN0e/woBJ9icdp+MssN4jMCbE+emWK+NdyR43DfOeHV7uOvN6w+X9W3H3y7QuP0ozquW2tQai5tkpXr8dHH/1An6TTVuMO9oT6/G0K77xeJ5RpoC22k7a+9jPaeCNtPneopFTXle93tWtfwqCWvK5GLYltuX/d+cQHget2P/bKXa8/vrY8hvYAlXNFwldPuX57a6v7AjVeb6PT45Ofm+6Wn77Iry+nA0gmfYvnI1d+mtxy4oK7XjM3v3Xyg45H/3nG2X9Kydk54eWrXz2zUTgPX5/0edGnU/LXrX4iuPvN3xw8fc4fS63dZ93eNGOaPfu12zcP+s59d8F+z3++/ODaJ4tb7ln+7e/saXP/9jurM7JuKH+78Lq/TJyTMbV45s0Hntjl+Wdggbh68ic/HahZMz1y9ocHN3ZPvz2j6+pDq69N3jWtpO7zGc+sf9mw4h9vP3rSzSfPeHLHrxsKT+j7r3zDt5Jfe/i2yoI/HXH8zl/33j2/+e9/jD0ra8+tx6btfv+gcfuNSx/+8L8doYtCN9308COdjwUvPuW2bxW8tv+DGfs/+dlPkrbPvIN2ayIBuYX4W1kskkkuDGLsI/33H2gpO9D13Imdj43bs2Dy+DHjS+/onT972TsLVp7wm/vMh/efFbl37bVzv9hePtcR6Lps3R+O7Lxo8tPXX/fsJYcOfPD39//mvnfXw56D66/YX37/D56cf/XR5rarf/XaxobT/vDMUxtSl3VPe8P/ycZflT1SufLVP+TdNXXHvVmDE07tybz38J7aqf3XfXTwwG82XJ9T7Pzt6X//0eemUzInNFl6ky557geFWx5f9cM1v7rB9ZPkcy3WSZ2/uOLSZfe889Nw8tbmX/4lN7X2gbOrHD/dM/PokQcWjw97Urae/ueW66bmNV9kf+nZnrcvu2nH4SWP9vy04olxn224ad7khyqKHhpzg/+kIrH3ez/ffMp5kQ+3/b4o+0VHyprPBl88+NQttz9oemFGk8u6+drUl3Zv6Cw4cfovrrvm6G83Gar2lj464aMFufuvvnbNgTmPDIr0l/pOePKHn/zu1F/k7Bm/zbW1rLa8+QXvW1t2Vs/c1ldw7EL7+YH7vvfnzt/n52yquvWDY6euadnen3PV79//Yt29J2978rRrXt69Y+8fW25tfqDlw5eOHRy8+ZHBG+q+LLj/lntP3LfrgTVT59/8zqQrO/9nyuKn2z/7266t33/s0H5zxcmfTX34n9teePWU6VPeS8/7VfIjt54TvmD/VQefLH3gaJ+h2/Zsd/Ezuzw/e/razNc9tz198Ni3TNt3lW/uPvT4HdPf3rQpdMae5xv3Htz0UuGSN9b89dLVH0W++OO8A5efk3X9kQLRvveFB+7df+Gbe+ddWbtmcvPnt1c/u7h/8HDX68derhr48213rqn78L7QlfZpqf6q7rNqjt5YdE73kzefsOZnT1dNu2PxR/cc7X1vJLmaufXBBcsvWbnPfmpPxT3f/rTL3HTg/A9fs93vnFtStcyd8qPJovKlxw/UrFsx/4Q591W7D398+s/f/Zm7+/Dr57cl5ZUdm9GwZ978XZeEP/UZX1l11RlPRoxVC7xZWxr/Y9oZV2yvWL664oxr3t35V8cPzRt3Lnv24p9l3PjZhVvnHV09dV/+/qvOX7hux97T03zrdjb/Zd6Ola/f9+L3Gg+2vXJ5ww9mfPlZ5IxxjuV/fz/5suqKBybu39Jy9glPnDf+x0vOvclsvGZa3YHwdbt3PXX33on7Ps+7LX/xbdlLPprpqSksefC2KU9duX3hwep3X8lIK/71/9z0hx9c+8Q5H16/759j9198ZzhNPD+9+uNfLTvnvpfuu/Pzp/7j4OCXB27uP/bWaVMyPzu3/IMf/uXVm1btvivnpMEi3wfnd8x+P2Xswb9kvXjLjLO2v9W+b98FW/aatl5S8PGkFVsKjhSXm+64+42dxgmld/39uZuvK4v88cVzza/8bu281bcvPTVp5r3tqypXzy2vLn3thtmv3pR8lf36C+78+PMLbrr58OtH9j9+6GXro9995azJmc2rOpYdfO7Yyru3733hgnc2nfvLgumr0la9ccsHK5fcMtH9wHe3LnrrgrE/rbvk0xvWe5IC/W/vqmrY+vf0ec+Fjhya/Upx7d2f3PH8qVP3/tfVLRe7tuWefsJr5z7/rSUXLy3NPfeHE499NmvA6+u8/KG0tx7c73ceXrzz3KPZ8zrnWvKnOENP/vmjs5aX5/zywg7P5oue8K8+kHfp5I93rHjnrNTrv1+SdaDomTfGm679+eWpm3Yd/tvuu349OW9b6m0d9z+9+2bf5nsvPLT4jXEdF+0557nBmopHSa5OZR09KbGWl5ZNfd9dsmjHNfaP+vIxdzG/lSiP/7WviN8cVirkP/bLESXcR/cSfpuYfFt3ftzDcppTzI/LS7DCSxOMT08pvWrpjy++37Tjsp07r6p6e+76zc8bitG3AX/rYGIfm3z7+QfG3NF6xlN3/fKctQ8fJvxSRcuzC83v/zXpyO6srdufzN/y+RsfBTs/f+Ghs3f89m+ftlXeeOxg6LGHLj30Uu9c2/NHu3939rn3nLJny4O1j7536mc//6PT7/H4xqavu2/+m+8tTnd/cVvh5I9ueWbgsVUXDn5x2z8c73VteHfsuot3jy89+fK6P4+96J6cj78zo6q1x/Tam8ue/+zkMT9yZyw4cOG1E//07P1z337PNmH6x5u/25C2s+jy8vVP/eOO//S8fMufTvZO+7Ln6Asb9j12ceihU1PE1dceevXOjJVXRDovqg5t/cmUD+6Zlbt233UNK+5dWdPefeHtC23Xb263Vv84591J9ftWHGl41vVgxpGtO2dtez/7y7kXfHjrhrb217Y3/KYoLzVy2W/zL7t1xZWjMPH/8ZeB/a9shKJD20m2CxO006sOf6sWGsRzui9re85I37m2QjjEWvVmNYd6m8ta/pekRSjT6+HkI8ckHEMczAWqRrGy/jvg6FXDo1bwW40WqYfh0QfBeJ3Cs1rUP00E4x44y9fdybONBIPe0BxQDzCHQ8rkMYXRH3obJ/m5Zfyth9oby2mNAexIvgGRXvRW2HZ+y5R8PNyl2r/D87R1RvjslVHmF9LDxuj8If9hhpd8O4v2R+vRtzDq/6WLHkPHME20Dr0Zgx7T0msGKE/fukz/7kUzacd+7JUw7hL0SU3S713E6zSpdo9aR8PT95XXk3SNfxvAV6FrIUXuQ+YNpU6Rji4VTMdKfizt5s/nkW8+HHmOnPd/5avQIOgLGS8o/3cj8v9f/47X/wJFtkDlACgBAA==
"@  # Paste your full Base64 string here
$compressedDllBytes = [Convert]::FromBase64String($base64EncodedDll)
$compressedStream = [MemoryStream]::new($compressedDllBytes)
$gzipStream = New-Object Compression.GZipStream($compressedStream, [Compression.CompressionMode]::Decompress)
$decompressedStream = New-Object MemoryStream
$gzipStream.CopyTo($decompressedStream)
$gzipStream.Close()
$decompressedDllBytes = $decompressedStream.ToArray()
[Assembly]::Load($decompressedDllBytes)

Function GetRandomKey([String] $ProductID) {
    try {
        $guid = [Guid]::Parse($ProductID)
        $pkc = [LibTSforge.SPP.PKeyConfig]::new()
        try {
          $pkc.LoadConfig($guid) | Out-Null
        } catch {
          $pkc.LoadAllConfigs([LibTSforge.SPP.SLApi]::GetAppId($guid)) | Out-Null
        }
        $config = [LibTSforge.SPP.ProductConfig]::new()
        $refConfig = [ref] $config
        $pkc.Products.TryGetValue($guid, $refConfig) | Out-Null
        return $config.GetRandomKey().ToString()
    } catch {
        Write-Warning "Failed to retrieve key for Product ID: $ProductID"
        return $null
    }
}
function Activate-License([string]$desc, [string]$ver, [string]$prod, [string]$tsactid) {
    if ($desc -match 'KMS|KMSCLIENT') {
        [LibTSforge.Activators.KMS4k]::Activate($ver, $prod, $tsactid)
    }
    elseif ($desc -match 'VIRTUAL_MACHINE_ACTIVATION') {
        [LibTSforge.Activators.AVMA4K]::Activate($ver, $prod, $tsactid)
    }
    elseif ($desc -match 'MAK|RETAIL|OEM|KMS_R2|WS12|WS12_R2|WS16|WS19|WS22|WS25') {
        
        $isInsiderBuild = $Global:osVersion.Build -ge 26100 -and $Global:osVersion.UBR -ge 4188
        $serverAvailable = Test-Connection -ComputerName "activation.sls.microsoft.com" -Count 1 -Quiet

        Write-Warning "Insider build detected: $isInsiderBuild"
        Write-Warning "Activation server reachable: $serverAvailable"

        if ($isInsiderBuild -and $serverAvailable) {
            
            Write-Warning "Selected activation mode: Static_Cid"
            [Net.ServicePointManager]::SecurityProtocol = [Net.SecurityProtocolType]::Tls12
            $attempts = @(
                @(100055, 1000043, 1338662172562478),
                @(1345, 1003020, 6311608238084405)
            )
            foreach ($params in $attempts) {
                Write-Warning "$ver, $prod, $tsactid"
                [LibTSforge.Modifiers.SetIIDParams]::SetParams($ver, $prod, $tsactid, [LibTSforge.SPP.PKeyAlgorithm]::PKEY2009, $params[0], $params[1], $params[2])
                $instId = [LibTSforge.SPP.SLApi]::GetInstallationID($tsactid)
                Write-Warning "GetInstallationID, $instId"
                $confId = Call-WebService -requestType 1 -installationId $instId -extendedProductId "31337-42069-123-456789-04-1337-2600.0000-2542001"
                Write-Warning "Call-WebService, $confId"
                $result = [LibTSforge.SPP.SLApi]::DepositConfirmationID($tsactid, $instId, $confId)
                Write-Warning "DepositConfirmationID, $result"
                if ($result -eq 0) { break }
            }
            [LibTSforge.SPP.SPPUtils]::RestartSPP($ver)
        } 
        else {
            if ($isInsiderBuild) {
                Write-Host
                Write-Host "Activation could fail, you should select Vol' products instead" -ForegroundColor Green
                Write-Host
            }
            Write-Warning "Selected activation mode: Zero_Cid"
            [LibTSforge.Activators.ZeroCID]::Activate($ver, $prod, $tsactid)
        }
    }
    else {
        Write-Warning "Unknown license type: $desc"
        return
    }

    $ProductInfo = gwmi SoftwareLicensingProduct -ErrorAction SilentlyContinue -Filter "ID='$tsactid'"
    if (-not $ProductInfo) {
        Write-Warning "Product not found"
        return
    }

    if ($desc -match 'KMS|KMSCLIENT') {
        if ($ProductInfo.GracePeriodRemaining -gt 259200) {
            if ($desc -match 'KMS' -and (
                $desc -notmatch 'CLIENT')) {
                [LibTSforge.Modifiers.KMSHostCharge]::Charge($ver, $prod, $tsactid)
            }
            return
        }

        Write-Warning "KMS4K activation failed"
        return
    }

    if ($desc -notmatch 'KMS|KMSCLIENT') {
        if ($ProductInfo.LicenseStatus -ne 1) {
            Write-Warning "Activation Failed [ZeroCid/StaticCid/AVMA4K]"   
            return
        }
    }

}
function Capture-ConsoleOutput {
    param (
        [ScriptBlock]$ScriptBlock
    )

    $stringWriter = New-Object StringWriter
    $originalOut = [Console]::Out
    $originalErr = [Console]::Error

    try {
        [Console]::SetOut($stringWriter)
        [Console]::SetError($stringWriter)

        & $ScriptBlock
    }
    finally {
        [Console]::SetOut($originalOut)
        [Console]::SetError($originalErr)
    }

    return $stringWriter.ToString()
}
# TSForge part -->

# ActivationWs project -->
<#
This code is adapted from the ActivationWs project.
Original Repository: https://github.com/dadorner-msft/activationws

MIT License

Copyright (c) Daniel Dorner

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is furnished
to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT, OR OTHERWISE, ARISING FROM,
OUT OF, OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
#>
function Call-WebService {
    param (
        [int]$requestType,
        [string]$installationId,
        [string]$extendedProductId
    )

function Parse-SoapResponse {
    param (
        [Parameter(Mandatory=$true)]
        [string]$soapResponse
    )

    # Unescape the HTML-encoded XML content
    $unescapedXml = [System.Net.WebUtility]::HtmlDecode($soapResponse)

    # Check for ErrorCode in the unescaped XML
    if ($unescapedXml -match "<ErrorCode>(.*?)</ErrorCode>") {
        $errorCode = $matches[1]

        # Handle known error codes
        switch ($errorCode) {
            "0x7F" { throw [System.Exception]::new("The Multiple Activation Key has exceeded its limit.") }
            "0x67" { throw [System.Exception]::new("The product key has been blocked.") }
            "0x68" { throw [System.Exception]::new("Invalid product key.") }
            "0x86" { throw [System.Exception]::new("Invalid key type.") }
            "0x90" { throw [System.Exception]::new("Please check the Installation ID and try again.") }
            default { throw [System.Exception]::new("The remote server reported an error ($errorCode).") }
        }
    }

    # Check for ResponseType in the unescaped XML and handle it
    if ($unescapedXml -match "<ResponseType>(.*?)</ResponseType>") {
        $responseType = $matches[1]

        switch ($responseType) {
            "1" {
                # Extract the CID value
                if ($unescapedXml -match "<CID>(.*?)</CID>") {
                    return $matches[1]
                } else {
                    throw "CID not found in the XML."
                }
            }
            "2" {
                # Extract the ActivationRemaining value
                if ($unescapedXml -match "<ActivationRemaining>(.*?)</ActivationRemaining>") {
                    return "$($matches[1]) Activation left"
                } else {
                    throw "ActivationRemaining not found in the XML."
                }
            }
            default {
                throw "The remote server returned an unrecognized response."
            }
        }
    } else {
        throw "ResponseType not found in the XML."
    }
}
function Create-WebRequest {
    param (
        [Parameter(Mandatory=$true)]
        [string]$soapRequest  # Expecting raw XML text as input
    )
    
    # Define the URI and the SOAPAction
    $Uri = New-Object Uri("https://activation.sls.microsoft.com/BatchActivation/BatchActivation.asmx")
    $Action = "http://www.microsoft.com/BatchActivationService/BatchActivate"  # Correct SOAPAction URL
    
    # Create the web request
    $webRequest = [System.Net.HttpWebRequest]::Create($Uri)
    
    # Set necessary headers and content type
    $webRequest.Accept = "text/xml"
    $webRequest.ContentType = "text/xml; charset=`"utf-8`""
    $webRequest.Headers.Add("SOAPAction", $Action)
    $webRequest.Host = "activation.sls.microsoft.com"
    $webRequest.Method = "POST"
    
    try {
        # Convert the string to a byte array and insert into the request stream
        $byteArray = [Encoding]::UTF8.GetBytes($soapRequest)
        $webRequest.ContentLength = $byteArray.Length
        
        $stream = $webRequest.GetRequestStream()
        $stream.Write($byteArray, 0, $byteArray.Length)  # Write the byte array to the stream
        $stream.Close()  # Close the stream after writing
        
        return $webRequest  # Return the webRequest object
        
    } catch {
        throw $_  # Catch any exceptions and rethrow
    }
}
function Create-SoapRequest {
    param (
        [int]$requestType,
        [string]$installationId,
        [string]$extendedProductId
    )

    $activationRequestXml = @"
<ActivationRequest xmlns="http://www.microsoft.com/DRM/SL/BatchActivationRequest/1.0">
  <VersionNumber>2.0</VersionNumber>
  <RequestType>$requestType</RequestType>
  <Requests>
    <Request>
      <PID>$extendedProductId</PID>
      <IID>$installationId</IID>
    </Request>
  </Requests>
</ActivationRequest>
"@
    
    if ($requestType -ne 1) {
        $activationRequestXml = $activationRequestXml -replace '\s*<IID>.*?</IID>\s*', ''
    }

    # Convert string to Base64-encoded Unicode bytes
    $base64RequestXml = [Convert]::ToBase64String([Encoding]::Unicode.GetBytes($activationRequestXml))

    # HMACSHA256 calculation with hardcoded MacKey
    $hmacSHA = New-Object System.Security.Cryptography.HMACSHA256
    $hmacSHA.Key = [byte[]]@(
        254, 49, 152, 117, 251, 72, 132, 134, 156, 243, 241, 206, 153, 168, 144, 100, 
        171, 87, 31, 202, 71, 4, 80, 88, 48, 36, 226, 20, 98, 135, 121, 160, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
    )
    $digest = [Convert]::ToBase64String($hmacSHA.ComputeHash([Encoding]::Unicode.GetBytes($activationRequestXml)))

    # Create SOAP envelope with the necessary values
    return @"
<soap:Envelope xmlns:soap="http://schemas.xmlsoap.org/soap/envelope/" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
  <soap:Body>
    <BatchActivate xmlns="http://www.microsoft.com/BatchActivationService">
      <request>
        <Digest>$digest</Digest>
        <RequestXml>$base64RequestXml</RequestXml>
      </request>
    </BatchActivate>
  </soap:Body>
</soap:Envelope>
"@
}

    # Create SOAP request
    #Write-Warning "$requestType, $installationId, $extendedProductId"
    $soapRequest = Create-SoapRequest -requestType ([int]$requestType) -installationId $installationId -extendedProductId $extendedProductId

    # Create Web Request
    $webRequest = Create-WebRequest -soapRequest $soapRequest

    try {
        # Send the web request and get the response synchronously
        $webResponse = $webRequest.GetResponse()
        $streamReader = New-Object StreamReader($webResponse.GetResponseStream())
        $soapResponse = $streamReader.ReadToEnd()

        # Parse and return the response
        $Response = Parse-SoapResponse -soapResponse $soapResponse
        return $Response

    } catch {
       return "$_"
    }
    
    return 0
}
# ActivationWs project -->

<#
Based on idea from ->

# Old source, work on W7
# GetSLCertify.cs by laomms
# https://forums.mydigitallife.net/threads/open-source-windows-7-product-key-checker.10858/page-14#post-1531837

# new source, work on Windows 8 & up, N key's
# keycheck.py by WitherOrNot
# https://github.com/WitherOrNot/winkeycheck
#>
function Validate-ProductKey {
    param (
        [Parameter(Mandatory = $true)]
        [ValidateNotNullOrEmpty()]
        [string]$ProductKey,

        [Parameter(Mandatory = $false)]
        [Guid]$SkuID = [guid]::Empty
    )

    $IndexN = ([string]::IsNullOrEmpty($ProductKey) -or (
        $ProductKey.LastIndexOf("n",[StringComparison]::InvariantCultureIgnoreCase) -lt 0))
    $keyInfo = Decode-Key -Key $ProductKey
    if ($SkuID -eq [guid]::Empty) {
        $SkuID = Retrieve-ProductKeyInfo -CdKey $ProductKey | select -ExpandProperty SkuID
    }
    if (!$SkuId -or !$keyInfo -or $IndexN) {
        Clear-Host
        Write-Host
        Write-Host "** Verified process Failure:" -ForegroundColor Red
        Write-host "** Product Key, N Index, Not found." -ForegroundColor Green
        Write-host "** Possible Error: Failed to decode product key." -ForegroundColor Green
        Write-host "** Possible Error: SkuId not found for the product key." -ForegroundColor Green
        Write-Host
        return
    }

    [long]$group    = $keyInfo.Group
    [long]$serial   = $keyInfo.Serial
    [long]$security = $keyInfo.Security
    [int32]$upgrade = $keyInfo.Upgrade

    [System.Numerics.BigInteger]$act_hash = [BigInteger]$upgrade -band 1
    $act_hash = $act_hash -bor (([BigInteger]$serial -band ((1L -shl 30) - 1)) -shl 1)
    $act_hash = $act_hash -bor (([BigInteger]$group -band ((1L -shl 20) - 1)) -shl 31)
    $act_hash = $act_hash -bor (([BigInteger]$security -band ((1L -shl 53) - 1)) -shl 51)
    $bytes = $act_hash.ToByteArray()
    $KeyData = New-Object 'Byte[]' 13
    [Array]::Copy($bytes, 0, $KeyData, 0, [Math]::Min(13, $bytes.Length))
    $act_data = [Convert]::ToBase64String($KeyData)

    $value = [HttpUtility]::HtmlEncode("msft2009:$SkuID&$act_data")
    $requestXml = @"
<?xml version="1.0" encoding="utf-8"?>
<soap:Envelope
    xmlns:soapenc="http://schemas.xmlsoap.org/soap/encoding/"
    xmlns:soap="http://schemas.xmlsoap.org/soap/envelope/"
    xmlns:xsd="http://www.w3.org/2001/XMLSchema"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance">
    <soap:Body>
        <RequestSecurityToken
            xmlns="http://schemas.xmlsoap.org/ws/2004/04/security/trust">
            <TokenType>PKC</TokenType>
            <RequestType>http://schemas.xmlsoap.org/ws/2004/04/security/trust/Issue</RequestType>
            <UseKey>
                <Values xsi:nil="1"/>
            </UseKey>
            <Claims>
                <Values
                    xmlns:q1="http://schemas.xmlsoap.org/ws/2004/04/security/trust" soapenc:arrayType="q1:TokenEntry[3]">
                    <TokenEntry>
                        <Name>ProductKey</Name>
                        <Value>$ProductKey</Value>
                    </TokenEntry>
                    <TokenEntry>
                        <Name>ProductKeyType</Name>
                        <Value>msft:rm/algorithm/pkey/2009</Value>
                    </TokenEntry>
                    <TokenEntry>
                        <Name>ProductKeyActConfigId</Name>
                        <Value>$value</Value>
                    </TokenEntry>
                </Values>
            </Claims>
        </RequestSecurityToken>
    </soap:Body>
</soap:Envelope>
"@

    try {
        $response = $null
        $webRequest = [System.Net.HttpWebRequest]::Create('https://activation.sls.microsoft.com/slpkc/SLCertifyProduct.asmx')
        $webRequest.Method      = "POST"
        $webRequest.Accept      = 'text/*'
        $webRequest.UserAgent   = 'SLSSoapClient'
        $webRequest.ContentType = 'text/xml; charset=utf-8'
        $webRequest.Headers.Add("SOAPAction", "http://microsoft.com/SL/ProductCertificationService/IssueToken");

        try {
            $byteArray = [System.Text.Encoding]::UTF8.GetBytes($requestXml)
            $webRequest.ContentLength = $byteArray.Length
            $stream = $webRequest.GetRequestStream()
            $stream.Write($byteArray, 0, $byteArray.Length)
            $stream.Close()
            $httpResponse = $webRequest.GetResponse()
            $streamReader = New-Object System.IO.StreamReader($httpResponse.GetResponseStream())
            $response = $streamReader.ReadToEnd()
            $streamReader.Close()
        }
        catch [System.Net.WebException] {
            if ($_.Exception) {
                $stream = $_.Exception.Response.GetResponseStream()
                $reader = New-Object System.IO.StreamReader($stream)
                $response = $reader.ReadToEnd().ToString()
                $reader.Close()
            }
        }
        catch {
            Write-Error "Error: $($_.Exception.Message)"
            $global:error = $_
            return $null
        }

    }
    catch {
        Write-Error "Error: $($_.Exception.Message)"
        return $null
    }

    if ($response -ne $null) {
        [xml]$xmlResponse = $response
        if ($xmlResponse.Envelope.Body.Fault -eq $null) {
            return "Valid Key"
        } else {
            return Parse-ErrorMessage -MessageId ($xmlResponse.Envelope.Body.Fault.detail.HRESULT) -Flags ACTIVATION
        }
    }

    return "Error: No response received.", "", $false
}

<#
Based on idea from ->

# Old source, work on W7
# GetSLCertify.cs by laomms
# https://forums.mydigitallife.net/threads/open-source-windows-7-product-key-checker.10858/page-14#post-1531837

# new source, work on Windows 8 & up, N key's
# keycheck.py by WitherOrNot
# https://github.com/WitherOrNot/winkeycheck
#>
function Consume-ProductKey {
    param (
        [Parameter(Mandatory = $true)]
        [ValidateNotNullOrEmpty()]
        [string]$ProductKey,

        [Parameter(Mandatory = $false)]
        [Guid]$SkuID = [guid]::Empty
    )
    $IndexN = ([string]::IsNullOrEmpty($ProductKey) -or `
        ($ProductKey.LastIndexOf("n",[StringComparison]::InvariantCultureIgnoreCase) -lt 0))
    if ($IndexN) {
        return
    }
    $keyInfo = Decode-Key -Key $ProductKey
    if ($SkuID -eq [guid]::Empty) {
        $SkuID = Retrieve-ProductKeyInfo -CdKey $ProductKey | select -ExpandProperty SkuID
    }
    if ($SkuID -eq $null -or $SkuID -eq [guid]::Empty) {
        return
    }
    $LicenseURL  = Get-LicenseDetails -ActConfigId $SkuID -pwszValueName PAUrl ## GetUseLicenseURL
    if (!$LicenseURL) {
        return
    }
    $LicenseXML  = Get-LicenseData -SkuID $SkuID -Mode License
    if (!$LicenseXML) {
        return
    }
    if ($LicenseXML[0] -eq [char]0xFEFF) {
        $LicenseXML = $LicenseXML.Substring(1)
    }
    $LicenseData = [HttpUtility]::HtmlEncode($LicenseXML)

    if (!$SkuID -or !$keyInfo -or !$LicenseXML -or !$LicenseURL -or $IndexN) {
        <#
        Clear-Host
        Write-Host
        Write-Host "** Consume process Failure:" -ForegroundColor Red
        Write-host "** Couldn't find N. Index" -ForegroundColor Green
        Write-host "** Possible Error: Failed to decode product key." -ForegroundColor Green
        Write-host "** Possible Error: SkuID not found for the product key." -ForegroundColor Green
        Write-host "** Possible Error: Failed to Accuire License File for SKU Guid." -ForegroundColor Green
        Write-host "** Possible Error: Can't find License URL." -ForegroundColor Green
        Write-Host
        #>
        return
    }

    [long]$group    = $keyInfo.Group
    [long]$serial   = $keyInfo.Serial
    [long]$security = $keyInfo.Security
    [int32]$upgrade = $keyInfo.Upgrade
    [System.Numerics.BigInteger]$act_hash = [BigInteger]$upgrade -band 1
    $act_hash = $act_hash -bor (([BigInteger]$serial -band ((1L -shl 30) - 1)) -shl 1)
    $act_hash = $act_hash -bor (([BigInteger]$group -band ((1L -shl 20) - 1)) -shl 31)
    $act_hash = $act_hash -bor (([BigInteger]$security -band ((1L -shl 53) - 1)) -shl 51)
    $bytes = $act_hash.ToByteArray()
    $KeyData = New-Object 'Byte[]' 13
    [Array]::Copy($bytes, 0, $KeyData, 0, [Math]::Min(13, $bytes.Length))
    $act_data = [Convert]::ToBase64String($KeyData)

    $Hex = "2A0000000100020001000100000000000000010001000100"
    [byte[]]$Binding = @(
        for ($i=0; $i -lt $Hex.Length; $i+=2) {
            [byte]::Parse($Hex.Substring($i, 2), 'HexNumber')
        }
    )
    [byte[]]$RandomBytes = New-Object byte[] 18
    (New-Object System.Security.Cryptography.RNGCryptoServiceProvider).GetBytes($RandomBytes)
    $bindingData = [System.Convert]::ToBase64String((@($Binding) + @($RandomBytes)))

    $secure_store_id = [guid]::NewGuid()
    $act_config_id = [HttpUtility]::HtmlEncode("msft2009:$SkuID&$act_data")
    $systime = [DateTime]::UtcNow.ToString("yyyy-MM-ddTHH:mm:sszzz", [System.Globalization.CultureInfo]::InvariantCulture)
    $utctime = [DateTime]::UtcNow.ToString("yyyy-MM-ddTHH:mm:sszzz", [System.Globalization.CultureInfo]::InvariantCulture)
    $requestXml = @"
<?xml version="1.0" encoding="utf-8"?>
<soap:Envelope
    xmlns:soapenc="http://schemas.xmlsoap.org/soap/encoding/"
    xmlns:soap="http://schemas.xmlsoap.org/soap/envelope/"
    xmlns:xsd="http://www.w3.org/2001/XMLSchema"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance">
    <soap:Body>
        <RequestSecurityToken
            xmlns="http://schemas.xmlsoap.org/ws/2004/04/security/trust">
            <TokenType>ProductActivation</TokenType>
            <RequestType>http://schemas.xmlsoap.org/ws/2004/04/security/trust/Issue</RequestType>
            <UseKey>
                <Values
                    xmlns:q1="http://schemas.xmlsoap.org/ws/2004/04/security/trust" soapenc:arrayType="q1:TokenEntry[1]">
                    <TokenEntry>
                        <Name>PublishLicense</Name>
                        <Value>$LicenseData</Value>
                    </TokenEntry>
                </Values>
            </UseKey>
            <Claims>
                <Values
                    xmlns:q1="http://schemas.xmlsoap.org/ws/2004/04/security/trust" soapenc:arrayType="q1:TokenEntry[14]">
                    <TokenEntry>
                        <Name>BindingType</Name>
                        <Value>msft:rm/algorithm/hwid/4.0</Value>
                    </TokenEntry>
                    <TokenEntry>
                        <Name>Binding</Name>
                        <Value>$bindingData</Value>
                    </TokenEntry>
                    <TokenEntry>
                        <Name>ProductKey</Name>
                        <Value>$ProductKey</Value>
                    </TokenEntry>
                    <TokenEntry>
                        <Name>ProductKeyType</Name>
                        <Value>msft:rm/algorithm/pkey/2009</Value>
                    </TokenEntry>
                    <TokenEntry>
                        <Name>ProductKeyActConfigId</Name>
                        <Value>$act_config_id</Value>
                    </TokenEntry>
                    <TokenEntry>
                        <Name>otherInfoPublic.licenseCategory</Name>
                        <Value>msft:sl/EUL/ACTIVATED/PUBLIC</Value>
                    </TokenEntry>
                    <TokenEntry>
                        <Name>otherInfoPrivate.licenseCategory</Name>
                        <Value>msft:sl/EUL/ACTIVATED/PRIVATE</Value>
                    </TokenEntry>
                    <TokenEntry>
                        <Name>otherInfoPublic.sysprepAction</Name>
                        <Value>rearm</Value>
                    </TokenEntry>
                    <TokenEntry>
                        <Name>otherInfoPrivate.sysprepAction</Name>
                        <Value>rearm</Value>
                    </TokenEntry>
                    <TokenEntry>
                        <Name>ClientInformation</Name>
                        <Value>SystemUILanguageId=1033;UserUILanguageId=1033;GeoId=244</Value>
                    </TokenEntry>
                    <TokenEntry>
                        <Name>ClientSystemTime</Name>
                        <Value>$($systime)Z</Value>
                    </TokenEntry>
                    <TokenEntry>
                        <Name>ClientSystemTimeUtc</Name>
                        <Value>$($utctime)Z</Value>
                    </TokenEntry>
                    <TokenEntry>
                        <Name>otherInfoPublic.secureStoreId</Name>
                        <Value>$secure_store_id</Value>
                    </TokenEntry>
                    <TokenEntry>
                        <Name>otherInfoPrivate.secureStoreId</Name>
                        <Value>$secure_store_id</Value>
                    </TokenEntry>
                </Values>
            </Claims>
        </RequestSecurityToken>
    </soap:Body>
</soap:Envelope>
"@
    try {
        $response = $null
        $webRequest = [System.Net.HttpWebRequest]::Create($LicenseURL)
        $webRequest.Method      = "POST"
        $webRequest.Accept      = 'text/*'
        $webRequest.UserAgent   = 'SLSSoapClient'
        $webRequest.ContentType = 'text/xml; charset=utf-8'
        $webRequest.Headers.Add("SOAPAction", "http://microsoft.com/SL/ProductActivationService/IssueToken");

        try {
            $byteArray = [System.Text.Encoding]::UTF8.GetBytes($requestXml)
            $webRequest.ContentLength = $byteArray.Length
            $stream = $webRequest.GetRequestStream()
            $stream.Write($byteArray, 0, $byteArray.Length)
            $stream.Close()
            $httpResponse = $webRequest.GetResponse()
            $streamReader = New-Object System.IO.StreamReader($httpResponse.GetResponseStream())
            $response = $streamReader.ReadToEnd()
            $streamReader.Close()
        }
        catch [System.Net.WebException] {
            if ($_.Exception) {
                $stream = $_.Exception.Response.GetResponseStream()
                $reader = New-Object System.IO.StreamReader($stream)
                $response = $reader.ReadToEnd().ToString()
                $reader.Close()
            }
        }
        catch {
            Write-Error "Error: $($_.Exception.Message)"
            $global:error = $_
            return $null
        }

    }
    catch {
        Write-Error "Error: $($_.Exception.Message)"
        return $null
    }

    if ($response -ne $null) {
        [xml]$xmlResponse = $response
        if ($xmlResponse.Envelope.Body.Fault -eq $null) {
            return "Valid Key"
        } else {
            return Parse-ErrorMessage -MessageId ($xmlResponse.Envelope.Body.Fault.detail.HRESULT) -Flags ACTIVATION
        }
    }

    return "Error: No response received.", "", $false
}

<#
Validate Key Helper.
For Keys who matching local System Pkeyconfig file Only.!
example usage.

Clear-Host
$Pattern = "`nProductKey:        {0}`nBatchActivation:   {1}`nSLCertifyProduct:  {2}`nSLActivateProduct: {3}"
(Lookup-ProductKey `
    -ProductKey @(
        "XQ8WW-N6WGD-67K88-74XDH-RGG2T",
        "GD4TT-HKNR7-PT36K-FF64G-PDQCT",
        "7F6DW-3NH9Q-H46WY-8VTXC-MP46G",
        "DH9CD-TKNQH-W3H7G-GD6JT-9K3CT",
        "NC6G4-8B8VK-6V9JR-MFQ2R-4YCGG",
        "PFFMJ-JNFFD-KDBF9-JFCTJ-GVPGG",
        "NQJWP-FG6GT-HBP7G-K3M2R-KBXPT",
        "DBCP8-RCNTK-H6KMC-MC674-WFKPT") `
    -Consume) | % { 
        ($Pattern -f $_.ProductKey, $_.BatchActivation, $_.SLCertifyProduct, $_.SLActivateProduct)
    }
Write-Host
#>
function Check-ProductKey {
    param (
        [string]$key,
        [string]$configPath
    )

    try {
        # Validate input
        if ([string]::IsNullOrWhiteSpace($key) -or [string]::IsNullOrWhiteSpace($configPath)) {
            throw "KEY and CONFIG PATH cannot be empty."
        }

        <#
        sppcomapi.dll
        __int64 __fastcall GetWindowsPKeyInfo(_WORD *a1, __int64 a2, __int64 a3, __int64 a4)
        { 
            __int128 v46[3]; // __m128 v46[3], 48 bytes total
            int v47[44];
            int v48[320];
            memset(v46, 0, sizeof(v46)); // size of structure 2
            memset_0(v47, 0, 0xA4ui64);
            memset_0(v48, 0, 0x4F8ui64);
            v47[0] = 164;   // size of structure 3
            v48[0] = 1272;  // size of structure 4
        }
        #>

        # Allocate unmanaged memory for PID, DPID, and DPID4
        $PIDPtr   = New-IntPtr -Size 0x30  -WriteSizeAtZero
        $DPIDPtr  = New-IntPtr -Size 0xB0  -InitialValue 0xA4
        $DPID4Ptr = New-IntPtr -Size 0x500 -InitialValue 0x4F8

        try {
            try {
                # Call the function with appropriate parameters
                $result = $Global:PIDGENX::PidGenX2(
                    # Most important Roles
                    $key, $configPath,
                    # Default value for MSPID, 03612 ?? 00000 ?
                    # PIDGENX2 -> v26 = L"00000" // SPPCOMAPI, GetWindowsPKeyInfo -> L"03612"
                    "00000",
                    # Unknown1 / [Unknown2, Added in PidGenX2!]
                    0,0,
                    # Structs
                    $PIDPtr, $DPIDPtr, $DPID4Ptr
                )

                #Dump-MemoryAddress -Pointer $PIDPtr   -Length 0x30  -FileName PIDPtr
                #Dump-MemoryAddress -Pointer $DPIDPtr  -Length 0xB0  -FileName DPIDPtr
                #Dump-MemoryAddress -Pointer $DPID4Ptr -Length 0x500 -FileName DPID4Ptr

            } catch {
                
				<#
                >>> .InnerException Class <<<
                -----------------------------

                ErrorCode      : -1979645951
                Message        : Exception from HRESULT: 0x8A010001
                Data           : {}
                InnerException : 
                TargetSite     : Int32 PidGenX(System.String, System.String, System.String, Int32, IntPtr, IntPtr, IntPtr)
                StackTrace     :    at 0.PidGenX(String , String , String , Int32 , IntPtr , IntPtr , IntPtr )
								                at CallSite.Target(Closure , CallSite , Object , String , String , String , Int32 , IntPtr , IntPtr , Object )
                HelpLink       : 
                Source         : 4
                HResult        : -1979645951
                #>

                # Access the inner exception
                $innerException = $_.Exception.InnerException

                # Get the HResult directly
                $HResult   = $innerException.HResult
                $ErrorCode = $innerException.ErrorCode

                # Map HResult to error text
                $ErrorText = switch ($HResult) {
                    -2147024809 { "The parameter is incorrect." }                   # PGX_MALFORMEDKEY
                    -1979645695 { "Specified key is not valid." }                   # PGX_INVALIDKEY
                    -1979645951 { "Specified key is valid but can't be verified." } # (Add appropriate message if needed)
                    -2147024894 { "Can't find specified pkeyconfig file." }         # PGX_PKEYMISSING
                    -2147024893 { "Specified pkeyconfig path does not exist." }     # (Already exists)
                    -2147483633 { "Specified key is BlackListed." }                 # PGX_BLACKLISTEDKEY
                        default { "Unhandled HResult" }                             # any other error
                }

                # Convert HResult to hexadecimal
                $HResultHex = "0x{0:X8}" -f $HResult

                throw "HRESULT: $ErrorText ($HResultHex)"
            }

            # Define offsets based on the DigitalProductId4 layout
            $offsets = @{
                AdvancedPid    = 8     # 128/2
                ActivationId   = 136   # 128/2
                EditionType    = 280   # 520/2
                EditionId      = 888   # 128/2
                KeyType        = 1016  # 128/2
                EULA           = 1144  # 128/2
            }

            # Function to read WCHAR arrays
            function Read-WCHARArray {
                param (
                    [IntPtr]$ptr,
                    [int]$size
                )
                $bytes = New-Object byte[] ($size * 2)  # Each WCHAR is 2 bytes
                [Marshal]::Copy($ptr, $bytes, 0, $bytes.Length)
                return [Encoding]::Unicode.GetString($bytes).TrimEnd([char]0)
            }

            # Initilize results value
            $results = @()

            # Extract KeyGroup value from DigitalProductId3
            $keyGroupOffset = 32
            $keyGroup = [UInt32][Marshal]::ReadInt32([IntPtr]::Add($DPIDPtr, $keyGroupOffset))

            if ($keyGroup) {
                
                #V2
				try {
                    $ProductDescription = $KeysText[[INT]$keyGroup]
                }
                catch {}

                
                #V1
                if (-not $ProductDescription) {
                  $list = GenerateConfigList -pkeyconfig $configPath -SkipKey $true -SkipKeyRange $true
                  $data = $list | ? RefGroupId -eq $keyGroup
                  if ($data -and (-not [STRING]::IsNullOrWhiteSpace($data.ProductDescription))) {
                    $ProductDescription = $data.ProductDescription
            }}}

            $pidString = [marshal]::PtrToStringUni($pidPtr, 0x30/2)
            foreach ($key in $offsets.Keys) {
                $offset = $offsets[$key]
                $size = if ($key -eq "EditionType") { (520/2) } else { (128/2) }
                $value = if ($key -eq "IsUpgrade") { [Marshal]::ReadByte([IntPtr]::Add($DPID4Ptr, $offset)) } else { Read-WCHARArray ([IntPtr]::Add($DPID4Ptr, $offset)) $size }
                
				switch ($key) 
                {
                  'EULA'         {$EULA=$value}
				  'KeyType'      {$KeyType=$value}
				  'EditionId'    {$EditionId=$value}
				  'AdvancedPid'  {$AdvancedPid=$value}
                  'EditionType'  {$EditionType=$value}
				  'ActivationId' {$ActivationId=$value}
                }
            }
            
          # $results += @{ Property = "KeyGroup"; Value = $keyGroup }
            $results += @{ Property = "EditionType"; Value = $EditionType }
            $results += @{ Property = "EditionId"; Value = $EditionId }
            $results += @{ Property = "KeyType"; Value = $KeyType }
            $results += @{ Property = "ProductID"; Value = $pidString }
            $results += @{ Property = "ActivationId"; Value = $ActivationId }
            $results += @{ Property = "AdvancedPid"; Value = $AdvancedPid }
            $results += @{ Property = "Description"; Value = $ProductDescription }

            return $results
        } finally {
            [Marshal]::FreeHGlobal($PIDPtr)
            [Marshal]::FreeHGlobal($DPIDPtr)
            [Marshal]::FreeHGlobal($DPID4Ptr)
        }
    } catch {
        return @(
            @{ Property = "Error"; Value = "$($_.Exception.Message)" }
        )
    }
}
function Lookup-ProductKey {
    param (
        [Parameter(Mandatory = $true)]
        [ValidateNotNullOrEmpty()]
        [string[]]$ProductKey,

        [Parameter(Mandatory = $false)]
        [switch]$Consume
    )

    $results = @()
    foreach ($key in $ProductKey) {
        # Validate product key format and ensure exactly one 'N'
        if (!($key -match '^\w{5}(-\w{5}){4}$' -and
              ($key.IndexOf("n",[StringComparison]::InvariantCultureIgnoreCase) -eq
               $key.LastIndexOf("n",[StringComparison]::InvariantCultureIgnoreCase) -and
               $key.IndexOf("n",[StringComparison]::InvariantCultureIgnoreCase) -ge 0))) {
            Write-Warning "Product key $key is either not in the correct 5X5 format or does not contain exactly one 'N.'"
            continue
        }

        $pkeyInfo = $null
        $pkey = $key.Substring(0,29)

        $paths = @(
            "C:\Windows\System32\spp\tokens\pkeyconfig\pkeyconfig.xrm-ms",
            "C:\Windows\System32\spp\tokens\pkeyconfig\pkeyconfig-csvlk.xrm-ms",
            "C:\Windows\System32\spp\tokens\pkeyconfig\pkeyconfig-downlevel.xrm-ms",
            "C:\Program Files\Microsoft Office\root\Licenses16\pkeyconfig-office.xrm-ms"
        )
        foreach ($path in $paths) {
            try {
                $result = Check-ProductKey -key $pkey -configPath $path
                if ($result.GetValue(1).Property -ne 'Error') {
                    $pkeyInfo = $result
                    break
                }
            } catch {}
        }
        if (!$pkeyInfo) {
            continue
        }
        if ($pkeyInfo) {
            $resultObject = if ($Consume) {
                try {
                    $SLActivateProduct = ((Consume-ProductKey -ProductKey $pkey) -split "`r?`n" | Select-Object -First 1).Trim()
                } 
                catch {
                    $SLActivateProduct = "{License file not found. Failed to acquire URI and XML.}"
                }
        
                [PSCustomObject]@{
                    ProductKey        = $pkey
                    BatchActivation   = Call-WebService -requestType 2 -extendedProductId $pkeyInfo.GetValue(5).Value
                    SLCertifyProduct  = ((Validate-ProductKey -ProductKey $pkey) -split "`r?`n" | Select-Object -First 1).Trim()
                    SLActivateProduct = $SLActivateProduct
                }
            } else {
                [PSCustomObject]@{
                    ProductKey        = $pkey
                    BatchActivation   = Call-WebService -requestType 2 -extendedProductId $pkeyInfo.GetValue(5).Value
                    SLCertifyProduct  = ((Validate-ProductKey -ProductKey $pkey) -split "`r?`n" | Select-Object -First 1).Trim()
                }
            }
            $results += $resultObject
            Start-sleep -Milliseconds 500
        }
    }
    return $results
}

<#
Get-WindowsProductKey Helper
Help manage DigitalProductId, DigitalProductId4, OA3xOriginalProductKey
etc etc etc.
#>
function Get-WindowsProductKey {
    
    # Define the registry path
    $registryPath = "HKLM:\SOFTWARE\Microsoft\Windows NT\CurrentVersion"

    # Function to retrieve the product key
    function Get-ProductKey($propertyName, $offset) {
        $digitalProductId = (Get-ItemProperty -Path $registryPath).$propertyName
        $byteArray = New-Object Byte[] ($digitalProductId.Length)
        [Array]::Copy($digitalProductId, $byteArray, $digitalProductId.Length)
        $bCDKey = $byteArray[$offset..($offset + 15)]
        return Get-DigitalProductKey -bCDKeyArray $bCDKey
    }

    # Get the product keys
    $DigitalProductIdKey = Get-ProductKey -propertyName "DigitalProductId" -offset 52
    $DigitalProductIdKey4 = Get-ProductKey -propertyName "DigitalProductId4" -offset 808

    # Retrieve additional product keys
    $OA3xOriginalProductKey = Get-OA3xOriginalProductKey
    #$OA3xOriginalProductKey = (Get-WmiObject -Class SoftwareLicensingService).OA3xOriginalProductKey
    $BackupProductKeyDefault = (Get-ItemProperty -Path "HKLM:\SOFTWARE\Microsoft\Windows NT\CurrentVersion\SoftwareProtectionPlatform" -ea 0).BackupProductKeyDefault

    # Define default text if keys are not found
    if (-not $OA3xOriginalProductKey) {
        $OA3xOriginalProductKey = "Not Found"
    }
    if (-not $BackupProductKeyDefault) {
        $BackupProductKeyDefault = "Not Found"
    }

    # Create a custom object to hold the keys
    $productKeys = [PSCustomObject]@{
        DigitalProductId         = $DigitalProductIdKey
        DigitalProductId4     = $DigitalProductIdKey4
        BackupProductKeyDefault   = $BackupProductKeyDefault
		OA3xOriginalProductKey   = $OA3xOriginalProductKey
    }

    return $productKeys
}

# Start #
# PidGenX API.
# Begin #

<#
"PIDGenX failed with error code: 80070057"
https://stackoverflow.com/questions/79505851/pidgenx-failed-with-error-code-80070057

https://github.com/IonBazan/pidgenx
https://github.com/IonBazan/pidgenx/blob/master/pidxcheckerclass.h
https://github.com/IonBazan/pidgenx/blob/master/pidxcheckerclass.cpp

typedef struct {
    CHAR m_productId2[24];
} DigitalProductId2;

typedef struct {
    DWORD m_length;
    WORD  m_versionMajor;
    WORD  m_versionMinor;
    BYTE  m_productId2[24];
    DWORD m_keyIdx;
    CHAR m_sku[16];
    BYTE  m_abCdKey[16];
    DWORD m_cloneStatus;
    DWORD m_time;
    DWORD m_random;
    DWORD m_lt;
    DWORD m_licenseData[2];
    CHAR m_oemId[8];
    DWORD m_bundleId;
    CHAR m_hardwareIdStatic[8];
    DWORD m_hardwareIdTypeStatic;
    DWORD m_biosChecksumStatic;
    DWORD m_volSerStatic;
    DWORD m_totalRamStatic;
    DWORD m_videoBiosChecksumStatic;
    CHAR m_hardwareIdDynamic[8];
    DWORD m_hardwareIdTypeDynamic;
    DWORD m_biosChecksumDynamic;
    DWORD m_volSerDynamic;
    DWORD m_totalRamDynamic;
    DWORD m_videoBiosChecksumDynamic;
    DWORD m_crc32;
} DigitalProductId3;

typedef struct {
    DWORD m_length;
    WORD  m_versionMajor;
    WORD  m_versionMinor;
    WCHAR m_productId2Ex[64];
    WCHAR m_sku[64];
    WCHAR m_oemId[8];
    WCHAR m_editionId[260];
    BYTE  m_isUpgrade;
    BYTE  m_reserved[7];
    BYTE  m_abCdKey[16];
    BYTE  m_abCdKeySHA256Hash[32];
    BYTE  m_abSHA256Hash[32];
    WCHAR m_partNumber[64];
    WCHAR m_productKeyType[64];
    WCHAR m_eulaType[64];
} DigitalProductId4;
#>
function KeyParser {
    param (
        [string]$key,
        [string]$configPath
    )

    try {
        # Validate input
        if ([string]::IsNullOrWhiteSpace($key) -or [string]::IsNullOrWhiteSpace($configPath)) {
            throw "KEY and CONFIG PATH cannot be empty."
        }

        <#
        sppcomapi.dll
        __int64 __fastcall GetWindowsPKeyInfo(_WORD *a1, __int64 a2, __int64 a3, __int64 a4)
        { 
            __int128 v46[3]; // __m128 v46[3], 48 bytes total
            int v47[44];
            int v48[320];
            memset(v46, 0, sizeof(v46)); // size of structure 2
            memset_0(v47, 0, 0xA4ui64);
            memset_0(v48, 0, 0x4F8ui64);
            v47[0] = 164;   // size of structure 3
            v48[0] = 1272;  // size of structure 4
        }
        #>

        # Allocate unmanaged memory for PID, DPID, and DPID4
        $PIDPtr   = New-IntPtr -Size 0x30  -WriteSizeAtZero
        $DPIDPtr  = New-IntPtr -Size 0xB0  -InitialValue 0xA4
        $DPID4Ptr = New-IntPtr -Size 0x500 -InitialValue 0x4F8

        try {
            try {
                # Call the function with appropriate parameters
                $result = $Global:PIDGENX::PidGenX2(
                    # Most important Roles
                    $key, $configPath,
                    # Default value for MSPID, 03612 ?? 00000 ?
                    # PIDGENX2 -> v26 = L"00000" // SPPCOMAPI, GetWindowsPKeyInfo -> L"03612"
                    "00000",
                    # Unknown1 / [Unknown2, Added in PidGenX2!]
                    0,0,
                    # Structs
                    $PIDPtr, $DPIDPtr, $DPID4Ptr
                )

                #Dump-MemoryAddress -Pointer $PIDPtr   -Length 0x30  -FileName PIDPtr
                #Dump-MemoryAddress -Pointer $DPIDPtr  -Length 0xB0  -FileName DPIDPtr
                #Dump-MemoryAddress -Pointer $DPID4Ptr -Length 0x500 -FileName DPID4Ptr

            } catch {
                
				<#
                >>> .InnerException Class <<<
                -----------------------------

                ErrorCode      : -1979645951
                Message        : Exception from HRESULT: 0x8A010001
                Data           : {}
                InnerException : 
                TargetSite     : Int32 PidGenX(System.String, System.String, System.String, Int32, IntPtr, IntPtr, IntPtr)
                StackTrace     :    at 0.PidGenX(String , String , String , Int32 , IntPtr , IntPtr , IntPtr )
								                at CallSite.Target(Closure , CallSite , Object , String , String , String , Int32 , IntPtr , IntPtr , Object )
                HelpLink       : 
                Source         : 4
                HResult        : -1979645951
                #>

                # Access the inner exception
                $innerException = $_.Exception.InnerException

                # Get the HResult directly
                $HResult   = $innerException.HResult
                $ErrorCode = $innerException.ErrorCode

                # Map HResult to error text
                $ErrorText = switch ($HResult) {
                    -2147024809 { "The parameter is incorrect." }                   # PGX_MALFORMEDKEY
                    -1979645695 { "Specified key is not valid." }                   # PGX_INVALIDKEY
                    -1979645951 { "Specified key is valid but can't be verified." } # (Add appropriate message if needed)
                    -2147024894 { "Can't find specified pkeyconfig file." }         # PGX_PKEYMISSING
                    -2147024893 { "Specified pkeyconfig path does not exist." }     # (Already exists)
                    -2147483633 { "Specified key is BlackListed." }                 # PGX_BLACKLISTEDKEY
                        default { "Unhandled HResult" }                             # any other error
                }

                # Convert HResult to hexadecimal
                $HResultHex = "0x{0:X8}" -f $HResult

                throw "HRESULT: $ErrorText ($HResultHex)"
            }

            # Define offsets based on the DigitalProductId4 layout
            $offsets = @{
                AdvancedPid    = 8     # 128/2
                ActivationId   = 136   # 128/2
                EditionType    = 280   # 520/2
                EditionId      = 888   # 128/2
                KeyType        = 1016  # 128/2
                EULA           = 1144  # 128/2
            }

            # Function to read WCHAR arrays
            function Read-WCHARArray {
                param (
                    [IntPtr]$ptr,
                    [int]$size
                )
                $bytes = New-Object byte[] ($size * 2)  # Each WCHAR is 2 bytes
                [Marshal]::Copy($ptr, $bytes, 0, $bytes.Length)
                return [Encoding]::Unicode.GetString($bytes).TrimEnd([char]0)
            }

            # Initilize results value
            $results = @()

            # Extract KeyGroup value from DigitalProductId3
            $keyGroupOffset = 32
            $keyGroup = [UInt32][Marshal]::ReadInt32([IntPtr]::Add($DPIDPtr, $keyGroupOffset))

            if ($keyGroup) {
                
                #V2
				$ProductDescription = $KeysText[[INT]$keyGroup]
                
                #V1
                if (-not $ProductDescription) {
                  $list = GenerateConfigList -pkeyconfig $configPath -SkipKey $true -SkipKeyRange $true
                  $data = $list | ? RefGroupId -eq $keyGroup
                  if ($data -and (-not [STRING]::IsNullOrWhiteSpace($data.ProductDescription))) {
                    $ProductDescription = $data.ProductDescription
            }}}

            $pidString = [marshal]::PtrToStringUni($pidPtr, 0x30/2)
            foreach ($key in $offsets.Keys) {
                $offset = $offsets[$key]
                $size = if ($key -eq "EditionType") { (520/2) } else { (128/2) }
                $value = if ($key -eq "IsUpgrade") { [Marshal]::ReadByte([IntPtr]::Add($DPID4Ptr, $offset)) } else { Read-WCHARArray ([IntPtr]::Add($DPID4Ptr, $offset)) $size }
                
				switch ($key) 
                {
                  'EULA'         {$EULA=$value}
				  'KeyType'      {$KeyType=$value}
				  'EditionId'    {$EditionId=$value}
				  'AdvancedPid'  {$AdvancedPid=$value}
                  'EditionType'  {$EditionType=$value}
				  'ActivationId' {$ActivationId=$value}
                }
            }
            
          # $results += @{ Property = "KeyGroup"; Value = $keyGroup }
            $results += @{ Property = "EditionType"; Value = $EditionType }
            $results += @{ Property = "EditionId"; Value = $EditionId }
            $results += @{ Property = "KeyType"; Value = $KeyType }
            $results += @{ Property = "ProductID"; Value = $pidString }
            $results += @{ Property = "ActivationId"; Value = $ActivationId }
            $results += @{ Property = "AdvancedPid"; Value = $AdvancedPid }
            $results += @{ Property = "Description"; Value = $ProductDescription }

            return $results
        } finally {
            [Marshal]::FreeHGlobal($PIDPtr)
            [Marshal]::FreeHGlobal($DPIDPtr)
            [Marshal]::FreeHGlobal($DPID4Ptr)
        }
    } catch {
        return @(
            @{ Property = "Error"; Value = "$($_.Exception.Message)" }
        )
    }
}

# Start #
# KeyInfo Based Code.
# Begin #

enum SyncSource {
    U8 = 8
    U16 = 16
    U32 = 32
    U64 = 64
}
class UINT32u {
    [UInt32]   $u32
    [UInt16[]] $u16 = @(0, 0)
    [Byte[]]   $u8  = @(0, 0, 0, 0)

    [void] Sync([SyncSource]$source) {
        switch ($source.value__) {
            8 {
            	$this.u16 = 0..1 | % { [BitConverter]::ToUInt16($this.u8, $_ * 2) }
                $this.u32 = [BitConverter]::ToUInt32($this.u8, 0)
                #$this.u16 = [BitConverterHelper]::ToArrayOfType([UINT16],$this.u8)
                #$this.u32 = [BitConverterHelper]::ToArrayOfType([UINT32],$this.u8)[0]
            }
            16 {
                $this.u8 = $this.u16 | % { [BitConverter]::GetBytes($_) } | % {$_} 
                $this.u32 = [BitConverter]::ToUInt32($this.u8, 0)
                #$this.u8 = [BitConverterHelper]::ToByteArray($this.u16)
                #$this.u32 = [BitConverterHelper]::ToArrayOfType([UINT32],$this.u8)[0]
            }
            32 {
                $this.u8 = [BitConverter]::GetBytes($this.u32)
                $this.u16 = 0..1 | % { [BitConverter]::ToUInt16($this.u8, $_ * 2) }
                #$this.u8 = [BitConverter]::GetBytes($this.u32)
                #$this.u16 = [BitConverterHelper]::ToArrayOfType([UINT16],$this.u8)
            }
        }
    }
}
class UINT64u {
    [UInt64]   $u64
    [UInt32[]] $u32 = @(0, 0)
    [UInt16[]] $u16 = @(0, 0, 0, 0)
    [Byte[]]   $u8  = @(0, 0, 0, 0, 0, 0, 0, 0)

    [void] Sync([SyncSource]$source) {
        switch ($source.value__) {
            8 {
            	$this.u16 = 0..3 | % { [BitConverter]::ToUInt16($this.u8, $_ * 2) }
                $this.u32 = 0..1 | % { [BitConverter]::ToUInt32($this.u8, $_ * 4) }
                $this.u64 = [BitConverter]::ToUInt64($this.u8, 0)
                #$this.u16 = [BitConverterHelper]::ToArrayOfType([UINT16],$this.u8)
                #$this.u32 = [BitConverterHelper]::ToArrayOfType([UINT32],$this.u8)
                #$this.u64 = [BitConverterHelper]::ToArrayOfType([UINT64],$this.u8)[0]
            }
            16 {
            	$this.u8 = $this.u16 | % { [BitConverter]::GetBytes($_) } | % {$_}
                $this.u32 = 0..1 | % { [BitConverter]::ToUInt32($this.u8, $_ * 4) }
                $this.u64 = [BitConverter]::ToUInt64($this.u8, 0)
                #$this.u8 = [BitConverterHelper]::ToByteArray($this.u16)
                #$this.u32 = [BitConverterHelper]::ToArrayOfType([UINT32],$this.u8)
                #$this.u64 = [BitConverterHelper]::ToArrayOfType([UINT64],$this.u8)[0]
            }
            32 {
            	$this.u8 = $this.u32 | % { [BitConverter]::GetBytes($_) } | % {$_}
                $this.u16 = 0..3 | % { [BitConverter]::ToUInt16($this.u8, $_ * 2) }
                $this.u64 = [BitConverter]::ToUInt64($this.u8, 0)
                #$this.u8 = [BitConverterHelper]::ToByteArray($this.u32)
                #$this.u16 = [BitConverterHelper]::ToArrayOfType([UINT16],$this.u8)
                #$this.u64 = [BitConverterHelper]::ToArrayOfType([UINT64],$this.u8)[0]
            }
            64 {
                $this.u8 = [BitConverter]::GetBytes($this.u64)
                $this.u16 = 0..3 | % { [BitConverter]::ToUInt16($this.u8, $_ * 2) }
                $this.u32 = 0..1 | % { [BitConverter]::ToUInt32($this.u8, $_ * 4) }
                #$this.u8 = [BitConverterHelper]::ToByteArray($this.u64)
                #$this.u16 = [BitConverterHelper]::ToArrayOfType([UINT16],$this.u8)
                #$this.u32 = [BitConverterHelper]::ToArrayOfType([UINT32],$this.u8)
            }
        }
    }
}
class UINT128u {
    [UInt64[]] $u64 = @(0, 0)
    [UInt32[]] $u32 = @(0, 0, 0, 0)
    [UInt16[]] $u16 = @(0, 0, 0, 0, 0, 0, 0, 0)
    [Byte[]]   $u8  = @(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0)

    [void] Sync([SyncSource]$source) {
        switch ($source.value__) {
            8 {
                $this.u16 = 0..7 | % { [BitConverter]::ToUInt16($this.u8, $_ * 2) }
                $this.u32 = 0..3 | % { [BitConverter]::ToUInt32($this.u8, $_ * 4) }
                $this.u64 = 0..1 | % { [BitConverter]::ToUInt64($this.u8, $_ * 8) }
                #$this.u16 = [BitConverterHelper]::ToArrayOfType([UINT16],$this.u8)
                #$this.u32 = [BitConverterHelper]::ToArrayOfType([UINT32],$this.u8)
                #$this.u64 = [BitConverterHelper]::ToArrayOfType([UINT64],$this.u8)
            }
            16 {
                $this.u8 = $this.u16 | % { [BitConverter]::GetBytes($_) } | % {$_}
                $this.u32 = 0..3 | % { [BitConverter]::ToUInt32($this.u8, $_ * 4) }
                $this.u64 = 0..1 | % { [BitConverter]::ToUInt64($this.u8, $_ * 8) }
                #$this.u8 = [BitConverterHelper]::ToByteArray($this.u16)
                #$this.u32 = [BitConverterHelper]::ToArrayOfType([UINT32],$this.u8)
                #$this.u64 = [BitConverterHelper]::ToArrayOfType([UINT64],$this.u8)
            }
            32 {
                $this.u8 = $this.u32 | % { [BitConverter]::GetBytes($_) } | % {$_}
                $this.u16 = 0..7 | % { [BitConverter]::ToUInt16($this.u8, $_ * 2) }
                $this.u64 = 0..1 | % { [BitConverter]::ToUInt64($this.u8, $_ * 8) }
                #$this.u8 = [BitConverterHelper]::ToByteArray($this.u32)
                #$this.u16 = [BitConverterHelper]::ToArrayOfType([UINT16],$this.u8)
                #$this.u64 = [BitConverterHelper]::ToArrayOfType([UINT64],$this.u8)
            }
            64 {
                $this.u8 = [BitConverter]::GetBytes($this.u64[0]) + [BitConverter]::GetBytes($this.u64[1])
                $this.u16 = 0..7 | % { [BitConverter]::ToUInt16($this.u8, $_ * 2) }
                $this.u32 = 0..3 | % { [BitConverter]::ToUInt32($this.u8, $_ * 4) }
                #$this.u8 = [BitConverterHelper]::ToByteArray($this.u64)
                #$this.u16 = [BitConverterHelper]::ToArrayOfType([UINT16],$this.u8)
                #$this.u32 = [BitConverterHelper]::ToArrayOfType([UINT32],$this.u8)
            }
        }
    }
}
class BitConverterHelper {

    # Convert array of UInt16, Int16, UInt32, Int32, UInt64, or Int64 to byte array
    static [Byte[]] ToByteArray([Object[]] $values) {
        $byteList = New-Object List[Byte]

        foreach ($value in $values) {
            if ($value -is [UInt16]) {
                $byteList.AddRange([BitConverter]::GetBytes([UInt16]$value))
            } elseif ($value -is [Int16]) {
                $byteList.AddRange([BitConverter]::GetBytes([Int16]$value))
            } elseif ($value -is [UInt32]) {
                $byteList.AddRange([BitConverter]::GetBytes([UInt32]$value))
            } elseif ($value -is [Int32]) {
                $byteList.AddRange([BitConverter]::GetBytes([Int32]$value))
            } elseif ($value -is [UInt64]) {
                $byteList.AddRange([BitConverter]::GetBytes([UInt64]$value))
            } elseif ($value -is [Int64]) {
                $byteList.AddRange([BitConverter]::GetBytes([Int64]$value))
            } else {
                throw "Unsupported type: $($value.GetType().FullName)"
            }
        }

        return $byteList.ToArray()
    }

     # Convert byte array to an array of specified types (UInt16, Int16, UInt32, Int32, UInt64, Int64)
    static [Array] ToArrayOfType([Type] $type, [Byte[]] $bytes) {
        # Determine the size of each type in bytes
        $typeName = $type.FullName
        $size = switch ($typeName) {
            "System.UInt16" { 2 }
            "System.Int16"  { 2 }
            "System.UInt32" { 4 }
            "System.Int32"  { 4 }
            "System.UInt64" { 8 }
            "System.Int64"  { 8 }
            default { throw "Unsupported type: $type" }
        }
        
        # Validate byte array length
        if ($bytes.Length % $size -ne 0) {
            throw "Byte array length must be a multiple of $size for conversion to $type."
        }

        # Prepare result list
        $count = [math]::Floor($bytes.Length / $size)
        $result = New-Object 'System.Collections.Generic.List[Object]'

        # Convert bytes to the specified type
        for ($i = 0; $i -lt $count; $i++) {
            $index = $i * $size
            if ($typeName -eq "System.UInt16") {
                $result.Add([BitConverter]::ToUInt16($bytes, $index))
            } elseif ($typeName -eq "System.Int16") {
                $result.Add([BitConverter]::ToInt16($bytes, $index))
            } elseif ($typeName -eq "System.UInt32") {
                $result.Add([BitConverter]::ToUInt32($bytes, $index))
            } elseif ($typeName -eq "System.Int32") {
                $result.Add([BitConverter]::ToInt32($bytes, $index))
            } elseif ($typeName -eq "System.UInt64") {
                $result.Add([BitConverter]::ToUInt64($bytes, $index))
            } elseif ($typeName -eq "System.Int64") {
                $result.Add([BitConverter]::ToInt64($bytes, $index))
            }
        }

        return $result.ToArray()
    }
}

function Hash([UINT128u]$key) {
    $hash = -1
    for ($i = 0; $i -lt 16; $i++) {
        $index = (($hash -shr 24) -bxor $key.u8[$i]) -band 0xff
        $hash  = (($hash -shl 8) -bxor $crc32_table[$index]) -band 0xFFFFFFFF
    }
    return (-bnot $hash) -band 0x3ff
}
function SetHash {
    param (
        [UINT128u]$key3,
        [ref]$key2,
        [ref]$check
    )

    # Copy $key3 to $key2
    $key2.Value = [UINT128u]::new()
    [Array]::Copy($key3.u8, $key2.Value.u8, 16)

    # Compute the hash and set it in $check
    $check.Value.u8 = [BitConverter]::GetBytes([UINT32](Hash($key2.Value)))

    # Update $key2 with values from $check
    $key2.Value.u8[12] = [Byte]($key2.Value.u8[12] -bor ($check.Value.u8[0] -shl 7))
    $key2.Value.u8[13] = [Byte](($check.Value.u8[0] -shr 1) -bor ($check.Value.u8[1] -shl 7))
    $key2.Value.u8[14] = [Byte]($key2.Value.u8[14] -bor (($check.Value.u8[1] -shr 1) -band 0x1))
}
function SetInfo {
    param (
        [UINT32u]$groupid,
        [UINT32u]$keyid,
        [UINT64u]$secret,
        [ref]$key3
    )

    # Set bytes using groupid
    0..1 | % { $key3.Value.u8[$_] = [BYTE]$groupid.u8[$_] }
    $key3.Value.u8[2] = [BYTE]($key3.Value.u8[2] -bor ($groupid.u8[2] -band 0x0F))

    # Set bytes using keyid
    $key3.Value.u8[2] = [BYTE]($key3.Value.u8[2] -bor ($keyid.u8[0] -shl 4))
    3..5 | % { $key3.Value.u8[$_] = [BYTE](($keyid.u8[$_ - 3 + 1] -shl 4) -bor ($keyid.u8[$_ - 3] -shr 4) -band 0xFF) }
    $key3.Value.u8[6] = [BYTE]($key3.Value.u8[6] -bor (($keyid.u8[3] -shr 4) -band 0x03))

    # Set bytes using secret
    $key3.Value.u8[6] = [BYTE]($key3.Value.u8[6] -bor ($secret.u8[0] -shl 2))
    7..11 | % { $key3.Value.u8[$_] = [BYTE](($secret.u8[$_ - 7 + 1] -shl 2) -bor ($secret.u8[$_ - 7] -shr 6)) }
    $key3.Value.u8[12] = [BYTE](($key3.Value.u8[12] -bor (($secret.u8[6] -shl 2) -bor ($secret.u8[5] -shr 6))) -band 0x7F)
}
function Encode {
    param (
        [UINT128u]$key2,
        [ref]$key1
    )
    $data = 0..3 | % { [BitConverter]::ToUInt32($key2.u8, $_ * 4) }
    for ($i = 25; $i -gt 0; $i--) {
        for ($j = 3; $j -ge 0; $j--) {
            $tmp = if ($j -eq 3) { [UInt64]$data[$j] } else { ([UInt64]$last -shl 32) -bor [UInt64]$data[$j] }
            $data[$j], $last = [math]::Floor($tmp / 24), [UInt32]($tmp % 24)
        }
        $key1.Value[$i - 1] = [byte]$last }
}
function UnconvertChars([byte[]]$key1, [ref]$key0) {
    $n = $key1[0]
    $n += [math]::Floor($n / 5)

    $j = 1
    for ($i = 0; $i -lt 29; $i++) {
        if ($i -eq $n) {
            $key0.Value[$i] = 'N'
        }
        elseif ($i -eq 5 -or $i -eq 11 -or $i -eq 17 -or $i -eq 23) {
            $key0.Value[$i] = '-'
        }
        else {
            switch ($key1[$j++]) {
                0x00 { $key0.Value[$i] = 'B' }
                0x01 { $key0.Value[$i] = 'C' }
                0x02 { $key0.Value[$i] = 'D' }
                0x03 { $key0.Value[$i] = 'F' }
                0x04 { $key0.Value[$i] = 'G' }
                0x05 { $key0.Value[$i] = 'H' }
                0x06 { $key0.Value[$i] = 'J' }
                0x07 { $key0.Value[$i] = 'K' }
                0x08 { $key0.Value[$i] = 'M' }
                0x09 { $key0.Value[$i] = 'P' }
                0x0A { $key0.Value[$i] = 'Q' }
                0x0B { $key0.Value[$i] = 'R' }
                0x0C { $key0.Value[$i] = 'T' }
                0x0D { $key0.Value[$i] = 'V' }
                0x0E { $key0.Value[$i] = 'W' }
                0x0F { $key0.Value[$i] = 'X' }
                0x10 { $key0.Value[$i] = 'Y' }
                0x11 { $key0.Value[$i] = '2' }
                0x12 { $key0.Value[$i] = '3' }
                0x13 { $key0.Value[$i] = '4' }
                0x14 { $key0.Value[$i] = '6' }
                0x15 { $key0.Value[$i] = '7' }
                0x16 { $key0.Value[$i] = '8' }
                0x17 { $key0.Value[$i] = '9' }
                default { $key0.Value[$i] = '?' }
            }
        }
    }
}
function KeyEncode {
    param (
        # 'sgroupid' must be either a hexadecimal (e.g., 0xABC123) or an integer (e.g., 123456)
        [Parameter(Mandatory = $true)]
        [ValidatePattern('^(0x[0-9A-Fa-f]+|\d+)$')]
        [string]$sgroupid,

        [UInt32]$skeyid,
        [UInt64]$sunk
    )
   
    $sgroupid_f = if ($sgroupid -match '^0x') { [Convert]::ToUInt32($sgroupid.Substring(2), 16) } else { [UInt32]$sgroupid }

    if ($sgroupid_f -gt 0xffffff) {
        Write-Host "GroupId must be in the range 0-ffffff"
        return -1
    }
    if ($skeyid -gt 0x3fffffff) {
        Write-Host "KeyId must be in the range 0-3fffffff"
        return -1
    }
    if ($sunk -gt 0x1fffffffffffff) {
        Write-Host "Secret must be in the range 0-1fffffffffffff"
        return -1
    }

    $keyid     = [UINT32u]::new()
    $secret     = [UINT64u]::new()
    $groupid     = [UINT32u]::new()

    $secret.u8  = [BitConverter]::GetBytes($sunk)
    $keyid.u8  = [BitConverter]::GetBytes($skeyid)
    $groupid.u8  = [BitConverter]::GetBytes($sgroupid_f)

    $key3 = [UINT128u]::new()
    SetInfo -groupid $groupid -keyid $keyid -secret $secret -key3 ([ref]$key3)

    $key2 = [UINT128u]::new()
    $check = [UINT32u]::new()
    SetHash -key3 $key3 -key2 ([ref]$key2) -check ([ref]$check)

    $key1 = New-Object Byte[] 25
    Encode -key2 $key2 -key1 ([ref]$key1)

    $key0 = New-Object Char[] 29
    UnconvertChars -key1 $key1 -key0 ([ref]$key0)
   
    return (-join $key0)
}

function Get-Info {
    param (
        [Parameter(Mandatory=$true)]
        [UINT128u]$key3,

        [Parameter(Mandatory=$true)]
        [ref]$groupid,

        [Parameter(Mandatory=$true)]
        [ref]$keyid,

        [Parameter(Mandatory=$true)]
        [ref]$secret
    )

    $groupid.Value.u32 = 0
    $keyid.Value.u32 = 0
    $secret.Value.u64 = 0

    $groupid.Value.u8[0] = $key3.u8[0]
    $groupid.Value.u8[1] = $key3.u8[1]
    $groupid.Value.u8[2] = $key3.u8[2] -band 0x0f

    $keyid.Value.u8[0] = ($key3.u8[2] -shr 4) -bor ($key3.u8[3] -shl 4)
    $keyid.Value.u8[1] = ($key3.u8[3] -shr 4) -bor ($key3.u8[4] -shl 4)
    $keyid.Value.u8[2] = ($key3.u8[4] -shr 4) -bor ($key3.u8[5] -shl 4)
    $keyid.Value.u8[3] = (($key3.u8[5] -shr 4) -bor ($key3.u8[6] -shl 4)) -band 0x3f

    $secret.Value.u8[0] = ($key3.u8[6] -shr 2) -bor ($key3.u8[7] -shl 6)
    $secret.Value.u8[1] = ($key3.u8[7] -shr 2) -bor ($key3.u8[8] -shl 6)
    $secret.Value.u8[2] = ($key3.u8[8] -shr 2) -bor ($key3.u8[9] -shl 6)
    $secret.Value.u8[3] = ($key3.u8[9] -shr 2) -bor ($key3.u8[10] -shl 6)
    $secret.Value.u8[4] = ($key3.u8[10] -shr 2) -bor ($key3.u8[11] -shl 6)
    $secret.Value.u8[5] = ($key3.u8[11] -shr 2) -bor ($key3.u8[12] -shl 6)
    $secret.Value.u8[6] = ($key3.u8[12] -shr 2) -band 0x1f

    $groupid.Value.Sync([SyncSource]::U8)
    $keyid.Value.Sync([SyncSource]::U8)
    $secret.Value.Sync([SyncSource]::U8)

    return $true
}
function Check-Hash {
    param (
        [Parameter(Mandatory=$true)]
        [UINT128u]$key2,

        [Parameter(Mandatory=$true)]
        [ref]$key3,

        [Parameter(Mandatory=$true)]
        [ref]$check
    )

    # Reset the check value
    $check.Value.u32 = 0

    # Copy key2 to key3
    [Array]::Copy($key2.u8, $key3.Value.u8, $key2.u8.Length)

    # Modify key3 bytes
    $key3.Value.u8[12] = $key3.Value.u8[12] -band 0x7f
    $key3.Value.u8[13] = 0
    $key3.Value.u8[14] = $key3.Value.u8[14] -band 0xfe

    # Compute check bytes
    $check.Value.u8[0] = ($key2.u8[13] -shl 1) -bor ($key2.u8[12] -shr 7)
    $check.Value.u8[1] = (($key2.u8[14] -shl 1) -bor ($key2.u8[13] -shr 7)) -band 3

    # Compute hash
    $hash = Hash($key3.Value)
    $key3.Value.Sync([SyncSource]::U8)
    $check.Value.Sync([SyncSource]::U8)

    # Compare hash with check value
    if ($hash -ne $check.Value.u32) {
        Write-Output "Invalid key. The hash is incorrect."
        return $false
    }

    return $true
}
function ConvertTo-UInt32 {
    param (
        [Parameter(Mandatory = $true)]
        [BigInteger]$value
    )

    # Convert BigInteger to uint32 with proper masking
    return [uint32]($value % [BigInteger]0x100000000)
}
function Decode {
    param (
        [Parameter(Mandatory = $true)]
        [byte[]]$key1,

        [ref]$key2
    )

    # Initialize key2
    $key2.Value.u64[0] = 0
    $key2.Value.u64[1] = 0

    for ($ikey = 0; $ikey -lt 25; $ikey++) {
        $res = [BigInteger]24 * [BigInteger]$key2.Value.u32[0] + $key1[$ikey]
        $key2.Value.u32[0] = ConvertTo-UInt32 -value $res
        $res = [BigInteger]($res / [BigInteger]0x100000000)  # Handle overflow

        for ($i = 1; $i -lt 4; $i++) {
            $res += [BigInteger]24 * [BigInteger]$key2.Value.u32[$i]
            $key2.Value.u32[$i] = ConvertTo-UInt32 -value $res
            $res = [BigInteger]($res / [BigInteger]0x100000000)  # Handle overflow
        }
    }

    $key2.Value.Sync([SyncSource]::U32)

    return $true
}
function ConvertChars {
    param (
        [Parameter(Mandatory=$true)]
        [char[]]$key0,

        [ref]$key1
    )

    if ($key0.Length -ne 29) {
        Write-Output "Your key must be 29 characters long."
        return $false
    }

    if ($key0[5] -ne '-' -or $key0[11] -ne '-' -or $key0[17] -ne '-' -or $key0[23] -ne '-') {
        Write-Output "Incorrect hyphens."
        return $false
    }

    if ($key0[28] -eq 'N') {
        Write-Output "The last character must not be an N."
        return $false
    }

    $n = $false
    $j = 1
    $i = 0

    while ($j -lt 25 -and $i -lt $key0.Length) {
        switch ($key0[$i++]) {
            'N' {
                if ($n) {
                    throw "There may only be one N in a key."
                    return $false
                }
                $n = $true
                $key1.Value[0] = $j - 1
            }
            'B' { if ($j -lt 25) { $key1.Value[$j++] = 0x00 } }
            'C' { if ($j -lt 25) { $key1.Value[$j++] = 0x01 } }
            'D' { if ($j -lt 25) { $key1.Value[$j++] = 0x02 } }
            'F' { if ($j -lt 25) { $key1.Value[$j++] = 0x03 } }
            'G' { if ($j -lt 25) { $key1.Value[$j++] = 0x04 } }
            'H' { if ($j -lt 25) { $key1.Value[$j++] = 0x05 } }
            'J' { if ($j -lt 25) { $key1.Value[$j++] = 0x06 } }
            'K' { if ($j -lt 25) { $key1.Value[$j++] = 0x07 } }
            'M' { if ($j -lt 25) { $key1.Value[$j++] = 0x08 } }
            'P' { if ($j -lt 25) { $key1.Value[$j++] = 0x09 } }
            'Q' { if ($j -lt 25) { $key1.Value[$j++] = 0x0a } }
            'R' { if ($j -lt 25) { $key1.Value[$j++] = 0x0b } }
            'T' { if ($j -lt 25) { $key1.Value[$j++] = 0x0c } }
            'V' { if ($j -lt 25) { $key1.Value[$j++] = 0x0d } }
            'W' { if ($j -lt 25) { $key1.Value[$j++] = 0x0e } }
            'X' { if ($j -lt 25) { $key1.Value[$j++] = 0x0f } }
            'Y' { if ($j -lt 25) { $key1.Value[$j++] = 0x10 } }
            '2' { if ($j -lt 25) { $key1.Value[$j++] = 0x11 } }
            '3' { if ($j -lt 25) { $key1.Value[$j++] = 0x12 } }
            '4' { if ($j -lt 25) { $key1.Value[$j++] = 0x13 } }
            '6' { if ($j -lt 25) { $key1.Value[$j++] = 0x14 } }
            '7' { if ($j -lt 25) { $key1.Value[$j++] = 0x15 } }
            '8' { if ($j -lt 25) { $key1.Value[$j++] = 0x16 } }
            '9' { if ($j -lt 25) { $key1.Value[$j++] = 0x17 } }
            '-' { }
            default {
                throw "Invalid character in key."
                return $false
            }
        }
    }

    if (-not $n) {
        throw "The character N must be in the product key."
        return $false
    }

    return $true
}
function KeyDecode {
    param (
        [Parameter(Mandatory=$true)]
        [string]$key0
    )

    # Convert the string to a character array
    $key0Chars = $key0.ToCharArray()

    # Initialize $key1 array
    $key1 = New-Object byte[] 25
    
    # Convert characters to bytes
    if (-not (ConvertChars -key0 $key0Chars -key1 ([ref]$key1))) {
        return -1
    }
    
    # Initialize UINT128u structures
    $key2 = [UINT128u]::new()
    $key3 = [UINT128u]::new()
    $hash = [UINT32u]::new()
    
    # Decode the key
    if (-not (Decode -key1 $key1 -key2 ([ref]$key2))) {
        return -1
    }

    # Check the hash
    if (-not (Check-Hash -key2 $key2 -key3 ([ref]$key3) -check ([ref]$hash))) {
        return -1
    }
    
    # Initialize UINT32u and UINT64u structures
    $groupid = [UINT32u]::new()
    $keyid = [UINT32u]::new()
    $secret = [UINT64u]::new()
    
    # Get information
    if (-not (Get-Info -key3 $key3 -groupid ([ref]$groupid) -keyid ([ref]$keyid) -secret ([ref]$secret))) {
        return -1
    }
    
    return @(
    @{ Property = "KeyId";   Value = $keyid.u32 },
    @{ Property = "Hash";    Value = $hash.u32 },
    @{ Property = "GroupId"; Value = $groupid.u32 },
    @{ Property = "Secret";  Value = $secret.u64}
    )
}

# Adaption of "Licensing Stuff" from =awuctl=, "KeyInfo" from Bob65536
# https://github.com/awuctl/licensing-stuff/blob/main/keycutter.py
# https://forums.mydigitallife.net/threads/how-get-oem-key-system-key.87962/#post-1825092
# https://forums.mydigitallife.net/threads/we8industry-pro-wes8-activation.45312/#post-771802
# https://web.archive.org/web/20121026081005/http://forums.mydigitallife.info/threads/37590-Windows-8-Product-Key-Decoding

function Encode-Key {
    param(
        [Parameter(Mandatory=$true)]
        [UInt64]$group,

        [Parameter(Mandatory=$false)]
        [UInt64]$serial = 0,

        [Parameter(Mandatory=$false)]
        [UInt64]$security = 0,

        [Parameter(Mandatory=$false)]
        [int]$upgrade = 0,

        [Parameter(Mandatory=$false)]
        [int]$extra = 0,

        [Parameter(Mandatory=$false)]
        [int]$checksum = -1
    )

    # Alphabet used for encoding base24 digits (excluding 'N')
    $ALPHABET = 'BCDFGHJKMPQRTVWXY2346789'.ToCharArray()

    # Validate input ranges (equivalent to Python BOUNDS)
    if ($group -gt 0xFFFFF) {
        throw "Group value ($group) out of bounds (max 0xFFFFF)"
    }
    if ($serial -gt 0x3FFFFFFF) {
        throw "Serial value ($serial) out of bounds (max 0x3FFFFFFF)"
    }
    if ($security -gt 0x1FFFFFFFFFFFFF) {
        throw "Security value ($security) out of bounds (max 0x1FFFFFFFFFFFFF)"
    }
    if ($checksum -ne -1 -and $checksum -gt 0x3FF) {
        throw "Checksum value ($checksum) out of bounds (max 0x3FF)"
    }
    if ($upgrade -notin @(0, 1)) {
        throw "Upgrade value must be either 0 or 1"
    }
    if ($extra -notin @(0, 1)) {
        throw "Extra value must be either 0 or 1"
    }

    function Get-Checksum {
        param([byte[]]$data)

        [uint32]$crc = [uint32]::MaxValue
        foreach ($b in $data) {
            $index = (($crc -shr 24) -bxor $b) -band 0xFF
            $crc = ((($crc -shl 8) -bxor $crc32_table[$index]) -band 0xFFFFFFFF)
        }
        $crc = (-bnot $crc) -band 0xFFFFFFFF
        return $crc -band 0x3FF  # 10 bits checksum mask
    }
    function Encode-Base24 {
        param([System.Numerics.BigInteger]$num)
        $digits = New-Object byte[] 25
        for ($i = 24; $i -ge 0; $i--) {
            $digits[$i] = [byte]($num % 24)
            $num = [System.Numerics.BigInteger]::Divide($num, 24)
        }
        return $digits
    }
    function Format-5x5 {
        param([byte[]]$digits)

        # Calculate position for inserting 'N'
        $pos = $digits[0] #+ [math]::Floor($digits[0] / 5)

        $ALPHABET = @('B','C','D','F','G','H','J','K','M','P','Q','R','T','V','W','X','Y','2','3','4','6','7','8','9')

        $chars = @()
        for ($i = 1; $i -lt 25; $i++) {
            $chars += $ALPHABET[$digits[$i]]
        }

        # Insert 'N' at the calculated position
        if ($pos -le 0) {
            $chars = @('N') + $chars
        }
        elseif ($pos -ge $chars.Count) {
            $chars += 'N'
        }
        else {
            $chars = $chars[0..($pos - 1)] + 'N' + $chars[$pos..($chars.Count - 1)]
        }

        # Insert dashes every 5 characters to form groups
        return -join (
            ($chars[0..4] -join ''), '-',
            ($chars[5..9] -join ''), '-',
            ($chars[10..14] -join ''), '-',
            ($chars[15..19] -join ''), '-',
            ($chars[20..24] -join '')
        )
    }

    # Validate input ranges to avoid overflow
    if ($group -gt 0xFFFFF -or $serial -gt 0x3FFFFFFF -or $security -gt 0x1FFFFFFFFFFFFF) {
        throw "Field values out of range"
    }

    # Compose the key bits using BigInteger (64+ bit shifts)
    $key = [System.Numerics.BigInteger]::Zero
    $key = $key -bor ([System.Numerics.BigInteger]$extra -shl 114)
    $key = $key -bor ([System.Numerics.BigInteger]$upgrade -shl 113)
    $key = $key -bor ([System.Numerics.BigInteger]$security -shl 50)
    $key = $key -bor ([System.Numerics.BigInteger]$serial -shl 20)
    $key = $key -bor ([System.Numerics.BigInteger]$group)

    # Calculate checksum if not provided
    if ($checksum -lt 0) {
        $keyBytes = $key.ToByteArray()

        # Remove extra sign byte if present (BigInteger uses signed representation)
        if ($keyBytes.Length -gt 16) {
            if ($keyBytes[-1] -eq 0x00) {
                # Remove the last byte (sign byte)
                $keyBytes = $keyBytes[0..($keyBytes.Length - 2)]
            }
            else {
                throw "Key bytes length greater than 16 with unexpected data"
            }
        }

        # Pad with trailing zeros to get exactly 16 bytes (little-endian)
        if ($keyBytes.Length -lt 16) {
            $keyBytes += ,0 * (16 - $keyBytes.Length)
        }

        # No reversal needed ? checksum function expects little-endian bytes
        # [array]::Reverse($keyBytes)  # <-- removed

        $checksum = Get-Checksum $keyBytes
    }

    # Insert checksum bits at bit position 103
    $key = $key -bor ([System.Numerics.BigInteger]$checksum -shl 103)

    # Encode the final key to base24 digits
    $base24 = Encode-Base24 $key

    # Format into the 5x5 grouped string with 'N' insertion and dashes
    return Format-5x5 $base24
}
function Decode-Key {
    param (
        [Parameter(Mandatory=$true)]
        [ValidateNotNullOrEmpty()]
        [string]$Key
    )

    $ALPHABET = 'BCDFGHJKMPQRTVWXY2346789'.ToCharArray()

    # Remove hyphens and uppercase
    $k = $Key.Replace('-','').ToUpper()

    # Find 'N' position
    $ni = $k.IndexOf('N')
    if ($ni -lt 0) { throw "Invalid key (missing 'N')." }

    # Start digits array with position of 'N'
    $digits = @($ni)

    # Remove 'N' from key
    $rest = $k.Replace('N','')

    # Convert each character to index in alphabet
    foreach ($ch in $rest.ToCharArray()) {
        $idx = $Alphabet.IndexOf($ch)
        if ($idx -lt 0) { throw "Invalid character '$ch' in key." }
        $digits += $idx
    }

    [bigint]$value = 0
    foreach ($d in $digits) {
        $value = ($value * 24) + $d
    }

    # Extract bit fields
    $group    = [int]($value -band 0xfffff)                         # 20 bits decimal
    $serial   = [int](($value -shr 20) -band 0x3fffffff)             # 30 bits decimal
    $security = [bigint](($value -shr 50) -band 0x1fffffffffffff)    # 53 bits decimal (bigint)
    $checksum = [int](($value -shr 103) -band 0x3ff)                  # 10 bits decimal
    $upgrade  = [int](($value -shr 113) -band 0x1)                    # 1 bit decimal
    $extra    = [int](($value -shr 114) -band 0x1)                    # 1 bit decimal

    return [pscustomobject]@{
        Key      = $Key
        Integer  = $value
        Group    = $group
        Serial   = $serial
        Security = $security
        Checksum = $checksum
        Upgrade  = $upgrade
        Extra    = $extra
    }
}

<#
Generates product keys using:

1. Template mode:
   - Use -template (e.g. "NBBBB-BBBBB-") to find matching keys.
   - Stops when keys no longer match the given prefix.

2. Brute-force mode:
   - If no -template is given, generates up to -MaxTries.
   - Collects keys starting with "NBBBB".
   - If no valid keys are found, automatically retries up to 5 times,
     each time increasing the MaxTries limit by 5000.
     Stops once at least one key is found or the retry limit is reached.

Based on abbodi1406's logic:
https://forums.mydigitallife.net/threads/88595/page-6#post-1882091

Examples:
    Brute-force mode
    List-Keys -RefGroupId 2048
    List-Keys -RefGroupId 2048 -OffsetLimit 200000
    List-Keys -RefGroupId 2048 -StartAtOffset 120000 -KeysLimit 2
    List-Keys -RefGroupId 2048 -StartAtOffset 120000 -OffsetLimit 20000

    Template mode
    List-Keys -RefGroupId 2077 -template JDHD7-DHN6R-JDHD7
    List-Keys -RefGroupId 2048 -template NBBBB-BBBBB-BBBBB -KeysLimit 2
    List-Keys -RefGroupId 2048 -template NBBBB-BBBBB-BBBBB -OffsetLimit 20000
#>
function List-Keys {
    param(
        [Parameter(Mandatory=$true)]
        [ValidateScript( { $_ -gt 0 } )]
        [int32]$RefGroupId,

        [Parameter(Mandatory=$false)]
        [string]$Template,

        [Parameter(Mandatory=$false)]
        [ValidateScript( { $_ -gt 0 } )]
        [int32]$OffsetLimit = 10000,

        [Parameter(Mandatory=$false)]
        [ValidateScript( { $_ -ge 0 } )]
        [int32]$KeysLimit = 0,

        [Parameter(Mandatory=$false)]
        [ValidateScript( { $_ -ge 0 } )]
        [int32]$StartAtOffset = 0
    )

    if ($template) {
        if ($template.Length -gt 21) {
            throw "Template too long"
        }        
        $paddingTemplate = 'NBBBB-BBBBB-BBBBB-BBBBB-BBBBB'

        # Pad the template to full length with padding string starting from template length
        $paddedTemplate = $template + $paddingTemplate.Substring($template.Length)

        # Decode the padded template into components
        $templateKey = Decode-Key -Key $paddedTemplate
        $serialIter = $templateKey.Serial
        $serialEdgeOffset = $serialIter + $OffsetLimit

    } 
    if (-not $template) {
        $serialIter = $StartAtOffset
    }

    # Initialize variables
    $keyArray = @()
    $attemptCount = 0

    while ($true) {
        if ($template) {   
            # ----- > Begin
            if ($serialIter -ge $serialEdgeOffset) {
                return $keyArray
            }
            $key = Encode-Key -group $RefGroupId -serial $serialIter -security $templateKey.Security -upgrade $templateKey.Upgrade -extra $templateKey.Extra
            $decodedKey = Decode-Key -Key $key
            if ($decodedKey.Checksum -ne $templateKey.Checksum) {
                $serialIter++
                continue
            }
            if (($key.Substring(0, $template.Length) -ne $template)) {
                break
            }
            # ----- > End
        }

        if (-not $template) {
            # ----- > Begin
            if ($serialIter -ge ($OffsetLimit+$StartAtOffset)) {
                if ($keyArray.Count -gt 0) {
                    return $keyArray
                }
                elseif ($attemptCount -lt 5) {
                    $OffsetLimit += 5000
                    $attemptCount++
                    continue 
                } else {
                    return $keyArray
                }
            }
            $key = Encode-Key -group $RefGroupId -serial $serialIter -security 0
            if ($key -notmatch "NBBBB") {
                $serialIter++
                continue 
            }
            # ----- > End
        }

        $keyArray += $key
        Write-Warning "StartAtOffset: $serialIter, Key: $key"

        # Check if MaxKeys is set and if we've reached the limit
        if ($KeysLimit -gt 0 -and $keyArray.Count -ge $KeysLimit) {
            return $keyArray
        }

        $serialIter++
    }

    # Just in case.
    # Should not arrived here.
    return $keyArray
}
# KeyInfo Part -->

# Start #
# JSON Parser Function's
# Begin #

function Compress-FileData {
    param (
        [string]$filePath
    )

    # Open the file to read as bytes
    $fileBytes = [File]::ReadAllBytes($filePath)

    # Create a memory stream to store the compressed data
    $compressedMemoryStream = [MemoryStream]::new()

    # Use GZipStream to compress the file data
    $gzipStream = New-Object GZipStream($compressedMemoryStream, [CompressionLevel]::Optimal)

    # Write the file bytes to the GZipStream to compress
    $gzipStream.Write($fileBytes, 0, $fileBytes.Length)
    $gzipStream.Close()

    # Convert the compressed memory stream to a byte array
    $compressedBytes = $compressedMemoryStream.ToArray()

    # Return the Base64 string of the compressed file data
    return [Convert]::ToBase64String($compressedBytes)
}
function Save-DirectoryStructureWithData {
    param (
        [string]$rootDirectory,   # The root directory to scan
        [string]$outputFilePath    # The file path to save the data (JSON)
    )

    # Initialize the directory structure and file metadata collection
    $directoryStructure = @()

    # Function to get the directory structure with compressed file data
    function Get-DirectoryStructureWithData {
        param (
            [string]$currentDirectory
        )

        $directories = Get-ChildItem -Path $currentDirectory -Directory
        $directoryList = @()

        foreach ($dir in $directories) {
            $dirMetadata = New-Object PSObject -property @{
                Name           = $dir.Name
                FullPath       = $dir.FullName
                CreationTime   = $dir.CreationTime
                LastWriteTime  = $dir.LastWriteTime
                Files          = @()
                Subdirectories = Get-DirectoryStructureWithData -currentDirectory $dir.FullName
            }

            $files = Get-ChildItem -Path $dir.FullName -File
            foreach ($file in $files) {
                # Compress the file content
                $compressedData = Compress-FileData -filePath $file.FullName

                # Store compressed data as a Base64 string
                $fileMetadata = New-Object PSObject -property @{
                    Name                = $file.Name
                    FullPath            = $file.FullName
                    Extension           = $file.Extension
                    Size                = $file.Length
                    CreationTime        = $file.CreationTime
                    LastWriteTime       = $file.LastWriteTime
                    CompressedDataBase64 = $compressedData
                }

                $dirMetadata.Files += $fileMetadata
            }

            $directoryList += $dirMetadata
        }

        return $directoryList
    }

    # Collect the directory structure and metadata
    $directoryStructure = Get-DirectoryStructureWithData -currentDirectory $rootDirectory

    # Convert the directory structure to JSON and save it
    $directoryStructureJson = $directoryStructure | ConvertTo-Json -Depth 5
    $directoryStructureJson | Set-Content -Path $outputFilePath

    Write-Host "Directory structure with compressed file data saved to $outputFilePath"
}
function Restore-DirectoryStructureFromData {
    param (
        [string]$inputFilePath,   # The path to the JSON file to read
        [string]$outPath          # The directory where the structure and files will be restored
    )

    # Function to decode Base64 and decompress the file content
    function Decompress-FileData {
        param (
            [string]$compressedDataBase64
        )

        # Convert the Base64 string to bytes
        $compressedBytes = [Convert]::FromBase64String($compressedDataBase64)

        # Create a memory stream with the compressed data
        $compressedMemoryStream = [MemoryStream]::new($compressedBytes)

        # Create a GZipStream to decompress the data
        $gzipStream = New-Object GZipStream($compressedMemoryStream, [CompressionMode]::Decompress)

        # Create a memory stream to store the decompressed file content
        $decompressedMemoryStream = [MemoryStream]::new()

        # Decompress the data
        $gzipStream.CopyTo($decompressedMemoryStream)
        $gzipStream.Close()

        # Return the decompressed byte array
        return $decompressedMemoryStream.ToArray()
    }

    # Read the saved JSON file with directory structure and compressed file data
    $directoryStructure = Get-Content -Path $inputFilePath | ConvertFrom-Json

    # Ensure the output path exists
    if (-not (Test-Path -Path $outPath)) {
        New-Item -Path $outPath -ItemType Directory | Out-Null
        Write-Host "Created output directory: $outPath"
    }

    # Function to restore the directory and files from the metadata
    function Restore-Directory {
        param (
            [array]$directoryData,
            [string]$parentPath
        )

        foreach ($dir in $directoryData) {
            $fullDirPath = Join-Path -Path $parentPath -ChildPath $dir.Name

            # Create the directory if it does not exist
            if (-not (Test-Path -Path $fullDirPath)) {
                New-Item -Path $fullDirPath -ItemType Directory | Out-Null
                Write-Host "Created directory: $fullDirPath"
            }

            # Restore files within this directory
            foreach ($file in $dir.Files) {
                $filePath = Join-Path -Path $fullDirPath -ChildPath $file.Name

                # Decompress the file content
                $decompressedData = Decompress-FileData -compressedDataBase64 $file.CompressedDataBase64

                # Write the decompressed file content to disk
                [File]::WriteAllBytes($filePath, $decompressedData)

                Write-Host "Restored file: $filePath"
            }

            # Recursively restore subdirectories
            if ($dir.Subdirectories.Count -gt 0) {
                Restore-Directory -directoryData $dir.Subdirectories -parentPath $fullDirPath
            }
        }
    }

    # Start restoring the directory structure and files
    Restore-Directory -directoryData $directoryStructure -parentPath $outPath

    Write-Host "Directory structure and files restored successfully to $outPath"
}

# XML Parser Function's Part -->

$prefixes = [ordered]@{
  VisualStudio = 'ns1:'
  Office = 'pkc:'
  None = '' # keep last.
}
$validConfigTypes = @(
  'Office',
  'Windows',
  'VisualStudio'
)
Class KeyRange {
  [string] $RefActConfigId
  [string] $PartNumber
  [string] $EulaType
  [bool]   $IsValid
  [int]    $Start
  [int]    $End
}
Class Range {
  [KeyRange[]] $Ranges

  [String] ToString() {
    $output = $null
    $this.Ranges | Sort-Object -Property @{Expression = "Start"; Descending = $false } | Select-First 1 | % { 
      $keyInfo = $_ -as [KeyRange]
      $output += "[$($keyInfo.Start), $($keyInfo.End)], Number:$($keyInfo.PartNumber), Type:$($keyInfo.EulaType), IsValid:$($keyInfo.IsValid)`n" }
    return $output
  }
}
Class INFO_DATA {
  [string] $ActConfigId
  [int]    $RefGroupId
  [string] $EditionId
  [string] $ProductDescription
  [string] $ProductKeyType
  [bool]   $IsRandomized
  [Range]  $KeyRanges
  [string] $ProductKey
  [string] $Command

  [String] ToString() {
    $output = $null
    $GroupId = [String]::Format("{0:X}",$this.RefGroupId)
    $output  = " Ref: $($this.RefGroupId)`nType: $($this.ProductKeyType)`nEdit: $($this.EditionId)`n  ID: $($this.ActConfigId)`nName: $($this.ProductDescription)`n"
    $output += " Gen: (gwmi SoftwareLicensingService).InstallProductKey((KeyInfo $($GroupId) 0 0))`n"
    ($this.KeyRanges).Ranges | Sort-Object -Property @{Expression = "Start"; Descending = $false } | % { 
      $keyInfo = $_ -as [KeyRange]
      $output += "* Key Range: [$($keyInfo.Start)] => [$($keyInfo.End)], Number: $($keyInfo.PartNumber), Type: $($keyInfo.EulaType), IsValid: $($keyInfo.IsValid)`n" }
    return $output
  }
}
Function GenerateConfigList {
    param (
        [ValidateNotNullOrEmpty()]
        [Parameter(ValueFromPipeline)]
        [string] $pkeyconfig = "$env:windir\System32\spp\tokens\pkeyconfig\pkeyconfig.xrm-ms",

        [Parameter(Mandatory=$false)]
        [bool] $IgnoreAPI = $false,

        [Parameter(Mandatory=$false)]
        [bool] $SkipKey = $false,

        [Parameter(Mandatory=$false)]
        [bool] $SkipKeyRange = $false
    )

    function Get-XmlValue {
        param (
            [string]$Source,
            [string]$TagName
        )
    
        $startTag = "<$TagName>"
        $endTag = "</$TagName>"
        $iStart = $Source.IndexOf($startTag) + $startTag.Length
        $iEnd = $Source.IndexOf($endTag) - $iStart
        if ($iStart -ge 0 -and $iEnd -ge 0) {
            return $Source.Substring($iStart, $iEnd)
        }
        Write-Debug $TagName
        return $null
    }
    function Get-XmlSection {
        param (
            [string] $XmlContent,
            [string] $StartTag,
            [string] $EndTag,
            [string] $Delimiter
        )
    
        $iStart = $XmlContent.IndexOf($StartTag) + $StartTag.Length
        $iEnd = $XmlContent.IndexOf($EndTag)
        if ($iStart -ge $iEnd -or $iEnd -lt 0) {
            return @()
        }

        $length = $iEnd - $iStart
        $section = $XmlContent.Substring($iStart, $length)
        return ($section -split $Delimiter)
    }
    function Get-ConfigTags {
        [CmdletBinding()]
        param (
            [Parameter(Mandatory = $true, Position = 0, ParameterSetName = 'FromContent', HelpMessage = "Content source string.")]
            [ValidateNotNullOrEmpty()]
            [string]$Source,

            [Parameter(Mandatory = $true, Position = 0, ParameterSetName = 'FromType', HelpMessage = "Type of configuration.")]
            [ValidateScript({
                if ($_ -notin $validConfigTypes) {
                    throw "ERROR: Invalid ConfigType '$_'."
                }
                return $true
            })]
            [string]$ConfigType
        )

        # Initialize prefix
        $prefix = $prefixes.None

        # Determine the prefix based on the parameter set
        switch ($PSCmdlet.ParameterSetName) {
            'FromType' {
                $prefix = $prefixes[$ConfigType]
            }
            'FromContent' {
                if ($Source -match "r:grant|sl:policy") {
                    throw "ERROR: Source must contain valid content."
                }

                # Dynamically check for patterns, excluding None
                foreach ($key in $prefixes.Keys.Where({ $_ -ne 'None' })) {
                    if ($Source -match "$($prefixes[$key])ActConfigId") {
                        $prefix = $prefixes[$key]
                        break  # Exit loop on first match
                    }
                }
            }
        }

        # Create base tags using the determined prefix
        $baseConfigTag = "${prefix}Configuration"
        $baseKeyRangeTag = "${prefix}KeyRange"

        # Build and return XML tags as a custom object
        return [PSCustomObject]@{
            StartTagConfig    = "<${baseConfigTag}s>"
            EndTagConfig      = "</${baseConfigTag}s>"
            DelimiterConfig    = "<${baseConfigTag}>"
            StartTagKeyRange  = "<${baseKeyRangeTag}s>"
            EndTagKeyRange    = "</${baseKeyRangeTag}s>"
            DelimiterKeyRange  = "<${baseKeyRangeTag}>"
            TagPrefix          = $prefix
        }
    }

    if (-not [IO.FILE]::Exists($pkeyconfig)) {
        throw "ERROR: File not exist" }

    $data = Get-Content -Path $pkeyconfig
    $iStart = $data.IndexOf('<tm:infoBin name="pkeyConfigData">')
    if ($iStart -le 0) {
        throw "ERROR: FILE NOT SUPPORTED" }

    $iEnd = $data.Substring($iStart+34).IndexOf('</tm:infoBin>')
    $Conf = [Encoding]::UTF8.GetString(
      [Convert]::FromBase64String(
        $data.Substring(($iStart+34), $iEnd)))

    # Get configuration based on ConfigType
    $Config = Get-ConfigTags -Source $Conf

    # Process Configurations
    $Output = @{}
    $Configurations = Get-XmlSection -XmlContent $Conf -StartTag $Config.StartTagConfig -EndTag $Config.EndTagConfig -Delimiter $Config.DelimiterConfig
    $KeyRanges = Get-XmlSection -XmlContent $Conf -StartTag $Config.StartTagKeyRange -EndTag $Config.EndTagKeyRange -Delimiter $Config.DelimiterKeyRange

    $Configurations | ForEach-Object {
        
        try {
          $length = 0
          $Source = $_ | Out-String
          $length = $Source.Length
        }
        catch {
          # just in case of
          $length = 0
        }

        $ActConfigId = $null
        $RefGroupId = $null
        $EditionId = $null
        $ProductDescription = $null
        $ProductKeyType = $null
        $IsRandomized = $null

        if ($length -ge 5) {
          $ActConfigId = Get-XmlValue -Source $Source -TagName "$($Config.TagPrefix)ActConfigId"
          $RefGroupId = Get-XmlValue -Source $Source -TagName "$($Config.TagPrefix)RefGroupId"
          $EditionId = Get-XmlValue -Source $Source -TagName "$($Config.TagPrefix)EditionId"
          $ProductDescription = Get-XmlValue -Source $Source -TagName "$($Config.TagPrefix)ProductDescription"
          $ProductKeyType = Get-XmlValue -Source $Source -TagName "$($Config.TagPrefix)ProductKeyType"
          $IsRandomized = Get-XmlValue -Source $Source -TagName "$($Config.TagPrefix)IsRandomized" -as [BOOL]
        }

        if ($ActConfigId) {
            $cInfo = [INFO_DATA]::new()
            $cInfo.ActConfigId = $ActConfigId
            $cInfo.IsRandomized = $IsRandomized
            $cInfo.ProductDescription = $ProductDescription
            $cInfo.RefGroupId = $RefGroupId
            $cInfo.ProductKeyType = $ProductKeyType
            $cInfo.EditionId = $EditionId

            # Attempt to set ProductKey from the reference array
            if (-not $SkipKey) {
			    if ($Config.TagPrefix -and ($Config.TagPrefix -eq 'pkc:')) {
				    $cInfo.ProductKey = $OfficeOnlyKeys[[int]$RefGroupId]
			    } elseif ($Config.TagPrefix -and ($Config.TagPrefix -eq 'ns1:')){
                    $cInfo.ProductKey = ($VSOnlyKeys | ? { $_.Key -eq [int]$RefGroupId } | Get-Random -Count 1).Value
			    } else {
                    $cInfo.ProductKey = ($KeysRef | ? { $_.Key -eq [int]$RefGroupId } | Get-Random -Count 1).Value
                }
            }
            
            # Check if ProductKey is empty
            if (-not $SkipKey -and ([STRING]::IsNullOrEmpty($cInfo.ProductKey) -and ($RefGroupId -ne '999999'))) {
                # Check if ProductKeyType matches one of the groups
                if (![string]::IsNullOrEmpty($Config.TagPrefix)) {
                    # CASE OF --> Office & VS
                    $IgnoreAPI = $true }

                if (-not $IgnoreAPI -and ($groups -contains $ProductKeyType)) {
                    
                    # i don't think i need it any longer,
                    # since i extract all key's from pkhelper.dll

                    $value = Get-ProductKeys -EditionID $EditionId -ProductKeyType $ProductKeyType
                    if ($value) {
                        # Set ProductKey based on the result of Get-ProductKeys
                        $RefInfo = $null
                        try { $RefInfo = KeyDecode -key0 $value.ProductKey}
                        catch {}
                        if ($value -and $RefInfo -and ($RefInfo[2].Value -match $RefGroupId)) {
                          $cInfo.ProductKey = $value.ProductKey }}}}

            # Call Encode-Key only if ProductKey is still empty after the checks
            if (-not $SkipKey -and ([STRING]::IsNullOrEmpty($cInfo.ProductKey)-and ($RefGroupId -ne '999999'))) {
                $cInfo.ProductKey = Encode-Key $RefGroupId 0 0
            }
            # Call LibTSForge Generate key function only if ProductKey is still empty after the checks
            if (-not $SkipKey -and ([STRING]::IsNullOrEmpty($cInfo.ProductKey)-and ($RefGroupId -ne '999999'))) {
              $cInfo.ProductKey = GetRandomKey -ProductID (
                ([GUID]::Parse($cInfo.ActConfigId)).ToString())
            }

            $cInfo.Command = "(gwmi SoftwareLicensingService).InstallProductKey(""$($cInfo.ProductKey)"")"
            $cInfo.KeyRanges = [Range]::new()
            $Output[$ActConfigId] = $cInfo
        }
    }

    # Process Key Ranges
    if ($KeyRanges -and (-not $SkipKeyRange)) {
        $KeyRanges | ForEach-Object {
            $Source = $_ | Out-String
            $RefActConfigId = Get-XmlValue -Source $Source -TagName "$($Config.TagPrefix)RefActConfigId"
            $PartNumber = Get-XmlValue -Source $Source -TagName "$($Config.TagPrefix)PartNumber"
            $EulaType = Get-XmlValue -Source $Source -TagName "$($Config.TagPrefix)EulaType"
            $IsValid = Get-XmlValue -Source $Source -TagName "$($Config.TagPrefix)IsValid" -as [BOOL]
            $Start = Get-XmlValue -Source $Source -TagName "$($Config.TagPrefix)Start" -as [INT]
            $End = Get-XmlValue -Source $Source -TagName "$($Config.TagPrefix)End" -as [INT]

            if ($RefActConfigId) {
                $kRange = [KeyRange]::new()
                $kRange.End = $End
                $kRange.Start = $Start
                $kRange.IsValid = $IsValid
                $kRange.EulaType = $EulaType
                $kRange.PartNumber = $PartNumber
                $kRange.RefActConfigId = $RefActConfigId

                if ($Output[$RefActConfigId]) {
                    $cInfo = $Output[$RefActConfigId] -as [INFO_DATA]
                    $iInfo = $cInfo.KeyRanges -as [Range]
                    $iInfo.Ranges += $kRange
                }
            }
        }
    }

    return $Output.Values
}

# XML Parser Function's Part -->

# Start #
# License Info
# Begin #

# License Info Part -->

<#
TSforge
https://github.com/massgravel/TSforge

Open-source slc.dll patch for Windows 8 Milestone builds (7850, 795x, 7989)
Useful if you want to enable things such as Modern Task Manager, Ribbon Explorer, etc.
https://github.com/LBBNetwork/openredpill/blob/master/private.c

Open-source slc.dll patch for Windows 8 Milestone builds (7850, 795x, 7989)
https://github.com/LBBNetwork/openredpill/blob/master/slpublic.h

slpublic.h header
https://learn.microsoft.com/en-us/windows/win32/api/slpublic/
#>

<#
.SYNOPSIS
Opens or closes the global SLC handle,
and optionally closes a specified $hSLC handle.

#>
function Manage-SLHandle {
    [CmdletBinding()]
    param(
        [IntPtr]$hSLC = [IntPtr]::Zero,
        [switch]$Create,
        [switch]$Release,
        [switch]$Force
    )

    # Initialize global variables
    if (-not $global:Status_)      { $global:Status_ = 0 }
    if (-not $global:hSLC_)        { $global:hSLC_   = [IntPtr]::Zero }
    if (-not $global:TrackedSLCs)  { $global:TrackedSLCs = [System.Collections.Generic.HashSet[IntPtr]]::new() }
    if (-not $global:SLC_Lock)        { $global:SLC_Lock = New-Object Object }


    # Helper: Check if handle is tracked
    function Is-HandleTracked([IntPtr]$handle) {
        return $global:TrackedSLCs.Contains($handle)
    }

    # Create new handle
    [System.Threading.Monitor]::Enter($global:SLC_Lock)
    try {
        if ($Create) {
            $newHandle = [IntPtr]::Zero
            $hr = $Global:SLC::SLOpen([ref]$newHandle)
            if ($hr -ne 0) {
                throw "SLOpen failed with HRESULT 0x{0:X8}" -f $hr
            }
            $global:TrackedSLCs.Add($newHandle) | Out-Null
            Write-Verbose "New handle created and tracked."
            return $newHandle
        }

        # Release handle
        if ($Release) {
            # Release specific handle if valid
            if ($hSLC -and $hSLC -ne [IntPtr]::Zero) {
                if (-not (Is-HandleTracked $hSLC) -and -not $Force) {
                    Write-Warning "Handle not tracked or already released. Use -Force to override."
                    return
                }
                Write-Verbose "Releasing specified handle."
                Free-IntPtr -handle $hSLC -Method License
                $global:TrackedSLCs.Remove($hSLC) | Out-Null
                return $hr
            }

            # Release global handle
            if ($global:Status_ -eq 0 -and -not $Force) {
                Write-Warning "Global handle already closed. Use -Force to override."
                return
            }

            Write-Verbose "Releasing global handle."
            Free-IntPtr -handle $hSLC_ -Method License
            $global:TrackedSLCs.Remove($global:hSLC_) | Out-Null
            $global:hSLC_ = [IntPtr]::Zero
            $global:Status_ = 0
            return $hr
        }

        # Return existing global handle if already open
        if ($global:Status_ -eq 1 -and $global:hSLC_ -ne [IntPtr]::Zero -and -not $Force) {
            Write-Verbose "Returning existing global handle."
            return $global:hSLC_
        }

        # Open or reopen global handle
        if ($Force -and $global:hSLC_ -ne [IntPtr]::Zero) {
            Write-Verbose "Force-closing previously open global handle."
            Free-IntPtr -handle $hSLC_ -Method License
            $global:TrackedSLCs.Remove($global:hSLC_) | Out-Null
        }

        Write-Verbose "Opening new global handle."
        $global:hSLC_ = [IntPtr]::Zero
        $hr = $Global:SLC::SLOpen([ref]$global:hSLC_)
        if ($hr -ne 0) {
            throw "SLOpen failed with HRESULT 0x{0:X8}" -f $hr
        }
        $global:TrackedSLCs.Add($global:hSLC_) | Out-Null
        $global:Status_ = 1
        return $global:hSLC_
    }
    finally {
        [System.Threading.Monitor]::Exit($global:SLC_Lock)
    }
}

<#
typedef enum _tagSLDATATYPE {

SL_DATA_NONE = REG_NONE,      // 0
SL_DATA_SZ = REG_SZ,          // 1
SL_DATA_DWORD = REG_DWORD,    // 4
SL_DATA_BINARY = REG_BINARY,  // 3
SL_DATA_MULTI_SZ,             // 7
SL_DATA_SUM = 100             // 100

} SLDATATYPE;

#define REG_NONE		0	/* no type */
#define REG_SZ			1	/* string type (ASCII) */
#define REG_EXPAND_SZ	2	/* string, includes %ENVVAR% (expanded by caller) (ASCII) */
#define REG_BINARY		3	/* binary format, callerspecific */
#define REG_DWORD		4	/* DWORD in little endian format */
#define REG_DWORD_LITTLE_ENDIAN	4	/* DWORD in little endian format */
#define REG_DWORD_BIG_ENDIAN	5	/* DWORD in big endian format  */
#define REG_LINK		6	/* symbolic link (UNICODE) */
#define REG_MULTI_SZ	7	/* multiple strings, delimited by \0, terminated by \0\0 (ASCII) */
#define REG_RESOURCE_LIST	8	/* resource list? huh? */
#define REG_FULL_RESOURCE_DESCRIPTOR	9	/* full resource descriptor? huh? */
#define REG_RESOURCE_REQUIREMENTS_LIST	10
#define REG_QWORD		11	/* QWORD in little endian format */
#>
$SLDATATYPE = @{
    SL_DATA_NONE       = 0   # REG_NONE
    SL_DATA_SZ         = 1   # REG_SZ
    SL_DATA_DWORD      = 4   # REG_DWORD
    SL_DATA_BINARY     = 3   # REG_BINARY
    SL_DATA_MULTI_SZ   = 7   # REG_MULTI_SZ
    SL_DATA_SUM        = 100 # Custom value
}
function Parse-RegistryData {
    param (
        # Data type (e.g., $SLDATATYPE.SL_DATA_NONE, $SLDATATYPE.SL_DATA_SZ, etc.)
        [Parameter(Mandatory=$true)]
        [int]$dataType,

        # Pointer to the data (e.g., registry value pointer)
        [Parameter(Mandatory=$false)]
        [IntPtr]$ptr,

        # Size of the data (in bytes)
        [Parameter(Mandatory=$true)]
        [int]$valueSize,

        # Optional, for special cases (e.g., ProductSkuId)
        [Parameter(Mandatory=$false)]
        [string]$valueName,

        [Parameter(Mandatory=$false)]
        [byte[]]$blob,

        [Parameter(Mandatory=$false)]
        [int]$dataOffset = 0
    )

    # Treat IntPtr.Zero as null for XOR logic
    $ptrIsSet = ($ptr -ne [IntPtr]::Zero) -and ($ptr -ne $null)
    $blobIsSet = ($blob -ne $null)

    if (-not ($ptrIsSet -xor $blobIsSet)) {
        Write-Warning "Exactly one of 'ptr' or 'blob' must be provided, not both or neither."
        return $null
    }

    if ($valueSize -le 0) {
        Write-Warning "Data size is zero or negative for valueName '$valueName'. Returning null."
        return $null
    }

    if ($blobIsSet) {
        if ($dataOffset -lt 0 -or ($dataOffset + $valueSize) -gt $blob.Length) {
            Write-Warning "Invalid dataOffset ($dataOffset) or valueSize ($valueSize) exceeds blob length ($($blob.Length)) for valueName '$valueName'. Returning null."
            return $null
        }
    }

    $result = $null

    $uint32Names = @(
        'SL_LAST_ACT_ATTEMPT_HRESULT',
        'SL_LAST_ACT_ATTEMPT_SERVER_FLAGS',
        'Security-SPP-LastWindowsActivationHResult'
    )

    $datetimeNames = @(
        'SL_LAST_ACT_ATTEMPT_TIME',
        'EvaluationEndDate',
        'TrustedTime',
        'Security-SPP-LastWindowsActivationTime'
    )

    switch ($dataType) {
        $SLDATATYPE.SL_DATA_NONE { 
            $result = $null 
        }

        $SLDATATYPE.SL_DATA_SZ {
            # SL_DATA_SZ = Unicode string
            if ($ptr) {
                # PtrToStringUni expects length in characters, valueSize is in bytes, so divide by 2
                $result = [Marshal]::PtrToStringUni($ptr, $valueSize / 2).TrimEnd([char]0)
            }
            else {
                $buffer = New-Object byte[] $valueSize
                [Buffer]::BlockCopy($blob, $dataOffset, $buffer, 0, $valueSize)
                $result = [Encoding]::Unicode.GetString($buffer).TrimEnd([char]0)
            }
        }

        $SLDATATYPE.SL_DATA_DWORD {
            # SL_DATA_DWORD = DWORD (4 bytes)
            if ($valueSize -ne 4) {
                $result = $null
            }
            elseif ($ptr) {
                # Allocate 4-byte array
                $bytes = New-Object byte[] 4
                [Marshal]::Copy($ptr, $bytes, 0, 4)
                $result = [BitConverter]::ToInt32($bytes, 0)    # instead ToUInt32
            }
            else {
                $buffer = New-Object byte[] $valueSize
                [Buffer]::BlockCopy($blob, $dataOffset, $buffer, 0, $valueSize)
                $result = [BitConverter]::ToInt32($buffer, 0)  # instead ToUInt32
            }
        }

        $SLDATATYPE.SL_DATA_BINARY {
            # SL_DATA_BINARY = Binary blob
            if ($valueName -eq 'ProductSkuId' -and $valueSize -eq 16) {
                # If it's ProductSkuId and the buffer is 16 bytes, treat it as a GUID
                $bytes = New-Object byte[] 16
                if ($ptr) {
                    [Marshal]::Copy($ptr, $bytes, 0, 16)
                }
                else {
                    [Buffer]::BlockCopy($blob, $dataOffset, $bytes, 0, $valueSize)
                }
                $result = [Guid]::new($bytes)
            }
            elseif ($datetimeNames -contains $valueName -and $valueSize -eq 8) {
                $bytes = New-Object byte[] 8
                if ($ptr) {
                    [Marshal]::Copy($ptr, $bytes, 0, 8)
                }
                else {
                    [Buffer]::BlockCopy($blob, $dataOffset, $bytes, 0, 8)
                }
                $fileTime = [BitConverter]::ToInt64($bytes, 0)
                $result = [DateTime]::FromFileTimeUtc($fileTime)
            }
            elseif ($uint32Names -contains $valueName -and $valueSize -eq 4) {
                $bytes = New-Object byte[] 4
                if ($ptr) {
                    [Marshal]::Copy($ptr, $bytes, 0, 4)
                }
                else {
                    [Buffer]::BlockCopy($blob, $dataOffset, $bytes, 0, 4)
                }
                $result = [BitConverter]::ToInt32($bytes, 0) # instead ToUInt32
            }
            else {
                # Otherwise, just copy the binary data
                $result = New-Object byte[] $valueSize
                if ($ptr) {
                    [Marshal]::Copy($ptr, $result, 0, $valueSize)
                    $result = ($result | ForEach-Object { $_.ToString("X2") }) -join "-"
                }
                else {
                    [Buffer]::BlockCopy($blob, $dataOffset, $result, 0, $valueSize)
                }
            }
        }

        $SLDATATYPE.SL_DATA_MULTI_SZ {
            # SL_DATA_MULTI_SZ = Multi-string
            if ($ptr) {
               $raw = [Marshal]::PtrToStringUni($ptr, $valueSize / 2)
               $result = $raw -split "`0" | Where-Object { $_ -ne '' }
            }
            else {
               $buffer = New-Object byte[] $valueSize
               [Buffer]::BlockCopy($blob, $dataOffset, $buffer, 0, $valueSize)
               $raw = [Encoding]::Unicode.GetString($buffer)
               $result = $raw -split "`0" | Where-Object { $_ -ne '' }
            }
        }

        $SLDATATYPE.SL_DATA_SUM { # SL_DATA_SUM = Custom (100)
            # Handle this case accordingly (based on your logic)
            $result = $null
        }

        default {
            # Return null for any unsupported data types
            $result = $null
        }
    }

    return $result
}

<#
Check if a specific Sku is token based edition
#>
Function IsTokenBasedEdition {
    param (
        [Parameter(Mandatory=$false)]
        [GUID]$SkuId,

        [Parameter(Mandatory=$false)]
        [GUID]$LicenseFileId,

        [Parameter(Mandatory=$false)]
        [Intptr]$hSLC = [IntPtr]::Zero
    )

    if (-not $hSLC -or $hSLC -eq [IntPtr]::Zero -or $hSLC -eq 0) {
        $hSLC = if ($global:hSLC_ -and $global:hSLC_ -ne [IntPtr]::Zero -and $global:hSLC_ -ne 0) {
            $global:hSLC_
        } else {
            Manage-SLHandle
        }
    }

    try {
        $closeHandle = $true
        if (-not $hSLC -or $hSLC -eq [IntPtr]::Zero -or $hSLC -eq 0) {
            $hr = $Global:SLC::SLOpen([ref]$hSLC)
            if ($hr -ne 0) {
                throw "SLOpen failed: HRESULT 0x{0:X8}" -f $hr
            }
        } else {
            $closeHandle = $false
        }
    }
    catch {
    }

    try {
        if ((-not $LicenseFileId -and -not $SkuId) -or (
            $LicenseFileId -and $SkuId)) {
                throw "Not a valid choice."
        }

        [Guid]$LicenseFile = [guid]::Empty

        if ($SkuId) {
            $LicenseFile = Retrieve-SKUInfo -SkuId $SkuId -eReturnIdType SL_ID_LICENSE_FILE
        }
        else {
            $LicenseFile = $LicenseFileId
        }

        [IntPtr]$TokenActivationGrants = [IntPtr]::Zero
        if ($LicenseFile -ne ([guid]::empty)) {
            $hrsults = $Global:slc::SLGetTokenActivationGrants(
                $hSLC, [ref]$LicenseFile, [ref]$TokenActivationGrants
            )
                    
            if ($hrsults -ne 0) {
                $errorMessege = Parse-ErrorMessage -MessageId $hrsults -Flags ([ErrorMessageType]::ACTIVATION -bor [ErrorMessageType]::HRESULT)
                Write-Warning "$($hrsults): $($errorMessege)"
                $result = $false
            }
            else {
                $null = $Global:slc::SLFreeTokenActivationGrants(
                    $TokenActivationGrants)
                $result = $true
            }

            return $result
        }
        throw "cant parse GUID"
    }
    finally {
        if ($closeHandle) {
            Write-Warning "Consider Open handle Using Manage-SLHandle"
            Free-IntPtr -handle $hSLC -Method License
        }
    }
}

<#
.SYNOPSIS

$fileId = '?'
$LicenseId = '?'
$OfficeAppId  = '0ff1ce15-a989-479d-af46-f275c6370663'
$windowsAppID  = '55c92734-d682-4d71-983e-d6ec3f16059f'
$enterprisesn = '7103a333-b8c8-49cc-93ce-d37c09687f92'

# should return $OfficeAppId & $windowsAppID
Write-Warning 'Get all installed application IDs.'
Get-SLIDList -eQueryIdType SL_ID_APPLICATION -eReturnIdType SL_ID_APPLICATION
Read-Host

# should return All Office & windows installed SKU
Write-Warning 'Get all installed product SKU IDs.'
Get-SLIDList -eQueryIdType SL_ID_PRODUCT_SKU -eReturnIdType SL_ID_PRODUCT_SKU
Read-Host

# should return $SKU per group <Office -or windows>
Write-Warning 'Get SKU IDs according to the input application ID.'
Get-SLIDList -eQueryIdType SL_ID_APPLICATION -eReturnIdType SL_ID_PRODUCT_SKU -pQueryId $OfficeAppId
Get-SLIDList -eQueryIdType SL_ID_APPLICATION -eReturnIdType SL_ID_PRODUCT_SKU -pQueryId $windowsAppID
Read-Host

# should return $windowsAppID or $OfficeAppId
Write-Warning 'Get application IDs according to the input SKU ID.'
Get-SLIDList -eQueryIdType SL_ID_PRODUCT_SKU -eReturnIdType SL_ID_APPLICATION -pQueryId $enterprisesn
Read-Host

# Same As SLGetInstalledProductKeyIds >> SL_ID_PKEY >> SLGetPKeyInformation >> BLOB
Write-Warning 'Get license PKey IDs according to the input SKU ID.'
Get-SLIDList -eQueryIdType SL_ID_PRODUCT_SKU -eReturnIdType SL_ID_PKEY -pQueryId $enterprisesn 
Read-Host

Write-Warning 'Get license file Ids according to the input SKU ID.'
Get-SLIDList -eQueryIdType SL_ID_PRODUCT_SKU -eReturnIdType SL_ID_LICENSE_FILE -pQueryId $enterprisesn 
Read-Host

Write-Warning 'Get license IDs according to the input license file ID.'
Get-SLIDList -eQueryIdType SL_ID_LICENSE_FILE -eReturnIdType SL_ID_LICENSE -pQueryId $fileId 
Read-Host

Write-Warning 'Get license file ID according to the input license ID.'
Get-SLIDList -eQueryIdType SL_ID_LICENSE -pQueryId $LicenseId -eReturnIdType SL_ID_LICENSE_FILE
Read-Host

Write-Warning 'Get License File Id according to the input License Id'
Get-SLIDList -eQueryIdType SL_ID_LICENSE -pQueryId $LicenseId -eReturnIdType SL_ID_LICENSE_FILE
Read-Host

write-warning "Get union of all application IDs or SKU IDs from all grants of a token activation license."
write-warning "Returns SL_E_NOT_SUPPORTED if the license ID is valid but doesn't refer to a token activation license."
Get-SLIDList -eQueryIdType SL_ID_LICENSE -pQueryId $LicenseId -eReturnIdType SL_ID_APPLICATION

write-warning "Get union of all application IDs or SKU IDs from all grants of a token activation license."
write-warning "Returns SL_E_NOT_SUPPORTED if the license ID is valid but doesn't refer to a token activation license."
Get-SLIDList -eQueryIdType SL_ID_LICENSE -pQueryId $LicenseId -eReturnIdType SL_ID_PRODUCT_SKU

# SLUninstallLicense >> [in] const SLID *pLicenseFileId
Write-Warning 'Get License File IDs associated with a specific Application ID:'
Get-SLIDList -eQueryIdType SL_ID_APPLICATION -pQueryId $OfficeAppId -eReturnIdType SL_ID_ALL_LICENSE_FILES
Read-Host

Write-Warning 'Get License File IDs associated with a specific Application ID:'
Get-SLIDList -eQueryIdType SL_ID_APPLICATION -pQueryId $OfficeAppId -eReturnIdType SL_ID_ALL_LICENSES
Read-Host

$LicensingProducts = (
    Get-SLIDList -eQueryIdType SL_ID_APPLICATION -eReturnIdType SL_ID_PRODUCT_SKU -pQueryId $windowsAppID | ? { Retrieve-SKUInfo -SkuId $_ -eReturnIdType SL_ID_PKEY }
    ) | % {
    [PSCustomObject]@{
        ID            = $_
        Description   = Get-LicenseDetails -ActConfigId $_ -pwszValueName 'Description'
        Name          = Get-LicenseDetails -ActConfigId $_ -pwszValueName 'productName'
        LicenseFamily = Get-LicenseDetails -ActConfigId $_ -pwszValueName 'Family'
    }
}
#>
enum eQueryIdType {
    SL_ID_APPLICATION = 0
    SL_ID_PRODUCT_SKU = 1
    SL_ID_LICENSE_FILE = 2
    SL_ID_LICENSE = 3
}
enum eReturnIdType {
    SL_ID_APPLICATION = 0
    SL_ID_PRODUCT_SKU = 1
    SL_ID_LICENSE_FILE = 2
    SL_ID_LICENSE = 3
    SL_ID_PKEY = 4
    SL_ID_ALL_LICENSES = 5
    SL_ID_ALL_LICENSE_FILES = 6
}
function Get-SLIDList {
    param(
        [Parameter(Mandatory=$true)]
        [ValidateSet("SL_ID_APPLICATION", "SL_ID_PRODUCT_SKU", "SL_ID_LICENSE_FILE", "SL_ID_LICENSE")]
        [string]$eQueryIdType,

        [Parameter(Mandatory=$true)]
        [ValidateSet("SL_ID_APPLICATION", "SL_ID_PRODUCT_SKU", "SL_ID_LICENSE", "SL_ID_PKEY", "SL_ID_ALL_LICENSES", "SL_ID_ALL_LICENSE_FILES", "SL_ID_LICENSE_FILE")]
        [string]$eReturnIdType,

        [Parameter(Mandatory=$false)]
        [ValidateNotNullOrEmpty()]
        [string]$pQueryId = $null,

        [Parameter(Mandatory=$false)]
        [Intptr]$hSLC = [IntPtr]::Zero
    )
    
    $dummyGuid = [Guid]::Empty
    $QueryIdValidation = ($eQueryIdType -ne $eReturnIdType) -and [string]::IsNullOrWhiteSpace($pQueryId)
    $GuidValidation = (-not [string]::IsNullOrWhiteSpace($pQueryId)) -and (
        -not [Guid]::TryParse($pQueryId, [ref]$dummyGuid) -or
        ($dummyGuid -eq [Guid]::Empty)
    )
    $AppIDValidation = ($eQueryIdType -ne [eQueryIdType]::SL_ID_APPLICATION) -and ($eReturnIdType.ToString() -match '_ALL_')
    $AppGUIDValidation = ($eQueryIdType -eq [eQueryIdType]::SL_ID_APPLICATION) -and ($eReturnIdType -ne $eQueryIdType) -and
                        (-not ($knownAppGuids -contains $pQueryId))

    if ($AppIDValidation -or $QueryIdValidation -or $GuidValidation -or $AppGUIDValidation) {
        Write-Warning "Invalid parameters:"

        if ($AppIDValidation) {
            "  - _ALL_ types are allowed only with SL_ID_APPLICATION"
            return  }

        if ($QueryIdValidation -and $GuidValidation) {
            "  - A valid, non-empty pQueryId is required when source and target types differ"
            return }

        if ($QueryIdValidation -and $AppGUIDValidation) {
            if ($eQueryIdType -eq [eQueryIdType]::SL_ID_APPLICATION) {
                try {
                    $output = foreach ($appId in $Global:knownAppGuids) {
                        Get-SLIDList -eQueryIdType $eQueryIdType -eReturnIdType $eReturnIdType -pQueryId $appId
                    }
                }
                catch {
                    Write-Warning "An error occurred while attempting to retrieve results with known GUIDs: $_"
                }

                if ($output) {
                    return $output.Guid
                } else {
                    Write-Warning "No valid results returned for the known Application GUIDs."
                    return
                }
            }

            Write-Warning "  - pQueryId must be a known Application GUID when source is SL_ID_APPLICATION and target differs"
            return
        }

        if ($QueryIdValidation) {
            "  - A valid pQueryId is required when source and target types differ"
            return }

        if ($GuidValidation) {
            "  - pQueryId must be a non-empty valid GUID"
            return }

        if ($AppGUIDValidation) {
            "  - pQueryId must match a known Application GUID when source is SL_ID_APPLICATION and target differs"
            return }
    }


    $eQueryIdTypeInt = [eQueryIdType]::$eQueryIdType
    $eReturnIdTypeInt = [eReturnIdType]::$eReturnIdType

    $queryIdPtr = [IntPtr]::Zero 
    $gch = $null                 

    $pnReturnIds = 0
    $ppReturnIds = [IntPtr]::Zero
    
    $needToCloseLocalHandle = $true
    $currentHSLC = if ($hSLC -and $hSLC -ne [IntPtr]::Zero -and $hSLC -ne 0) {
        $hSLC
    } elseif ($global:hSLC_ -and $global:hSLC_ -ne [IntPtr]::Zero -and $global:hSLC_ -ne 0) {
        $global:hSLC_
    } else {
        Manage-SLHandle
    }

    try {
        if (-not $currentHSLC -or $currentHSLC -eq [IntPtr]::Zero -or $currentHSLC -eq 0) {
            $hresult = $Global:SLC::SLOpen([ref]$currentHSLC)
            
            if ($hresult -ne 0) {
                $uint32Value = $hresult -band 0xFFFFFFFF
                $hexString = "0x{0:X8}" -f $uint32Value
                throw "Failed to open SLC handle. HRESULT: $hexString"
            }
        } else {
            $needToCloseLocalHandle = $false
        }
        
        if ($pQueryId) {
            if ($pQueryId -match '^[{]?[0-9A-Fa-f]{8}-[0-9A-Fa-f]{4}-[0-9A-Fa-f]{4}-[0-9A-Fa-f]{4}-[0-9A-Fa-f]{12}[}]?$') {
                $queryGuid = [Guid]$pQueryId
                $bytes = $queryGuid.ToByteArray()
                $gch = [GCHandle]::Alloc($bytes, [GCHandleType]::Pinned)
                $queryIdPtr = $gch.AddrOfPinnedObject()
            } else {
                $queryIdPtr = [Marshal]::StringToHGlobalUni($pQueryId)
            }
        } else {
            $queryIdPtr = [IntPtr]::Zero
        }

        $result = $Global:SLC::SLGetSLIDList($currentHSLC, $eQueryIdTypeInt, $queryIdPtr, $eReturnIdTypeInt, [ref]$pnReturnIds, [ref]$ppReturnIds)
        if ($result -eq 0 -and $pnReturnIds -gt 0 -and $ppReturnIds -ne [IntPtr]::Zero) {
            $guidList = @()

            foreach ($i in 0..($pnReturnIds - 1)) {
                $currentPtr = [IntPtr]([Int64]$ppReturnIds + [Int64]16 * $i)
                $guidBytes = New-Object byte[] 16
                [Marshal]::Copy($currentPtr, $guidBytes, 0, 16)
                $guidList += (New-Object Guid (,$guidBytes))
            }
            return $guidList
        } else {
            $uint32Value = $result -band 0xFFFFFFFF
            $hexString = "0x{0:X8}" -f $uint32Value
            if ($result -eq 0xC004F012) {
                return @()
            } else {
                throw "Failed to retrieve ID list. HRESULT: $hexString"
            }
        }
    } catch {
        Write-Warning "Error in Get-SLIDList (QueryIdType: $($eQueryIdType), ReturnIdType: $($eReturnIdType), pQueryId: $($pQueryId)): $($_.Exception.Message)"
        throw $_
    } finally {

        if ($ppReturnIds -ne [IntPtr]::Zero) {
            $null = $Global:kernel32::LocalFree($ppReturnIds)
            $ppReturnIds = [IntPtr]::Zero
        }
        if ($queryIdPtr -ne [IntPtr]::Zero -and $gch -eq $null) {
            [Marshal]::FreeHGlobal($queryIdPtr)
            $queryIdPtr = [IntPtr]::Zero
        }
        if ($gch -ne $null -and $gch.IsAllocated) {
            $gch.Free()
            $gch = $null
        }

        if ($needToCloseLocalHandle -and $currentHSLC -ne [IntPtr]::Zero) {
            Free-IntPtr -handle $currentHSLC -Method License
            $currentHSLC = [IntPtr]::Zero
        }
    }
}

<#
.SYNOPSIS
Function Retrieve-SKUInfo retrieves related licensing IDs for a given SKU GUID.
Also, Support for SL_ID_ALL_LICENSES & SL_ID_ALL_LICENSE_FILES, Only for Application-ID

Specific SKUs require particular IDs:
- The SKU for SLUninstallLicense requires the ID_LICENSE_FILE GUID.
- The SKU for SLUninstallProofOfPurchase requires the ID_PKEY GUID.

Optional Pointer: Handle to the Software Licensing Service (SLC).
Optional eReturnIdType: Type of ID to return (e.g., SL_ID_APPLICATION, SL_ID_PKEY, etc.).
#>
function Retrieve-SKUInfo {
    param(
        [Parameter(Mandatory = $true)]
        [ValidatePattern('^[{]?[0-9A-Fa-f]{8}-[0-9A-Fa-f]{4}-[0-9A-Fa-f]{4}-[0-9A-Fa-f]{4}-[0-9A-Fa-f]{12}[}]?$')]
        [string]$SkuId,

        [Parameter(Mandatory = $false)]
        [ValidateSet("SL_ID_APPLICATION", "SL_ID_PRODUCT_SKU", "SL_ID_LICENSE", "SL_ID_PKEY", "SL_ID_ALL_LICENSES", "SL_ID_ALL_LICENSE_FILES", "SL_ID_LICENSE_FILE")]
        [string]$eReturnIdType,

        [Parameter(Mandatory=$false)]
        [Intptr]$hSLC = [IntPtr]::Zero
    )

    # Define once at the top
    $Is__ALL = $eReturnIdType -match '_ALL_'
    $IsAppID = $Global:knownAppGuids -contains $SkuId

    # XOR Case, Check if Both Valid, if one valid, exit
    if ($Is__ALL -xor $IsAppID) {
        Write-Warning "ApplicationID Work with SL_ID_ALL_LICENSES -or SL_ID_ALL_LICENSE_FILES Only!"
        return $null
    }

    function Get-IDs {
        param (
            [string]$returnType,
            [Intptr]$hSLC
        )
        try {
            if ($IsAppID) {
                return Get-SLIDList -eQueryIdType SL_ID_APPLICATION -eReturnIdType $returnType -pQueryId $SkuId -hSLC $hSLC
            } else {
                return Get-SLIDList -eQueryIdType SL_ID_PRODUCT_SKU -eReturnIdType $returnType -pQueryId $SkuId -hSLC $hSLC
            }
        } catch {
            Write-Warning "Get-SLIDList call failed for $returnType and $SkuId"
            return $null
        }
    }

    $product = [Guid]$SkuId

    if (-not $hSLC -or $hSLC -eq [IntPtr]::Zero -or $hSLC -eq 0) {
        $hSLC = if ($global:hSLC_ -and $global:hSLC_ -ne [IntPtr]::Zero -and $global:hSLC_ -ne 0) {
            $global:hSLC_
        } else {
            Manage-SLHandle
        }
    }

    try {
        $closeHandle = $true
        if (-not $hSLC -or $hSLC -eq [IntPtr]::Zero -or $hSLC -eq 0) {
            $hr = $Global:SLC::SLOpen([ref]$hSLC)
            if ($hr -ne 0) {
                throw "SLOpen failed: HRESULT 0x{0:X8}" -f $hr
            }
        } else {
            $closeHandle = $false
        }
    }
    catch {
        return $null
    }

    try {
        # [SL_ID_LICENSE_FILE] Case
        [Guid]$fileId = try {
            [Guid]::Parse((Get-LicenseDetails -ActConfigId $product -pwszValueName fileId -hSLC $hSLC).Trim().Substring(0,36))
        }
        catch {
            [GUID]::Empty
        }

        # [SL_ID_LICENSE] Case **Alternative**
        [Guid]$licenseId = try {
            [Guid]::Parse((Get-LicenseDetails -ActConfigId $product -pwszValueName licenseId -hSLC $hSLC).Trim().Substring(0,36))
        } catch {
            [Guid]::Empty
        }

        [Guid]$privateCertificateId = try {
            [Guid]::Parse((Get-LicenseDetails -ActConfigId $product -pwszValueName privateCertificateId -hSLC $hSLC).Trim().Substring(0,36))
        } catch {
            [Guid]::Empty
        }

        # [SL_ID_APPLICATION] Case **Alternative**
        [Guid]$applicationId = try {
            [Guid]::Parse((Get-LicenseDetails -ActConfigId $product -pwszValueName applicationId -hSLC $hSLC).Trim().Substring(0,36))
        } catch {
            [Guid]::Empty
        }

        # [SL_ID_PKEY] Case **Alternative**
        [Guid]$pkId = try {
            [Guid]::Parse((Get-LicenseDetails -ActConfigId $product -pwszValueName pkeyIdList -hSLC $hSLC).Trim().Substring(0,36)) # Instead `pkeyId`
        } catch {
            [Guid]::Empty
        }

        [uint32]$countRef = 0
        [IntPtr]$ppKeyIds = [intPtr]::Zero
        [GUID]$pKeyId = [GUID]::Empty
        [uint32]$hresults = $Global:SLC::SLGetInstalledProductKeyIds(
            $hSLC, [ref]$product, [ref]$countRef, [ref]$ppKeyIds)
        if ($hresults -eq 0) {
            if ($countRef -gt 0 -and (
                $ppKeyIds -ne [IntPtr]::Zero)) {
                    if ($ppKeyIds.ToInt64() -gt 0) {
                        try {
                            $buffer = New-Object byte[] 16
                            [Marshal]::Copy($ppKeyIds, $buffer, 0, 16)
                            $pKeyId = [Guid]::new($buffer)
                        }
                        catch {
                            $pKeyId = $null
                        }
        }}}

        # -------------------------------------------------

        if (-not $eReturnIdType) {
            $SKU_DATA = [pscustomobject]@{
                ID_SKU          = $SkuId
                ID_APPLICATION  = if ($applicationId -and $applicationId -ne [Guid]::Empty) { $applicationId } else { try { Get-IDs SL_ID_APPLICATION -hSLC $hSLC } catch { [Guid]::Empty } }
                ID_PKEY         = if ($pkId -and $pkId -ne [Guid]::Empty) { $pkId } elseif ($Product_SKU_ID -and $Product_SKU_ID -ne [Guid]::Empty) { $Product_SKU_ID } else { try { Get-IDs SL_ID_PKEY -hSLC $hSLC } catch { [Guid]::Empty } }
                ID_LICENSE_FILE = if ($fileId -and $fileId -ne [Guid]::Empty) { $fileId } else { try { Get-IDs SL_ID_LICENSE_FILE -hSLC $hSLC } catch { [Guid]::Empty } }
                ID_LICENSE      = if (($licenseId -and $privateCertificateId) -and ($licenseId -ne [Guid]::Empty -and $privateCertificateId -ne [Guid]::Empty)) { @($licenseId, $privateCertificateId) } else { try { Get-IDs SL_ID_LICENSE -hSLC $hSLC } catch { [Guid]::Empty } }
            }
            return $SKU_DATA
        }

        switch ($eReturnIdType) {
            "SL_ID_APPLICATION" {
                if ($applicationId -and $applicationId -ne [Guid]::Empty) {
                    return $applicationId
                }
                try { return Get-IDs SL_ID_APPLICATION -hSLC $hSLC } catch {}
                return [Guid]::Empty
            }

            "SL_ID_PRODUCT_SKU" {
                return $SkuId
            }

            "SL_ID_LICENSE" {
                if ($licenseId -and $privateCertificateId -and $licenseId -ne [Guid]::Empty -and $privateCertificateId -ne [Guid]::Empty) {
                    return @($licenseId, $privateCertificateId)
                }
                try { return Get-IDs SL_ID_LICENSE -hSLC $hSLC } catch {}
                return [Guid]::Empty
            }

            "SL_ID_PKEY" {
                if ($pkId -and $pkId -ne [Guid]::Empty) {
                    return $pkId
                }
                if ($pKeyId -and $pKeyId -ne [Guid]::Empty) {
                    return $pKeyId
                }
                try { return Get-IDs SL_ID_PKEY -hSLC $hSLC } catch {}
                return [Guid]::Empty
            }

            "SL_ID_ALL_LICENSES" {
                try { return Get-IDs SL_ID_ALL_LICENSES -hSLC $hSLC } catch {}
                return [Guid]::Empty
            }

            "SL_ID_ALL_LICENSE_FILES" {
                try { return Get-IDs SL_ID_ALL_LICENSE_FILES -hSLC $hSLC } catch {}
                return [Guid]::Empty
            }

            "SL_ID_LICENSE_FILE" {
                if ($fileId -and $fileId -ne [Guid]::Empty) {
                    return $fileId
                }

                # it possible using Get-SLIDList to convert SKU > ID_LICENSE > ID_LICENSE_FILE, but not directly.!
                try { return Get-SLIDList -eQueryIdType SL_ID_LICENSE -eReturnIdType SL_ID_LICENSE_FILE -pQueryId $licenseId } catch {}
                try { return Get-SLIDList -eQueryIdType SL_ID_LICENSE -eReturnIdType SL_ID_LICENSE_FILE -pQueryId $privateCertificateId } catch {}
                return [Guid]::Empty
            }
            default {
                return [Guid]::Empty
            }
        }
    }
    finally {

        if ($null -ne $ppKeyIds -and (
            $ppKeyIds -ne [IntPtr]::Zero) -and (
                $ppKeyIds -ne 0)) {
                    $null = $Global:kernel32::LocalFree($ppKeyIds)
        }

        if ($closeHandle) {
            Write-Warning "Consider Open handle Using Manage-SLHandle"
            Free-IntPtr -handle $hSLC -Method License
        }
    }
}

<#
.SYNOPSIS
Function Receive license data as Config or License file
#>
function Get-LicenseData {
    [CmdletBinding()]
    param(
        [Parameter(Mandatory=$true)]
        [ValidateNotNullOrEmpty()]
        [Guid]$SkuID,

        [Parameter(Mandatory=$false)]
        [Intptr]$hSLC = [IntPtr]::Zero,

        [ValidateNotNullOrEmpty()]
        [ValidateSet("License", "Config")]
        [string]$Mode
    )

    if (-not $hSLC -or $hSLC -eq [IntPtr]::Zero -or $hSLC -eq 0) {
        $hSLC = if ($global:hSLC_ -and $global:hSLC_ -ne [IntPtr]::Zero -and $global:hSLC_ -ne 0) {
            $global:hSLC_
        } else {
            Manage-SLHandle
        }
    }

    try {
        $closeHandle = $true
        if (-not $hSLC -or $hSLC -eq [IntPtr]::Zero -or $hSLC -eq 0) {
            $hr = $Global:SLC::SLOpen([ref]$hSLC)
            if ($hr -ne 0) {
                throw "SLOpen failed: HRESULT 0x{0:X8}" -f $hr
            }
        } else {
            $closeHandle = $false
        }
    }
    catch {
        return $null
    }
	
    try {
        $fileGuid = [guid]::Empty
        if ($Mode -eq 'License') {
            $fileGuid = Retrieve-SKUInfo -SkuId $SkuID -eReturnIdType SL_ID_LICENSE_FILE
        }
        if ($Mode -eq 'Config') {
            $LicenseId = Get-LicenseDetails -ActConfigId $SkuID -pwszValueName pkeyConfigLicenseId
            $fileGuid = Retrieve-SKUInfo -SkuId $LicenseId -eReturnIdType SL_ID_LICENSE_FILE
        }
        if (-not $fileGuid -or (
	        [guid]$fileGuid -eq [GUID]::Empty)) {
		        return $null
        }

        $count = 0
        $ppbLicenseFile = [IntPtr]::Zero
        $res = $global:SLC::SLGetLicense($hSLC, [ref]$fileGuid, [ref]$count, [ref]$ppbLicenseFile)
        if ($res -ne 0) { throw "SLGetLicense failed (code $res)" }
        $blob = New-Object byte[] $count
        [Marshal]::Copy($ppbLicenseFile, $blob, 0, $count)
        $content = [Text.Encoding]::UTF8.GetString($blob)
        return $content

    }
    finally {
        Free-IntPtr -handle $ppbLicenseFile -Method Local
        if ($closeHandle) {
            Write-Warning "Consider Open handle Using Manage-SLHandle"
            Free-IntPtr -handle $hSLC -Method License
        }
    }
}

<#
.SYNOPSIS
Function Retrieve-SKUInfo retrieves related licensing IDs for a given SKU GUID.
Convert option, CD-KEY->Ref/ID, Ref->SKU, SKU->Ref
#>
function Retrieve-ProductKeyInfo {
    param (
        [ValidateScript({ $_ -ne $null -and $_ -ne [guid]::Empty })]
        [guid]$SkuId,

        [ValidateScript({ $_ -ne $null -and $_ -gt 0 })]
        [int]$RefGroupId,

        [ValidateScript({ $_ -match '^(?i)[A-Z0-9]{5}(-[A-Z0-9]{5}){4}$' })]
        [string]$CdKey
    )

    # Validate only one parameter
    $paramsProvided = @($SkuId, $RefGroupId, $CdKey) | Where-Object { $_ }
    if ($paramsProvided.Count -ne 1) {
        Write-Warning "Please specify exactly one of -SkuId, -RefGroupId, or -CdKey"
        return $null
    }

    # SkuId to RefGroupId
    if ($SkuId) {
        $entry = $Global:PKeyDatabase | Where-Object { $_.ActConfigId -eq "{$SkuId}" } | Select-Object -First 1
        if ($entry) {
            return $entry.RefGroupId
        } else {
            Write-Warning "RefGroupId not found for SkuId: $SkuId"
            return $null
        }
    }

    # RefGroupId to SkuId
    elseif ($RefGroupId) {
        $entry = $Global:PKeyDatabase | Where-Object { $_.RefGroupId -eq $RefGroupId } | Select-Object -First 1
        if ($entry) {
            return [guid]($entry.ActConfigId -replace '[{}]', '')
        } else {
            Write-Warning "ActConfigId not found for RefGroupId: $RefGroupId"
            return $null
        }
    }

    # CdKey to RefGroupId to SkuId
    elseif ($CdKey) {
        try {
            $decoded = KeyDecode -key0 $CdKey.Substring(0,29)
            $refGroupFromKey = [int]$decoded[2].Value

            $entry = $Global:PKeyDatabase | Where-Object { $_.RefGroupId -eq $refGroupFromKey } | Select-Object -First 1
            if ($entry) {
                return [PSCustomObject]@{
                    RefGroupId = $refGroupFromKey
                    SkuId      = [guid]($entry.ActConfigId -replace '[{}]', '')
                }
            } else {
                Write-Warning "SKU not found for RefGroupId $refGroupFromKey extracted from CD Key"
                return $null
            }
        } catch {
            Write-Warning "Failed to decode CD Key: $_"
            return $null
        }
    }
}

<#
.SYNOPSIS
    Fires a licensing state change event after installing or removing a license/key.
#>
function Fire-LicensingStateChangeEvent {
    param (
        [Parameter(Mandatory=$true)]
        [IntPtr]$hSLC
    )
    
    if (-not $hSLC -or $hSLC -eq [IntPtr]::Zero -or $hSLC -eq 0) {
        $hSLC = if ($global:hSLC_ -and $global:hSLC_ -ne [IntPtr]::Zero -and $global:hSLC_ -ne 0) {
            $global:hSLC_
        } else {
            Manage-SLHandle
        }
    }

    try {
        $closeHandle = $true
        if (-not $hSLC -or $hSLC -eq [IntPtr]::Zero -or $hSLC -eq 0) {
            $hr = $Global:SLC::SLOpen([ref]$hSLC)
            if ($hr -ne 0) {
                throw "SLOpen failed: HRESULT 0x{0:X8}" -f $hr
            }
        } else {
            $closeHandle = $false
        }
    }
    catch {
        return $null
    }

    try {
        $SlEvent = "msft:rm/event/licensingstatechanged"
        $WindowsSlid = New-Object Guid($Global:windowsAppID)
        $OfficeSlid  = New-Object Guid($Global:OfficeAppId)
        ($WindowsSlid, $OfficeSlid) | % {
            $hrEvent = $Global:SLC::SLFireEvent(
                $hSLC,  # Using the IntPtr (acting like a pointer)
                $SlEvent, 
                [ref]$_
            )

            # Check if the event firing was successful (HRESULT 0 means success)
            if ($hrEvent -eq 0) {
                Write-Host "Licensing state change event fired successfully."
            } else {
                Write-Host "Failed to fire licensing state change event. HRESULT: $hrEvent"
            }
        }
    }
    finally {
        if ($closeHandle) {
            Write-Warning "Consider Open handle Using Manage-SLHandle"
            Free-IntPtr -handle $hSLC -Method License
        }
    }
}

<#
.SYNOPSIS
    Re-Arm Specific ID <> SKU.
#>
Function SL-ReArm {
    param (
        [Parameter(Mandatory=$false)]
        [ValidateSet(
            '0ff1ce15-a989-479d-af46-f275c6370663',
            '55c92734-d682-4d71-983e-d6ec3f16059f'
        )]
        [GUID]$AppID,

        [Parameter(Mandatory=$false)]
        [GUID]$skuID,

        [Parameter(Mandatory=$false)]
        [Intptr]$hSLC = [IntPtr]::Zero
    )

    if (-not $hSLC -or $hSLC -eq [IntPtr]::Zero -or $hSLC -eq 0) {
        $hSLC = if ($global:hSLC_ -and $global:hSLC_ -ne [IntPtr]::Zero -and $global:hSLC_ -ne 0) {
            $global:hSLC_
        } else {
            Manage-SLHandle
        }
    }

    try {
        $closeHandle = $true
        if (-not $hSLC -or $hSLC -eq [IntPtr]::Zero -or $hSLC -eq 0) {
            $hr = $Global:SLC::SLOpen([ref]$hSLC)
            if ($hr -ne 0) {
                throw "SLOpen failed: HRESULT 0x{0:X8}" -f $hr
            }
        } else {
            $closeHandle = $false
        }
    }
    catch {
    }

    try {
        if (-not $AppID -or -not $skuID) {
            $hrsults = $Global:slc::SLReArmWindows()
        }
        elseif ($AppID -and $skuID) {
            $AppID_ = [GUID]::new($AppID)
            $skuID_ = [GUID]::new($skuID)
            $hrsults = $Global:slc::SLReArm(
                $hSLC, [ref]$AppID_, [REF]$skuID_, 0)
        }        
        if ($hrsults -ne 0) {
            $errorMessege = Parse-ErrorMessage -MessageId $hrsults -Flags ([ErrorMessageType]::ACTIVATION -bor [ErrorMessageType]::HRESULT)
            Write-Warning "$($hrsults): $($errorMessege)"
        }
        return $hrsults
    }
    finally {
        if ($closeHandle) {
            Write-Warning "Consider Open handle Using Manage-SLHandle"
            Free-IntPtr -handle $hSLC -Method License
        }
    }
}

<#
.SYNOPSIS
    Activate Specific SKU.
#>
Function SL-Activate {
    param (
        [Parameter(Mandatory=$true)]
        [GUID]$skuID,

        [Parameter(Mandatory=$false)]
        [Intptr]$hSLC = [IntPtr]::Zero
    )

    if (-not $hSLC -or $hSLC -eq [IntPtr]::Zero -or $hSLC -eq 0) {
        $hSLC = if ($global:hSLC_ -and $global:hSLC_ -ne [IntPtr]::Zero -and $global:hSLC_ -ne 0) {
            $global:hSLC_
        } else {
            Manage-SLHandle
        }
    }

    try {
        $closeHandle = $true
        if (-not $hSLC -or $hSLC -eq [IntPtr]::Zero -or $hSLC -eq 0) {
            $hr = $Global:SLC::SLOpen([ref]$hSLC)
            if ($hr -ne 0) {
                throw "SLOpen failed: HRESULT 0x{0:X8}" -f $hr
            }
        } else {
            $closeHandle = $false
        }
    }
    catch {
    }

    try {
        $skuID_ = [GUID]::new($skuID)
        $hrsults = $Global:slc::SLActivateProduct(
            $hSLC, [REF]$skuID_, 0,[IntPtr]::Zero,[IntPtr]::Zero,$null,0)

        if ($hrsults -ne 0) {
            $errorMessege = Parse-ErrorMessage -MessageId $hrsults -Flags ([ErrorMessageType]::ACTIVATION -bor [ErrorMessageType]::HRESULT)
            Write-Warning "$errorMessege, $hresult"
        }
        return $hrsults
    }
    finally {
        if ($closeHandle) {
            Write-Warning "Consider Open handle Using Manage-SLHandle"
            Free-IntPtr -handle $hSLC -Method License
        }
    }
}

<#
.SYNOPSIS
   WMI -> RefreshLicenseStatus
#>
Function SL-RefreshLicenseStatus {
    param (
        [Parameter(Mandatory=$false)]
        [ValidateSet(
            '0ff1ce15-a989-479d-af46-f275c6370663',
            '55c92734-d682-4d71-983e-d6ec3f16059f'
        )]
        [GUID]$AppID,

        [Parameter(Mandatory=$false)]
        [GUID]$skuID,

        [Parameter(Mandatory=$false)]
        [Intptr]$hSLC = [IntPtr]::Zero
    )

    if (-not $hSLC -or $hSLC -eq [IntPtr]::Zero -or $hSLC -eq 0) {
        $hSLC = if ($global:hSLC_ -and $global:hSLC_ -ne [IntPtr]::Zero -and $global:hSLC_ -ne 0) {
            $global:hSLC_
        } else {
            Manage-SLHandle
        }
    }

    try {
        $closeHandle = $true
        if (-not $hSLC -or $hSLC -eq [IntPtr]::Zero -or $hSLC -eq 0) {
            $hr = $Global:SLC::SLOpen([ref]$hSLC)
            if ($hr -ne 0) {
                throw "SLOpen failed: HRESULT 0x{0:X8}" -f $hr
            }
        } else {
            $closeHandle = $false
        }
    }
    catch {
    }

    try {
        if (-not $AppID -and -not $skuID) {
            $hrsults = $Global:slc::SLConsumeWindowsRight($hSLC)
        }
        elseif ($AppID) {
            $AppID_ = [GUID]::new($AppID)
            if (-not $skuID) {
                $hrsults = $Global:slc::SLConsumeRight(
                    $hSLC, [ref]$AppID_, [IntPtr]::Zero, [IntPtr]::Zero, [IntPtr]::Zero)
            }
            else {
                $skuID_ = [GUID]::new($skuID)
                $skuIDPtr = New-IntPtr -Size 16
                try {
                    [Marshal]::StructureToPtr($skuID_, $skuIDPtr, $false)
                    $hrsults = $Global:slc::SLConsumeRight(
                        $hSLC, [ref]$AppID_, $skuIDPtr, [IntPtr]::Zero, [IntPtr]::Zero)
                }
                finally {
                    New-IntPtr -hHandle $skuIDPtr -Release
                }
            }
        }
        elseif ($skuID) {
            $skuID_ = [GUID]::new($skuID)
            $AppID_ = Retrieve-SKUInfo -SkuId $skuID -eReturnIdType SL_ID_APPLICATION
            if (-not $AppID_) {
                throw "Couldn't retrieve AppId for SKU: $skuID"
            }
            $skuIDPtr = New-IntPtr -Size 16
            try {
                [Marshal]::StructureToPtr($skuID_, $skuIDPtr, $false)
                $hrsults = $Global:slc::SLConsumeRight(
                    $hSLC, [ref]$AppID_, $skuIDPtr, [IntPtr]::Zero, [IntPtr]::Zero)
            }
            finally {
                New-IntPtr -hHandle $skuIDPtr -Release
            }
        }

        if ($hrsults -ne 0) {
            $errorMessege = Parse-ErrorMessage -MessageId $hrsults -Flags ([ErrorMessageType]::ACTIVATION -bor [ErrorMessageType]::HRESULT)
            Write-Warning "$($hrsults): $($errorMessege)"
        }
        return $hrsults
    }
    finally {
        if ($closeHandle) {
            Write-Warning "Consider Open handle Using Manage-SLHandle"
            Free-IntPtr -handle $hSLC -Method License
        }
    }
}

<#
.SYNOPSIS

Usage: KEY
SL-InstallProductKey -Keys "3HYJN-9KG99-F8VG9-V3DT8-JFMHV"
SL-InstallProductKey -Keys ("BW9HJ-N9HF7-7M9PW-3PBJR-37DCT","NJ8QJ-PYYXJ-F6HVQ-RYPFK-BKQ86","K8BH4-6TN3G-YXVMY-HBMMF-KBXPT","GMN9H-QCX29-F3JWJ-RYPKC-DDD86","TN6YY-MWHCT-T6PK2-886FF-6RBJ6")
#>
function SL-InstallProductKey {
    param (
        [Parameter(Mandatory = $true)]
        [string[]]$Keys,

        [Parameter(Mandatory=$false)]
        [Intptr]$hSLC = [IntPtr]::Zero
    )

    if (-not $hSLC -or $hSLC -eq [IntPtr]::Zero -or $hSLC -eq 0) {
        $hSLC = if ($global:hSLC_ -and $global:hSLC_ -ne [IntPtr]::Zero -and $global:hSLC_ -ne 0) {
            $global:hSLC_
        } else {
            Manage-SLHandle
        }
    }

    try {
        $closeHandle = $true
        if (-not $hSLC -or $hSLC -eq [IntPtr]::Zero -or $hSLC -eq 0) {
            $hr = $Global:SLC::SLOpen([ref]$hSLC)
            if ($hr -ne 0) {
                throw "SLOpen failed: HRESULT 0x{0:X8}" -f $hr
            }
        } else {
            $closeHandle = $false
        }
    }
    catch {
        return $null
    }

    [guid[]]$PKeyIdLst = @()

    try {
        if (-not $Keys) {
            Write-Warning "No product keys provided. Please provide at least one key."
            return $null
        }

        $invalidKeys = $Keys | Where-Object { [string]::IsNullOrWhiteSpace($_) }
        if ($invalidKeys.Count -gt 0) {
            Write-Warning "The following keys are invalid (empty or whitespace): $($invalidKeys -join ', ')"
            return $null
        }

        foreach ($key in $Keys) {
            $KeyBlob = [System.Text.Encoding]::UTF8.GetBytes($key)
            $KeyTypes = @(
                "msft:rm/algorithm/pkey/detect",
                "msft:rm/algorithm/pkey/2009",
                "msft:rm/algorithm/pkey/2007",
                "msft:rm/algorithm/pkey/2005"
            )

            $PKeyIdOut = [Guid]::NewGuid()
            $installationSuccess = $false

            foreach ($KeyType in $KeyTypes) {
                $hrInstall = $Global:SLC::SLInstallProofOfPurchase(
                    $hSLC,
                    $KeyType,
                    $key,            # Directly using the key string
                    0,               # PKeyDataSize is 0 (no additional data)
                    [IntPtr]::Zero,  # No additional data (zero pointer)
                    [ref]$PKeyIdOut
                )

                if ($hrInstall -eq 0) {
                    Write-Host "Proof of purchase installed successfully with KeyType: $KeyType. PKeyId: $PKeyIdOut"
                    $PKeyIdLst += $PKeyIdOut  # Add the successful GUID to the list
                    $installationSuccess = $true  # Mark success for this key
                    break
                }
            }

            if (-not $installationSuccess) {
                $errorMessege = Parse-ErrorMessage -MessageId $hrInstall -Flags ([ErrorMessageType]::ACTIVATION -bor [ErrorMessageType]::HRESULT)
                Write-Warning "Failed to install the proof of purchase for key $key. HRESULT: $hrInstall"
                Write-Warning "$($hrInstall): $($errorMessege)"
            }
        }
    }
    finally {

        Fire-LicensingStateChangeEvent -hSLC $hSLC     
        if ($closeHandle) {
            Write-Warning "Consider Open handle Using Manage-SLHandle"
            Free-IntPtr -handle $hSLC -Method License
        }
    }

    # Return list of successfully installed PKeyIds
    # return $PKeyIdLst
}

<#
.SYNOPSIS
Usage: KEY -OR SKU -OR PKEY
Usage: Remove Current Windows KEY

Example.
SL-UninstallProductKey -ClearKey $true
SL-UninstallProductKey -KeyLst ("3HYJN-9KG99-F8VG9-V3DT8-JFMHV", "JFMHV") -skuList @("dabaa1f2-109b-496d-bf49-1536cc862900") -pkeyList @("e953e4ac-7ce5-0401-e56c-70c13b8e5a82")
#>
function SL-UninstallProductKey {
    param (
        [Parameter(Mandatory = $false)]
        [string[]]$KeyLst,  # List of partial product keys (optional)

        [Parameter(Mandatory = $false)]
        [GUID[]]$skuList,  # List of GUIDs (optional)

        [Parameter(Mandatory = $false)]
        [GUID[]]$pkeyList,  # List of GUIDs (optional),

        [Parameter(Mandatory=$false)]
        [Intptr]$hSLC = [IntPtr]::Zero,

        [Parameter(Mandatory=$false)]
        [switch]$ClearKey
    )

    if (-not $hSLC -or $hSLC -eq [IntPtr]::Zero -or $hSLC -eq 0) {
        $hSLC = if ($global:hSLC_ -and $global:hSLC_ -ne [IntPtr]::Zero -and $global:hSLC_ -ne 0) {
            $global:hSLC_
        } else {
            Manage-SLHandle
        }
    }

    try {
        $closeHandle = $true
        if (-not $hSLC -or $hSLC -eq [IntPtr]::Zero -or $hSLC -eq 0) {
            $hr = $Global:SLC::SLOpen([ref]$hSLC)
            if ($hr -ne 0) {
                throw "SLOpen failed: HRESULT 0x{0:X8}" -f $hr
            }
        } else {
            $closeHandle = $false
        }
    }
    catch {
        return $null
    }

    try {
        # Initialize the list to hold GUIDs
        $guidList = @()

        if (-not ($skuList -or $KeyLst -or $pkeyList) -and !$ClearKey) {
            Write-Warning "No provided SKU or Key"
            return
        }
        
        $validSkuList = @()
        $validCdKeys  = @()
        $validPkeyList = @()
        if ($KeyLst) {
            foreach ($key in $KeyLst) {
                if ($key.Length -eq 5 -or $key -match '^[A-Z0-9]{5}(-[A-Z0-9]{5}){4}$') {
                    $validCdKeys += $key
                }}}
        if ($skuList) {
            foreach ($sku in $skuList) {
                if ($sku -match '^[{]?[0-9A-Fa-f]{8}-[0-9A-Fa-f]{4}-[0-9A-Fa-f]{4}-[0-9A-Fa-f]{4}-[0-9A-Fa-f]{12}[}]?$') {
                    $validSkuList += [guid]$sku  }}}
        if ($pkeyList) {
            foreach ($pkey in $pkeyList) {
                if ($pkey -match '^[{]?[0-9A-Fa-f]{8}-[0-9A-Fa-f]{4}-[0-9A-Fa-f]{4}-[0-9A-Fa-f]{4}-[0-9A-Fa-f]{12}[}]?$') {
                    $validPkeyList += [guid]$pkey }}}

        $results = @()
        foreach ($guid in (
            Get-SLIDList -eQueryIdType SL_ID_PRODUCT_SKU -eReturnIdType SL_ID_PRODUCT_SKU)) {
                $ID_PKEY = Retrieve-SKUInfo -SkuId $guid -eReturnIdType SL_ID_PKEY
                if ($ID_PKEY) {
                    $results += [PSCustomObject]@{
                        SL_ID_PRODUCT_SKU = $guid
                        SL_ID_PKEY = $ID_PKEY
                        PartialProductKey = Get-SLCPKeyInfo -PKEY $ID_PKEY -pwszValueName PartialProductKey
                    }}}

        if ($KeyLst) {
            foreach ($key in $KeyLst) {
                if ($key.Length -eq 29) {
                    $pPKeyId = [GUID]::Empty
                    $AlgoTypes = @(
                        "msft:rm/algorithm/pkey/detect",
                        "msft:rm/algorithm/pkey/2009",
                        "msft:rm/algorithm/pkey/2007",
                        "msft:rm/algorithm/pkey/2005"
                    )
                    foreach ($type in $AlgoTypes) {
                        $hresults = $Global:SLC::SLGetPKeyId(
                            $hSLC,$type,$key,[Intptr]::Zero,[Intptr]::Zero,[ref]$pPKeyId)
                        if ($hresults -eq 0) {
                            break;
                        }
                    }
                    if ($hresults -eq 0 -and (
                        $pPKeyId -ne [GUID]::Empty)) {
                            $results += [PSCustomObject]@{
                                SL_ID_PRODUCT_SKU = $null
                                SL_ID_PKEY = $pPKeyId
                                PartialProductKey = $key
                            }
                    }
                }
            }
        }

        # Initialize filtered results array
        $filteredResults = @()
        foreach ($item in $results) {          
            $isValidPkey = $validPkeyList -contains $item.SL_ID_PKEY
            $isValidKey  = $validCdKeys -contains $item.PartialProductKey
            $isValidSKU  = $validSkuList -contains $item.SL_ID_PRODUCT_SKU
            if ($isValidKey){
                write-warning "Valid key found, $($item.PartialProductKey)"
            }
            if ($isValidSKU){
                write-warning "Valid SKU found, $($item.SL_ID_PRODUCT_SKU)"
            }
            if ($isValidPkey){
                write-warning "Valid PKEY found, $($item.SL_ID_PKEY)"
            }
            if ($isValidKey -or $isValidSKU -or $isValidPkey) {
                $filteredResults += $item
            }
        }

        # Step 3: Retrieve unique SL_ID_PKEY values from the filtered results
        $SL_ID_PKEY_list = $filteredResults | Select-Object -ExpandProperty SL_ID_PKEY | Sort-Object | Select-Object -Unique

        if ($ClearKey) {
            $pPKeyId = [GUID]::Empty
            $AlgoTypes = @(
                "msft:rm/algorithm/pkey/detect",
                "msft:rm/algorithm/pkey/2009",
                "msft:rm/algorithm/pkey/2007",
                "msft:rm/algorithm/pkey/2005"
            )
            $DigitalKey  = $(Parse-DigitalProductId).DigitalKey
            if (-not $DigitalKey) {
                $DigitalKey = $(Parse-DigitalProductId4).DigitalKey
            }
            if ($DigitalKey) {
                foreach ($type in $AlgoTypes) {
                    $hresults = $Global:SLC::SLGetPKeyId(
                        $hSLC,$type,$DigitalKey,[Intptr]::Zero,[Intptr]::Zero,[ref]$pPKeyId)
                    if ($hresults -eq 0) {
                        break;
                    }
                }
                if ($hresults -eq 0 -and (
                    $pPKeyId -ne [GUID]::Empty)) {
                        $SL_ID_PKEY_list = @($pPKeyId)
                }
            }
        }

        # Proceed to uninstall each product key using its GUID
        foreach ($guid in $SL_ID_PKEY_list) {
            if ($guid) {
                Write-Host "Attempting to uninstall product key with GUID: $guid"
                $hrUninstall = $Global:SLC::SLUninstallProofOfPurchase($hSLC, $guid)

                if ($hrUninstall -eq 0) {
                    Write-Host "Product key uninstalled successfully: $guid"
                } else {
                    $uint32Value = $hrUninstall -band 0xFFFFFFFF
                    $hexString = "0x{0:X8}" -f $uint32Value
                    Write-Warning "Failed to uninstall product key with HRESULT: $hexString for GUID: $guid"
                }
            } else {
                Write-Warning "Skipping invalid GUID: $guid"
            }
        }
    }
    catch {
        Write-Warning "An unexpected error occurred: $_"
    }
    finally {
        
        # Launch event of license status change after license/key install/remove
        Fire-LicensingStateChangeEvent -hSLC $hSLC

        if ($closeHandle) {
            Write-Warning "Consider Open handle Using Manage-SLHandle"
            Free-IntPtr -handle $hSLC -Method License
        }
    }
}

<#
.SYNOPSIS

# Path to license file
$licensePath = 'C:\Program Files\Microsoft Office\root\Licenses16\client-issuance-bridge-office.xrm-ms'

if (-not (Test-Path $licensePath)) {
    Write-Warning "License file not found: $licensePath"
    return
}

# 1. Install license from file path (string)
Write-Host "`n--- Installing from file path ---"
$result1 = SL-InstallLicense -LicenseInput $licensePath
Write-Host "Result (file path): $result1`n"

# 2. Install license from byte array
Write-Host "--- Installing from byte array ---"
$bytes = [System.IO.File]::ReadAllBytes($licensePath)
$result2 = SL-InstallLicense -LicenseInput $bytes
Write-Host "Result (byte array): $result2`n"

# 3. Install license from text string
Write-Host "--- Installing from text string ---"
$licenseText = Get-Content $licensePath -Raw
$result3 = SL-InstallLicense -LicenseInput $licenseText
Write-Host "Result (text): $result3`n"
#>
function SL-InstallLicense {
    param (
        # Can be string (file path or raw text) or byte[]
        [Parameter(Mandatory = $true)]
        [object[]]$LicenseInput,

        [Parameter(Mandatory=$false)]
        [Intptr]$hSLC = [IntPtr]::Zero
    )
    
    # Prepare to install license
    $LicenseFileIdOut = [Guid]::NewGuid()
    # Store the file IDs for all successfully installed licenses
    $LicenseFileIds = @()

    if (-not $hSLC -or $hSLC -eq [IntPtr]::Zero -or $hSLC -eq 0) {
        $hSLC = if ($global:hSLC_ -and $global:hSLC_ -ne [IntPtr]::Zero -and $global:hSLC_ -ne 0) {
            $global:hSLC_
        } else {
            Manage-SLHandle
        }
    }

    try {
        $closeHandle = $true
        if (-not $hSLC -or $hSLC -eq [IntPtr]::Zero -or $hSLC -eq 0) {
            $hr = $Global:SLC::SLOpen([ref]$hSLC)
            if ($hr -ne 0) {
                throw "SLOpen failed: HRESULT 0x{0:X8}" -f $hr
            }
        } else {
            $closeHandle = $false
        }
    }
    catch {
        return $null
    }

    try {
        # Initialize an array to store blobs
        $LicenseBlobs = @()

        # Loop through each license input
        foreach ($input in $LicenseInput) {
            # Determine the type of input and process accordingly
            if ($input -is [byte[]]) {
                # If input is already a byte array, use it directly
                $LicenseBlob = $input
            }
            elseif ($input -is [string]) {
                if (Test-Path $input) {
                    # If it's a file path, read the file and get its byte array
                    $LicenseBlob = [System.IO.File]::ReadAllBytes($input)
                }
                else {
                    # If it's plain text, convert the text to a byte array
                    $LicenseBlob = [Encoding]::UTF8.GetBytes($input)
                }
            }
            else {
                Write-Warning "Invalid input type. Provide a file path, byte array, or text string."
                continue
            }

            if ($LicenseBlob) {
                # Pin the current blob in memory // use helper instead
                $blobPtr = New-IntPtr -Data $LicenseBlob
                $hrInstall = $Global:SLC::SLInstallLicense($hSLC, $LicenseBlob.Length, $blobPtr, [ref]$LicenseFileIdOut)
                Free-IntPtr -handle $blobPtr -Method Auto

                # Check if the installation was successful (HRESULT 0 means success)
                if ($hrInstall -ne 0) {
                    $errorMessege = Parse-ErrorMessage -MessageId $hrInstall -Flags ([ErrorMessageType]::ACTIVATION -bor [ErrorMessageType]::HRESULT)
                    if ($errorMessege) {
                        Write-Warning "$($hrInstall): $($errorMessege)"
                    } else {
                        Write-Warning "Unknown error HRESULT $hexString"
                    }
                    Write-Warning "Failed to install the proof of purchase for key $key. HRESULT: $hrInstall"
                    continue  # Skip to the next blob if the current installation fails
                }

                # If successful, add the LicenseFileIdOut to the array
                $LicenseFileIds += $LicenseFileIdOut
                Write-Host "Successfully installed license with FileId: $LicenseFileIdOut"
            }

        }
    }
    finally {
        # Launch event of license status change after license/key install/remove
        Fire-LicensingStateChangeEvent -hSLC $hSLC

        if ($closeHandle) {
            Write-Warning "Consider Open handle Using Manage-SLHandle"
            Free-IntPtr -handle $hSLC -Method License
        }
    }

    # Return all the File IDs that were successfully installed
    #return $LicenseFileIds
}

<#
.SYNOPSIS
Uninstalls the license specified by the license file ID and target user option.

By --> SL_ID_ALL_LICENSE_FILES
$OfficeAppId  = '0ff1ce15-a989-479d-af46-f275c6370663'
$SL_ID_List = Get-SLIDList -eQueryIdType SL_ID_APPLICATION -pQueryId $OfficeAppId -eReturnIdType SL_ID_ALL_LICENSE_FILES
SL-UninstallLicense -LicenseFileIds $SL_ID_List

By --> SL_ID_PRODUCT_SKU -->
$OfficeAppId  = '0ff1ce15-a989-479d-af46-f275c6370663'
$WMI_QUERY = Get-SLIDList -eQueryIdType SL_ID_APPLICATION -eReturnIdType SL_ID_PRODUCT_SKU -pQueryId $OfficeAppId
SL-UninstallLicense -ProductSKUs $WMI_QUERY

>>> Results >> 

ActConfigId                            ProductDescription                  
-----------                            ------------------                  
{DABAA1F2-109B-496D-BF49-1536CC862900} Office16_O365AppsBasicR_Subscription

>>> Command >>
SL-UninstallLicense -ProductSKUs ('DABAA1F2-109B-496D-BF49-1536CC862900' -as [GUID])
#>
function SL-UninstallLicense {
    param (
        [Parameter(Mandatory=$false)]
        [Guid[]]$ProductSKUs,

        [Parameter(Mandatory=$false)]
        [Guid[]]$LicenseFileIds,

        [Parameter(Mandatory=$false)]
        [Intptr]$hSLC = [IntPtr]::Zero
    )

    if (-not $ProductSKUs -and -not $LicenseFileIds) {
        throw "You must provide at least one of -ProductSKUs or -LicenseFileIds."
    }

    if (-not $hSLC -or $hSLC -eq [IntPtr]::Zero -or $hSLC -eq 0) {
        $hSLC = if ($global:hSLC_ -and $global:hSLC_ -ne [IntPtr]::Zero -and $global:hSLC_ -ne 0) {
            $global:hSLC_
        } else {
            Manage-SLHandle
        }
    }

    try {
        $closeHandle = $true
        if (-not $hSLC -or $hSLC -eq [IntPtr]::Zero -or $hSLC -eq 0) {
            $hr = $Global:SLC::SLOpen([ref]$hSLC)
            if ($hr -ne 0) {
                throw "SLOpen failed: HRESULT 0x{0:X8}" -f $hr
            }
        } else {
            $closeHandle = $false
        }
    }
    catch {
        return $null
    }

    try {
        
        $LicenseFileIdsLst = @()

        # Add valid LicenseFileIds directly
        if ($LicenseFileIds) {
            foreach ($lfid in $LicenseFileIds) {
                if ($lfid -is [Guid]) {
                    $LicenseFileIdsLst += $lfid }}}

        # Convert each ProductSKU to LicenseFileId and add it
        if ($ProductSKUs) {
            foreach ($sku in $ProductSKUs) {
                if ($sku -isnot [Guid]) { continue }
                $fileGuid = Retrieve-SKUInfo -SkuId $sku -eReturnIdType SL_ID_LICENSE_FILE -hSLC $hSLC
                if ($fileGuid -and ($fileGuid -is [Guid]) -and ($fileGuid -ne [Guid]::Empty)) {
                    $LicenseFileIdsLst += $fileGuid }}}

        foreach ($LicenseFileId in ($LicenseFileIdsLst | Sort-Object -Unique)) {
            $hresult = $Global:SLC::SLUninstallLicense($hSLC, [ref]$LicenseFileId)
            if ($hresult -ne 0) {
                $errorMessege = Parse-ErrorMessage -MessageId $hresult -Flags ([ErrorMessageType]::ACTIVATION -bor [ErrorMessageType]::HRESULT)
                Write-Warning "$errorMessege, $hresult"
            } 
            else {
                Write-Warning "License File ID: $LicenseFileId was removed."
            }
        }
        
    }
    catch {
        # Convert to unsigned 32-bit int (number)
        $hresult = $_.Exception.HResult
        if ($hresult -ne 0) {
            $errorMessege = Parse-ErrorMessage -MessageId $hresult -Flags ([ErrorMessageType]::ACTIVATION -bor [ErrorMessageType]::HRESULT)
            Write-Warning "$errorMessege, $hresult"
        }
    }
    finally {
        
        # Launch event of license status change after license/key install/remove
        Fire-LicensingStateChangeEvent -hSLC $hSLC

        if ($closeHandle) {
            Write-Warning "Consider Open handle Using Manage-SLHandle"
            Free-IntPtr -handle $hSLC -Method License
        }
    }
}

<#
.SYNOPSIS
Retrieves Software Licensing Client status for application and product SkuID.

Example <1>

Clear-Host
Write-Host

#Default Guid For Windows & Office
$windowsAppID = '55c92734-d682-4d71-983e-d6ec3f16059f'
$OfficeAppId  = '0ff1ce15-a989-479d-af46-f275c6370663'

# Get All Sku Per Application Id
#Get-SLLicensingStatus  # default $windowsAppID
#Get-SLLicensingStatus $windowsAppID
#Get-SLLicensingStatus $OfficeAppId

# Get SkuiId info Of 'ed655016-a9e8-4434-95d9-4345352c2552'
#Get-SLLicensingStatus $null ed655016-a9e8-4434-95d9-4345352c2552
#Get-SLLicensingStatus $windowsAppID ed655016-a9e8-4434-95d9-4345352c2552

Example <2>

$LicensingProducts = (
    Get-SLIDList -eQueryIdType SL_ID_APPLICATION -eReturnIdType SL_ID_PRODUCT_SKU -pQueryId $windowsAppID | ? { Retrieve-SKUInfo -SkuId $_ -eReturnIdType SL_ID_PKEY }
    ) | % {
    [PSCustomObject]@{
        ID            = $_
        PKEY          = Retrieve-SKUInfo -SkuId $_ -eReturnIdType SL_ID_PKEY
        Description   = Get-LicenseDetails -ActConfigId $_ -pwszValueName 'Description'
        Name          = Get-LicenseDetails -ActConfigId $_ -pwszValueName 'productName'
        LicenseFamily = Get-LicenseDetails -ActConfigId $_ -pwszValueName 'Family'
    }
}

Clear-Host
$LicensingProducts | % { 
    Write-Host
    Write-Warning "Get-SLCPKeyInfo Function"
    Get-SLCPKeyInfo -PKEY ($_).PKEY -loopAllValues

    Write-Host
    Write-Warning "Get-SLLicensingStatus"
    Get-SLLicensingStatus -ApplicationID 55c92734-d682-4d71-983e-d6ec3f16059f -SkuID ($_).ID

    Write-Host
    Write-Warning "Get-GenuineInformation"
    Write-Host
    Get-GenuineInformation -QueryId ($_).ID -loopAllValues

    Write-Host
    Write-Warning "Get-ApplicationInformation"
    Write-Host
    Get-ApplicationInformation -ApplicationId ($_).ID -loopAllValues
}
#>
enum LicenseStatusEnum {
    Unlicensed        = 0
    Licensed          = 1
    OOBGrace          = 2
    OOTGrace          = 3
    NonGenuineGrace   = 4
    Notification      = 5
    ExtendedGrace     = 6
}
enum LicenseCategory {
    KMS38        # Valid until 2038
    KMS4K        # Beyond 2038
    ShortTermVL  # Volume expiring within 6 months
    Unknown
    NonKMS
}
function Get-SLLicensingStatus {
    [CmdletBinding()]
    param(
        [Nullable[Guid]]$ApplicationID = $null,
        [Nullable[Guid]]$SkuID = $null,
        [Intptr]$hSLC = [IntPtr]::Zero
    )

    function Test-Guid {
        [CmdletBinding()]
        param (
            [Parameter(ValueFromPipeline, ValueFromPipelineByPropertyName)]
            [object] $Value
        )
        process {
            if (-not $Value) { return $false }
            try {
                $guid = [Guid]::Parse($Value.ToString())
                return ($guid -ne [Guid]::Empty)
            } catch { return $false }
        }
    }

    # Or both null, Or both same,
    # but If one exist, we can handle things
    # $ApplicationID & [Optional: $skuId]
    # But even with just $skuId, we can get -> $ApplicationID
    # And still continue

    if ([Guid]::Equals($SkuID, $ApplicationID)) {
        $ApplicationID = Guid-Handler '55c92734-d682-4d71-983e-d6ec3f16059f' $null Guid
    }
    if (!(Test-Guid $ApplicationID)) {
        try {
            $ApplicationID = Retrieve-SKUInfo -SkuId $SkuID -eReturnIdType SL_ID_APPLICATION
        }
        catch {
        }
        if (!(Test-Guid $ApplicationID)) {
            return $null
        }
    }

    # region --- Handle management ---
    if (-not $hSLC -or $hSLC -eq [IntPtr]::Zero) {
        $hSLC = if ($global:hSLC_ -and $global:hSLC_ -ne [IntPtr]::Zero) {
            $global:hSLC_
        } else {
            Manage-SLHandle
        }
    }
    # endregion

    $closeHandle = $false
    try {
        if (-not $hSLC -or $hSLC -eq [IntPtr]::Zero) {
            $hr = $Global:SLC::SLOpen([ref]$hSLC)
            if ($hr -ne 0) {
                throw "SLOpen failed: HRESULT 0x{0:X8}" -f $hr
            }
            $closeHandle = $true
        }
    }
    catch {
        Write-Warning "Failed to open SLC handle: $_"
        return $null
    }

    # region --- Define struct if not already loaded ---
    if (-not ([PSTypeName]'SL_LICENSING_STATUS').Type) {
        New-Struct `
            -Module (New-InMemoryModule -ModuleName SL_LICENSING_STATUS) `
            -FullName SL_LICENSING_STATUS `
            -StructFields @{
                SkuId                = New-field 0 Guid
                eStatus              = New-field 1 Int32
                dwGraceTime          = New-field 2 UInt32
                dwTotalGraceDays     = New-field 3 UInt32
                hrReason             = New-field 4 Int32
                qwValidityExpiration = New-field 5 UInt64
            } | Out-Null
    }
    # endregion

    try {
        # region --- Call SL API ---
        $pAppID = [Guid]$ApplicationID
        $pSkuId = if (!$SkuID -or $SkuID -eq [Guid]::Empty) { [IntPtr]::Zero } else { Guid-Handler $SkuID $null Pointer }
        $pnCount = [uint32]0
        $ppStatus = [IntPtr]::Zero

        $result = $global:slc::SLGetLicensingStatusInformation(
            $hSLC,
            [ref]$pAppID,
            $pSkuId,
            [IntPtr]::Zero,
            [ref]$pnCount,
            [ref]$ppStatus
        )

        Free-IntPtr $pSkuId
        # endregion

        if ($result -ne 0 -or $pnCount -le 0 -or $ppStatus -eq [IntPtr]::Zero) {
            Write-Warning "SLGetLicensingStatusInformation returned 0x{0:X8}" -f $result
            return $null
        }

        # region --- Build results ---
        $blockSize = [Marshal]::SizeOf([Type][SL_LICENSING_STATUS])
        $LicensingStatusArr = New-Object SL_LICENSING_STATUS[] $pnCount

        for ($i = 0; $i -lt $pnCount; $i++) {
            $ptr = [IntPtr]::Add($ppStatus, $i * $blockSize)
            $LicensingStatusArr[$i] = [SL_LICENSING_STATUS]$ptr
        }

        # If specific SKU requested, return that one
        if (Test-Guid $SkuID) {
            $Status = $LicensingStatusArr | Where-Object { $_.SkuId -eq $SkuID } | Select-Object -First 1
            if (-not $Status) { return $null }    
        } else {
            return $LicensingStatusArr
        }
        # endregion

        # region --- Process single SKU ---
        $expirationDateTime = $null
        if ($Status.qwValidityExpiration -gt 0) {
            try {
                $expirationDateTime = [DateTime]::FromFileTimeUtc($Status.qwValidityExpiration)
            } catch { }
        }

        $now = Get-Date
        $graceExpiration = $now.AddMinutes($Status.dwGraceTime)
        $daysLeft = ($graceExpiration - $now).Days

        $licenseCategory = $Global:PKeyDatabase |
            Where-Object ActConfigId -eq "{$SkuID}" |
            Select-Object -First 1 -ExpandProperty ProductKeyType
        switch -Regex ($licenseCategory) {
            'Volume:GVLK' {
                if ($graceExpiration.Year -gt 2038) {
                    $typeKMS = [LicenseCategory]::KMS4K
                } elseif ($graceExpiration.Year -in 2037, 2038) {
                    $typeKMS = [LicenseCategory]::KMS38
                } elseif ($daysLeft -le 180 -and $daysLeft -ge 0) {
                    $typeKMS = [LicenseCategory]::ShortTermVL
                } else {
                    $typeKMS = [LicenseCategory]::Unknown
                }
            }
            default { $typeKMS = [LicenseCategory]::NonKMS }
        }

        $errorMessage = Parse-ErrorMessage -MessageId $Status.hrReason -Flags ACTIVATION
        $hrHex = '0x{0:X8}' -f ($Status.hrReason -band 0xFFFFFFFF)

        $StatusObj = [PsObject]@{
            ID                   = $Status.SkuID
            LicenseStatus        = [Enum]::GetName([LicenseStatusEnum], $Status.eStatus)
            GracePeriodRemaining = $Status.dwGraceTime
            TotalGraceDays       = $Status.dwTotalGraceDays
            EvaluationEndDate    = $expirationDateTime
            LicenseStatusReason  = $hrHex
            LicenseChannel       = $licenseCategory
            LicenseTier          = $typeKMS
            ApiCallHResult       = ('0x{0:X8}' -f $result)
            ErrorMessage         = $errorMessage
        }
        return $StatusObj
        # endregion
    }
    catch {
        Write-Warning "Error while retrieving licensing info: $_"
        return $null
    }
    finally {
        Free-IntPtr -handle $ppStatus -Method Local
        if ($closeHandle) {
            Write-Warning "Releasing temporary SLC handle"
            Free-IntPtr -handle $hSLC -Method License
        }
    }
}

<#
.SYNOPSIS
Gets the information of the specified product key.
work for all sku that are activated AKA [SL_ID_PKEY],
else, no results.

how to receive them --> demo code -->
Get-SLIDList -eQueryIdType SL_ID_PRODUCT_SKU -eReturnIdType SL_ID_PRODUCT_SKU | ? {Retrieve-SKUInfo -SkuId $_ -eReturnIdType SL_ID_PKEY}
Get-SLIDList -eQueryIdType SL_ID_PRODUCT_SKU -eReturnIdType SL_ID_PRODUCT_SKU | ? {Retrieve-SKUInfo -SkuId $_ -eReturnIdType SL_ID_PKEY} | % { Get-SLCPKeyInfo $_ -loopAllValues }

Example:
$LicensingProducts = (
    Get-SLIDList -eQueryIdType SL_ID_APPLICATION -eReturnIdType SL_ID_PRODUCT_SKU -pQueryId $windowsAppID | ? { Retrieve-SKUInfo -SkuId $_ -eReturnIdType SL_ID_PKEY }
    ) | % {
    [PSCustomObject]@{
        ID            = $_
        PKEY          = Retrieve-SKUInfo -SkuId $_ -eReturnIdType SL_ID_PKEY
        Description   = Get-LicenseDetails -ActConfigId $_ -pwszValueName 'Description'
        Name          = Get-LicenseDetails -ActConfigId $_ -pwszValueName 'productName'
        LicenseFamily = Get-LicenseDetails -ActConfigId $_ -pwszValueName 'Family'
    }
}

Clear-Host
$LicensingProducts | % { 
    Write-Host
    Write-Warning "Get-SLCPKeyInfo Function"
    Get-SLCPKeyInfo -PKEY ($_).PKEY -loopAllValues

    Write-Host
    Write-Warning "Get-SLLicensingStatus"
    Get-SLLicensingStatus -ApplicationID 55c92734-d682-4d71-983e-d6ec3f16059f -SkuID ($_).ID

    Write-Host
    Write-Warning "Get-GenuineInformation"
    Write-Host
    Get-GenuineInformation -QueryId ($_).ID -loopAllValues

    Write-Host
    Write-Warning "Get-ApplicationInformation"
    Write-Host
    Get-ApplicationInformation -ApplicationId ($_).ID -loopAllValues
}
#>
function Get-SLCPKeyInfo {
    param(
        [Parameter(Mandatory = $false)]
        [Guid] $SKU,

        [Parameter(Mandatory = $false)]
        [Guid] $PKEY,

        [Parameter(Mandatory = $false)]
        [ValidateSet("DigitalPID", "DigitalPID2", "PartialProductKey", "ProductSkuId", "Channel")]
        [string] $pwszValueName,

        [Parameter(Mandatory = $false)]
        [switch]$loopAllValues,

        [Parameter(Mandatory=$false)]
        [Intptr]$hSLC = [IntPtr]::Zero
    )

    # Oppsite XOR Case, Validate it Not both
    if (!($pwszValueName -xor $loopAllValues)) {
        Write-Warning "Choice 1 option only, can't use both / none"
        return
    }

    if (-not $hSLC -or $hSLC -eq [IntPtr]::Zero -or $hSLC -eq 0) {
        $hSLC = if ($global:hSLC_ -and $global:hSLC_ -ne [IntPtr]::Zero -and $global:hSLC_ -ne 0) {
            $global:hSLC_
        } else {
            Manage-SLHandle
        }
    }

    try {
        $closeHandle = $true
        if (-not $hSLC -or $hSLC -eq [IntPtr]::Zero -or $hSLC -eq 0) {
            $hr = $Global:SLC::SLOpen([ref]$hSLC)
            if ($hr -ne 0) {
                throw "SLOpen failed: HRESULT 0x{0:X8}" -f $hr
            }
        } else {
            $closeHandle = $false
        }
    }
    catch {
        return $null
    }

    try {
        
        # If loopAllValues is true, loop through all values in the ValidateSet and fetch the details for each
        $allValues = @{}
        $allValueNames = @("DigitalPID", "DigitalPID2", "PartialProductKey", "ProductSkuId", "Channel" )
        foreach ($valueName in $allValueNames) {
            $allValues[$valueName] = $null
        }

        if ($PKEY -and $PKEY -ne [GUID]::Empty) {
            $PKeyId = $PKEY
        }
        elseif ($SKU -and $SKU -ne [GUID]::Empty) {
            $PKeyId = Retrieve-SKUInfo -SkuId $SKU -eReturnIdType SL_ID_PKEY -hSLC $hSLC
        }        
        if (-not $PKeyId) {
            return ([GUID]::Empty)
        }

        if ($loopAllValues) {
            foreach ($valueName in $allValueNames) {
                $dataType = 0
                $bufferSize = 0
                $bufferPtr = [IntPtr]::Zero

                $hr = $Global:SLC::SLGetPKeyInformation(
                    $hSLC, [ref]$PKeyId, $valueName, [ref]$dataType, [ref]$bufferSize, [ref]$bufferPtr )

                if ($hr -ne 0) {
                    continue;
                }
                $allValues[$valueName] = Parse-RegistryData -dataType $dataType -ptr $bufferPtr -valueSize $bufferSize -valueName $valueName
            }
            return $allValues
        }

        $dataType = 0
        $bufferSize = 0
        $bufferPtr = [IntPtr]::Zero

        $hr = $Global:SLC::SLGetPKeyInformation(
            $hSLC, [ref]$PKeyId, $pwszValueName, [ref]$dataType, [ref]$bufferSize, [ref]$bufferPtr )

        if ($hr -ne 0) {
            throw "SLGetPKeyInformation failed: HRESULT 0x{0:X8}" -f $hr
        }
        return Parse-RegistryData -dataType $dataType -ptr $bufferPtr -valueSize $bufferSize -valueName $pwszValueName
    }
    catch { }
    finally {
        if ($null -ne $bufferPtr -and (
            $bufferPtr -ne [IntPtr]::Zero)) {
                $null = $Global:kernel32::LocalFree($bufferPtr)
        }
        if ($closeHandle) {
            Write-Warning "Consider Open handle Using Manage-SLHandle"
            Free-IntPtr -handle $hSLC -Method License
        }
    }
}

<#
.SYNOPSIS
Gets information about the genuine state of a Windows computer.

[in] pQueryId
A pointer to an SLID structure that specifies the *application* to check.

pQueryId
pQueryId can be one of the following.  

ApplicationId in case of querying following property values.
    SL_PROP_BRT_DATA
    SL_PROP_BRT_COMMIT

SKUId in case of querying following property values.
    SL_PROP_LAST_ACT_ATTEMPT_HRESULT
    SL_PROP_LAST_ACT_ATTEMPT_TIME
    SL_PROP_LAST_ACT_ATTEMPT_SERVER_FLAGS
    SL_PROP_ACTIVATION_VALIDATION_IN_PROGRESS

Example:
$LicensingProducts = (
    Get-SLIDList -eQueryIdType SL_ID_APPLICATION -eReturnIdType SL_ID_PRODUCT_SKU -pQueryId $windowsAppID | ? { Retrieve-SKUInfo -SkuId $_ -eReturnIdType SL_ID_PKEY }
    ) | % {
    [PSCustomObject]@{
        ID            = $_
        PKEY          = Retrieve-SKUInfo -SkuId $_ -eReturnIdType SL_ID_PKEY
        Description   = Get-LicenseDetails -ActConfigId $_ -pwszValueName 'Description'
        Name          = Get-LicenseDetails -ActConfigId $_ -pwszValueName 'productName'
        LicenseFamily = Get-LicenseDetails -ActConfigId $_ -pwszValueName 'Family'
    }
}

Clear-Host
$LicensingProducts | % { 
    Write-Host
    Write-Warning "Get-SLCPKeyInfo Function"
    Get-SLCPKeyInfo -PKEY ($_).PKEY -loopAllValues

    Write-Host
    Write-Warning "Get-SLLicensingStatus"
    Get-SLLicensingStatus -ApplicationID 55c92734-d682-4d71-983e-d6ec3f16059f -SkuID ($_).ID

    Write-Host
    Write-Warning "Get-GenuineInformation"
    Write-Host
    Get-GenuineInformation -QueryId ($_).ID -loopAllValues

    Write-Host
    Write-Warning "Get-ApplicationInformation"
    Write-Host
    Get-ApplicationInformation -ApplicationId ($_).ID -loopAllValues
}
 #>
function Get-GenuineInformation {
    param (
        [Parameter(Mandatory)]
        [string]$QueryId,

        [Parameter(Mandatory=$false)]
        [ValidateSet(
            'SL_BRT_DATA',
            'SL_BRT_COMMIT',
            'SL_GENUINE_RESULT',
            'SL_GET_GENUINE_AUTHZ',
            'SL_NONGENUINE_GRACE_FLAG',
            'SL_LAST_ACT_ATTEMPT_TIME',
            'SL_LAST_ACT_ATTEMPT_HRESULT',
            'SL_LAST_ACT_ATTEMPT_SERVER_FLAGS',
            'SL_ACTIVATION_VALIDATION_IN_PROGRESS'
        )]
        [string]$ValueName,

        [Parameter(Mandatory = $false)]
        [switch]$loopAllValues,

        [Parameter(Mandatory=$false)]
        [Intptr]$hSLC = [IntPtr]::Zero
    )

    # Oppsite XOR Case, Validate it Not both
    if (!($ValueName -xor $loopAllValues)) {
        Write-Warning "Choice 1 option only, can't use both / none"
        return
    }

    # Cast ApplicationId to Guid
    $appGuid = [Guid]::Parse($QueryId)
    $IsAppID = $Global:knownAppGuids -contains $appGuid

    if ($IsAppID -and (-not $loopAllValues) -and ($ValueName -notmatch "_BRT_|GENUINE")) {
        Write-Warning "The selected property '$ValueName' is not valid for an ApplicationId."
        return
    }
    elseif ((-not $IsAppID) -and (-not $loopAllValues) -and ($ValueName -match '_BRT_')) {
        Write-Warning "The selected property '$ValueName' is not valid for a SKUId."
        return
    }

    if (-not $hSLC -or $hSLC -eq [IntPtr]::Zero -or $hSLC -eq 0) {
        $hSLC = if ($global:hSLC_ -and $global:hSLC_ -ne [IntPtr]::Zero -and $global:hSLC_ -ne 0) {
            $global:hSLC_
        } else {
            Manage-SLHandle
        }
    }

    try {
        $closeHandle = $true
        if (-not $hSLC -or $hSLC -eq [IntPtr]::Zero -or $hSLC -eq 0) {
            $hr = $Global:SLC::SLOpen([ref]$hSLC)
            if ($hr -ne 0) {
                throw "SLOpen failed: HRESULT 0x{0:X8}" -f $hr
            }
        } else {
            $closeHandle = $false
        }
    }
    catch {
        return $null
    }

    # Prepare variables for out params
    $dataType = 0
    $valueSize = 0
    $ptrValue = [IntPtr]::Zero

    if ($loopAllValues) {
          
        # Combine all arrays and remove duplicates
        $allValues = @{}
        $allValueNames = if ($IsAppID) {
            @(
                'SL_BRT_DATA',
                'SL_BRT_COMMIT'
                'SL_GENUINE_RESULT',
                'SL_GET_GENUINE_AUTHZ',
                'SL_NONGENUINE_GRACE_FLAG'
            )
        } else {
            @(
                'SL_LAST_ACT_ATTEMPT_HRESULT',
                'SL_LAST_ACT_ATTEMPT_TIME',
                'SL_LAST_ACT_ATTEMPT_SERVER_FLAGS',
                'SL_ACTIVATION_VALIDATION_IN_PROGRESS'
            )
        }

        foreach ($Name in $allValueNames) {
            
            # Clear value
            $allValues[$Name] = $null

            $dataType = 0
            $valueSize = 0

            $hresult = $global:SLC::SLGetGenuineInformation(
                [ref] $appGuid,
                $Name,
                [ref] $dataType,
                [ref] $valueSize,
                [ref] $ptrValue
            )

            if ($hresult -ne 0) {
                continue
            }
            if ($valueSize -eq 0 -or $ptrValue -eq [IntPtr]::Zero) {
                continue
            }

            $allValues[$Name] = Parse-RegistryData -dataType $dataType -ptr $ptrValue -valueSize $valueSize -valueName $Name
            Free-IntPtr -handle $ptrValue -Method Local
            
            if ($allValues[$Name] -and (
                $Name -eq 'SL_LAST_ACT_ATTEMPT_HRESULT')) {
                $hrReason = $allValues[$Name]
                $errorMessage = Parse-ErrorMessage -MessageId $hrReason -Flags ACTIVATION
                $hrHex = '0x{0:X8}' -f ($hrReason -band 0xFFFFFFFF)
                $allValues[$Name] = $hrHex
            }
            
        }
        if ($errorMessage) {
            $allValues.Add("SL_LAST_ACT_ATTEMPT_MESSEGE",$errorMessage)
        }
        return $allValues
    }

    try {
        # Call SLGetGenuineInformation - pass [ref] for out params
        $hresult = $global:SLC::SLGetGenuineInformation(
            [ref] $appGuid,
            $ValueName,
            [ref] $dataType,
            [ref] $valueSize,
            [ref] $ptrValue
        )

        if ($hresult -ne 0) {
            $errorMessege = Parse-ErrorMessage -MessageId $hresult -Flags ([ErrorMessageType]::ACTIVATION -bor [ErrorMessageType]::HRESULT)
            Write-Warning "$errorMessege, $hresult"
            throw "SLGetGenuineInformation failed with HRESULT: $hresult"
        }

        if ($valueSize -eq 0 -or $ptrValue -eq [IntPtr]::Zero) {
            return $null
        }

        try {
            return Parse-RegistryData -dataType $dataType -ptr $ptrValue -valueSize $valueSize -valueName $ValueName
        }
        finally {
            Free-IntPtr -handle $ptrValue -Method Local
        }
    }
    finally {
        if ($closeHandle) {
            Write-Warning "Consider Open handle Using Manage-SLHandle"
            Free-IntPtr -handle $hSLC -Method License
        }
    }
}

<#
.SYNOPSIS
Gets information about the specified application.

Example:
$LicensingProducts = (
    Get-SLIDList -eQueryIdType SL_ID_APPLICATION -eReturnIdType SL_ID_PRODUCT_SKU -pQueryId $windowsAppID | ? { Retrieve-SKUInfo -SkuId $_ -eReturnIdType SL_ID_PKEY }
    ) | % {
    [PSCustomObject]@{
        ID            = $_
        PKEY          = Retrieve-SKUInfo -SkuId $_ -eReturnIdType SL_ID_PKEY
        Description   = Get-LicenseDetails -ActConfigId $_ -pwszValueName 'Description'
        Name          = Get-LicenseDetails -ActConfigId $_ -pwszValueName 'productName'
        LicenseFamily = Get-LicenseDetails -ActConfigId $_ -pwszValueName 'Family'
    }
}

Clear-Host
$LicensingProducts | % { 
    Write-Host
    Write-Warning "Get-SLCPKeyInfo Function"
    Get-SLCPKeyInfo -PKEY ($_).PKEY -loopAllValues

    Write-Host
    Write-Warning "Get-SLLicensingStatus"
    Get-SLLicensingStatus -ApplicationID 55c92734-d682-4d71-983e-d6ec3f16059f -SkuID ($_).ID

    Write-Host
    Write-Warning "Get-GenuineInformation"
    Write-Host
    Get-GenuineInformation -QueryId ($_).ID -loopAllValues

    Write-Host
    Write-Warning "Get-ApplicationInformation"
    Write-Host
    Get-ApplicationInformation -ApplicationId ($_).ID -loopAllValues
}
#>
function Get-ApplicationInformation {
    param (
        [Parameter(Mandatory)]
        [string]$ApplicationId,
        
        [Parameter(Mandatory = $false)]
        [ValidateSet(
            "TrustedTime",
            "IsKeyManagementService",
            "KeyManagementServiceCurrentCount",
            "KeyManagementServiceRequiredClientCount",
            "KeyManagementServiceUnlicensedRequests",
            "KeyManagementServiceLicensedRequests",
            "KeyManagementServiceOOBGraceRequests",
            "KeyManagementServiceOOTGraceRequests",
            "KeyManagementServiceNonGenuineGraceRequests",
            "KeyManagementServiceNotificationRequests",
            "KeyManagementServiceTotalRequests",
            "KeyManagementServiceFailedRequests"
        )]
        [string]$PropertyName,

        [Parameter(Mandatory = $false)]
        [switch]$loopAllValues,

        [Parameter(Mandatory=$false)]
        [Intptr]$hSLC = [IntPtr]::Zero
    )

    # Oppsite XOR Case, Validate it Not both
    if (!($PropertyName -xor $loopAllValues)) {
        Write-Warning "Choice 1 option only, can't use both / none"
        return
    }

    # Cast ApplicationId to Guid
    $appGuid = [Guid]$ApplicationId

    if (-not $hSLC -or $hSLC -eq [IntPtr]::Zero -or $hSLC -eq 0) {
        $hSLC = if ($global:hSLC_ -and $global:hSLC_ -ne [IntPtr]::Zero -and $global:hSLC_ -ne 0) {
            $global:hSLC_
        } else {
            Manage-SLHandle
        }
    }

    try {
        $closeHandle = $true
        if (-not $hSLC -or $hSLC -eq [IntPtr]::Zero -or $hSLC -eq 0) {
            $hr = $Global:SLC::SLOpen([ref]$hSLC)
            if ($hr -ne 0) {
                throw "SLOpen failed: HRESULT 0x{0:X8}" -f $hr
            }
        } else {
            $closeHandle = $false
        }
    }
    catch {
        return $null
    }

    if ($loopAllValues) {
          
        # Combine all arrays and remove duplicates
        $allValues = @{}
        $allValueNames = (
            "TrustedTime",
            "IsKeyManagementService",
            "KeyManagementServiceCurrentCount",
            "KeyManagementServiceRequiredClientCount",
            "KeyManagementServiceUnlicensedRequests",
            "KeyManagementServiceLicensedRequests",
            "KeyManagementServiceOOBGraceRequests",
            "KeyManagementServiceOOTGraceRequests",
            "KeyManagementServiceNonGenuineGraceRequests",
            "KeyManagementServiceNotificationRequests",
            "KeyManagementServiceTotalRequests",
            "KeyManagementServiceFailedRequests"
        )

        $dataTypePtr = [Marshal]::AllocHGlobal(4)
        $valueSizePtr = [Marshal]::AllocHGlobal(4)
        $ptrPtr = [Marshal]::AllocHGlobal([IntPtr]::Size)

        foreach ($valueName in $allValueNames) {
            # Clear value
            $allValues[$valueName] = $null

            # Initialize the out params to zero/null
            [Marshal]::WriteInt32($dataTypePtr, 0)
            [Marshal]::WriteInt32($valueSizePtr, 0)
            [Marshal]::WriteIntPtr($ptrPtr, [IntPtr]::Zero)

            $res = $global:SLC::SLGetApplicationInformation(
                $hSLC,
                [ref]$appGuid,
                $valueName,
                $dataTypePtr,
                $valueSizePtr,
                $ptrPtr
            )

            if ($res -ne 0) {
                continue
            }

            # Read the outputs from the unmanaged memory pointers
            $dataType = [Marshal]::ReadInt32($dataTypePtr)
            $valueSize = [Marshal]::ReadInt32($valueSizePtr)
        
            # Dereference the pointer-to-pointer to get actual buffer pointer
            $ptr = [Marshal]::ReadIntPtr($ptrPtr)

            if ($ptr -eq [IntPtr]::Zero) {
                continue
            }

            if ($valueSize -eq 0) {
                continue
            }

            $allValues[$valueName] = Parse-RegistryData -dataType $dataType -ptr $ptr -valueSize $valueSize -valueName $valueName
            Free-IntPtr -handle $ptr -Method Local
        }
        return $allValues
    }


    # Allocate memory for dataType (optional out parameter)
    $dataTypePtr = [Marshal]::AllocHGlobal(4)
    # Allocate memory for valueSize (UINT* out param)
    $valueSizePtr = [Marshal]::AllocHGlobal(4)
    # Allocate memory for pointer to byte buffer (PBYTE* out param)
    $ptrPtr = [Marshal]::AllocHGlobal([IntPtr]::Size)

    try {
        # Initialize the out params to zero/null
        [Marshal]::WriteInt32($dataTypePtr, 0)
        [Marshal]::WriteInt32($valueSizePtr, 0)
        [Marshal]::WriteIntPtr($ptrPtr, [IntPtr]::Zero)

        $hresult = $global:SLC::SLGetApplicationInformation(
            $hSLC,
            [ref]$appGuid,
            $PropertyName,
            $dataTypePtr,
            $valueSizePtr,
            $ptrPtr
        )

        if ($hresult -ne 0) {
            $errorMessege = Parse-ErrorMessage -MessageId $hresult -Flags ([ErrorMessageType]::ACTIVATION -bor [ErrorMessageType]::HRESULT)
            Write-Warning "$errorMessege, $hresult"
            throw "SLGetApplicationInformation failed (code $hresult)"
        }

        # Read the outputs from the unmanaged memory pointers
        $dataType = [Marshal]::ReadInt32($dataTypePtr)
        $valueSize = [Marshal]::ReadInt32($valueSizePtr)
        
        # Dereference the pointer-to-pointer to get actual buffer pointer
        $ptr = [Marshal]::ReadIntPtr($ptrPtr)

        if ($ptr -eq [IntPtr]::Zero) {
            throw "Pointer to data buffer is null"
        }

        if ($valueSize -eq 0) {
            throw "Returned value size is zero"
        }

        try {
            return Parse-RegistryData -dataType $dataType -ptr $ptr -valueSize $valueSize -valueName $PropertyName
        }
        finally {
            Free-IntPtr -handle $ptr -Method Local
        }
    }
    finally {
        if ($closeHandle) {
            Write-Warning "Consider Open handle Using Manage-SLHandle"
            Free-IntPtr -handle $hSLC -Method License
        }
        if ($dataTypePtr -and $dataTypePtr -ne [IntPtr]::Zero) {
            [Marshal]::FreeHGlobal($dataTypePtr)
        }
        if ($valueSizePtr -and $valueSizePtr -ne [IntPtr]::Zero) {
            [Marshal]::FreeHGlobal($valueSizePtr)
        }
        if ($ptrPtr -and $ptrPtr -ne [IntPtr]::Zero) {
            [Marshal]::FreeHGlobal($ptrPtr)
        }
    }
}

<#
.SYNOPSIS
Gets information about the specified product SKU.

"Description", "Name", "Author", 
Taken from Microsoft Offical Documentation.

# ----------------------------------------------

fileId                # SL_ID_LICENSE_FILE
pkeyId                # SL_ID_PKEY
productSkuId          # SL_ID_PRODUCT_SKU
applicationId         # SL_ID_APPLICATION
licenseId             # SL_ID_LICENSE 
privateCertificateId  # SL_ID_LICENSE 

# ------>>>> More info ------>>>

https://github.com/LBBNetwork/openredpill/blob/master/slpublic.h
https://learn.microsoft.com/en-us/windows/win32/api/slpublic/nf-slpublic-slgetslidlist

SL_ID_APPLICATION,  appId        X
SL_ID_PRODUCT_SKU,  skuId        ?
SL_ID_LICENSE_FILE, fileId       V
SL_ID_LICENSE,      LicenseId    V

# ----------------------------------------------

"msft:sl/EUL/GENERIC/PUBLIC",    "msft:sl/EUL/GENERIC/PRIVATE",
"msft:sl/EUL/PHONE/PUBLIC",      "msft:sl/EUL/PHONE/PRIVATE",
"msft:sl/EUL/STORE/PUBLIC",      "msft:sl/EUL/STORE/PRIVATE",
"msft:sl/EUL/ACTIVATED/PRIVATE", "msft:sl/EUL/ACTIVATED/PUBLIC",

# ----------------------------------------------

Also, 
if you read String's from sppwmi.dll [hint by abbody1406]
you will find more data.

!Jackpot!
inside sppsvc.exe, lot of data, we can search,
include fileId & more info.

# ----------------------------------------------

Also, some properties from *SoftwareLicensingProduct* WMI Class
can be enum too, some with diffrent name.

class SoftwareLicensingProduct
{
  string   ID;                                            --> Function * SLGetProductSkuInformation  --> productSkuId
  string   Name;                                          --> Function * SLGetProductSkuInformation 
  string   Description;                                   --> Function * SLGetProductSkuInformation 
  string   ApplicationID;                                 --> Function * SLGetProductSkuInformation 
  string   ProcessorURL;                                  --> Function * SLGetProductSkuInformation 
  string   MachineURL;                                    --> Function * SLGetProductSkuInformation 
  string   ProductKeyURL;                                 --> Function * SLGetProductSkuInformation 
  
  sppcomapi.dll
  __int64 __fastcall SPPGetServerAddresses(HSLC hSLC, struct SActivationServerAddress **a2, unsigned int *a3)
  v58[0] = (__int64)L"SPCURL"; // GetProcessorURL
  v58[1] = (__int64)L"RACURL"; // GetMachineURL
  v51 = L"PAURL";              // GetUseLicenseURL
  v58[2] = (__int64)L"PKCURL"; // GetProductKeyURL
  v58[3] = (__int64)L"EULURL"; // GetUseLicenseURL

  string   UseLicenseURL;                                 --> Function * SLGetProductSkuInformation  --> PAUrl [-or EULURL, By abbody1406]

  uint32   LicenseStatus;                                 --> Function * SLGetLicensingStatusInformation
  uint32   LicenseStatusReason;                           --> Function * SLGetLicensingStatusInformation
  uint32   GracePeriodRemaining;                          --> Function * SLGetLicensingStatusInformation
  datetime EvaluationEndDate;                             --> Function * SLGetLicensingStatusInformation
  string   OfflineInstallationId;                         --> Function * SLGenerateOfflineInstallationId
  string   PartialProductKey;                             --> Function * SLGetPKeyInformation
  string   ProductKeyID;                                  --> Function * SLGetPKeyInformation
  string   ProductKeyID2;                                 --> Function * SLGetPKeyInformation
  string   ProductKeyChannel;                             --> Function * SLGetPKeyInformation
  string   LicenseFamily;                                 --> Function * SLGetProductSkuInformation  --> Family
  string   LicenseDependsOn;                              --> Function * SLGetProductSkuInformation  --> DependsOn
  string   ValidationURL;                                 --> Function * SLGetProductSkuInformation  --> ValUrl
  boolean  LicenseIsAddon;                                --> Function * SLGetProductSkuInformation  --> [BOOL](DependsOn) // From TSforge project
  uint32   VLActivationInterval;                          --> Function * SLGetProductSkuInformation
  uint32   VLRenewalInterval;                             --> Function * SLGetProductSkuInformation
  string   KeyManagementServiceProductKeyID;              --> Function * SLGetProductSkuInformation  --> CustomerPID
  string   KeyManagementServiceMachine;                   --> Function * SLGetProductSkuInformation  --> KeyManagementServiceName
  uint32   KeyManagementServicePort;                      --> Function * SLGetProductSkuInformation  --> KeyManagementServicePort
  string   DiscoveredKeyManagementServiceMachineName;     --> Function * SLGetProductSkuInformation  --> DiscoveredKeyManagementServiceName
  uint32   DiscoveredKeyManagementServiceMachinePort;     --> Function * SLGetProductSkuInformation  --> DiscoveredKeyManagementServicePort
  BOOL     IsKeyManagementServiceMachine;                 --> Function * SLGetApplicationInformation --> Key: "IsKeyManagementService"                      (SL_INFO_KEY_IS_KMS)
  uint32   KeyManagementServiceCurrentCount;              --> Function * SLGetApplicationInformation --> Key: "KeyManagementServiceCurrentCount"            (SL_INFO_KEY_KMS_CURRENT_COUNT)
  uint32   RequiredClientCount;                           --> Function * SLGetApplicationInformation --> Key: "KeyManagementServiceRequiredClientCount"     (SL_INFO_KEY_KMS_REQUIRED_CLIENT_COUNT)
  uint32   KeyManagementServiceUnlicensedRequests;        --> Function * SLGetApplicationInformation --> Key: "KeyManagementServiceUnlicensedRequests"      (SL_INFO_KEY_KMS_UNLICENSED_REQUESTS)
  uint32   KeyManagementServiceLicensedRequests;          --> Function * SLGetApplicationInformation --> Key: "KeyManagementServiceLicensedRequests"        (SL_INFO_KEY_KMS_LICENSED_REQUESTS)
  uint32   KeyManagementServiceOOBGraceRequests;          --> Function * SLGetApplicationInformation --> Key: "KeyManagementServiceOOBGraceRequests"        (SL_INFO_KEY_KMS_OOB_GRACE_REQUESTS)
  uint32   KeyManagementServiceOOTGraceRequests;          --> Function * SLGetApplicationInformation --> Key: "KeyManagementServiceOOTGraceRequests"        (SL_INFO_KEY_KMS_OOT_GRACE_REQUESTS)
  uint32   KeyManagementServiceNonGenuineGraceRequests;   --> Function * SLGetApplicationInformation --> Key: "KeyManagementServiceNonGenuineGraceRequests" (SL_INFO_KEY_KMS_NON_GENUINE_GRACE_REQUESTS)
  uint32   KeyManagementServiceTotalRequests;             --> Function * SLGetApplicationInformation --> Key: "KeyManagementServiceTotalRequests"           (SL_INFO_KEY_KMS_TOTAL_REQUESTS)
  uint32   KeyManagementServiceFailedRequests;            --> Function * SLGetApplicationInformation --> Key: "KeyManagementServiceFailedRequests"          (SL_INFO_KEY_KMS_FAILED_REQUESTS)
  uint32   KeyManagementServiceNotificationRequests;      --> Function * SLGetApplicationInformation --> Key: "KeyManagementServiceNotificationRequests"    (SL_INFO_KEY_KMS_NOTIFICATION_REQUESTS)
  uint32   GenuineStatus;                                 --> Function * SLGetLicensingStatusInformation
  uint32   ExtendedGrace;                                 --> Function * SLGetProductSkuInformation  --> TimeBasedExtendedGrace
  string   TokenActivationILID;                           --> Function * SLGetProductSkuInformation
  uint32   TokenActivationILVID;                          --> Function * SLGetProductSkuInformation
  uint32   TokenActivationGrantNumber;                    --> Function * SLGetProductSkuInformation 
  string   TokenActivationCertificateThumbprint;          --> Function * SLGetProductSkuInformation
  string   TokenActivationAdditionalInfo;                 --> Function * SLGetProductSkuInformation
  datetime TrustedTime;                                   --> Function * SLGetProductSkuInformation [Licensing System Date]
};

# ----------------------------------------------

Now found that it read --> r:otherInfo Section
So it support for Any <tm:infoStr name=

<r:otherInfo xmlns:r="urn:mpeg:mpeg21:2003:01-REL-R-NS">
	<tm:infoTables xmlns:tm="http://www.microsoft.com/DRM/XrML2/TM/v2">
		<tm:infoList tag="#global">
		<tm:infoStr name="licenseType">msft:sl/PL/GENERIC/PUBLIC</tm:infoStr>
		<tm:infoStr name="licenseVersion">2.0</tm:infoStr>
		<tm:infoStr name="licensorUrl">http://licensing.microsoft.com</tm:infoStr>
		<tm:infoStr name="licenseCategory">msft:sl/PL/GENERIC/PUBLIC</tm:infoStr>
		<tm:infoStr name="productSkuId">{2c060131-0e43-4e01-adc1-cf5ad1100da8}</tm:infoStr>
		<tm:infoStr name="privateCertificateId">{274ff0e9-dfec-43e7-b675-67e61645b6a9}</tm:infoStr>
		<tm:infoStr name="applicationId">{55c92734-d682-4d71-983e-d6ec3f16059f}</tm:infoStr>
		<tm:infoStr name="productName">Windows(R), EnterpriseSN edition</tm:infoStr>
		<tm:infoStr name="Family">EnterpriseSN</tm:infoStr>
		<tm:infoStr name="productAuthor">Microsoft Corporation</tm:infoStr>
		<tm:infoStr name="productDescription">Windows(R) Operating System</tm:infoStr>
		<tm:infoStr name="clientIssuanceCertificateId">{4961cc30-d690-43be-910c-8e2db01fc5ad}</tm:infoStr>
		<tm:infoStr name="hwid:ootGrace">0</tm:infoStr>
		</tm:infoList>
	</tm:infoTables>
</r:otherInfo>
<r:otherInfo xmlns:r="urn:mpeg:mpeg21:2003:01-REL-R-NS">
	<tm:infoTables xmlns:tm="http://www.microsoft.com/DRM/XrML2/TM/v2">
		<tm:infoList tag="#global">
		<tm:infoStr name="licenseType">msft:sl/PL/GENERIC/PRIVATE</tm:infoStr>
		<tm:infoStr name="licenseVersion">2.0</tm:infoStr>
		<tm:infoStr name="licensorUrl">http://licensing.microsoft.com</tm:infoStr>
		<tm:infoStr name="licenseCategory">msft:sl/PL/GENERIC/PRIVATE</tm:infoStr>
		<tm:infoStr name="publicCertificateId">{0f6421d2-b7ea-45e0-b87d-773975685c35}</tm:infoStr>
		<tm:infoStr name="clientIssuanceCertificateId">{4961cc30-d690-43be-910c-8e2db01fc5ad}</tm:infoStr>
		<tm:infoStr name="hwid:ootGrace">0</tm:infoStr>
		<tm:infoStr name="win:branding">126</tm:infoStr>
		</tm:infoList>
	</tm:infoTables>
</r:otherInfo>
#>
<#
Clear-host
$WMI_QUERY = Get-SLIDList -eQueryIdType SL_ID_PRODUCT_SKU -eReturnIdType SL_ID_PRODUCT_SKU
$XML_Table = $WMI_QUERY | % { Get-LicenseDetails $_ -ReturnRawData}

write-host
$uniqueNamesHashTable = @{}
foreach ($xmlEntry in $XML_Table) {
    # Ensure the licenseGroup property exists on the current object
    if ($xmlEntry.licenseGroup) {
        # The 'license' property within licenseGroup can be a single object or an array of objects.
        # Use @() to ensure it's treated as an array, making iteration consistent.
        foreach ($licenseObject in @($xmlEntry.licenseGroup.license)) {
            # Safely navigate the object path to get to the 'infoStr' elements.
            # We check each step to prevent errors if a property is missing.
            if ($licenseObject.otherInfo -and
                $licenseObject.otherInfo.infoTables -and
                $licenseObject.otherInfo.infoTables.infoList -and
                $licenseObject.otherInfo.infoTables.infoList.infoStr) {

                # Extract all 'name' attributes from the 'infoStr' elements for the current license.
                # If infoStr is a single object, .name will work. If it's an array, it will automatically
                # collect all names.
                $names = $licenseObject.otherInfo.infoTables.infoList.infoStr.name

                # Add each extracted name to our hashtable.
                # The 'ContainsKey' check ensures that only unique names are added.
                foreach ($name in @($names)) { # @($names) ensures we iterate even if $names is a single string
                    if (-not $uniqueNamesHashTable.ContainsKey($name)) {
                        $uniqueNamesHashTable[$name] = $true # Value can be anything; we only care about the key
                    }
                }
            }
        }
    }
}
$uniqueNamesHashTable.keys

$xmlStrings = $XML_Table | ForEach-Object { $_.OuterXml }
$regexPattern = ">(msft.*?)<"
$extractedContent = New-Object System.Collections.ArrayList # Use ArrayList for efficient adding
foreach ($xmlString in $xmlStrings) {
    $matchesInCurrentString = [regex]::Matches($xmlString, $regexPattern)
    if ($matchesInCurrentString.Count -gt 0) {
        foreach ($match in $matchesInCurrentString) {
            # Add the content of the first capturing group (index 1) to our ArrayList
            # $match.Groups[0] would be the entire match (>msft...<)
            # $match.Groups[1] is the content of the first capturing group (msft...)
            [void]$extractedContent.Add($match.Groups[1].Value)
        }
    }
}

write-host
if ($extractedContent.Count -gt 0) {
    $extractedContent | Select-Object -Unique | Sort-Object | ForEach-Object {
        Write-Host $_ }}
Read-Host
#>
function Get-LicenseDetails {
    param (
        [Parameter(Mandatory)]
        [Guid]$ActConfigId,

        [Parameter(Mandatory = $false)]
        [ValidateSet(
        "fileId", "pkeyId", "productSkuId", "applicationId",
        "licenseId", "privateCertificateId", "pkeyIdList",

        "msft:sl/EUL/GENERIC/PUBLIC", "msft:sl/EUL/GENERIC/PRIVATE",
        "msft:sl/EUL/PHONE/PUBLIC", "msft:sl/EUL/PHONE/PRIVATE",
        "msft:sl/EUL/STORE/PUBLIC", "msft:sl/EUL/STORE/PRIVATE",
        "msft:sl/EUL/ACTIVATED/PRIVATE", "msft:sl/EUL/ACTIVATED/PUBLIC",
        "msft:sl/PL/GENERIC/PUBLIC",    "msft:sl/PL/GENERIC/PRIVATE",

        "Description", "Name", "Author",
		
        "TokenActivationILID", "TokenActivationILVID","TokenActivationGrantNumber",
        "TokenActivationCertificateThumbprint", "TokenActivationAdditionalInfo",
        "pkeyConfigLicenseId", "licenseType", "licenseVersion", "licensorUrl", "licenseNamespace",
        "productName", "Family", "productAuthor", "productDescription", "licenseCategory",
        "hwid:ootGrace", "issuanceCertificateId", "ValUrl", "PAUrl", "ActivationSequence", 
        "UXDifferentiator", "ProductKeyGroupUniqueness", "EnableNotificationMode", "EULURL", 
        "GraceTimerUniqueness", "ValidityTimerUniqueness", "EnableActivationValidation", "PKCURL",
        "DependsOn", "phone:policy", "licensorKeyIndex", "BuildVersion", "ValidationTemplateId",
        "ProductUniquenessGroupId", "ApplicationBitmap", "migratable",
        "ProductKeyID", "VLActivationInterval", "VLRenewalInterval", "KeyManagementServiceProductKeyID", 
        "KeyManagementServicePort", "TrustedTime", "CustomerPID", "KeyManagementServiceName", 
        "KeyManagementServicePort", "DiscoveredKeyManagementServiceName", 
        "DiscoveredKeyManagementServicePort", "TimeBasedExtendedGrace",
        "ADActivationObjectDN", "ADActivationObjectName", "DiscoveredKeyManagementServiceIpAddress",
        "KeyManagementServiceLookupDomain", "RemainingRearmCount", "VLActivationType",
        "TokenActivationCertThumbprint", "RearmCount", "ADActivationCsvlkPID", "ADActivationCsvlkSkuID",
        "fileIndex", "licenseDescription", "metaInfoType", "DigitalEncryptedPID",
        "InheritedActivationId", "InheritedActivationHostMachineName", "InheritedActivationHostDigitalPid2",
        "InheritedActivationActivationTime"
        )]
        [String]$pwszValueName,

        [Parameter(Mandatory = $false)]
        [switch]$loopAllValues,

        [Parameter(Mandatory = $false)]
        [switch]$ReturnRawData,

        [Parameter(Mandatory=$false)]
        [Intptr]$hSLC = [IntPtr]::Zero
    )

    # 3 CASES OF XOR
    if (@([BOOL]$pwszValueName + [BOOL]$loopAllValues + [BOOL]$ReturnRawData) -ne 1) {
        Write-Warning "Exactly one of -pwszValueName, -loopAllValues, or -ReturnRawData must be specified."
        return
    }

    if (-not $hSLC -or $hSLC -eq [IntPtr]::Zero -or $hSLC -eq 0) {
        $hSLC = if ($global:hSLC_ -and $global:hSLC_ -ne [IntPtr]::Zero -and $global:hSLC_ -ne 0) {
            $global:hSLC_
        } else {
            Manage-SLHandle
        }
    }

    try {
        $closeHandle = $true
        if (-not $hSLC -or $hSLC -eq [IntPtr]::Zero -or $hSLC -eq 0) {
            $hr = $Global:SLC::SLOpen([ref]$hSLC)
            if ($hr -ne 0) {
                throw "SLOpen failed: HRESULT 0x{0:X8}" -f $hr
            }
        } else {
            $closeHandle = $false
        }
    }
    catch {
        return $null
    }

    try {
        if ($loopAllValues) {
            $allValues = @{}
            $SL_ID = @(
                "fileId",               # SL_ID_LICENSE_FILE
                "pkeyId",               # SL_ID_PKEY
                "pkeyIdList"            # SL_ID_PKEY [Same]
                "productSkuId",         # SL_ID_PRODUCT_SKU
                "applicationId"         # SL_ID_APPLICATION
                "licenseId",            # SL_ID_LICENSE
                "privateCertificateId"  # SL_ID_LICENSE
            )

            # un offical, intersting pattern
            # first saw in MAS AIO file, TSforge project}
            $MSFT = @(
                "msft:sl/EUL/GENERIC/PUBLIC",    "msft:sl/EUL/GENERIC/PRIVATE",    # un-offical
                "msft:sl/EUL/PHONE/PUBLIC",      "msft:sl/EUL/PHONE/PRIVATE",      # un-offical
                "msft:sl/EUL/STORE/PUBLIC",      "msft:sl/EUL/STORE/PRIVATE",      # un-offical
                "msft:sl/EUL/ACTIVATED/PRIVATE", "msft:sl/EUL/ACTIVATED/PUBLIC",   # extract from SPP* dll/exe files
                "msft:sl/PL/GENERIC/PUBLIC",    "msft:sl/PL/GENERIC/PRIVATE"       # extract from SPP* dll/exe files
            )
            
            # Offical from MS
            $OfficalPattern = @("Description", "Name", "Author")

            # the rest, from XML Blobs --> <infoStr>
            $xml = @("pkeyConfigLicenseId", "privateCertificateId", "licenseType", 
                "licensorUrl",  "licenseCategory", "productName", "Family","licenseVersion",
                "productAuthor", "productDescription",  "hwid:ootGrace", "issuanceCertificateId", "PAUrl",
                "ActivationSequence", "ValidationTemplateId", "ValUrl", "UXDifferentiator",
				"ProductKeyGroupUniqueness", "EnableNotificationMode", "GraceTimerUniqueness",
                "ValidityTimerUniqueness", "EnableActivationValidation",
                "DependsOn", "phone:policy", "licensorKeyIndex", "BuildVersion",
                "ProductUniquenessGroupId", "ApplicationBitmap", "migratable")
            
            # SoftwareLicensingProduct class (WMI)
            $SoftwareLicensingProduct = @(
                "Name",  "Description", "ApplicationID", "VLActivationInterval", "VLRenewalInterval",
                "ProductKeyID",  "KeyManagementServiceProductKeyID", "KeyManagementServicePort", 
                "RequiredClientCount", "TrustedTime", "TokenActivationILID", "TokenActivationILVID",
                "TokenActivationGrantNumber", "TokenActivationCertificateThumbprint", "CustomerPID",
                "KeyManagementServiceName", "KeyManagementServicePort","TimeBasedExtendedGrace", 
                "DiscoveredKeyManagementServiceName", "DiscoveredKeyManagementServicePort",
                "PKCURL", "EULURL"
            )

            # SPP* DLL/EXE file's
            $sppwmi = @(
                "ADActivationObjectDN", "ADActivationObjectName", "DiscoveredKeyManagementServiceIpAddress",
                "KeyManagementServiceLookupDomain", "RemainingRearmCount", "TokenActivationAdditionalInfo",
                "TokenActivationCertThumbprint", "VLActivationType", "RearmCount", "ADActivationCsvlkPID", 
                "fileIndex", "licenseDescription", "metaInfoType", "DigitalEncryptedPID", "ADActivationCsvlkSkuID",
				"InheritedActivationId", "InheritedActivationHostMachineName", "InheritedActivationHostDigitalPid2",
				"InheritedActivationActivationTime", "licenseNamespace"
            )

            # Combine all arrays and remove duplicates
            $allValueNames = ($SL_ID + $MSFT + $OfficalPattern + $xml + $SoftwareLicensingProduct + $sppwmi) | Sort-Object -Unique

            foreach ($valueName in $allValueNames) {
                $dataType = 0
                $valueSize = 0
                $ptr = [IntPtr]::Zero
                $res = $global:SLC::SLGetProductSkuInformation(
                    $hSLC,
                    [ref]$ActConfigId,
                    $valueName,
                    [ref]$dataType,
                    [ref]$valueSize,
                    [ref]$ptr
                )

                if ($res -ne 0) {
                    #Write-Warning "fail to process Name: $valueName"
                    $allValues[$valueName] = $null
                    continue;
                }
 
                $allValues[$valueName] = Parse-RegistryData -dataType $dataType -ptr $ptr -valueSize $valueSize -valueName $valueName
                Free-IntPtr -handle $ptr -Method Local
            }

            return $allValues
        }

        if ($pwszValueName) {
            $dataType = 0
            $valueSize = 0
            $ptr = [IntPtr]::Zero
            $res = $global:SLC::SLGetProductSkuInformation(
                $hSLC,
                [ref]$ActConfigId,
                $pwszValueName,
                [ref]$dataType,
                [ref]$valueSize,
                [ref]$ptr
            )

            if ($res -ne 0) {
                #$messege = $(Parse-ErrorMessage -MessageId $res)
                #Write-Warning "ERROR $res, $messege, Value: $pwszValueName"
                throw
            }

            try {
                return Parse-RegistryData -dataType $dataType -ptr $ptr -valueSize $valueSize -valueName $pwszValueName
            }
            finally {
                Free-IntPtr -handle $ptr -Method Local
            }
        }

        try {
            $content = Get-LicenseData -SkuID $ActConfigId -Mode License
            $xmlContent = $content.Substring($content.IndexOf('<r'))
            $xml = [xml]$xmlContent
        }
        catch {
        }

        if ($ReturnRawData) {
            return $xml
        }

        # Transform into detailed custom objects
        $licenseObjects = @()

        foreach ($license in $xml.licenseGroup.license) {
            $policyList = @()
            foreach ($policy in $license.grant.allConditions.allConditions.productPolicies.policyStr) {
                $policyList += [PSCustomObject]@{
                    Name  = $policy.name
                    Value = $policy.InnerText
                }
            }

            if (-not $policyList) {
                continue;
            }

            $licenseObjects += [PSCustomObject]@{
                LicenseId  = $license.licenseId
                GrantName  = $license.grant.name
                Policies   = $policyList
            }
        }

        return $licenseObjects
    }
    catch { }
    finally {
        if ($closeHandle) {
            Write-Warning "Consider Open handle Using Manage-SLHandle"
            Free-IntPtr -handle $hSLC -Method License
        }
    }
}

<#
.SYNOPSIS
    Retrieves various system and service information,
    based on the specified value name or fetches all available information if requested.

.Source
   sppwmi.dll.! 
   *GetServiceInformation*

.Usage

Example Code:
~~~~~~~~~~~~

Get-ServiceInfo -loopAllValues
Get-ServiceInfo -pwszValueName SecureStoreId

~~~~~~~~~~~~~~~~~~~~~~~~~

Clear-Host

Write-Host
Write-Host "Get-OA3xOriginalProductKey" -ForegroundColor Green
Get-OA3xOriginalProductKey

Write-Host
Write-Host "Get-ServiceInfo" -ForegroundColor Green
Get-ServiceInfo -loopAllValues | Format-Table -AutoSize

Write-Host
Write-Host "Get-ActiveLicenseInfo" -ForegroundColor Green
Get-ActiveLicenseInfo | Format-List
#>
function Get-ServiceInfo {
    param (
        [Parameter(Mandatory = $false)]
        [ValidateSet(
            "ActivePlugins", "CustomerPID", "SystemState", "Version",
            "BiosOA2MinorVersion", "BiosProductKey", "BiosSlicState",
            "BiosProductKeyDescription", "BiosProductKeyPkPn",
            "ClientMachineID", "SecureStoreId", "SessionMachineId",
            "DiscoveredKeyManagementPort",
            "DiscoveredKeyManagementServicePort",
            "DiscoveredKeyManagementServiceIpAddress",
            "DiscoveredKeyManagementServiceName",
            "IsKeyManagementService",
            "KeyManagementServiceCurrentCount",
            "KeyManagementServiceFailedRequests",
            "KeyManagementServiceLicensedRequests",
            "KeyManagementServiceNonGenuineGraceRequests",
            "KeyManagementServiceNotificationRequests",
            "KeyManagementServiceOOBGraceRequests",
            "KeyManagementServiceOOTGraceRequests",
            "KeyManagementServiceRequiredClientCount",
            "KeyManagementServiceTotalRequests",
            "KeyManagementServiceUnlicensedRequests",
            "TokenActivationAdditionalInfo",
            "TokenActivationCertThumbprint",
            "TokenActivationGrantNumber",
            "TokenActivationILID",
            "TokenActivationILVID"
        )]
        [String]$pwszValueName,

        [Parameter(Mandatory = $false)]
        [switch]$loopAllValues,

        [Parameter(Mandatory=$false)]
        [Intptr]$hSLC = [IntPtr]::Zero
    )

    # !Xor Case
    if (!($pwszValueName -xor [BOOL]$loopAllValues)) {
        Write-Warning "Exactly one of -pwszValueName, -loopAllValues, must be specified."
        return
    }

    if (-not $hSLC -or $hSLC -eq [IntPtr]::Zero -or $hSLC -eq 0) {
        $hSLC = if ($global:hSLC_ -and $global:hSLC_ -ne [IntPtr]::Zero -and $global:hSLC_ -ne 0) {
            $global:hSLC_
        } else {
            Manage-SLHandle
        }
    }

    try {
        $closeHandle = $true
        if (-not $hSLC -or $hSLC -eq [IntPtr]::Zero -or $hSLC -eq 0) {
            $hr = $Global:SLC::SLOpen([ref]$hSLC)
            if ($hr -ne 0) {
                throw "SLOpen failed: HRESULT 0x{0:X8}" -f $hr
            }
        } else {
            $closeHandle = $false
        }
    }
    catch {
        return $null
    }

    try {
        $allValues = @{}
        if ($loopAllValues) {
            $allValueNames = @(
                "ActivePlugins", "CustomerPID", "SystemState", "Version",
                "BiosOA2MinorVersion", "BiosProductKey", "BiosSlicState",
                "BiosProductKeyDescription", "BiosProductKeyPkPn",
                "ClientMachineID", "SecureStoreId", "SessionMachineId",
                "DiscoveredKeyManagementPort",
                "DiscoveredKeyManagementServicePort",
                "DiscoveredKeyManagementServiceIpAddress",
                "DiscoveredKeyManagementServiceName",
                "IsKeyManagementService",
                "KeyManagementServiceCurrentCount",
                "KeyManagementServiceFailedRequests",
                "KeyManagementServiceLicensedRequests",
                "KeyManagementServiceNonGenuineGraceRequests",
                "KeyManagementServiceNotificationRequests",
                "KeyManagementServiceOOBGraceRequests",
                "KeyManagementServiceOOTGraceRequests",
                "KeyManagementServiceRequiredClientCount",
                "KeyManagementServiceTotalRequests",
                "KeyManagementServiceUnlicensedRequests",
                "TokenActivationAdditionalInfo",
                "TokenActivationCertThumbprint",
                "TokenActivationGrantNumber",
                "TokenActivationILID",
                "TokenActivationILVID"
            )

            foreach ($valueName in $allValueNames) {
                $dataType = 0
                $valueSize = 0
                $ptr = [IntPtr]::Zero
                $res = $global:SLC::SLGetServiceInformation(
                    $hSLC,
                    $valueName,
                    [ref]$dataType,
                    [ref]$valueSize,
                    [ref]$ptr
                )

                if ($res -ne 0) {
                    #Write-Warning "fail to process Name: $valueName"
                    $allValues[$valueName] = $null
                    continue;
                }
 
                $allValues[$valueName] = Parse-RegistryData -dataType $dataType -ptr $ptr -valueSize $valueSize -valueName $valueName
                Free-IntPtr -handle $ptr -Method Local
            }

            return $allValues
        }

        if ($pwszValueName) {
            $dataType = 0
            $valueSize = 0
            $ptr = [IntPtr]::Zero
            $res = $global:SLC::SLGetServiceInformation(
                $hSLC,
                $pwszValueName,
                [ref]$dataType,
                [ref]$valueSize,
                [ref]$ptr
            )

            if ($res -ne 0) {
                #$messege = $(Parse-ErrorMessage -MessageId $res)
                #Write-Warning "ERROR $res, $messege, Value: $pwszValueName"
                throw
            }

            # Parse value based on data type
            try {
                return Parse-RegistryData -dataType $dataType -ptr $ptr -valueSize $valueSize -valueName $pwszValueName
            }
            finally {
                Free-IntPtr -handle $ptr -Method Local
            }
        }
    }
    catch { }
    finally {
        if ($closeHandle) {
            Write-Warning "Consider Open handle Using Manage-SLHandle"
            Free-IntPtr -handle $hSLC -Method License
        }
    }
}

<#
.SYNOPSIS
Get active information using SLGetActiveLicenseInfo API
return value is struct DigitalProductId4

Also, Parse-DigitalProductId4 function, read same results just from registry
"HKLM:\SOFTWARE\Microsoft\Windows NT\CurrentVersion" -> DigitalProductId4 [Propertie]

*** not always, in case of ==> Get-OA3xOriginalProductKey == TRUE
Get-ActiveLicenseInfo ==> IS EQAL too ==>
$GroupID = Decode-Key -Key (Get-OA3xOriginalProductKey) | Select-Object -ExpandProperty Group
$Global:PKeyDatabase | ? RefGroupId -eq $GroupID | Select-Object -First 1

it also mask the key, like it was mak key [it's bios key !]
and, not even active, so, why mark it as active ?

.Usage

Example Code:
~~~~~~~~~~~~

Clear-Host

Write-Host
Write-Host "Get-OA3xOriginalProductKey" -ForegroundColor Green
Get-OA3xOriginalProductKey

Write-Host
Write-Host "Get-ServiceInfo" -ForegroundColor Green
Get-ServiceInfo -loopAllValues | Format-Table -AutoSize

Write-Host
Write-Host "Get-ActiveLicenseInfo" -ForegroundColor Green
Get-ActiveLicenseInfo | Format-List
#>
function Get-ActiveLicenseInfo {
    param (
        [Guid]$SkuID = [Guid]::Empty
    )

    # Initialize all pointers to zero
    $hSLC = $ptr = $contextPtr = [IntPtr]::Zero
    $size = 0

    try {
        # If GUID is provided, allocate and copy
        if ($SkuID -ne [Guid]::Empty) {
            $guidBytes = $SkuID.ToByteArray()
            $contextPtr = New-IntPtr -Size 16
            [Marshal]::Copy($guidBytes, 0, $contextPtr, 16)
        }

        Manage-SLHandle -Release | Out-Null
        $hSLC = Manage-SLHandle

        if ($hSLC -eq [IntPtr]::Zero) {
            throw "Fail to get handle from SLOPEN API"
        }

        $res = $Global:SLC::SLGetActiveLicenseInfo($hSLC, $contextPtr, [ref]$size, [ref]$ptr)
        if ($res -ne 0 -or $ptr -eq [IntPtr]::Zero -or $size -le 0) {
            $ErrorMessage = Parse-ErrorMessage -MessageId $res
            throw "SLGetActiveLicenseInfo failed with HRESULT: $res, $ErrorMessage."
        }

        if ($size -lt 1280) {
            throw "Returned license buffer too small ($size bytes). Expected >= 1280 for DigitalProductId4."
        }
        
        Parse-DigitalProductId4 -Pointer $ptr -Length $size -FromIntPtr
    }
    catch {
        Write-Warning "Failed to get active license info: $_"
    }
    finally {
        if ($hSLC -ne [IntPtr]::Zero) {
            Manage-SLHandle -Release | Out-Null
        }
        if ($contextPtr -ne [IntPtr]::Zero) {
            New-IntPtr -hHandle $contextPtr -Release
        }
        if ($ptr -ne [IntPtr]::Zero) {
            $Global:kernel32::LocalFree($ptr) | Out-Null
        }
    }
}

<#
.SYNOPSIS
Get Info per license, using Pkeyconfig [XML] & low level API

$WMI_QUERY = Get-SLIDList -eQueryIdType SL_ID_PRODUCT_SKU -eReturnIdType SL_ID_PRODUCT_SKU
$WMI_SQL = $WMI_QUERY | % { Get-LicenseInfo -ActConfigId $_ }
$WMIINFO = $WMI_SQL | Select-Object * -ExcludeProperty Policies | ? EditionID -NotMatch 'ESU'
Manage-SLHandle -Release | Out-null
#>
function Get-LicenseInfo {
    param(
        [Parameter(Mandatory = $true)]
        [string] $ActConfigId,

        [Parameter(Mandatory=$false)]
        [Intptr]$hSLC = [IntPtr]::Zero
    )
    function Get-BrandingValue {
        param (
            [Parameter(Mandatory=$true)]
            [guid]$sku
        )

        try {

            # Fetch license details for the SKU
            $xml = Get-LicenseDetails -ActConfigId $sku -ReturnRawData -hSLC $hSLC
            if (-not $xml) {
                return;  }

            $BrandingValue = $xml.licenseGroup.license[1].otherInfo.infoTables.infoList.infoStr | Where-Object Name -EQ 'win:branding'
            return $BrandingValue.'#text'

            #$match = $Global:productTypeTable | Where-Object {
            #    [Convert]::ToInt32($_.DWORD, 16) -eq $BrandingValue.'#text'
            #}
            #return $match.ProductID

        } catch {
            Write-Warning "An error occurred: $_"
            return $null
        }
    }
    Function Get-KeyManagementServiceInfo {
        param (
            [Parameter(Mandatory=$true)]
            [STRING]$SKU_ID
        )

        if ([STRING]::IsNullOrWhiteSpace($SKU_ID) -or (
        $SKU_ID -notmatch '^[0-9a-fA-F]{8}-([0-9a-fA-F]{4}-){3}[0-9a-fA-F]{12}$')) {
            Return @();
        }

        $Base = "HKLM:SOFTWARE\Microsoft\Windows NT\CurrentVersion\SoftwareProtectionPlatform"
        $Application_ID = Retrieve-SKUInfo -SkuId 7103a333-b8c8-49cc-93ce-d37c09687f92 -eReturnIdType SL_ID_APPLICATION | select -ExpandProperty Guid

        if ($Application_ID) {
            $KeyManagementServiceName = Get-ItemProperty -Path "$Base\$Application_ID\$SKU_ID" -Name "KeyManagementServiceName" -ea 0 | select -ExpandProperty KeyManagementServiceName
            $KeyManagementServicePort = Get-ItemProperty -Path "$Base\$Application_ID\$SKU_ID" -Name "KeyManagementServicePort" -ea 0 | select -ExpandProperty KeyManagementServicePort
        }
        if (-not $KeyManagementServiceName) {
            $KeyManagementServiceName = Get-ItemProperty -Path "$Base" -Name "KeyManagementServiceName" -ea 0 | select -ExpandProperty KeyManagementServiceName
        }
        if (-not $KeyManagementServicePort) {
            $KeyManagementServicePort = Get-ItemProperty -Path "$Base" -Name "KeyManagementServicePort" -ea 0 | select -ExpandProperty KeyManagementServicePort
        }
        return @{
            KeyManagementServiceName = $KeyManagementServiceName
            KeyManagementServicePort = $KeyManagementServicePort
        }
    }

    if (-not $hSLC -or $hSLC -eq [IntPtr]::Zero -or $hSLC -eq 0) {
        $hSLC = if ($global:hSLC_ -and $global:hSLC_ -ne [IntPtr]::Zero -and $global:hSLC_ -ne 0) {
            $global:hSLC_
        } else {
            Manage-SLHandle
        }
    }

    try {
        $closeHandle = $true
        if (-not $hSLC -or $hSLC -eq [IntPtr]::Zero -or $hSLC -eq 0) {
            $hr = $Global:SLC::SLOpen([ref]$hSLC)
            if ($hr -ne 0) {
                throw "SLOpen failed: HRESULT 0x{0:X8}" -f $hr
            }
        } else {
            $closeHandle = $false
        }
    }
    catch {
        return $null
    }
    
    # Normalize GUID (no braces for WMI)
    $guidNoBraces = $ActConfigId.Trim('{}')

    # Get WMI data filtered by ID
    #$wmiData = Get-WmiObject -Query "SELECT * FROM SoftwareLicensingProduct WHERE ID='$guidNoBraces'"

    $Policies = Get-LicenseDetails -ActConfigId $ActConfigId -hSLC $hSLC
    if ($Policies) {
        $policiesArray = foreach ($item in $Policies) {
            $LicenseId = $item.LicenseId
            foreach ($policy in $item.Policies) {
                if ($policy.Name -and $policy.Value) {
                    [PSCustomObject]@{
                        ID    = $LicenseId
                        Name  = $policy.Name
                        Value = $policy.Value
                    }
                }
            }
        }
    }

    # Gets the information of the specified product key.
    $SLCPKeyInfo = Get-SLCPKeyInfo -SKU $ActConfigId -loopAllValues -hSLC $hSLC

    # Define your ValidateSet values for license details
    $info = Get-LicenseDetails -ActConfigId $ActConfigId -loopAllValues -hSLC $hSLC

    if ($closeHandle) {
        Write-Warning "Consider Open handle Using Manage-SLHandle"
        Free-IntPtr -handle $hSLC -Method License
    }

    # Extract XML data filtered by ActConfigId
    $xmlData = $Global:PKeyDatabase | ? { $_.ActConfigId -eq $ActConfigId -or $_.ActConfigId -eq "{$guidNoBraces}" }
    $KeyManagementServiceInfo = Get-KeyManagementServiceInfo -SKU_ID $ActConfigId

    $ppwszInstallation = $null
    $ppwszInstallationIdPtr = [IntPtr]::Zero
    $pProductSkuId = [GUID]::new($ActConfigId)
    $null = $Global:SLC::SLGenerateOfflineInstallationIdEx(
        $hSLC, [ref]$pProductSkuId, 0, [ref]$ppwszInstallationIdPtr)
    if ($ppwszInstallationIdPtr -ne [IntPtr]::Zero) {
        $ppwszInstallation = [marshal]::PtrToStringAuto($ppwszInstallationIdPtr)
    }
    Free-IntPtr -handle $ppwszInstallationIdPtr -Method Local
    $ppwszInstallationIdPtr = 0

    $Branding = Get-BrandingValue -sku $ActConfigId

    return [PSCustomObject]@{
        # Policies
        Branding = $Branding
        Policies = $policiesArray

        # XML data properties, with safety checks
        ActConfigId        = if ($xmlData.ActConfigId) { $xmlData.ActConfigId } else { $null }
        RefGroupId         = if ($xmlData.RefGroupId) { $xmlData.RefGroupId } else { $null }
        EditionId          = if ($xmlData.EditionId) { $xmlData.EditionId } else { $null }
        #ProductDescription = if ($xmlData.ProductDescription) { $xmlData.ProductDescription } else { $null }
        ProductKeyType     = if ($xmlData.ProductKeyType) { $xmlData.ProductKeyType } else { $null }
        IsRandomized       = if ($xmlData.IsRandomized) { $xmlData.IsRandomized } else { $null }

        # License Details (from ValidateSet)
        Description          = $info["Description"]
        Name                 = $info["Name"]
        Author               = $info["Author"]
        licenseType         = $info["licenseType"]
        licenseVersion      = $info["licenseVersion"]
        licensorUrl         = $info["licensorUrl"]
        licenseCategory     = $info["licenseCategory"]
        ID                  = $info["productSkuId"]
        privateCertificateId = $info["privateCertificateId"]
        applicationId       = $info["applicationId"]
        productName         = $info["productName"]
        LicenseFamily       = $info["Family"]
        productAuthor       = $info["productAuthor"]
        productDescription  = $info["productDescription"]
        hwidootGrace        = $info["hwid:ootGrace"]
        TrustedTime         = $info["TrustedTime"]
        ProductUniquenessGroupId  = $info["ProductUniquenessGroupId"]
        issuanceCertificateId         = $info["issuanceCertificateId"]
        pkeyConfigLicenseId         = $info["pkeyConfigLicenseId"]
        ValidationURL         = $info["ValUrl"]
        BuildVersion         = $info["BuildVersion"]
        ActivationSequence         = $info["ActivationSequence"]
        EnableActivationValidation         = $info["EnableActivationValidation"]
        ValidityTimerUniqueness         = $info["ValidityTimerUniqueness"]
        ApplicationBitmap         = $info["ApplicationBitmap"]
        
        # Abbody1406 suggestion PAUrl -or EULURL
        UseLicenseURL         = if ($info["PAUrl"]) {$info["PAUrl"]} else {if ($info["EULURL"]) {$info["EULURL"]} else {$null}}
        ExtendedGrace         = $info["TimeBasedExtendedGrace"]
        phone_policy         = $info["phone:policy"]
        UXDifferentiator         = $info["UXDifferentiator"] # WindowsSkuCategory
        ProductKeyGroupUniqueness         = $info["ProductKeyGroupUniqueness"]
        migratable         = $info["migratable"]
        LicenseDependsOn         = $info["DependsOn"]
        LicenseIsAddon           = [BOOL]($info["DependsOn"])
        EnableNotificationMode         = $info["EnableNotificationMode"]
        GraceTimerUniqueness         = $info["GraceTimerUniqueness"]
        VLActivationInterval = $info["VLActivationInterval"]
        ValidationTemplateId = $info["ValidationTemplateId"]      
        licensorKeyIndex = $info["licensorKeyIndex"]
        TokenActivationILID = $info["TokenActivationILID"]
        TokenActivationILVID = $info["TokenActivationILVID"]
        TokenActivationGrantNumber = $info["TokenActivationGrantNumber"]
        TokenActivationCertificateThumbprint = $info["TokenActivationCertificateThumbprint"]
        OfflineInstallationId = $ppwszInstallation

        #KeyManagementServicePort = $info["KeyManagementServicePort"]
        #KeyManagementServiceName = if ($KeyManagementServiceInfo.KeyManagementServiceName) { $KeyManagementServiceInfo.KeyManagementServiceName } else { $null }
        #KeyManagementServicePort = if ($KeyManagementServiceInfo.KeyManagementServicePort) { $KeyManagementServiceInfo.KeyManagementServicePort } else { $null }

        # thank's abbody1406 for last 5 item's
        KeyManagementServiceProductKeyID = $info["CustomerPID"]
        KeyManagementServiceMachine = $info["KeyManagementServiceName"]
        KeyManagementServicePort = $info["KeyManagementServicePort"]
        DiscoveredKeyManagementServiceMachineName = $info["DiscoveredKeyManagementServiceName"]
        DiscoveredKeyManagementServiceMachinePort = $info["DiscoveredKeyManagementServicePort"]

        # another new list from sppwmi.dll
        ADActivationObjectDN = $info["ADActivationObjectDN"]
        ADActivationObjectName = $info["ADActivationObjectName"]
        ADActivationCsvlkPID = $info["ADActivationCsvlkPID"]
        ADActivationCsvlkSkuID = $info["ADActivationCsvlkSkuID"]
        DiscoveredKeyManagementServiceIpAddress = $info["DiscoveredKeyManagementServiceIpAddress"]
        KeyManagementServiceLookupDomain = $info["KeyManagementServiceLookupDomain"]
        TokenActivationAdditionalInfo = $info["TokenActivationAdditionalInfo"]
        TokenActivationCertThumbprint = $info["TokenActivationCertThumbprint"]
        VLActivationType = $info["VLActivationType"]
        RearmCount = $info["RearmCount"]
        RemainingRearmCount = $info["RemainingRearmCount"]

        # CPKey Info
        ProductKeyChannel    = $SLCPKeyInfo["Channel"]
        ProductKeyID        = $SLCPKeyInfo["DigitalPID"]
        ProductKeyID2       = $SLCPKeyInfo["DigitalPID2"]
        #ProductSkuId      = $SLCPKeyInfo["ProductSkuId"]
        PartialProductKey = $SLCPKeyInfo["PartialProductKey"]
    }
}

<#
Service & Active Lisence Info
~ Get-ServiceInfo >> SLGetServiceInformation
~ Get-ActiveLicenseInfo >> SLGetActiveLicenseInfo

mostly good for oem information
in case of oem license not exist,
SLGetActiveLicenseInfo will output current active license
#>
Function Query-ActiveLicenseInfo {
    $Info = @()
    $licInput, $serInput = @{}, @{}

    try {
        $ActiveLicenseInfo = Get-ActiveLicenseInfo
        @("ActivationID", "AdvancedPID", "DigitalKey",
            "EditionID", "EditionType", "EULA", "KeyType",
            "MajorVersion", "MinorVersion" ) | % { $licInput.Add($_,$ActiveLicenseInfo.$_)}

        $licInput.Keys | Sort | % {
            $Info += [PSCustomObject]@{
                Name = $_
                Value = $licInput[$_]
            }
        }

        $ServiceInfo = Get-ServiceInfo -loopAllValues
        $ServiceInfo.Keys | % { $serInput.Add($_,$ServiceInfo[$_])}

        $serInput.Keys | Sort | % {
            $Info += [PSCustomObject]@{
                Name = $_
                Value = $serInput[$_]
            }
        }
    }
    catch {
    }

    return $Info
}
# License Info Part -->

# Start #
# Extract Keys Function's
# Begin #

function Get-Strings {
    param (
        [Parameter(Position = 1, Mandatory = $True)]
        [ValidateNotNullOrEmpty()]
        [String[]]
        $Path,

        [ValidateSet('Default','Ascii','Unicode')]
        [String]
        $Encoding = 'Default',

        [UInt32]
        $MinimumLength = 3
    )

    $Results = @()

    foreach ($File in $Path) {
        if ($Encoding -eq 'Unicode' -or $Encoding -eq 'Default') {
            $UnicodeFileContents = Get-Content -Encoding 'Unicode' $File -EA 0
            if (![STRING]::IsNullOrWhiteSpace($UnicodeFileContents)) {
                $UnicodeRegex = [Regex] "[\u0020-\u007E]{$MinimumLength,}"
                $Results += $UnicodeRegex.Matches($UnicodeFileContents)
            }
        }
        
        if ($Encoding -eq 'Ascii' -or $Encoding -eq 'Default') {
            $AsciiFileContents = Get-Content -Encoding 'UTF7' $File
            $AsciiRegex = [Regex] "[\x20-\x7E]{$MinimumLength,}"
            $Results += $AsciiRegex.Matches($AsciiFileContents)
        }
    }

    return $Results | ForEach-Object { $_.Value }
}
function Extract-CdKeys {
    param (
        [string[]]$strings
    )

    # Define a regex pattern to match the CD keys
    $pattern = '\b[A-Z0-9]{5}-[A-Z0-9]{5}-[A-Z0-9]{5}-[A-Z0-9]{5}-[A-Z0-9]{5}\b'

    # Create a hash set to store unique CD keys
    $uniqueCdKeys = @{}

    # Extract the CD keys
    foreach ($line in $strings) {
        if ($line -match $pattern) {
            $matches = [regex]::Matches($line, $pattern)
            foreach ($match in $matches) {
                $uniqueCdKeys[$match.Value] = $true
            }
        }
    }

    return $uniqueCdKeys.Keys
}
function Add-Missing-Ref {
    param (
        [string[]]$cdKeys
    )

    # Define the output list for results
    $results = @()

    # Read reference data into a hash table
    $IgnoreCase = [Text.RegularExpressions.RegexOptions]::IgnoreCase
    $Rpattern = '^\s*(\d+)\s*=\s*"(.*)"\s*#?\s*(.*)?$'
    $refHashTable = @{}

    # Process each key from cdKeys
    foreach ($keyInfo in $cdKeys) {
        if ($keyInfo) {
            $keyId = $null
            try {
            $keyId = @(KeyDecode -key0 $keyInfo )[2].Value
            }
            catch {}

            # Use the captured KeyId in the results
            if ($keyId) {
                $results += "$keyId = `"$keyInfo`" # Add Ref."
            } else {
                continue
            }
        }
    }

    return $results
}
function Add-Missing-Label {
    param (
        [PSCustomObject[]]$referenceData  # Accepts reference data directly
    )

    # Create a list for results
    $results = [List[PSCustomObject]]::new()

    $IgnoreCase = [Text.RegularExpressions.RegexOptions]::IgnoreCase
    $pattern = '^\s*(\d+)\s*=\s*"(.*)"\s*#.*$'

    # Read all keys from the reference data
    foreach ($line in $referenceData) {
        $match = [Regex]::Matches($line, $pattern, $IgnoreCase)

        if ($match.Count -gt 0) {
            $keyKey = $match[0].Groups[1].Value.Trim()  # Key
            $keyValue = $match[0].Groups[2].Value.Trim()  # Value

            # Check for a corresponding reference
            $KeyText = $KeysText[[int]$keyKey]

            # Add the processed key to results
            $results.Add([PSCustomObject]@{ Key = $keyKey; Value = $keyValue; RefText = $KeyText })
        }
    }

    # Return the results
    return $results
}

# Start #
# Windows Form Function's
# Begin #

function Filter-HashTable {
    param (
        [hashtable]$table
    )

    # Define the keys we want to handle
    $keysToCheck = @(
        "OEM", "OEM:COA", "OEM:SLP", "OEM:NONSLP", "OEM:DM", "Volume:GVLK", "Volume:MAK"
    )

    # Initialize a hashtable to store values
    $values = @{}
    
    # Populate the values hashtable, defaulting to $null if keys do not exist
    foreach ($key in $keysToCheck) {
        $values[$key] = if ($table.ContainsKey($key)) { $table[$key] } else { $null }
    }

    # Create a new hashtable for the results
    $filteredTable = @{}

    # Always keep specified values
    foreach ($key in @("OEM:COA", "OEM:SLP", "OEM:NONSLP", "OEM:DM", "Volume:GVLK", "Volume:MAK", "Retail")) {
        if ($values[$key]) { $filteredTable[$key] = $values[$key] }
    }

    # Only keep OEM if it doesn't share a value with OEM:NONSLP or OEM:DM
    if (($values["OEM"] -ne $values["OEM:NONSLP"]) -and ($values["OEM"] -ne $values["OEM:DM"]) -and 
	  ($values["OEM"] -ne $values["OEM:COA"])  -and ($values["OEM"] -ne $values["OEM:SLP"]) -and ($values["OEM"] -ne $values["Retail"])) {
        if ($filteredTable.ContainsKey("OEM:DM")) {
		  $filteredTable["OEM:DM:$"] = $values["OEM"] 
		} else {
		  $filteredTable["OEM:DM"] = $values["OEM"] 
		}
    }

    # Remove Retail if its value matches any of the OEM types
    if ($filteredTable.ContainsKey("Retail")) {
        foreach ($k in @("OEM:COA", "OEM:SLP", "OEM:NONSLP", "OEM:DM")) {
            if ($values["Retail"] -eq $values[$k]) {
                $filteredTable.Remove("Retail")
                break
            }
        }
    }

    # Final pass: Remove OEM-type keys if they match Volume:GVLK
    $volumeGVLK = $values["Volume:GVLK"]
    if ($volumeGVLK) {
        foreach ($k in @("OEM", "OEM:COA", "OEM:SLP", "OEM:NONSLP", "OEM:DM", "OEM:DM:$")) {
            if ($filteredTable.ContainsKey($k) -and $filteredTable[$k] -eq $volumeGVLK) {
                $filteredTable.Remove($k)
            }
        }
    }

    # Final pass: Remove OEM-type keys if they match Volume:MAK
    $volumeGVLK = $values["Volume:MAK"]
    if ($volumeGVLK) {
        foreach ($k in @("OEM", "OEM:COA", "OEM:SLP", "OEM:NONSLP", "OEM:DM", "OEM:DM:$")) {
            if ($filteredTable.ContainsKey($k) -and $filteredTable[$k] -eq $volumeGVLK) {
                $filteredTable.Remove($k)
            }
        }
    }

    # If Volume:GVLK equals Volume:MAK, replace both with Volume
    $volGVLK = $values["Volume:GVLK"]
    $volMAK  = $values["Volume:MAK"]

    if ($volGVLK -and $volGVLK -eq $volMAK) {
        $filteredTable.Remove("Volume:GVLK")
        $filteredTable.Remove("Volume:MAK")
        $filteredTable["Volume"] = $volGVLK
    }

    return $filteredTable
}
function Create-RoundedRectangleRegion {
    param (
        [Rectangle]$rect,
        [float]$radius
    )

    $path = New-Object Drawing2D.GraphicsPath
    $path.AddArc($rect.X, $rect.Y, $radius, $radius, 180, 90) # Top-left corner
    $path.AddArc($rect.X + $rect.Width - $radius, $rect.Y, $radius, $radius, 270, 90) # Top-right corner
    $path.AddArc($rect.X + $rect.Width - $radius, $rect.Y + $rect.Height - $radius, $radius, $radius, 0, 90) # Bottom-right corner
    $path.AddArc($rect.X, $rect.Y + $rect.Height - $radius, $radius, $radius, 90, 90) # Bottom-left corner
    $path.CloseFigure()
    return $path
}
Function ValidateForm {
    $font = New-Object System.Drawing.Font('Segoe UI', 10)
    $form = New-Object System.Windows.Forms.Form
    $form.Size = New-Object System.Drawing.Size(750, 650)
    $form.StartPosition = 'CenterScreen'
    $form.FormBorderStyle = [System.Windows.Forms.FormBorderStyle]::FixedDialog
    $form.MaximizeBox = $false
    $form.MinimizeBox = $false
    $form.BackColor = [System.Drawing.Color]::LightSteelBlue

    $txtCdKey = New-Object System.Windows.Forms.TextBox
    $txtCdKey.Location = New-Object System.Drawing.Point(20, 20)
    $txtCdKey.Size = New-Object System.Drawing.Size(700, 250)
    $txtCdKey.Multiline = $true
    $txtCdKey.Font = $font
    $txtCdKey.ScrollBars = 'Vertical'
    $txtCdKey.Text = @"
    Latest LTSC 2021 KEY activation key sharing

    Win 2021 RTM EnterpriseSN Volume:MAK

    XQ8WW-N6WGD-67K88-74XDH-RGG2T

    GD4TT-HKNR7-PT36K-FF64G-PDQCT

    7F6DW-3NH9Q-H46WY-8VTXC-MP46G

    DH9CD-TKNQH-W3H7G-GD6JT-9K3CT
"@
    $form.Controls.Add($txtCdKey)

    $txtResult = New-Object System.Windows.Forms.RichTextBox
    $txtResult.Location = New-Object System.Drawing.Point(20, 300)
    $txtResult.Size = New-Object System.Drawing.Size(700, 250)
    $txtResult.Font = $font
    $txtResult.ReadOnly = $true
    $txtResult.ScrollBars = 'Vertical'
    $txtResult.WordWrap = $false
    $form.Controls.Add($txtResult)

    $btnValidate = New-Object System.Windows.Forms.Button
    $btnValidate.Text = "Validate"
    $btnValidate.Location = New-Object System.Drawing.Point(20, 560)
    $btnValidate.Size = New-Object System.Drawing.Size(150, 40)
    $btnValidate.Font = $font
    $btnValidate.Add_Click({
        $txtResult.Clear()
        $CdKeys = Extract-CdKeys $txtCdKey.Text
        if ($chkOption.Checked) {
            $lookUpInfo = Lookup-ProductKey -ProductKey $CdKeys -Consume
        } else {
            $lookUpInfo = Lookup-ProductKey -ProductKey $CdKeys
        }
        if ($lookUpInfo -ne $null) {
            $results = @()
            $global:jsonContent = $null
            $lookUpInfo | % {
                $txtResult.AppendText(("ProductKey:         {0}" -f $_.ProductKey) + "`n")
                $txtResult.AppendText(("BatchActivation:    {0}" -f $_.BatchActivation) + "`n")
                $txtResult.AppendText(("SLCertifyProduct:   {0}" -f $_.SLCertifyProduct) + "`n")
                if ($_.SLActivateProduct) {
                   $txtResult.AppendText(("SLActivateProduct: {0}" -f $_.SLActivateProduct) + "`n")
                }
                $txtResult.AppendText("`n") 
                $results += [PSCustomObject]@{
                    ProductKey        = $_.ProductKey
                    BatchActivation   = $_.BatchActivation
                    SLCertifyProduct  = $_.SLCertifyProduct
                    SLActivateProduct = $_.SLActivateProduct
                }
            }
            $global:jsonContent = $results | ConvertTo-Json -Depth 5
        }
    })
    $form.Controls.Add($btnValidate)

    $btnClear = New-Object System.Windows.Forms.Button
    $btnClear.Text = "Clear"
    $btnClear.Location = New-Object System.Drawing.Point(185, 560) 
    $btnClear.Size = New-Object System.Drawing.Size(150, 40)
    $btnClear.Font = $font
    $btnClear.Add_Click({
        $txtCdKey.Clear()
        $txtResult.Clear()
    })
    $form.Controls.Add($btnClear)

    $CopyBtn = New-Object System.Windows.Forms.Button
    $CopyBtn.Text = "Open In Notepad"
    $CopyBtn.Location = New-Object System.Drawing.Point(350, 560) 
    $CopyBtn.Size = New-Object System.Drawing.Size(150, 40)
    $CopyBtn.Font = $font
    $CopyBtn.Add_Click({
        if ($global:jsonContent) {
            $tempFilePath = "$env:windir\temp\json.txt"
            $global:jsonContent | out-file $tempFilePath
            notepad $tempFilePath
            [System.Windows.Forms.Clipboard]::SetText($txtResult.Text)
        }
    })
    $form.Controls.Add($CopyBtn)

    $chkOption = New-Object System.Windows.Forms.CheckBox
    $chkOption.Text = "Consume Key [API]"
    $chkOption.Location = New-Object System.Drawing.Point(550, 560) 
    $chkOption.Size = New-Object System.Drawing.Size(300, 50) 
    $chkOption.Font = New-Object System.Drawing.Font('Segoe UI', 12) 
    $form.Controls.Add($chkOption)

    # Show the form
    $form.ShowDialog()
}
function EncodeForm {
    
    # Create the form
    $form = New-Object Form
    $form.Size = New-Object Size(650, 950)
    $form.StartPosition = 'CenterScreen'
    $form.FormBorderStyle = [FormBorderStyle]::FixedDialog
    $form.MaximizeBox = $false
    $form.MinimizeBox = $false
    $form.BackColor = [Color]::LightSteelBlue

    # Create a font for labels and inputs
    $font = New-Object Font('Segoe UI', 10)
    $listViewFont = New-Object Font('Segoe UI', 9)

    # Upper GroupBox for Generate by ID
    $groupBoxZxy = New-Object GroupBox
    $groupBoxZxy.Text = "By GUID"
    $groupBoxZxy.Size = New-Object Size(600, 120)  # Adjusted to fit controls
    $groupBoxZxy.Location = New-Object Point(20, 780)
    $groupBoxZxy.AutoSize = $true  # Automatically resize if needed
    $form.Controls.Add($groupBoxZxy)

    # Text box for search input
    $inputFieldSearchID = New-Object TextBox
    $inputFieldSearchID.Location = New-Object Point(20, 30)  # Adjusted location
    $inputFieldSearchID.Width = 360
    $inputFieldSearchID.Font = $font
    $inputFieldSearchID.TextAlign = [HorizontalAlignment]::Center
    $groupBoxZxy.Controls.Add($inputFieldSearchID)

    # Button to search
    $buttonSearchID = New-Object Button
    $buttonSearchID.Text = 'Generate'
    $buttonSearchID.Location = New-Object Point(400, 30)  # Adjusted location
    $buttonSearchID.Width = 170
    $buttonSearchID.Height = 30
    $buttonSearchID.Font = $font
    $buttonSearchID.BackColor = [Color]::CadetBlue
    $buttonSearchID.ForeColor = [Color]::White
    $buttonSearchID.FlatStyle = [System.Windows.Forms.FlatStyle]::Flat  # Fixed FlatStyle
    $groupBoxZxy.Controls.Add($buttonSearchID)

    # Text box for displaying results
    $inputFieldResults = New-Object TextBox
    $inputFieldResults.Location = New-Object Point(20, 70)  # Adjusted to be below the search box
    $inputFieldResults.Width = 550  # Larger width to display results
    $inputFieldResults.Height = 30  # Height to fit the results
    $inputFieldResults.Font = New-Object Font('Segoe UI', 10)
    $inputFieldResults.ReadOnly = $true  # Make it read-only to prevent editing
    $inputFieldResults.TextAlign = [HorizontalAlignment]::Center
    $groupBoxZxy.Controls.Add($inputFieldResults)

    # Button click event to validate the GUID
    $buttonSearchID.Add_Click({
        # Function to validate GUID
        function Validate-Guid {
            param (
                [string]$guid
            )
    
            # Regular expression for GUID with or without curly braces
            $regex = '^\{?[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}\}?$'
    
            # Test if the input matches the regex pattern
            if ($guid -match $regex) {
                return $true
            } else {
                return $false
            }
        }

        # Get the input from the search box and trim any extra spaces
        $inputText = $inputFieldSearchID.Text.Trim()

        # Validate the input GUID
        if (Validate-Guid $inputText) {
            # If the GUID is valid, remove curly braces, trim spaces, and display it
            $validGuid = $inputText -replace '^\{|\}$'  # Remove { or } at the beginning/end of the GUID
            $validGuid = $validGuid.Trim()  # Trim any extra spaces after removing curly braces
        
            # Retrieve key using the valid GUID (replace with your actual logic)
            $key = GetRandomKey -ProductID $validGuid
        
            if ($key) {
                # If the key is found, display it in the result TextBox
                $inputFieldResults.Text = $key
            } else {
                # If the key retrieval failed, show an error message
                $inputFieldResults.Text = "Failed to retrieve key for Product ID: $validGuid"
            }
        } else {
            # If the GUID is not valid, clear the results text box
            $inputFieldResults.Text = "ERROR: Not a valid {GUID}"  # Clear the results text box
        }
    })

    # Upper GroupBox for Calculation
    $groupBoxCalc = New-Object GroupBox
    $groupBoxCalc.Text = "Calculate"
    $groupBoxCalc.Size = New-Object Size(600, 160)
    $groupBoxCalc.Location = New-Object Point(20, 20)
    $form.Controls.Add($groupBoxCalc)

    # Label and input fields for 'Group', 'Secret', and 'ID'
    $labelGroup = New-Object System.Windows.Forms.Label
    $labelGroup.Text = 'Group:'
    $labelGroup.AutoSize = $true
    $labelGroup.Font = $font
    $labelGroup.Location = New-Object Point(20, 30)
    $groupBoxCalc.Controls.Add($labelGroup)

    $inputFieldGroup = New-Object TextBox
    $inputFieldGroup.Location = New-Object Point(80, 30)
    $inputFieldGroup.Width = 60
    $inputFieldGroup.Font = $font
    $inputFieldGroup.Text = "0"
    $inputFieldGroup.TextAlign = [HorizontalAlignment]::Center
    $groupBoxCalc.Controls.Add($inputFieldGroup)

    $labelSecret = New-Object System.Windows.Forms.Label
    $labelSecret.Text = 'Secret:'
    $labelSecret.AutoSize = $true
    $labelSecret.Location = New-Object Point(145, 30)
    $labelSecret.Font = $font
    $groupBoxCalc.Controls.Add($labelSecret)

    $inputFieldSecret = New-Object TextBox
    $inputFieldSecret.Location = New-Object Point(205, 30)
    $inputFieldSecret.Width = 105
    $inputFieldSecret.Text = '0'
    $inputFieldSecret.Font = $font
    $inputFieldSecret.TextAlign = [HorizontalAlignment]::Center
    $groupBoxCalc.Controls.Add($inputFieldSecret)

    $labelID = New-Object System.Windows.Forms.Label
    $labelID.Text = 'ID:'
    $labelID.AutoSize = $true
    $labelID.Location = New-Object Point(315, 30)
    $labelID.Font = $font
    $groupBoxCalc.Controls.Add($labelID)

    $inputFieldID = New-Object TextBox
    $inputFieldID.Location = New-Object Point(350, 30)
    $inputFieldID.Width = 50
    $inputFieldID.Text = '0'
    $inputFieldID.Font = $font
    $inputFieldID.TextAlign = [HorizontalAlignment]::Center
    $groupBoxCalc.Controls.Add($inputFieldID)

    # New TextBox for "Limit Keys" (Offset value)
    $labelOffset = New-Object System.Windows.Forms.Label
    $labelOffset.Text = "Key's:"
    $labelOffset.AutoSize = $true
    $labelOffset.Location = New-Object Point(410, 30) 
    $labelOffset.Font = $font
    $groupBoxCalc.Controls.Add($labelOffset)

    $MaxKeys = New-Object TextBox
    $MaxKeys.Location = New-Object Point(470, 30) 
    $MaxKeys.Width = 90
    $MaxKeys.Text = '5'
    $MaxKeys.Font = $font
    $MaxKeys.TextAlign = [HorizontalAlignment]::Center
    $groupBoxCalc.Controls.Add($MaxKeys)

    # -----------------

    # Checkbox for 'Pattern' placed before the label
    $checkboxPattern = New-Object System.Windows.Forms.CheckBox
    $checkboxPattern.Location = New-Object Point(20, 70)  # Position of the checkbox
    $checkboxPattern.Width = 20
    $groupBoxCalc.Controls.Add($checkboxPattern)

    # New Label + TextBox for "Pattern" at Y = 70
    $labelPattern = New-Object System.Windows.Forms.Label
    $labelPattern.Text = 'Pattern:'
    $labelPattern.AutoSize = $true
    $labelPattern.Font = $font
    $labelPattern.Location = New-Object Point(40, 70)  # Position after checkbox
    $groupBoxCalc.Controls.Add($labelPattern)

    $inputFieldPattern = New-Object TextBox
    $inputFieldPattern.Location = New-Object Point(105, 70)  # Position next to label
    $inputFieldPattern.Width = 240
    $inputFieldPattern.Text = "NBBBB-BBBBB-BBBBB"
    $inputFieldPattern.Font = $font
    $inputFieldPattern.TextAlign = [HorizontalAlignment]::Left
    $groupBoxCalc.Controls.Add($inputFieldPattern)

    # Checkbox for 'Offset Limit' placed before the label
    $checkboxOffsetLimit = New-Object System.Windows.Forms.CheckBox
    $checkboxOffsetLimit.Location = New-Object Point(360, 70)  # Position of the checkbox
    $checkboxOffsetLimit.Width = 20
    $checkboxOffsetLimit.Checked = $true
    $checkboxOffsetLimit.Enabled = $false
    $groupBoxCalc.Controls.Add($checkboxOffsetLimit)

    # New Label + TextBox for "Offset Limit" at Y = 70
    $labelOffsetLimit = New-Object System.Windows.Forms.Label
    $labelOffsetLimit.Text = 'Offset Limit:'
    $labelOffsetLimit.AutoSize = $true
    $labelOffsetLimit.Font = $font
    $labelOffsetLimit.Location = New-Object Point(380, 70) 
    $groupBoxCalc.Controls.Add($labelOffsetLimit)

    $inputFieldOffsetLimit = New-Object TextBox
    $inputFieldOffsetLimit.Location = New-Object Point(480, 70) 
    $inputFieldOffsetLimit.Width = 80
    $inputFieldOffsetLimit.Font = $font
    $inputFieldOffsetLimit.Text = "20000"
    $inputFieldOffsetLimit.TextAlign = [HorizontalAlignment]::Center
    $groupBoxCalc.Controls.Add($inputFieldOffsetLimit)


    # -----------------

    $buttonCalculate = New-Object Button
    $buttonCalculate.Text = 'Calculate'
    $buttonCalculate.Location = New-Object Point(20, 110)
    $buttonCalculate.Width = 140
    $buttonCalculate.Height = 30
    $buttonCalculate.Font = New-Object Font('Segoe UI', 10, [FontStyle]::Bold)
    $buttonCalculate.BackColor = [Color]::CadetBlue
    $buttonCalculate.ForeColor = [Color]::White
    $buttonCalculate.FlatStyle = 'Flat'
    $buttonCalculate.Add_Click({
        
        # Clear existing items in the ComboBox (resultField)
        $resultField.Items.Clear()

        try {
            [bigint]$sgroupid = 0;
            $isInt = [bigint]::TryParse($inputFieldGroup.Text,[ref]$sgroupid)
            if (-not $isInt -or $sgroupid -lt 0) {
                $resultField.Items.Add("Validate your Group input.")
                throw
            }

            [bigint]$skeyid = -1;
            $isInt = [bigint]::TryParse($inputFieldID.Text,[ref]$skeyid)
            if (-not $isInt -or $skeyid -lt 0) {
                $resultField.Items.Add("Validate your ID input.")
                throw
            }

            [bigint]$sunk = -1;
            $isInt = [bigint]::TryParse($inputFieldSecret.Text,[ref]$sunk)
            if (-not $isInt -or $sunk -lt 0) {
                $resultField.Items.Add("Validate your Secret input.")
                throw
            }

            if ($checkboxPattern.Checked ) {
                # Patteren Code here

                $Pattern = $inputFieldPattern.Text
                if ([string]::IsNullOrWhiteSpace($Pattern)) {
                    $resultField.Items.Add("Check your Pattern String.")
                    throw
                }

               if ($checkboxOffsetLimit.Checked) {
                  [bigint]$OffsetLimit = -1;
                  $isInt = [bigint]::TryParse($inputFieldOffsetLimit.Text,[ref]$OffsetLimit)
                  if (-not $isInt -or $OffsetLimit -le 0) {
                     $resultField.Items.Add("Validate your Offset Input.")
                     throw
                  }
               }

               [bigint]$TotalKeys = 5
                $isInt = [bigint]::TryParse($MaxKeys.Text,[ref]$TotalKeys)
                if (-not $isInt -or $TotalKeys -le 0) {
                    [int]$TotalKeys = 5
                }

                if ($checkboxOffsetLimit.Checked) {
                   $result = List-Keys $sgroupid -Template $Pattern -KeysLimit $TotalKeys -OffsetLimit $OffsetLimit
                }
                else  {
                   $result = List-Keys $sgroupid -Template $Pattern -KeysLimit $TotalKeys
                }
            
              # Patteren Code here
            }
            else {
                $result = Encode-Key $sgroupid $skeyid $sunk
            }

            foreach ($item in $result) {
                $resultField.Items.Add($item)
            }
        }
        catch {
        }

        if ($resultField.Items.Count -gt 0) {
            $resultField.SelectedIndex = 0 
        }
    })
    $groupBoxCalc.Controls.Add($buttonCalculate)

    # Create ComboBox for selecting options (like a dropdown)
    $resultField = New-Object System.Windows.Forms.ComboBox
    $resultField.Location = New-Object Point(180, 110)
    $resultField.Width = 380
    $resultField.Font = $font
    $resultField.DropDownStyle = [System.Windows.Forms.ComboBoxStyle]::DropDownList  # Non-editable dropdown
    $resultField.BackColor = [Color]::White
    $resultField.Add_SelectedIndexChanged({
        # Get the selected item text from the ComboBox
        $selectedText = $resultField.SelectedItem
        Write-Host "$selectedText, copied to clipboard"

        # Copy it to clipboard
        [Clipboard]::SetText($selectedText)
    })
    $groupBoxCalc.Controls.Add($resultField)

    # Lower GroupBox for Search
    $groupBoxSearch = New-Object GroupBox
    $groupBoxSearch.Text = "Find Products"
    $groupBoxSearch.Size = New-Object Size(600, 300)
    $groupBoxSearch.Location = New-Object Point(20, 200)
    $form.Controls.Add($groupBoxSearch)

    # Text box for search input
    $inputFieldSearch = New-Object TextBox
    $inputFieldSearch.Location = New-Object Point(20, 30)
    $inputFieldSearch.Width = 360
    $inputFieldSearch.Font = $font
    $groupBoxSearch.Controls.Add($inputFieldSearch)

    # Button to search
    $buttonSearch = New-Object Button
    $buttonSearch.Text = 'Search'
    $buttonSearch.Location = New-Object Point(400, 30)
    $buttonSearch.Width = 170
    $buttonSearch.Height = 30
    $buttonSearch.Font = New-Object Font('Segoe UI', 10, [FontStyle]::Bold)
    $buttonSearch.BackColor = [Color]::CadetBlue
    $buttonSearch.ForeColor = [Color]::White
    $buttonSearch.FlatStyle = 'Flat'
    $groupBoxSearch.Controls.Add($buttonSearch)

    # ListView to display search results
    $listViewResults = New-Object ListView
    $listViewResults.Location = New-Object Point(20, 70)
    $listViewResults.Size = New-Object Size(550, 200)
    $listViewResults.View = 'Details'
    $listViewResults.FullRowSelect = $true
    $listViewResults.GridLines = $true
    $listViewResults.Font = $listViewFont
    $groupBoxSearch.Controls.Add($listViewResults)

    # Add columns to ListView
    $listViewResults.Columns.Add("Key", 50)
    $listViewResults.Columns.Add("Description", 650)

    
    # Populate the ListView with initial data from the hashtable
    foreach ($key in $KeysText.Keys) {
        $item = New-Object ListViewItem($key.ToString())
        $item.SubItems.Add($KeysText[$key])
        $listViewResults.Items.Add($item)
    }

    # Search button click event
    $buttonSearch.Add_Click({
        $listViewResults.Items.Clear()
        $searchTerm = $inputFieldSearch.Text.Trim()
        
        if ($searchTerm -ne "") {
            foreach ($key in $KeysText.Keys) {
                if ($KeysText[$key] -like "*$searchTerm*") {
                    $item = New-Object ListViewItem($key.ToString())
                    $item.SubItems.Add($KeysText[$key])
                    $listViewResults.Items.Add($item)
                }
            }

            if ($listViewResults.Items.Count -eq 0) {
                $item = New-Object ListViewItem("No results found.")
                $listViewResults.Items.Add($item)
            }
        }
    })

    # Trigger search on Enter key
    $inputFieldSearch.Add_KeyDown({
        param($sender, $e)
        if ($e.KeyCode -eq [Keys]::Enter) {
            $buttonSearch.PerformClick()
        }
    })

    # Single-click event for ListView items
    $listViewResults.Add_Click({
        if ($listViewResults.SelectedItems.Count -gt 0) {
            $selectedItem = $listViewResults.SelectedItems[0]
            $inputFieldGroup.Text = $selectedItem.Text
        }
    })

    # New GroupBox for SKU selection
    $groupBoxSku = New-Object GroupBox
    $groupBoxSku.Text = "Select SKU"
    $groupBoxSku.Size = New-Object Size(600, 260)
    $groupBoxSku.Location = New-Object Point(20, 510)
    $form.Controls.Add($groupBoxSku)

    # Label for SKU selection
    $labelSku = New-Object System.Windows.Forms.Label
    $labelSku.Text = 'SKU:'
    $labelSku.AutoSize = $true
    $labelSku.Font = $font
    $labelSku.Location = New-Object Point(20, 30)
    $groupBoxSku.Controls.Add($labelSku)

    # ComboBox for SKU selection
    $skuComboBox = New-Object ComboBox
    $skuComboBox.Location = New-Object Point(60, 30)
    $skuComboBox.Width = 210
    $skuComboBox.Font = $font
    $groupBoxSku.Controls.Add($skuComboBox)

    # Convert the string into an array
    $skuList = $keys -split ', ' | Sort

    # Populate the ComboBox with SKUs
    $skuComboBox.Items.AddRange($skuList)

    # Button to get product keys
    $submitButton = New-Object Button
    $submitButton.Text = 'Get'
    $submitButton.Location = New-Object Point(480, 30)  # Adjusted location to avoid overlap
    $submitButton.Size = New-Object Size(90, 30)
    $submitButton.Font = New-Object Font('Segoe UI', 10, [FontStyle]::Bold)
    $submitButton.BackColor = [Color]::CadetBlue
    $submitButton.ForeColor = [Color]::White
    $submitButton.FlatStyle = 'Flat'
    $groupBoxSku.Controls.Add($submitButton)

    # DataGridView for displaying results
    $dataGridView = New-Object DataGridView
    $dataGridView.Location = New-Object Point(20, 70)
    $dataGridView.Size = New-Object Size(550, 170)
    $dataGridView.AllowUserToAddRows = $false
    $dataGridView.AllowUserToDeleteRows = $false
    # Set a smaller font size
    $dataGridView.Font = New-Object Font('Segoe UI', 9)  # Smaller font size
    $dataGridView.RowTemplate.Height = 20  # Adjust row height to match smaller font
    # Set column count and names
    $dataGridView.ColumnCount = 2
    $dataGridView.Columns[0].Name = 'Group'
    $dataGridView.Columns[1].Name = 'Product Key'
    # Set fixed widths for columns with minimum widths
    $dataGridView.Columns[0].Width = 120  # Width for 'Group'
    $dataGridView.Columns[1].AutoSizeMode = 'Fill'  # Allow 'Product Key' to fill the remaining space
    $dataGridView.Columns[1].MinimumWidth = 250  # Minimum width for 'Product Key'
    # Enable horizontal scrolling if needed
    $dataGridView.ScrollBars = 'Horizontal'
    # Set DefaultCellStyle for better text handling
    $dataGridView.DefaultCellStyle.Alignment = [DataGridViewContentAlignment]::MiddleLeft
    $groupBoxSku.Controls.Add($dataGridView)

    # Create a TextBox to display the selected SKU
    $skuTextBox = New-Object TextBox
    $skuTextBox.Location = New-Object Point(275, 30)  # Position next to ComboBox
    $skuTextBox.Width = 200
    $skuTextBox.Height = 25  # Set a specific height to visually match ComboBox
    $skuTextBox.BorderStyle = [BorderStyle]::FixedSingle  # Match ComboBox style
    $skuTextBox.Font = $font  # Set the same font as ComboBox
    $skuTextBox.TextAlign = [HorizontalAlignment]::Center
    $groupBoxSku.Controls.Add($skuTextBox)

    # ComboBox SelectedIndexChanged event to update the TextBox
    $skuComboBox.Add_SelectedIndexChanged({
        $skuTextBox.Text = $skuComboBox.SelectedItem
    })
    # Button click event for getting product keys
    $submitButton.Add_Click({
        $dataGridView.Rows.Clear()  # Clear previous results
        $selectedSku = $skuTextBox.Text  # Use value from the TextBox

        if (-not $selectedSku) {
            #[MessageBox]::Show("Please select a SKU.")
            return
        }

        # Get product keys based on the selected SKU
        $CombinedValues = @{}
		
        # Use API
        $productKeysGPK = Get-ProductKeys -EditionID $selectedSku
        
        # Use Config XRM-MS file
        $ConfigList = GenerateConfigList -pkeyconfig "$env:windir\System32\spp\tokens\pkeyconfig\pkeyconfig.xrm-ms" -IgnoreAPI $true -SkipKeyRange $true
        $productKeysGCL = $ConfigList | ? EditionId -eq $selectedSku | select ProductKeyType, ProductKey
        
        if (($productKeysGPK.Count -eq 0) -and ($productKeysGCL.Count -eq 0)) {
            #[MessageBox]::Show("No product keys found for the selected SKU.")
        } else {
            if ($productKeysGPK) {foreach ($key in $productKeysGPK) {
                if (!$CombinedValues.Contains($key.ProductKeyType)) {
                  $CombinedValues.Add($key.ProductKeyType,$key.ProductKey)}
            }}
            if ($productKeysGCL) {foreach ($key in $productKeysGCL) {
                if (!$CombinedValues.Contains($key.ProductKeyType)) {
                  $CombinedValues.Add($key.ProductKeyType,$key.ProductKey)}
            }}

            $FilteredTable = Filter-HashTable -table $CombinedValues
            $FilteredTable.Keys | Sort | % {
              $dataGridView.Rows.Add($_, $FilteredTable[$_])
            }
        }
    })

    # Show the form
    $form.ShowDialog()
}
function DecodeForm {
    # Create the form
    $form = New-Object Form
    $form.Size = New-Object Size(800, 580)  # Increased height
    $form.StartPosition = 'CenterScreen'
    $form.FormBorderStyle = [FormBorderStyle]::FixedDialog
    $form.MaximizeBox = $false
    $form.MinimizeBox = $false
    $form.BackColor = [Color]::LightSteelBlue

    # Create a font for labels and inputs
    $font = New-Object Font('Segoe UI', 10)

    # Create controls for Key input
    $labelKey = New-Object System.Windows.Forms.Label
    $labelKey.Text = 'Key:'
    $labelKey.AutoSize = $true
    $labelKey.Location = New-Object Point(20, 20)
    $labelKey.Font = $font
    $form.Controls.Add($labelKey)

    $inputFieldKey = New-Object TextBox
    $inputFieldKey.Location = New-Object Point(120, 20)
    $inputFieldKey.Width = 640
    $inputFieldKey.Font = $font
    $form.Controls.Add($inputFieldKey)

    # Create controls for Predefined List
    $labelPredefinedList = New-Object System.Windows.Forms.Label
    $labelPredefinedList.Text = 'From List:'
    $labelPredefinedList.AutoSize = $true
    $labelPredefinedList.Location = New-Object Point(20, 60)
    $labelPredefinedList.Font = $font
    $form.Controls.Add($labelPredefinedList)

    $comboBoxPredefinedList = New-Object ComboBox
    $comboBoxPredefinedList.Location = New-Object Point(120, 60)
    $comboBoxPredefinedList.Width = 640
    $comboBoxPredefinedList.Font = $font
    $comboBoxPredefinedList.DropDownStyle = 'DropDownList'
    # Populate ComboBox with predefined locations
    $comboBoxPredefinedList.Items.AddRange($predefinedLocations)
    $form.Controls.Add($comboBoxPredefinedList)

    # Create controls for Config Path
    $labelConfigPath = New-Object System.Windows.Forms.Label
    $labelConfigPath.Text = 'From File:'
    $labelConfigPath.AutoSize = $true
    $labelConfigPath.Location = New-Object Point(20, 100)
    $labelConfigPath.Font = $font
    $form.Controls.Add($labelConfigPath)

    $inputFieldConfigPath = New-Object TextBox
    $inputFieldConfigPath.Location = New-Object Point(120, 100)
    $inputFieldConfigPath.Width = 550
    $inputFieldConfigPath.Font = $font
    $form.Controls.Add($inputFieldConfigPath)

    # Original button for file browsing
    $buttonBrowse = New-Object Button
    $buttonBrowse.Text = 'Browse...'
    $buttonBrowse.Location = New-Object Point(680, 100)
    $buttonBrowse.Width = 80
    $buttonBrowse.Height = $inputFieldConfigPath.Height  # Match height with TextBox
    $buttonBrowse.Font = $font
    $buttonBrowse.Add_Click({
        $openFileDialog = New-Object OpenFileDialog
        $openFileDialog.Title = 'Select a File'
        $openFileDialog.Filter = 'All Files (*.*)|*.*'  # Allow all file types
        
        if ($openFileDialog.ShowDialog() -eq 'OK') {
            $inputFieldConfigPath.Text = $openFileDialog.FileName
        }
    })
    $form.Controls.Add($buttonBrowse)

    # Create controls for folder selection
    $labelFolderPath = New-Object System.Windows.Forms.Label
    $labelFolderPath.Text = 'From Folder:'
    $labelFolderPath.AutoSize = $true
    $labelFolderPath.Location = New-Object Point(20, 140)  # Adjust position below existing controls
    $labelFolderPath.Font = $font
    $form.Controls.Add($labelFolderPath)

    $inputFieldFolderPath = New-Object TextBox
    $inputFieldFolderPath.Location = New-Object Point(120, 140)
    $inputFieldFolderPath.Width = 550  # Adjust width
    $inputFieldFolderPath.Font = $font
    $inputFieldFolderPath.Text = $outPath
    $form.Controls.Add($inputFieldFolderPath)

    # Browse button for folder selection
    $buttonBrowseFolder = New-Object Button
    $buttonBrowseFolder.Text = 'Browse...'
    $buttonBrowseFolder.Location = New-Object Point(680, 140)
    $buttonBrowseFolder.Width = 80
    $buttonBrowseFolder.Height = $inputFieldFolderPath.Height  # Match height with TextBox
    $buttonBrowseFolder.Font = $font
    $buttonBrowseFolder.Add_Click({
        $folderBrowserDialog = New-Object FolderBrowserDialog
        $folderBrowserDialog.Description = 'Select a Folder'
        
        if ($folderBrowserDialog.ShowDialog() -eq 'OK') {
            $inputFieldFolderPath.Text = $folderBrowserDialog.SelectedPath
        }
    })
    $form.Controls.Add($buttonBrowseFolder)

    # Create the Checkbox
    $checkboxHexValue = New-Object CheckBox
    $checkboxHexValue.Text = 'HEX'
    $checkboxHexValue.Location = New-Object Point(20, 180)  # Move checkbox to left
    $checkboxHexValue.AutoSize = $true
    $checkboxHexValue.Font = $font
    $form.Controls.Add($checkboxHexValue)

    # Move Decode button next to the checkbox
    $buttonDecode = New-Object Button
    $buttonDecode.Text = 'Decode Key'
    $buttonDecode.Location = New-Object Point(120, 180)  # Adjusted position
    $buttonDecode.Width = 640  # Adjusted width
    $buttonDecode.Font = New-Object Font('Segoe UI', 10, [FontStyle]::Bold)
    $buttonDecode.BackColor = [Color]::CadetBlue
    $buttonDecode.ForeColor = [Color]::White
    $buttonDecode.FlatStyle = 'Flat'

    $buttonDecode.Add_Click({
        try {
			# Clear any existing rows
            $dataGridView.Rows.Clear()
			Start-Sleep -Seconds 1

            $key = $inputFieldKey.Text -replace '\s+', ''
            $configPath = $inputFieldConfigPath.Text
            $configFolder = $inputFieldFolderPath.Text
            $hexValue = $checkboxHexValue.Checked

            $isFileValid = -not [string]::IsNullOrWhiteSpace($configPath) -and (Test-Path $configPath) -and $configPath -match '^[A-Z]:\\.*\.xrm-ms$'  # Updated validation
            $isFolderValid = -not [string]::IsNullOrWhiteSpace($configFolder) -and (Test-Path $configFolder) -and (Get-Item $configFolder).PSIsContainer
            $isKeyValid = $key -match '^[A-Z0-9]{5}-[A-Z0-9]{5}-[A-Z0-9]{5}-[A-Z0-9]{5}-[A-Z0-9]{5}$'

            if (!$isKeyValid -or (!$isFileValid -and !$isFolderValid)) {
                $message = "Please check the following:" + [Environment]::NewLine
                if (-not $isKeyValid) {
                    $message += "- KEY must be in the correct format." + [Environment]::NewLine
                }
                if (-not $isFileValid) {
                    $message += "- CONFIG PATH cannot be empty and must end with '.xrm-ms'." + [Environment]::NewLine
                }
                if (-not $isFolderValid) {
                    $message += "- FOLDER PATH cannot be empty." + [Environment]::NewLine
                }
    
                [MessageBox]::Show($message, "Error", [MessageBoxButtons]::OK, [MessageBoxIcon]::Error)
                return
            }
        } catch {
            [MessageBox]::Show("Error: $_", "Error", [MessageBoxButtons]::OK, [MessageBoxIcon]::Error)
        }

        # Results from KeyDecode (USING KeyInfo Tool, decode method)
        try {
            $result = KeyDecode -key0 $key
            $RefGroupId = $result.GetValue(2).Value
            $data = $result | Where-Object { (![STRING]::IsNullOrWhiteSpace($_.Property)) -or (![STRING]::IsNullOrWhiteSpace($_.Value)) }
            foreach ($item in $data) {
                $value = if ($hexValue) { $item.Value.ToString("X") } else { $item.Value }
                $dataGridView.Rows.Add($item.Property, $value)
            }
        } catch {
            # Windows 7 key .. etc.
            if ($isFileValid -and (-not $isFolderValid)) {
                $dataGridView.Rows.Add('Error', $_) }
            # return
        }

        # Initialize an array to hold .xrm-ms files
        $xrm_ms_lst = @()

        # Check file and folder validity
        if ($isFileValid -and (-not $isFolderValid)) {
            # Results from KeyParser (USING PidgenX API)
            $skuID = [guid]::Empty
            $result = KeyParser -key $key -configPath $configPath
            $data = $result | Where-Object { (![STRING]::IsNullOrWhiteSpace($_.Property)) -or (![STRING]::IsNullOrWhiteSpace($_.Value)) }
            foreach ($item in $data) {
                if ($item.Property -eq 'ActivationId') {
                    $skuID = [GUID]::new($item.Value)
                }
                $dataGridView.Rows.Add($item.Property, $item.Value)
            }
            $status1, $status2 = $null, $null
            try {
                $status1 = Call-WebService `
                -requestType 2 `
                -extendedProductId (
                    $result | ? {$_["Property"] -eq 'AdvancedPid' } | % { $_["Value"] }
                )
            } catch {}
            try {
                $status2 = Validate-ProductKey `
                    -ProductKey ($key.Substring(0,29)) `
                    -SkuID $skuID
            } catch {}
            $dataGridView.Rows.Add("Online Check", $status1)
            $dataGridView.Rows.Add("Online Check", $status2)

        } elseif ($isFolderValid) {
            # Include the file if valid
            if ($isFileValid) { $xrm_ms_lst += $configPath }

            # Get all .xrm-ms files from the folder
            $xrmFiles = Get-ChildItem -Path $configFolder -Filter '*.xrm-ms' -Recurse -EA 0
            $xrm_ms_lst += $xrmFiles.FullName  # Add the file paths to the list

            # Process each .xrm-ms file
            foreach ($file in $xrm_ms_lst) {
                # Validate KeyParser results for each .xrm-ms file
                try {
                    $result = KeyParser -key $key -configPath $file
                    if ($result.GetValue(1).Property -ne 'Error') {
                        $inputFieldConfigPath.Text = $file

                        # Results from KeyParser (USING PidgenX API)
                        $skuID = [guid]::Empty
                        $data = $result | Where-Object { (![STRING]::IsNullOrWhiteSpace($_.Property)) -or (![STRING]::IsNullOrWhiteSpace($_.Value)) }
                        foreach ($item in $data) {
                            if ($item.Property -eq 'ActivationId') {
                                $skuID = [GUID]::new($item.Value)
                            }
                            $dataGridView.Rows.Add($item.Property, $item.Value)
                        }
                        $status1, $status2 = $null, $null
                        try {
                            $status1 = Call-WebService `
                            -requestType 2 `
                            -extendedProductId (
                               $result | ? {$_["Property"] -eq 'AdvancedPid' } | % { $_["Value"] }
                            )
                        } catch {}
                        try {
                            $status2 = Validate-ProductKey `
                                -ProductKey ($key.Substring(0,29)) `
                                -SkuID $skuID
                        } catch {}
                        $dataGridView.Rows.Add("Online Check", $status1)
                        $dataGridView.Rows.Add("Online Check", $status2)

                        break  # Exit after processing the first valid file
                    }
                } catch {
                    # Handle errors during KeyParser call (optionally log or handle)
                }
            }
        }
    })
    $form.Controls.Add($buttonDecode)

    # Adjust the DataGridView position
    $dataGridView = New-Object DataGridView
    $dataGridView.Location = New-Object Point(20, 220)  # Moved down
    $dataGridView.Size = New-Object Size(740, 300)  # Adjusted size
    $dataGridView.AutoSizeColumnsMode = 'Fill'
    $dataGridView.ColumnCount = 2
    $dataGridView.Columns[0].Name = 'Property'
    $dataGridView.Columns[1].Name = 'Value'
    $dataGridView.Columns[0].Width = 150
    $dataGridView.Columns[1].Width = 590  # Adjusted width
    $dataGridView.AllowUserToAddRows = $false
    $dataGridView.AllowUserToDeleteRows = $false
    $form.Controls.Add($dataGridView)

    # Handle ComboBox selection change
    $comboBoxPredefinedList.Add_SelectedIndexChanged({
        $inputFieldConfigPath.Text = $comboBoxPredefinedList.SelectedItem
    })

    # Show the form
    $form.ShowDialog()
}
function GetWmiProductsForm {

    # Create the form
    $form = New-Object Windows.Forms.Form
    $form.Size = New-Object Drawing.Size(1010, 640)
    $form.StartPosition = 'CenterScreen'
    $form.FormBorderStyle = 'FixedDialog'
    $form.MaximizeBox = $false
    $form.MinimizeBox = $false
    $form.BackColor = [Drawing.Color]::LightSteelBlue

    # Create TabControl
    $tabControl = New-Object Windows.Forms.TabControl
    $tabControl.Size = New-Object Drawing.Size(980, 580)
    $tabControl.Location = New-Object Drawing.Point(10, 10)

    # Create Activate Tab
    $tabActivate = New-Object Windows.Forms.TabPage
    $tabActivate.Text = "Activate"

    # === BEGIN: Your original controls (added to tabActivate instead of form) ===

    $font = New-Object Drawing.Font('Segoe UI', 10)

    $dataGridView = New-Object Windows.Forms.DataGridView
    $dataGridView.Location = New-Object Drawing.Point(20, 60)
    $dataGridView.Size = New-Object Drawing.Size(940, 320)
    $dataGridView.AutoGenerateColumns = $false
    $dataGridView.ColumnHeadersHeightSizeMode = 'AutoSize'
    $dataGridView.AllowUserToAddRows = $false
    $dataGridView.AllowUserToDeleteRows = $false
    $dataGridView.RowHeadersVisible = $false
    $dataGridView.MultiSelect = $false
    $dataGridView.SelectionMode = 'FullRowSelect'
    $dataGridView.Font = New-Object System.Drawing.Font("Arial", 10)
    $dataGridView.RowTemplate.Height = 30

    $col1 = New-Object Windows.Forms.DataGridViewTextBoxColumn
    $col1.Name = 'Description'
    $col1.HeaderText = 'Description'
    $col1.Width = 360

    $col2 = New-Object Windows.Forms.DataGridViewTextBoxColumn
    $col2.Name = 'Name'
    $col2.HeaderText = 'Name'
    $col2.Width = 400

    $col3 = New-Object Windows.Forms.DataGridViewTextBoxColumn
    $col3.Name = 'ID'
    $col3.HeaderText = 'ID'
    $col3.Width = 200

    [void]$dataGridView.Columns.Add($col1)
    [void]$dataGridView.Columns.Add($col2)
    [void]$dataGridView.Columns.Add($col3)

    $buttonInit = New-Object Windows.Forms.Button
    $buttonInit.Text = 'Initialize'
    $buttonInit.Font = New-Object Drawing.Font('Segoe UI', 12, [Drawing.FontStyle]::Bold)
    $buttonInit.BackColor = [Drawing.Color]::CadetBlue
    $buttonInit.ForeColor = [Drawing.Color]::White
    $buttonInit.FlatStyle = 'Flat'
    $buttonInit.Location = New-Object Drawing.Point(20, 15)
    $buttonInit.Size = New-Object Drawing.Size(120, 35)

    $buttonSelect = New-Object Windows.Forms.Button
    $buttonSelect.Text = 'Select'
    $buttonSelect.Font = New-Object Drawing.Font('Segoe UI', 12, [Drawing.FontStyle]::Bold)
    $buttonSelect.BackColor = [Drawing.Color]::OliveDrab
    $buttonSelect.ForeColor = [Drawing.Color]::White
    $buttonSelect.FlatStyle = 'Flat'
    $buttonSelect.Location = New-Object Drawing.Point(150, 15)
    $buttonSelect.Size = New-Object Drawing.Size(100, 35)

    $checkBox = New-Object Windows.Forms.CheckBox
    $checkBox.Text = 'Filter HWID\KMS38 SKU'
    $checkBox.Font = New-Object Drawing.Font('Segoe UI', 10)
    $checkBox.AutoSize = $true
    $checkBox.Location = New-Object Drawing.Point(270, 22)

    $userKeyBox = New-Object Windows.Forms.CheckBox
    $userKeyBox.Text = 'Use Custom Key'
    $userKeyBox.Font = New-Object Drawing.Font('Segoe UI', 10)
    $userKeyBox.AutoSize = $true
    $userKeyBox.Location = New-Object Drawing.Point(470, 22)

    $inputFieldKey = New-Object TextBox
    $inputFieldKey.Location = New-Object Point(610, 22)
    $inputFieldKey.Width = 350
    $inputFieldKey.Font = New-Object Font('Segoe UI', 10)

    $logBox = New-Object Windows.Forms.TextBox
    $logBox.Multiline = $true
    $logBox.ScrollBars = 'Vertical'
    $logBox.Location = New-Object Drawing.Point(20, 400)
    $logBox.Size = New-Object Drawing.Size(940, 140)
    $logBox.Font = New-Object Drawing.Font('Segoe UI', 9)
    $logBox.ReadOnly = $true

    $tabActivate.Controls.AddRange(@(
        $buttonInit, $buttonSelect, $checkBox, $userKeyBox,
        $inputFieldKey, $dataGridView, $logBox
    ))

    # On form load
    $form.Add_Load({
        $dataGridView.Rows.Clear()
    })

    # Button click event
    $buttonInit.Add_Click({
        $dataGridView.Rows.Clear()
        try {
          if (!$checkBox.Checked) {
            
            # create new handle
            Manage-SLHandle -Release | Out-null
            $LicensingProducts = Get-SLIDList -eQueryIdType SL_ID_PRODUCT_SKU -eReturnIdType SL_ID_PRODUCT_SKU | % {
                [PSCustomObject]@{
                    ID            = $_
                    Description   = Get-LicenseDetails -ActConfigId $_ -pwszValueName 'Description'
                    Name          = Get-LicenseDetails -ActConfigId $_ -pwszValueName 'productName'
                    LicenseFamily = Get-LicenseDetails -ActConfigId $_ -pwszValueName 'Family'
                }
            }
            Manage-SLHandle -Release | Out-null
            $selected = $LicensingProducts | ? { $_.Description -notmatch 'DEMO|MSDN|PIN|FREE|TIMEBASED|GRACE|W10|DM' } |
                Sort-Object @{Expression='Name';Descending=$false}, @{Expression='Description';Descending=$true}|
                    Select-Object ID, Description, Name
                foreach ($prod in $selected) {
                    $dataGridView.Rows.Add($prod.Description,$prod.Name,$prod.ID)
                }
            } else {
                
                # create new handle
                Manage-SLHandle -Release | Out-null
                $LicensingProducts = Get-SLIDList -eQueryIdType SL_ID_APPLICATION -eReturnIdType SL_ID_PRODUCT_SKU -pQueryId $windowsAppID | % {
                    try {
                        $Branding = $null
                        [XML]$licenseData = Get-LicenseDetails $_ -ReturnRawData
                        $Branding = ($licenseData.licenseGroup.license[1].otherInfo.infoTables.infoList.infoStr | ? Name -EQ win:branding).'#text'
                    }
                    catch {
                        $Branding = $null
                    }
                    [PSCustomObject]@{
                        ID            = $_
                        Description   = Get-LicenseDetails -ActConfigId $_ -pwszValueName 'Description'
                        Name          = Get-LicenseDetails -ActConfigId $_ -pwszValueName 'productName'
                        LicenseFamily = Get-LicenseDetails -ActConfigId $_ -pwszValueName 'Family'
                        Branding      = $Branding
                    }
                }
                $EditionID = Get-ProductID
                Manage-SLHandle -Release | Out-null
                if (-not $EditionID) {
                    throw "EditionID Variable not found" }
                $products_KMS38 = $LicensingProducts | ? Description -Match 'VOLUME_KMSCLIENT' | ? { $_.LicenseFamily }

                $filter = ($customObjectArray | ? Status -EQ 0 | select ID).ID
                $products_HWID = $LicensingProducts | ? { $filter -contains $_.ID } | ? {
                    ($customObjectArray | ? ID -EQ $_.ID | select -ExpandProperty SKU_ID ) -match $_.Branding }

                if ($products_KMS38) {
                    foreach ($prod in $products_KMS38) {
                        $dataGridView.Rows.Add($prod.Description,$prod.Name,$prod.ID)
                }}
                if ($products_HWID) {
                    foreach ($prod in $products_HWID) {
                        $dataGridView.Rows.Add($prod.Description,$prod.Name,$prod.ID)
                }}
            }
        } catch {
            [Windows.Forms.MessageBox]::Show("Error fetching data: $_", "Error", 'OK', 'Error')
        }
    })

    # Select button click event
    $buttonSelect.Add_Click({
        if ($dataGridView.SelectedRows.Count -gt 0) {
            
            $key = $null;
            $Vol_Key = $null
            $hwid_key = $null
            $product = $null
            $hwid_info = $null
            $logBox.Text = ''
            $row = $dataGridView.SelectedRows[0]
            $tsactid = $row.Cells['ID'].Value
            $description = $row.Cells['Description'].Value
            $global:keyVal_User    = $null

            # remvoe KMS38 lock --> From MAS PROJECT, KMS38_Activation.cmd
            $SID = New-Object SecurityIdentifier('S-1-5-32-544')
            $Admin = ($SID.Translate([NTAccount])).Value
            $ruleArgs = @("$Admin", "FullControl", "Allow")
            $path = 'SOFTWARE\Microsoft\Windows NT\CurrentVersion\SoftwareProtectionPlatform\55c92734-d682-4d71-983e-d6ec3f16059f'
            $regkey = [Microsoft.Win32.RegistryKey]::OpenBaseKey('LocalMachine', 'Registry64').OpenSubKey($path, 'ReadWriteSubTree', 'ChangePermissions')
            if ($regKey) {
                $acl = $regKey.GetAccessControl()
                $rule = [RegistryAccessRule]::new.Invoke($ruleArgs)
                $acl.ResetAccessRule($rule)
                $regKey.SetAccessControl($acl)
            }

            if ($userKeyBox.Checked -and (![string]::IsNullOrWhiteSpace($inputFieldKey.Text))) {
                $keyInfo = $null
                try {
                    $keyInfo = Retrieve-ProductKeyInfo -CdKey $inputFieldKey.Text
                }
                catch {}
                if ($keyInfo -and $keyInfo.skuId -eq $tsactid){
                    $global:keyVal_User = $inputFieldKey.Text
                }
            }

            if (!$checkBox.Checked) {
                # Start ###########
                $ver   = [LibTSforge.Utils]::DetectVersion()
                $prod  = [LibTSforge.SPP.SPPUtils]::DetectCurrentKey()

                if (!$key -and $global:keyVal_User) {
                    $key = $global:keyVal_User
                    Write-Warning "User Key, $key"
                }

                if (-not $key) {
                    $key = GetRandomKey -ProductID $tsactid
                }

                if (-not $key) {
                    $refSku = Retrieve-ProductKeyInfo -SkuId $tsactid
                    $key = Encode-Key $refSku 0 0
                    Write-Warning "Encode-Key, $key"
                }

                if (-not $key) {
                    $key = GetRandomKey -ProductID $tsactid
                    Write-Warning "GetRandomKey, $key"
                }

                if ($key) {
                    Manage-SLHandle -Release | Out-null
                    SL-InstallProductKey -Keys $key
                    $ID_PKEY = Retrieve-SKUInfo -SkuId $tsactid -eReturnIdType SL_ID_PKEY
                    if (-not $ID_PKEY) {
                        $logBox.Text = "Error while trying install key, check if not case of 99999 ~ Retail license"
                        return
                    }
                    $transcriptFile = Capture-ConsoleOutput {
                        Activate-License -desc $Description -ver $ver -prod $prod -tsactid $tsactid
                    }             
                    # Read the transcript content and display it in the log box
                    $logBox.Text = $transcriptFile
                } else {
                    $logBox.Text = "No key generated for: $($item.Name)"
                    return
                }
                $logBox.Text = $logBox.Text -replace 'System.Management.ManagementBaseObject',[Environment]::NewLine
                return
                # END ###########
            }

            # Start ###########
            $sandbox = "Null" | Get-Service -EA 0
            if (-not $sandbox) {
                $logBox.Text = "'Null' service found! Possible sandbox environment."
                return
            }

            $ClipUp = Get-Command ClipUp -ea 0
            if (-not $ClipUp) {
                iwr "https://github.com/BlueOnBLack/Misc/raw/refs/heads/main/ClipUp.exe" -OutFile "$env:windir\ClipUp.exe" -ea 0
                if ([IO.FILE]::Exists("$env:windir\ClipUp.exe")) {
                if (@(Get-AuthenticodeSignature "$env:windir\ClipUp.exe" -ea 0).Status -ne 'Valid') {
                    ri "$env:windir\ClipUp.exe" -Force -ea 0
                }
                }
            }
            $ClipUp = Get-Command ClipUp -ea 0
            if (-not $ClipUp) {
                $logBox.Text = "ClipUp.exe not found"
            }

            $osInfo = Get-CimInstance Win32_OperatingSystem
            $server = $osInfo.Caption -match "Server"
            $evaluation = $osInfo.Caption -match "Evaluation"

            $IsKms38 = $description -match 'VOLUME_KMSCLIENT'
            if ($IsKms38) {
                if ($global:keyVal_User) {
                    $Vol_Key = $global:keyVal_User
                    Write-Warning "User Key, $Vol_Key"
                }
                else {
                    $Vol_Key = GetRandomKey -ProductID $tsactid
                    Write-Warning "Random Key, $Vol_Key"
                }
                if (-not $Vol_Key) {
                    $refSku = Retrieve-ProductKeyInfo -SkuId $tsactid
                    $Vol_Key = Encode-Key $refSku 0 0
                    Write-Warning "Encode-Key, $Vol_Key"
                }
            } else {
                $hwid_info = $customObjectArray | ? { $_.ID -match $tsactid }
                $hwid_key = $hwid_info.Key
            }

            if ($server -and $hwid_key) {
                $logBox.Text = "Server edition is found, select GLVK products only"
                return
            }

            if ($evaluation) {
                $transcriptFile = Capture-ConsoleOutput {
                    $version = [LibTSforge.Utils]::DetectVersion();
                    $production = [LibTSforge.SPP.SPPUtils]::DetectCurrentKey();

                    # Update from latest TSforge_Activation.cmd
                    [LibTSforge.Modifiers.TamperedFlagsDelete]::DeleteTamperFlags($ver, $prod)
                    [LibTSforge.SPP.SLApi]::RefreshLicenseStatus()
                    [LibTSforge.Modifiers.RearmReset]::Reset($ver, $prod)
                    [LibTSforge.Modifiers.GracePeriodReset]::Reset($version,$production)
                    [LibTSforge.Modifiers.KeyChangeLockDelete]::Delete($version,$production)
                }  
                # Read the transcript content and display it in the log box
                $logBox.Text = $transcriptFile
                return
            }

            if (!$Vol_Key -and !$hwid_key) {
                continue; }

            # Get the Windows build number from the registry
            $build = $Global:osVersion.Build

            # Convert to integer (safely)
            [int]$buildNum = 0
            if ([bigint]::TryParse($build, [ref]$buildNum)) {
                # Now $buildNum contains the numeric value
            } else {
                $logBox.Text = "[!] Failed to detect Windows build number."
                return
            }

            # Check for 0 or invalid build
            if ($buildNum -eq 0) {
                $logBox.Text =  "[!] Invalid build number detected: 0"
                return
            }

            # Check if the build is too old
            if ($buildNum -lt 10240) {
                $logBox.Text = "[!] Unsupported OS version detected: $buildNum"
                $logBox.Text += "`nHWID Activation is only supported on Windows 10 or 11."
                $logBox.Text += "`nUse the TSforge activation option from the main menu."
                return
            }

            ("ClipSVC","wlidsvc","sppsvc","KeyIso","LicenseManager","Winmgmt") | % { Start-Service $_ -ea 0}
            $EditionID = Get-ProductID
            if (-not $EditionID) {
                $logBox.Text = "EditionID Variable not found" 
                return
            }

Function Encode-Blob {
    param (
        $SessionIdStr
    )
    function Sign {
        param (
            $Properties,
            $rsa
        )

        $sha256 = [Security.Cryptography.SHA256]::Create()
        $bytes = [Text.Encoding]::UTF8.GetBytes($Properties)
        $hash = $sha256.ComputeHash($bytes)

        $signature = $rsa.SignHash($hash, [Security.Cryptography.HashAlgorithmName]::SHA256, [Security.Cryptography.RSASignaturePadding]::Pkcs1)
        return [Convert]::ToBase64String($signature)
    }
    [byte[]] $key = 0x07,0x02,0x00,0x00,0x00,0xA4,0x00,0x00,0x52,0x53,0x41,0x32,0x00,0x04,0x00,0x00,
                    0x01,0x00,0x01,0x00,0x29,0x87,0xBA,0x3F,0x52,0x90,0x57,0xD8,0x12,0x26,0x6B,0x38,
                    0xB2,0x3B,0xF9,0x67,0x08,0x4F,0xDD,0x8B,0xF5,0xE3,0x11,0xB8,0x61,0x3A,0x33,0x42,
                    0x51,0x65,0x05,0x86,0x1E,0x00,0x41,0xDE,0xC5,0xDD,0x44,0x60,0x56,0x3D,0x14,0x39,
                    0xB7,0x43,0x65,0xE9,0xF7,0x2B,0xA5,0xF0,0xA3,0x65,0x68,0xE9,0xE4,0x8B,0x5C,0x03,
                    0x2D,0x36,0xFE,0x28,0x4C,0xD1,0x3C,0x3D,0xC1,0x90,0x75,0xF9,0x6E,0x02,0xE0,0x58,
                    0x97,0x6A,0xCA,0x80,0x02,0x42,0x3F,0x6C,0x15,0x85,0x4D,0x83,0x23,0x6A,0x95,0x9E,
                    0x38,0x52,0x59,0x38,0x6A,0x99,0xF0,0xB5,0xCD,0x53,0x7E,0x08,0x7C,0xB5,0x51,0xD3,
                    0x8F,0xA3,0x0D,0xA0,0xFA,0x8D,0x87,0x3C,0xFC,0x59,0x21,0xD8,0x2E,0xD9,0x97,0x8B,
                    0x40,0x60,0xB1,0xD7,0x2B,0x0A,0x6E,0x60,0xB5,0x50,0xCC,0x3C,0xB1,0x57,0xE4,0xB7,
                    0xDC,0x5A,0x4D,0xE1,0x5C,0xE0,0x94,0x4C,0x5E,0x28,0xFF,0xFA,0x80,0x6A,0x13,0x53,
                    0x52,0xDB,0xF3,0x04,0x92,0x43,0x38,0xB9,0x1B,0xD9,0x85,0x54,0x7B,0x14,0xC7,0x89,
                    0x16,0x8A,0x4B,0x82,0xA1,0x08,0x02,0x99,0x23,0x48,0xDD,0x75,0x9C,0xC8,0xC1,0xCE,
                    0xB0,0xD7,0x1B,0xD8,0xFB,0x2D,0xA7,0x2E,0x47,0xA7,0x18,0x4B,0xF6,0x29,0x69,0x44,
                    0x30,0x33,0xBA,0xA7,0x1F,0xCE,0x96,0x9E,0x40,0xE1,0x43,0xF0,0xE0,0x0D,0x0A,0x32,
                    0xB4,0xEE,0xA1,0xC3,0x5E,0x9B,0xC7,0x7F,0xF5,0x9D,0xD8,0xF2,0x0F,0xD9,0x8F,0xAD,
                    0x75,0x0A,0x00,0xD5,0x25,0x43,0xF7,0xAE,0x51,0x7F,0xB7,0xDE,0xB7,0xAD,0xFB,0xCE,
                    0x83,0xE1,0x81,0xFF,0xDD,0xA2,0x77,0xFE,0xEB,0x27,0x1F,0x10,0xFA,0x82,0x37,0xF4,
                    0x7E,0xCC,0xE2,0xA1,0x58,0xC8,0xAF,0x1D,0x1A,0x81,0x31,0x6E,0xF4,0x8B,0x63,0x34,
                    0xF3,0x05,0x0F,0xE1,0xCC,0x15,0xDC,0xA4,0x28,0x7A,0x9E,0xEB,0x62,0xD8,0xD8,0x8C,
                    0x85,0xD7,0x07,0x87,0x90,0x2F,0xF7,0x1C,0x56,0x85,0x2F,0xEF,0x32,0x37,0x07,0xAB,
                    0xB0,0xE6,0xB5,0x02,0x19,0x35,0xAF,0xDB,0xD4,0xA2,0x9C,0x36,0x80,0xC6,0xDC,0x82,
                    0x08,0xE0,0xC0,0x5F,0x3C,0x59,0xAA,0x4E,0x26,0x03,0x29,0xB3,0x62,0x58,0x41,0x59,
                    0x3A,0x37,0x43,0x35,0xE3,0x9F,0x34,0xE2,0xA1,0x04,0x97,0x12,0x9D,0x8C,0xAD,0xF7,
                    0xFB,0x8C,0xA1,0xA2,0xE9,0xE4,0xEF,0xD9,0xC5,0xE5,0xDF,0x0E,0xBF,0x4A,0xE0,0x7A,
                    0x1E,0x10,0x50,0x58,0x63,0x51,0xE1,0xD4,0xFE,0x57,0xB0,0x9E,0xD7,0xDA,0x8C,0xED,
                    0x7D,0x82,0xAC,0x2F,0x25,0x58,0x0A,0x58,0xE6,0xA4,0xF4,0x57,0x4B,0xA4,0x1B,0x65,
                    0xB9,0x4A,0x87,0x46,0xEB,0x8C,0x0F,0x9A,0x48,0x90,0xF9,0x9F,0x76,0x69,0x03,0x72,
                    0x77,0xEC,0xC1,0x42,0x4C,0x87,0xDB,0x0B,0x3C,0xD4,0x74,0xEF,0xE5,0x34,0xE0,0x32,
                    0x45,0xB0,0xF8,0xAB,0xD5,0x26,0x21,0xD7,0xD2,0x98,0x54,0x8F,0x64,0x88,0x20,0x2B,
                    0x14,0xE3,0x82,0xD5,0x2A,0x4B,0x8F,0x4E,0x35,0x20,0x82,0x7E,0x1B,0xFE,0xFA,0x2C,
                    0x79,0x6C,0x6E,0x66,0x94,0xBB,0x0A,0xEB,0xBA,0xD9,0x70,0x61,0xE9,0x47,0xB5,0x82,
                    0xFC,0x18,0x3C,0x66,0x3A,0x09,0x2E,0x1F,0x61,0x74,0xCA,0xCB,0xF6,0x7A,0x52,0x37,
                    0x1D,0xAC,0x8D,0x63,0x69,0x84,0x8E,0xC7,0x70,0x59,0xDD,0x2D,0x91,0x1E,0xF7,0xB1,
                    0x56,0xED,0x7A,0x06,0x9D,0x5B,0x33,0x15,0xDD,0x31,0xD0,0xE6,0x16,0x07,0x9B,0xA5,
                    0x94,0x06,0x7D,0xC1,0xE9,0xD6,0xC8,0xAF,0xB4,0x1E,0x2D,0x88,0x06,0xA7,0x63,0xB8,
                    0xCF,0xC8,0xA2,0x6E,0x84,0xB3,0x8D,0xE5,0x47,0xE6,0x13,0x63,0x8E,0xD1,0x7F,0xD4,
                    0x81,0x44,0x38,0xBF

    $rsa = New-Object Security.Cryptography.RSACryptoServiceProvider
    $rsa.ImportCspBlob($key)
    $SessionId = [Convert]::ToBase64String([Text.Encoding]::Unicode.GetBytes($SessionIdStr + [char]0))
    $PropertiesStr = "OA3xOriginalProductId=;OA3xOriginalProductKey=;SessionId=$SessionId;TimeStampClient=2022-10-11T12:00:00Z"
    $SignatureStr = Sign $PropertiesStr $rsa
    return @"
<?xml version="1.0" encoding="utf-8"?><genuineAuthorization xmlns="http://www.microsoft.com/DRM/SL/GenuineAuthorization/1.0"><version>1.0</version><genuineProperties origin="sppclient"><properties>$PropertiesStr</properties><signatures><signature name="clientLockboxKey" method="rsa-sha256">$SignatureStr</signature></signatures></genuineProperties></genuineAuthorization>
"@
}

            $outputPath = Join-Path "C:\ProgramData\Microsoft\Windows\ClipSVC\GenuineTicket" "GenuineTicket.xml"
            if ($Vol_Key) { 
                $SessionID = 'OSMajorVersion=5;OSMinorVersion=1;OSPlatformId=2;PP=0;GVLKExp=2038-01-19T03:14:07Z;DownlevelGenuineState=1;'
                $signature = Encode-Blob -SessionIdStr $SessionID
                #$signature = '<?xml version="1.0" encoding="utf-8"?><genuineAuthorization xmlns="http://www.microsoft.com/DRM/SL/GenuineAuthorization/1.0"><version>1.0</version><genuineProperties origin="sppclient"><properties>OA3xOriginalProductId=;OA3xOriginalProductKey=;SessionId=TwBTAE0AYQBqAG8AcgBWAGUAcgBzAGkAbwBuAD0ANQA7AE8AUwBNAGkAbgBvAHIAVgBlAHIAcwBpAG8AbgA9ADEAOwBPAFMAUABsAGEAdABmAG8AcgBtAEkAZAA9ADIAOwBQAFAAPQAwADsARwBWAEwASwBFAHgAcAA9ADIAMAAzADgALQAwADEALQAxADkAVAAwADMAOgAxADQAOgAwADcAWgA7AEQAbwB3AG4AbABlAHYAZQBsAEcAZQBuAHUAaQBuAGUAUwB0AGEAdABlAD0AMQA7AAAA;TimeStampClient=2022-10-11T12:00:00Z</properties><signatures><signature name="clientLockboxKey" method="rsa-sha256">C52iGEoH+1VqzI6kEAqOhUyrWuEObnivzaVjyef8WqItVYd/xGDTZZ3bkxAI9hTpobPFNJyJx6a3uriXq3HVd7mlXfSUK9ydeoUdG4eqMeLwkxeb6jQWJzLOz41rFVSMtBL0e+ycCATebTaXS4uvFYaDHDdPw2lKY8ADj3MLgsA=</signature></signatures></genuineProperties></genuineAuthorization>'
            }
            elseif ($hwid_key){
                
                $product = $hwid_info
                $SessionID = 'OSMajorVersion=5;OSMinorVersion=1;OSPlatformId=2;PP=0;Pfn=Microsoft.Windows.'+$($product.SKU_ID)+'.'+$($product.Key_part)+
                    '_8wekyb3d8bbwe;PKeyIID=465145217131314304264339481117862266242033457260311819664735280;'
                $signature = Encode-Blob -SessionIdStr $SessionID
                
                <#
                $SessionID += [char]0
                $encoded = [convert]::ToBase64String([Text.Encoding]::Unicode.GetBytes($SessionID))
                $signature = '<?xml version="1.0" encoding="utf-8"?><genuineAuthorization xmlns="http://www.microsoft.com/DRM/SL/GenuineAuthorization/1.0">'+
                        '<version>1.0</version><genuineProperties origin="sppclient"><properties>OA3xOriginalProductId=;OA3xOriginalProductKey=;SessionId=' +
                        $encoded + ';TimeStampClient=2022-10-11T12:00:00Z</properties><signatures><signature name="clientLockboxKey" method="rsa-sha256">' +
                        $product.value + '=</signature></signatures></genuineProperties></genuineAuthorization>'
                #>

                $geoName = (Get-ItemProperty -Path "HKCU:\Control Panel\International\Geo" -ea 0).Name
                $geoNation = (Get-ItemProperty -Path "HKCU:\Control Panel\International\Geo" -ea 0).Nation
            }

            $tdir = "$env:ProgramData\Microsoft\Windows\ClipSVC\GenuineTicket"

            # Create directory if it doesn't exist
            if (-not (Test-Path -Path $tdir)) {
                New-Item -ItemType Directory -Path $tdir | Out-Null
            }

            # Delete files starting with "Genuine" in $tdir
            Get-ChildItem -Path $tdir -Filter "Genuine*" -File -EA 0 | Remove-Item -Force -EA 0

            # Delete .xml files in $tdir
            Get-ChildItem -Path $tdir -Filter "*.xml" -File -EA 0 | Remove-Item -Force -EA 0

            # Delete all files in the Migration folder
            $migrationPath = "$env:ProgramData\Microsoft\Windows\ClipSVC\Install\Migration"
            if (Test-Path -Path $migrationPath) {
                Get-ChildItem -Path $migrationPath -File -EA 0 | Remove-Item -Force -EA 0
            }
            if ($Vol_Key) {
                # Remove registry keys
                Remove-Item -Path "HKLM:\SOFTWARE\Microsoft\Windows NT\CurrentVersion\SoftwareProtectionPlatform\55c92734-d682-4d71-983e-d6ec3f16059f" -Force -Recurse -ea 0
                Remove-Item -Path "HKU:\S-1-5-20\SOFTWARE\Microsoft\Windows NT\CurrentVersion\SoftwareProtectionPlatform\55c92734-d682-4d71-983e-d6ec3f16059f" -Force -Recurse -ea 0

                # Registry path for new entries
                $regPath = "HKLM:\SOFTWARE\Microsoft\Windows NT\CurrentVersion\SoftwareProtectionPlatform\55c92734-d682-4d71-983e-d6ec3f16059f\$($tsactid)"

                # Create new registry values
                New-Item -Path $regPath -Force -ea 0 | Out-Null
                New-ItemProperty -Path $regPath -Name "KeyManagementServiceName" -PropertyType String -Value "127.0.0.2" -Force -ea 0
                New-ItemProperty -Path $regPath -Name "KeyManagementServicePort" -PropertyType String -Value "1688" -Force -ea 0
            }

            try {
                if ($geoName -and $geoNation -and ($geoName -ne 'US')){
                    Set-WinHomeLocation -GeoId 244 -ea 0 }
                if ($Vol_Key) {
                    Manage-SLHandle -Release | Out-null
                    Write-Warning "SL-InstallProductKey -Keys $Vol_Key"
                    SL-InstallProductKey -Keys $Vol_Key
                }
                elseif ($hwid_Key) {
                    Manage-SLHandle -Release | Out-null
                    Write-Warning "SL-InstallProductKey -Keys $hwid_Key"
                    SL-InstallProductKey -Keys $hwid_Key
                }
                
                $ID_PKEY = Retrieve-SKUInfo -SkuId $tsactid -eReturnIdType SL_ID_PKEY
                if (-not $ID_PKEY ) {
                    $RefGroupId = $Global:PKeyDatabase | ? ActConfigId -Match "{$tsactid}" | select -ExpandProperty RefGroupId
                    if (-not $RefGroupId) {
                        $logBox.Text += "Fail to receive RefGroupId for $tsactid"
                        return
                    }
                    if ($RefGroupId) {
                        $key = Encode-Key $RefGroupId
                        if ($key) {
                            SL-InstallProductKey -Keys $key
                            $ID_PKEY = Retrieve-SKUInfo -SkuId $tsactid -eReturnIdType SL_ID_PKEY
                            if (-not $ID_PKEY ) {
                                $logBox.Text += "Fail to install key for $tsactid"
                                return
                            }}}}

                if (-not (Retrieve-SKUInfo -SkuId $tsactid -eReturnIdType SL_ID_PKEY)) {
                }
                [File]::WriteAllText($outputPath, $signature, [Encoding]::UTF8)
                clipup -v -o 
                [File]::WriteAllText($outputPath, $signature, [Encoding]::UTF8)
                if ($Vol_Key) {
                    Stop-Service sppsvc -force -ea 0
                }
                Restart-Service ClipSVC
                if ($Vol_Key) {
                    Manage-SLHandle -Release | Out-null
                    SL-ReArm -AppID 55c92734-d682-4d71-983e-d6ec3f16059f -skuID $tsactid
                }
                elseif ($hwid_Key) {
                    Manage-SLHandle -Release | Out-null
                    SL-Activate -skuID $tsactid
                }
               
                Manage-SLHandle -Release | Out-null
                SL-RefreshLicenseStatus -AppID 55c92734-d682-4d71-983e-d6ec3f16059f -skuID $tsactid
            }
            Finally {
                if ($geoNation) {
                    Set-WinHomeLocation -GeoId $geoNation -ea 0
                }
            }

            Write-Warning "Verify info for $tsactid"
            
            Manage-SLHandle -Release | Out-null
            $StatusInfo = Get-SLLicensingStatus -ApplicationID 55c92734-d682-4d71-983e-d6ec3f16059f -SkuID $tsactid
            if (-not $StatusInfo) {
                $logBox.Text += "Fail to fetch status data"
                return
            }
            
            if ($Vol_Key -and (
                $StatusInfo.LicenseTier -ne [LicenseCategory]::KMS38)) {
                    $logBox.Text += [Environment]::NewLine
                    $logBox.Text += "KMS38 Activation Failed."
                    $logBox.Text += [Environment]::NewLine
                    $logBox.Text += "Try re-apply Activation again later"
                    $logBox.Text += [Environment]::NewLine

                    Remove-Item -Path "HKLM:\SOFTWARE\Microsoft\Windows NT\CurrentVersion\SoftwareProtectionPlatform\55c92734-d682-4d71-983e-d6ec3f16059f" -Force -Recurse -ea 0
                    Remove-Item -Path "HKU:\S-1-5-20\SOFTWARE\Microsoft\Windows NT\CurrentVersion\SoftwareProtectionPlatform\55c92734-d682-4d71-983e-d6ec3f16059f" -Force -Recurse -ea 0
            }
            elseif (-not $Vol_Key -and (
                $StatusInfo.LicenseStatus -ne [LicenseStatusEnum]::Licensed)) {
                    $logBox.Text += [Environment]::NewLine
                    $logBox.Text += "HWID Activation Failed."
                    $logBox.Text += [Environment]::NewLine
                    $logBox.Text += "Try re-apply Activation again later"
                    $logBox.Text += [Environment]::NewLine
            }
            else {
                $logBox.Text += [Environment]::NewLine
                $logBox.Text += "everything is Well Done"
                $logBox.Text += [Environment]::NewLine
                $logBox.Text += "Go Home & Rest. !"
                $logBox.Text += [Environment]::NewLine
            }

            $logBox.Text = $logBox.Text -replace 'System.Management.ManagementBaseObject',[Environment]::NewLine
            # END ###########
        } else {
        }
    })

    # === END: Your controls ===

    # Create Edition Matrix Tab (empty)
    $tabEditionMatrix = New-Object Windows.Forms.TabPage
    $tabEditionMatrix.Text = "Edition matrix"

    # ComboBox (left side)
    $editionCombo = New-Object Windows.Forms.ComboBox
    $editionCombo.Location = New-Object Drawing.Point(10, 15)
    $editionCombo.Size = New-Object Drawing.Size(300, 30)
    $editionCombo.Font = New-Object Drawing.Font('Segoe UI', 10)
    $editionCombo.DropDownStyle = 'DropDownList'
    $editionCombo.Items.AddRange(
        @("ultimate","homebasic","homepremium","enterprise","homebasicn","business","serverstandard","serverdatacenter","serversbsstandard","serverenterprise","starter",
        "serverdatacentercore","serverstandardcore","serverenterprisecore","serverenterpriseia64","businessn","serverweb","serverhpc","serverhomestandard","serverstorageexpress",
        "serverstoragestandard","serverstorageworkgroup","serverstorageenterprise","serverwinsb","serversbspremium","homepremiumn","enterprisen","ultimaten","serverwebcore",
        "servermediumbusinessmanagement","servermediumbusinesssecurity","servermediumbusinessmessaging","serverwinfoundation","serverhomepremium","serverwinsbv","serverstandardv",
        "serverdatacenterv","serverenterprisev","serverdatacentervcore","serverstandardvcore","serverenterprisevcore","serverhypercore","serverstorageexpresscore","serverstoragestandardcore",
        "serverstorageworkgroupcore","serverstorageenterprisecore","startern","professional","professionaln","serversolution","serverforsbsolutions","serversolutionspremium",
        "serversolutionspremiumcore","serversolutionem","serverforsbsolutionsem","serverembeddedsolution","serverembeddedsolutioncore","professionalembedded","serveressentialmanagement",
        "serveressentialadditional","serveressentialmanagementsvc","serveressentialadditionalsvc","serversbspremiumcore","serverhpcv","embedded","startere","homebasice",
        "homepremiume","professionale","enterprisee","ultimatee","enterpriseeval","prerelease","servermultipointstandard","servermultipointpremium","serverstandardeval",
        "serverdatacentereval","prereleasearm","prereleasen","enterpriseneval","embeddedautomotive","embeddedindustrya","thinpc","embeddeda","embeddedindustry","embeddede",
        "embeddedindustrye","embeddedindustryae","professionalplus","serverstorageworkgroupeval","serverstoragestandardeval","corearm","coren","corecountryspecific","coresinglelanguage",
        "core","professionalwmc","mobilecore","embeddedindustryeval","embeddedindustryeeval","embeddedeval","embeddedeeval","coresystemserver","servercloudstorage","coreconnected",
        "professionalstudent","coreconnectedn","professionalstudentn","coreconnectedsinglelanguage","coreconnectedcountryspecific","connectedcar","industryhandheld",
        "ppipro","serverarm64","education","educationn","iotuap","serverhi","enterprises","enterprisesn","professionals","professionalsn","enterpriseseval",
        "enterprisesneval","iotuapcommercial","mobileenterprise","analogonecore","holographic","professionalsinglelanguage","professionalcountryspecific","enterprisesubscription",
        "enterprisesubscriptionn","serverdatacenternano","serverstandardnano","serverdatacenteracor","serverstandardacor","serverdatacentercor","serverstandardcor","utilityvm",
        "serverdatacenterevalcor","serverstandardevalcor","professionalworkstation","professionalworkstationn","serverazure","professionaleducation","professionaleducationn",
        "serverazurecor","serverazurenano","enterpriseg","enterprisegn","businesssubscription","businesssubscriptionn","serverrdsh","cloud","cloudn","hubos","onecoreupdateos",
        "cloude","andromeda","iotos","clouden","iotedgeos","iotenterprise","modernpc","iotenterprises","systemos","nativeos","gamecorexbox","gameos","durangohostos",
        "scarletthostos","keystone","cloudhost","cloudmos","cloudcore","cloudeditionn","cloudedition","winvos","iotenterprisesk","iotenterprisek","iotenterpriseseval",
        "agentbridge","nanohost","wnc","serverazurestackhcicor","serverturbine","serverturbinecor"
    ))
    # Add event handler for SelectedIndexChanged
    $editionCombo.Add_SelectedIndexChanged({
        # Inside here, get the selected item text
        $editionTextBox.text = $editionCombo.SelectedItem
        
    })

    # Make TextBox smaller (e.g., 450 width)
    $editionTextBox = New-Object Windows.Forms.TextBox
    $editionTextBox.Location = New-Object Drawing.Point(320, 15)
    $editionTextBox.Size = New-Object Drawing.Size(450, 30)
    $editionTextBox.Font = New-Object Drawing.Font('Segoe UI', 10)

    # Add Select button right next to TextBox to fill remaining space
    $selectButton = New-Object Windows.Forms.Button
    $selectButton.Text = 'Select'
    $selectButton.Location = New-Object Drawing.Point(780, 14) 
    $selectButton.Size = New-Object Drawing.Size(160, 30) 
    $selectButton.Font = New-Object Drawing.Font('Segoe UI', 10)
    $selectButton.Add_Click({
        $editionList.Items.Clear()
        $selectedValue = $editionTextBox.Text
        if ([string]::IsNullOrWhiteSpace($selectedValue)) {
            return;
        }
        $MatrixTable = @()
        try {
          $MatrixTable = Get-EditionTargetsFromMatrix -EditionID $selectedValue -RawData
        }
        catch {
        }
        if ($MatrixTable) {
            foreach ($edition in $MatrixTable) {
                $item = New-Object Windows.Forms.ListViewItem("Edition")
                $item.SubItems.Add($edition)
                $editionList.Items.Add($item)
            }
        }
    })

    # ListView (spans wide, 1 row)
    $editionList = New-Object Windows.Forms.ListView
    $editionList.Location = New-Object Drawing.Point(10, 60)
    $editionList.Size = New-Object Drawing.Size(940, 470)
    $editionList.View = 'Details'
    $editionList.FullRowSelect = $true
    $editionList.GridLines = $true
    $editionList.Font = New-Object Drawing.Font('Segoe UI', 10)

    # Define some basic columns
    $editionList.Columns.Add("Type", 100) | Out-Null
    $editionList.Columns.Add("Name", 720) | Out-Null

    # Add controls to second tab
    $tabEditionMatrix.Controls.AddRange(@($editionCombo, $editionTextBox, $editionList, $selectButton))

    # Add tab control to form
    $tabControl.TabPages.Add($tabActivate)
    $tabControl.TabPages.Add($tabEditionMatrix)
    $form.Controls.Add($tabControl)

    # Show form
    $form.ShowDialog()
}
Function ExtractForm {
    # Create a font for labels and inputs
    $font = New-Object Font('Segoe UI', 10)

    # Create the form
    $form = New-Object System.Windows.Forms.Form
    $form.Size = New-Object System.Drawing.Size(1150, 600)  # Increased size
    $form.StartPosition = 'CenterScreen'
    $form.FormBorderStyle = [FormBorderStyle]::FixedDialog
    $form.MaximizeBox = $false
    $form.MinimizeBox = $false
    $form.BackColor = [Color]::LightSteelBlue

    # Create a font for labels and inputs
    $font = New-Object Font('Segoe UI', 10)

    # Define buttons and other controls
    $buttonCheck = New-Object System.Windows.Forms.Button
    $buttonCheck.Text = "Check"
    $buttonCheck.Location = New-Object System.Drawing.Point(10, 10)  # Same Y for alignment
    $buttonCheck.Size = New-Object System.Drawing.Size(140, 64)  # Increased size
    $buttonCheck.Font = New-Object Font('Segoe UI', 10, [FontStyle]::Bold)  # Bold font
    $buttonCheck.BackColor = [Color]::CadetBlue
    $buttonCheck.ForeColor = [Color]::White
    $buttonCheck.FlatStyle = 'Standard'  # Changed FlatStyle
    $form.Controls.Add($buttonCheck)

    $buttonBrowseFolder = New-Object System.Windows.Forms.Button
    $buttonBrowseFolder.Text = "Browse Folder"
    $buttonBrowseFolder.Location = New-Object System.Drawing.Point(160, 10)  # Same Y for alignment
    $buttonBrowseFolder.Size = New-Object System.Drawing.Size(140, 64)  # Increased size
    $buttonBrowseFolder.Font = New-Object Font('Segoe UI', 10, [FontStyle]::Bold)  # Bold font
    $buttonBrowseFolder.BackColor = [Color]::CadetBlue
    $buttonBrowseFolder.ForeColor = [Color]::White
    $buttonBrowseFolder.FlatStyle = 'Standard'  # Changed FlatStyle
    $form.Controls.Add($buttonBrowseFolder)

    $buttonBrowseFile = New-Object System.Windows.Forms.Button
    $buttonBrowseFile.Text = "Browse File"
    $buttonBrowseFile.Location = New-Object System.Drawing.Point(310, 10)  # Same Y for alignment
    $buttonBrowseFile.Size = New-Object System.Drawing.Size(140, 64)  # Increased size
    $buttonBrowseFile.Font = New-Object Font('Segoe UI', 10, [FontStyle]::Bold)  # Bold font
    $buttonBrowseFile.BackColor = [Color]::CadetBlue
    $buttonBrowseFile.ForeColor = [Color]::White
    $buttonBrowseFile.FlatStyle = 'Standard'  # Changed FlatStyle
    $form.Controls.Add($buttonBrowseFile)

    # Define Export button
    $buttonExport = New-Object System.Windows.Forms.Button
    $buttonExport.Text = "Export"
    $buttonExport.Location = New-Object System.Drawing.Point(460, 10)  # Same Y for alignment
    $buttonExport.Size = New-Object System.Drawing.Size(140, 64)  # Increased size
    $buttonExport.Font = New-Object Font('Segoe UI', 10, [FontStyle]::Bold)  # Bold font
    $buttonExport.BackColor = [Color]::CadetBlue
    $buttonExport.ForeColor = [Color]::White
    $buttonExport.FlatStyle = 'Standard'
    $form.Controls.Add($buttonExport)

    # Define the DataGridView
    $dataGridView = New-Object System.Windows.Forms.DataGridView
    $dataGridView.Location = New-Object System.Drawing.Point(10, 80)
    $dataGridView.Size = New-Object System.Drawing.Size(1110, 450)
    $dataGridView.AutoSizeColumnsMode = "Fill"
    $dataGridView.AllowUserToAddRows = $false
    $dataGridView.Font = New-Object System.Drawing.Font("Segoe UI", 10)
    $dataGridView.ColumnHeadersHeight = 35 
    $dataGridView.ColumnHeadersDefaultCellStyle.Font = New-Object System.Drawing.Font("Segoe UI", 11, [System.Drawing.FontStyle]::Bold)

    # Add columns to the DataGridView
    $form.Controls.Add($dataGridView)

    # Define ComboBox for predefined locations
    $comboBoxLocations = New-Object System.Windows.Forms.ComboBox
    $comboBoxLocations.Location = New-Object System.Drawing.Point(620, 10)  # Moved up for better layout
    $comboBoxLocations.Size = New-Object System.Drawing.Size(500, 30)  # Size remains efficient
    $comboBoxLocations.Font = New-Object Font('Segoe UI', 10)  # Standard font
    $comboBoxLocations.BackColor = [Color]::White  # Background color for better contrast
    $comboBoxLocations.ForeColor = [Color]::Black  # Text color for readability
    $comboBoxLocations.DropDownStyle = 'DropDownList'  # Prevent user from typing arbitrary text
    $comboBoxLocations.Items.AddRange($PreDefinedXt)  # Add predefined locations
    $form.Controls.Add($comboBoxLocations)

    # Define TextBox for input
    $textBoxSource = New-Object System.Windows.Forms.TextBox
    $textBoxSource.Location = New-Object System.Drawing.Point(620, 45)  # Moved up for better layout
    $textBoxSource.Size = New-Object System.Drawing.Size(500, 30)  # Size remains efficient
    $textBoxSource.Font = New-Object Font('Segoe UI', 10)  # Standard font
    $textBoxSource.BackColor = [Color]::White  # Background color for better contrast
    $textBoxSource.ForeColor = [Color]::Black  # Text color for readability
    $form.Controls.Add($textBoxSource)

    # Event to update TextBox when ComboBox selection changes
    $comboBoxLocations.add_SelectedIndexChanged({
        if ($comboBoxLocations.SelectedItem -eq '** ERROR:') {
            $textBoxSource.Text = "example: 17, 0x11, 0x80070011, -0x7FF8DCD5, -4294967279, 0225D, 225AAAD"
        }
        else {
            $textBoxSource.Text = $comboBoxLocations.SelectedItem.ToString()
        }
    })

    # Event to update TextBox when ComboBox selection changes
    $comboBoxLocations.add_SelectedIndexChanged({
        if ($comboBoxLocations.SelectedItem -eq '** ERROR:') {
            $textBoxSource.Text = "example: 17, 0x11, 0x80070011, -0x7FF8DCD5, -4294967279, 0225D, 225AAAD"
        }
        else {
            $textBoxSource.Text = $comboBoxLocations.SelectedItem.ToString()
        }
    })

    # Event handler for Export button
    $buttonExport.Add_Click({
        # Collect data from DataGridView into a PSCustomObject array
        $dataArray = @()

        for ($row = 0; $row -lt $dataGridView.Rows.Count; $row++) {
            $rowData = @{}
            for ($col = 0; $col -lt $dataGridView.Columns.Count; $col++) {
                $header = $dataGridView.Columns[$col].HeaderText
                $rowData[$header] = $dataGridView.Rows[$row].Cells[$col].Value
            }
            $dataArray += New-Object PSObject -Property $rowData
        }

        # Convert the array of PSCustomObjects to HTML
        $dataArray | Out-HtmlView
    })

    # Button click event for Browse Folder
    $buttonBrowseFolder.Add_Click({
        $folderDialog = New-Object System.Windows.Forms.FolderBrowserDialog
        if ($folderDialog.ShowDialog() -eq [System.Windows.Forms.DialogResult]::OK) {
            $textBoxSource.Text = $folderDialog.SelectedPath
        }
    })

    # Button click event for Browse File
    $buttonBrowseFile.Add_Click({
        $fileDialog = New-Object System.Windows.Forms.OpenFileDialog
        $fileDialog.Filter = "Data Files (*.exe;*.dll;*.txt;*.ini;)|*.exe;*.dll;*.txt;*.ini|All Files (*.*)|*.*"
        if ($fileDialog.ShowDialog() -eq [System.Windows.Forms.DialogResult]::OK) {
            $textBoxSource.Text = $fileDialog.FileName
        }
    })

    # Button click event for the Check button
    $buttonCheck.Add_Click({
        # Clear all existing columns and rows
        $dataGridView.Columns.Clear()
        $dataGridView.Rows.Clear()

        $isError = $comboBoxLocations.SelectedItem -eq "** ERROR:"
        if ($isError) {
            if ([STRING]::IsNullOrWhiteSpace($textBoxSource.Text)) {
                return
            }

            try {
                $ERR = $textBoxSource.Text.ToString().Trim()
                if (-not (Parse-MessageId -MessageId $ERR)){
                    return
                }
                $ERR = Parse-MessageId -MessageId $ERR
            }
            catch {
                return
            }
            
            $dataGridView.Columns.Add("Flag", "Flag") | Out-Null
            $dataGridView.Columns["Flag"].Width = 80
            $dataGridView.Columns.Add("Message", "Message") | Out-Null
            $dataGridView.Columns["Message"].Width = 880
            $dataGridView.RowTemplate.Height = 30  

            $Facility = Parse-ErrorFacility -HResult $ERR
            $dataGridView.Rows.Add("Facility", ($Facility.TOString()))
            foreach ($ITEM in (
                "CBS","BITS","HTTP","UPDATE","NETWORK","WIN32", "HRESULT","NTSTATUS","ACTIVATION")) {
                    $MSG = Parse-ErrorMessage -MessageId $ERR -flags $item
                    $dataGridView.Rows.Add($ITEM, $MSG)
            }
            try {
                $win32ERR = 0
                $win32ERR = $Global:ntdll::RtlNtStatusToDosError($ERR)
                if ($win32ERR -notin (0, 317)) {
                    $win32ERR = Parse-MessageId -MessageId $win32ERR
                    $MessageId = Parse-MessageId -MessageId $ERR
                    if ($win32ERR -ne $MessageId) {
                        Write-Warning "win32ERR = $win32ERR, MessageId = $MessageId"
                        $MSG = Parse-ErrorMessage -MessageId $win32ERR -flags WIN32
                        $dataGridView.Rows.Add("RtlNtStatusToDosError", $MSG)
                    }
                }
            }
            catch {
            }

            try {
                $win32ERR = 0
                $win32ERR = $Global:advapi32::LsaNtStatusToWinError($ERR)
                if ($win32ERR -notin (0, 317)) {
                    $win32ERR = Parse-MessageId -MessageId $win32ERR
                    $MessageId = Parse-MessageId -MessageId $ERR
                    if ($win32ERR -ne $MessageId) {
                        Write-Warning "win32ERR = $win32ERR, MessageId = $MessageId"
                        $MSG = Parse-ErrorMessage -MessageId $win32ERR -flags WIN32
                        $dataGridView.Rows.Add("LsaNtStatusToWinError", $MSG)
                    }
                }
            }
            catch {
            }

            return
        }

        if ($textBoxSource.Text -eq "** Active License Info") {

            $dataGridView.Columns.Add("Property", "Property")
            $dataGridView.Columns["Property"].Width = 550 
            $dataGridView.Columns.Add("Description", "Description")
            $dataGridView.Columns["Description"].Width = 650 
            $dataGridView.RowTemplate.Height = 30

            $licInfo = Query-ActiveLicenseInfo
            if ($licInfo) {
                foreach ($Item in $licInfo) {
                    try {
                        $name = $Item.Name
                        $val = ($Item.Value).ToString()
                        $dataGridView.Rows.Add($name, $val)
                    }
                    catch {
                    }
                }
            }
            return
        }

        $dataGridView.Columns.Add("Value", "File")
        $dataGridView.Columns["Value"].Width = 250 
        $dataGridView.Columns.Add("REF", "REF")
        $dataGridView.Columns["REF"].Width = 220
        $dataGridView.Columns.Add("Property", "Property")
        $dataGridView.Columns["Property"].Width = 560 
        $dataGridView.Columns.Add("Description", "Description")
        $dataGridView.Columns["Description"].Width = 450 
        $dataGridView.RowTemplate.Height = 30  

        if ($textBoxSource.Text -eq '** Interface-Com') {
            $licInfo = Get-LicensingInfo
            if ($licInfo) {
                foreach ($property in $licInfo.PSObject.Properties) {
                    try {
                        $name = $property.Name
                        $val = ($property.Value).ToString()
                        $dataGridView.Rows.Add($name, '', '', $val)
                    }
                    catch {
                    }
                }
            }
            return
        }

        if ($textBoxSource.Text -eq '** Kernel-Policies') {
            $ProductPolicy = Get-ProductPolicy

            # List of ProductPolicy names to fetch (real names with prefixes)
            $policyNames = @(
                'ConsumeAddonPolicySet',
                'Allow-WindowsSubscription',
                'Clip-SubscriptionEditionId',
                'Clip-SubscriptionPFN',
                'Kernel-EditionName',
                'Kernel-BrandingInfo',
                'Kernel-ProductInfo',
                'Kernel-ProductType',
                'Kernel-NonGenuineNotificationType',
                'Security-SPP-ActivationResetCount',
                'Security-SPP-ActivationResetCountMax',
                'Security-SPP-EvaluationModeEnabled',
                'Security-SPP-GenuineLocalStatus',
                'Security-SPP-LastWindowsActivationHResult',
                'Security-SPP-LastWindowsActivationTime',
                'Security-SPP-ProductType',
                'Security-SPP-SharedLicense',
                'Security-SPP-Reserved-SkuPpdConsumed',
                'Security-SPP-Reserved-TBLProductKeyType',
                'Security-SPP-Reserved-TBLRemainingTime',
                'Security-SPP-Reserved-TBLState'
            )

            # Handle StateData separately
            $StateData = $ProductPolicy | Where-Object Name -eq 'Security-SPP-Action-StateData' | Select-Object -ExpandProperty Value
            if (-not [string]::IsNullOrWhiteSpace($StateData)) {
                $StateData -split ';' | ForEach-Object {
                    $parts = $_ -split '='
                    if ($parts.Count -eq 2) {
                        $name = $parts[0].Trim()
                        $value = $parts[1].Trim()
                        if ($name -eq 'LastConsumptionReason') {
                            $value = Parse-ErrorMessage $value
                            $dataGridView.Rows.Add("StateData", '', $name, $value)
                        }
                        else {
                            $dataGridView.Rows.Add("StateData", '', $name, $value)
                        }
                    }
                }
            }

            # Loop through the rest of the policies
            foreach ($policyName in $policyNames) {
                $entry = $ProductPolicy | Where-Object Name -eq $policyName
                $displayName = $policyName -replace '^(Kernel-|Security-SPP-)', ''
                
                if ($entry) {
                    if ($displayName -eq 'LastWindowsActivationHResult') {
                        $message = Parse-ErrorMessage -MessageId $entry.Value -Flags ACTIVATION
                        $dataGridView.Rows.Add($displayName, '', $($entry.Value.ToString()),$message)
                    }
                    elseif ($displayName -eq 'ActivationResetCountMax') {
                        try {
                            $value = [INT]::Parse([uint32]$entry.Value)
                        }
                        catch {
                            $value = $null
                        }
                        $dataGridView.Rows.Add($displayName, '', '', $value.ToString())
                    }
                    else {
                        $dataGridView.Rows.Add($displayName, '', '', $entry.Value.ToString())
                    }
                } else {
                    $dataGridView.Rows.Add($displayName, '', '', '<Not Found>')
                }
            }

            return
        }
        if ($textBoxSource.Text -eq '** Registry-WMI') {
            
            $info = Parse-DigitalProductId
            $dataGridView.Rows.Add('DigitalProductId', '', 'Version' , "$($info.majorVersion),$($info.minorVersion)")
            $dataGridView.Rows.Add('DigitalProductId', '', 'EditionId' , $info.EditionId)
            $dataGridView.Rows.Add('DigitalProductId', '', 'ProductId' , $info.ProductId)
            $dataGridView.Rows.Add('DigitalProductId', '', 'DigitalKey' , $info.DigitalKey)

            $info = Parse-DigitalProductId4
            $dataGridView.Rows.Add('DigitalProductId4', '', 'Version', "$($info.majorVersion),$($info.minorVersion)")
            $dataGridView.Rows.Add('DigitalProductId4', '', 'EditionType' , $info.EditionType)
            $dataGridView.Rows.Add('DigitalProductId4', '', 'EditionID' , $info.EditionID)
            $dataGridView.Rows.Add('DigitalProductId4', '', 'EULA' , $info.EULA)
            $dataGridView.Rows.Add('DigitalProductId4', '', 'KeyType' , $info.KeyType)
            $dataGridView.Rows.Add('DigitalProductId4', '', 'DigitalKey' , $info.DigitalKey)
            $dataGridView.Rows.Add('DigitalProductId4', '', 'ActivationID' , $info.ActivationID)
            $dataGridView.Rows.Add('DigitalProductId4', '', 'AdvancedPID' , $info.AdvancedPID)

            $cdKeys = Get-WindowsProductKey
            $DigitalProductId = $cdKeys.DigitalProductId
            $DigitalProductId4 = $cdKeys.DigitalProductId4
            $OA3xOriginalProductKey = $cdKeys.OA3xOriginalProductKey
            $BackupProductKeyDefault = $cdKeys.BackupProductKeyDefault

            $DigitalProductId_Ref = Add-Missing-Ref -cdKeys $DigitalProductId
            $DigitalProductId4_Ref = Add-Missing-Ref -cdKeys $DigitalProductId4
            $OA3xOriginalProductKey_Ref = Add-Missing-Ref -cdKeys $OA3xOriginalProductKey
            $BackupProductKeyDefault_Ref = Add-Missing-Ref -cdKeys $BackupProductKeyDefault

            if ($DigitalProductId_Ref) {
              $DigitalProductId_F = Add-Missing-Label -referenceData $DigitalProductId_Ref
            }
            if ($DigitalProductId4_Ref) {
              $DigitalProductId4_F = Add-Missing-Label -referenceData $DigitalProductId4_Ref
            }
            if ($OA3xOriginalProductKey_Ref) {
              $OA3xOriginalProductKey_F = Add-Missing-Label -referenceData $OA3xOriginalProductKey_Ref
            }
            if ($BackupProductKeyDefault_Ref) {
              $BackupProductKeyDefault_F = Add-Missing-Label -referenceData $BackupProductKeyDefault_Ref
            }

            if ($DigitalProductId_F) {
              $dataGridView.Rows.Add('DigitalProductId', $DigitalProductId_F.Key, $DigitalProductId_F.Value, $DigitalProductId_F.RefText)  # Add file path and item details
            } else {
              $dataGridView.Rows.Add('DigitalProductId', '' , '', '')  # Add file path and item details
            }
            if ($DigitalProductId4_F) {
              $dataGridView.Rows.Add('DigitalProductId4', $DigitalProductId4_F.Key, $DigitalProductId4_F.Value, $DigitalProductId4_F.RefText)  # Add file path and item details
            } else {
              $dataGridView.Rows.Add('DigitalProductId4', '' , '', '')  # Add file path and item details
            }
            if ($BackupProductKeyDefault_F) {
              $dataGridView.Rows.Add('BackupProductKeyDefault', $BackupProductKeyDefault_F.Key, $BackupProductKeyDefault_F.Value, $BackupProductKeyDefault_F.RefText)  # Add file path and item details
            } else {
              $dataGridView.Rows.Add('BackupProductKeyDefault', '' , '', '')  # Add file path and item details
            }
			if ($OA3xOriginalProductKey_F) {
              $dataGridView.Rows.Add('OA3xOriginalProductKey', $OA3xOriginalProductKey_F.Key, $OA3xOriginalProductKey_F.Value, $OA3xOriginalProductKey_F.RefText)  # Add file path and item details
            } else {
              $dataGridView.Rows.Add('OA3xOriginalProductKey', '' , '', '')  # Add file path and item details
            }

            return
        }
        if (([String]::IsNullOrWhiteSpace($textBoxSource.Text)) -or (-not (Test-Path $textBoxSource.Text))) {
            throw "Invalid source path!"
        }

        # Check if the input is a single file or a directory
        $files = @()
        $sourcePath = $textBoxSource.Text
        if (Test-Path $sourcePath) {
            if (Test-Path -PathType Leaf $sourcePath) {
                # If it's a single file, add it to the $files array
                $files += Get-Item -Path $sourcePath
            } elseif (Test-Path -PathType Container $sourcePath) {
                # If it's a directory, get all .exe and .dll files
                $files = Get-ChildItem -Path $sourcePath -Recurse -Include *.exe, *.dll, *.txt, *.ini -File
            }
        }

        # Loop through each file
        foreach ($file in $files) {
            
            #check for ini \ txt file's
            $IsText = $file.Extension -match ".ini|.txt"
            
            try {
                if ($IsText) {
                    # Extract strings from the current file
                    $strings = Get-Content -Encoding UTF8 $file.FullName -EA 0
                } else {
                    # Extract strings from the current file
                    $strings = Get-Strings -Path $file.FullName -Encoding Unicode
                }
            }
            catch {}
    
            # Continue to the next file if no strings are found
            if (-not $strings) {
                continue
            }

            try {
                # Extract CD keys from the strings
                $cdKeys = Extract-CdKeys -strings $strings
            }
            catch {}

            # Check if reference data is null and exit if so
            if (-not $cdKeys) {
                continue
            }

            try {
                # Add missing references
                $referenceData = Add-Missing-Ref -cdKeys $cdKeys
            }
            catch {}

            # Check if reference data is null and exit if so
            if (-not $referenceData) {
                continue
            }

            try {
                # Add missing labels
                $finalResults = Add-Missing-Label -referenceData $referenceData
            }
            catch {}

            # Check if reference data is null and exit if so
            if (-not $finalResults) {
                continue
            }

            # Display results in the DataGridView
            foreach ($item in $finalResults) {
                $dataGridView.Rows.Add($file.FullName, $item.Key, $item.Value, $item.RefText)  # Add file path and item details
            }
        }
    })
    $form.ShowDialog()
}
Function SL_Add_License_Form {
    # Create a font for labels and inputs
    $font = New-Object System.Drawing.Font('Segoe UI', 10)

    # Create the form
    $form = New-Object System.Windows.Forms.Form
    $form.Size = New-Object System.Drawing.Size(1200, 600)  # Increased size for more columns
    $form.StartPosition = 'CenterScreen'
    $form.FormBorderStyle = [System.Windows.Forms.FormBorderStyle]::FixedDialog
    $form.MaximizeBox = $false
    $form.MinimizeBox = $false
    $form.BackColor = [System.Drawing.Color]::LightSteelBlue

    # Define Initialize button
    $buttonInitialize = New-Object System.Windows.Forms.Button
    $buttonInitialize.Text = "Initialize"
    $buttonInitialize.Location = New-Object System.Drawing.Point(10, 10)
    $buttonInitialize.Size = New-Object System.Drawing.Size(140, 40)  # Adjusted height (smaller)
    $buttonInitialize.Font = New-Object System.Drawing.Font('Segoe UI', 10, [System.Drawing.FontStyle]::Bold)
    $buttonInitialize.BackColor = [System.Drawing.Color]::CadetBlue
    $buttonInitialize.ForeColor = [System.Drawing.Color]::White
    $buttonInitialize.FlatStyle = 'Standard'
    $form.Controls.Add($buttonInitialize)

    # Define Add License button
    $buttonAdd = New-Object System.Windows.Forms.Button
    $buttonAdd.Text = "Add License"
    $buttonAdd.Location = New-Object System.Drawing.Point(160, 10)  # Adjusted X position for spacing
    $buttonAdd.Size = New-Object System.Drawing.Size(140, 40)  # Adjusted height (smaller)
    $buttonAdd.Font = New-Object System.Drawing.Font('Segoe UI', 10, [System.Drawing.FontStyle]::Bold)
    $buttonAdd.BackColor = [System.Drawing.Color]::CadetBlue
    $buttonAdd.ForeColor = [System.Drawing.Color]::White
    $buttonAdd.FlatStyle = 'Standard'
    $form.Controls.Add($buttonAdd)

    # Define the Search TextBox (Updated)
    $textBoxPro = New-Object System.Windows.Forms.TextBox
    $textBoxPro.Location = New-Object System.Drawing.Point(320, 14)  # Moved slightly to the right for spacing
    $textBoxPro.Size = New-Object System.Drawing.Size(850, 30)  # Adjusted width for a more balanced design
    $textBoxPro.Font = New-Object System.Drawing.Font('Segoe UI', 12)
    $form.Controls.Add($textBoxPro)

    # Define ComboBox for folder path
    $comboBoxFolderPath = New-Object System.Windows.Forms.ComboBox
    $comboBoxFolderPath.Location = New-Object System.Drawing.Point(10, 55)
    $comboBoxFolderPath.Size = New-Object System.Drawing.Size(1160, 20)
    $comboBoxFolderPath.DropDownStyle = [System.Windows.Forms.ComboBoxStyle]::DropDownList
    $comboBoxFolderPath.Font = New-Object System.Drawing.Font('Segoe UI', 10)
    # Add default folder paths to ComboBox
    $comboBoxFolderPath.Items.AddRange(@(
        "C:\Program Files\Microsoft Office\root\Licenses16"
    ))
    $comboBoxFolderPath.SelectedIndex = 0  # Set default selected index to first folder
    $form.Controls.Add($comboBoxFolderPath)

    # Add an event handler to update TextBox when ComboBox selection changes
    $comboBoxFolderPath.Add_SelectedIndexChanged({
        $textBoxPro.Text = $comboBoxFolderPath.SelectedItem  # Update TextBox with selected ComboBox item
    })

   # Define the Search TextBox
    $textBoxSearch = New-Object System.Windows.Forms.TextBox
    $textBoxSearch.Location = New-Object System.Drawing.Point(120, 94)  # Move to the right after button
    $textBoxSearch.Size = New-Object System.Drawing.Size(1050, 30)    # Adjust width to fill the space
    $textBoxSearch.Font = New-Object System.Drawing.Font('Segoe UI', 10)
    $form.Controls.Add($textBoxSearch)

    # Define Search button
    $buttonSearch = New-Object System.Windows.Forms.Button
    $buttonSearch.Text = "Search"
    $buttonSearch.Location = New-Object System.Drawing.Point(10, 90)  # Location of the button
    $buttonSearch.Size = New-Object System.Drawing.Size(100, 35)      # Adjusted button height (smaller)
    $buttonSearch.Font = New-Object System.Drawing.Font('Segoe UI', 10, [System.Drawing.FontStyle]::Bold)
    $buttonSearch.BackColor = [System.Drawing.Color]::CadetBlue
    $buttonSearch.ForeColor = [System.Drawing.Color]::White
    $buttonSearch.FlatStyle = 'Standard'
    $form.Controls.Add($buttonSearch)

    # Define ListView (table-like structure)
    $listView = New-Object System.Windows.Forms.ListView
    $listView.Location = New-Object System.Drawing.Point(10, 140)
    $listView.Size = New-Object System.Drawing.Size(1160, 400)
    $listView.View = [System.Windows.Forms.View]::Details
    $listView.FullRowSelect = $true
    $listView.Font = New-Object System.Drawing.Font('Segoe UI', 10, [System.Drawing.FontStyle]::Regular)

    # Add columns to ListView
    $listView.Columns.Add("File Name", 350)   # Narrow width for File Name
    $listView.Columns.Add("Path", 960)         # Wider column for Path
    $form.Controls.Add($listView)

    # Function to filter ListView based on search query
    Function Filter-ListView {
        param (
            [string]$searchTerm
        )

        # Clear the ListView to refresh it
        $listView.Items.Clear()

        # Get the folder path from the TextBox (not ComboBox)
        $folderPath = $textBoxPro.Text.Trim()

        # Get all .xrm-ms files in the folder
        $xrmFiles = Get-ChildItem -Path $folderPath -Filter "*.xrm-ms"

        # Filter based on search term
        $filteredFiles = $xrmFiles | Where-Object { $_.Name -like "*$searchTerm*" }

        # Add the filtered file names to the ListView
        $filteredFiles | ForEach-Object {
            $listViewItem = New-Object System.Windows.Forms.ListViewItem($_.Name)
            $listViewItem.SubItems.Add($_.FullName)  # Add path as a second column
            $listView.Items.Add($listViewItem)
        }
    }

    # Search button click event
    $buttonSearch.Add_Click({
        # Get the search term from the TextBox
        $searchTerm = $textBoxSearch.Text
        Filter-ListView -searchTerm $searchTerm
    })

    # Initialize button click event (show files in folder)
    $buttonInitialize.Add_Click({
        # Clear previous items in ListView
        $listView.Items.Clear()

        # Get the folder path from the ComboBox
        $folderPath = $textBoxPro.Text
        if ([string]::IsNullOrWhiteSpace($folderPath)) {
            return
        }

        # Check if the folder exists
        if (Test-Path $folderPath) {
            # Get all .xrm-ms files in the folder
            $xrmFiles = Get-ChildItem -Path $folderPath -Filter "*.xrm-ms"

            # Add the file names to the ListView
            $xrmFiles | ForEach-Object {
                $listViewItem = New-Object System.Windows.Forms.ListViewItem($_.Name)
                $listViewItem.SubItems.Add($_.FullName)  # Add path as a second column
                $listView.Items.Add($listViewItem)
            }
        } else {
            [System.Windows.Forms.MessageBox]::Show("Folder path does not exist.", "Error", [System.Windows.Forms.MessageBoxButtons]::OK, [System.Windows.Forms.MessageBoxIcon]::Error)
        }
    })

    # Add License button click event
    $buttonAdd.Add_Click({
        # Ensure we have selected items in the ListView
        if ($listView.SelectedItems.Count -gt 0) {
            # Initialize an empty list to hold the selected file paths
            $fileList = @()

            # Loop through selected items and add file path to $fileList
            $listView.SelectedItems | ForEach-Object {
                $filePath = $_.SubItems[1].Text
                $fileList += $filePath
            }

            # Now pass the $fileList to SL-InstallLicense
            if ($fileList.Count -gt 0) {
                # Install licenses from the selected .xrm-ms files
                Manage-SLHandle -Release | Out-null
                foreach ($file in $fileList) {
                    SL-InstallLicense -LicenseInput $file
                }
            } else {
                [System.Windows.Forms.MessageBox]::Show("Please select at least one file to add.", "Error", [System.Windows.Forms.MessageBoxButtons]::OK, [System.Windows.Forms.MessageBoxIcon]::Error)
            }

            # Optionally, refresh the file list after adding
            $buttonInitialize.PerformClick()
        } else {
            [System.Windows.Forms.MessageBox]::Show("Please select at least one file to add.", "Error", [System.Windows.Forms.MessageBoxButtons]::OK, [System.Windows.Forms.MessageBoxIcon]::Error)
        }
    })

    # Show the form
    $form.ShowDialog()
}
Function SL_Remove_License_Form {
    
    # Create a font for labels and inputs
    $font = New-Object Font('Segoe UI', 10)

    # Create the form
    $form = New-Object System.Windows.Forms.Form
    $form.Size = New-Object System.Drawing.Size(1200, 660)
    $form.StartPosition = 'CenterScreen'
    $form.FormBorderStyle = [FormBorderStyle]::FixedDialog
    $form.MaximizeBox = $false
    $form.MinimizeBox = $false
    $form.BackColor = [Color]::LightSteelBlue

    # Define Initialize button
    $buttonInitialize = New-Object System.Windows.Forms.Button
    $buttonInitialize.Text = "Refresh"
    $buttonInitialize.Location = New-Object System.Drawing.Point(12, 10)  # Starting point
    $buttonInitialize.Size = New-Object System.Drawing.Size(160, 40)  # Adjusted height (smaller)
    $buttonInitialize.Font = New-Object Font('Segoe UI', 10, [FontStyle]::Bold)
    $buttonInitialize.BackColor = [Color]::CadetBlue
    $buttonInitialize.ForeColor = [Color]::White
    $buttonInitialize.FlatStyle = 'Standard'
    $form.Controls.Add($buttonInitialize)

    # Define Remove button
    $buttonRemove = New-Object System.Windows.Forms.Button
    $buttonRemove.Text = "Remove"
    $buttonRemove.Location = New-Object System.Drawing.Point(180, 10)  # Adjusted X position to add space
    $buttonRemove.Size = New-Object System.Drawing.Size(160, 40)  # Adjusted height (smaller)
    $buttonRemove.Font = New-Object Font('Segoe UI', 10, [FontStyle]::Bold)
    $buttonRemove.BackColor = [Color]::CadetBlue
    $buttonRemove.ForeColor = [Color]::White
    $buttonRemove.FlatStyle = 'Standard'
    $form.Controls.Add($buttonRemove)

    # Define the DataGridView
    $dataGridView = New-Object System.Windows.Forms.DataGridView
    $dataGridView.Location = New-Object System.Drawing.Point(12, 55)  # Reduced gap between buttons and DataGridView
    $dataGridView.Size = New-Object System.Drawing.Size(1160, 550)  # Reduced height to fit within available space
    $dataGridView.AutoSizeColumnsMode = "Fill"
    $dataGridView.AllowUserToAddRows = $false
    $form.Controls.Add($dataGridView)

    # Add a label for the upper-left corner (adjusted to fit on one line)
    $statusLabel = New-Object System.Windows.Forms.Label
    $statusLabel.Text = "Loading License Data, Please Wait..."
    $statusLabel.Font = New-Object Font('Segoe UI', 10, [FontStyle]::Bold)
    $statusLabel.Location = New-Object System.Drawing.Point(800, 10)  # Moved left to fit text
    $statusLabel.Size = New-Object System.Drawing.Size(450, 30)  # Increased width to 250 for better fit
    $statusLabel.ForeColor = [Color]::DarkSlateGray
    $statusLabel.TextAlign = 'MiddleCenter'
    $form.Controls.Add($statusLabel)

    # Add only the essential columns
    $dataGridView.Columns.Clear()
    $dataGridView.Columns.Add("ID", "Id")
    $dataGridView.Columns.Add("Name", "Name")
    $dataGridView.Columns.Add("Description", "Description")
    $dataGridView.SelectionMode = [System.Windows.Forms.DataGridViewSelectionMode]::FullRowSelect
    $dataGridView.Font = New-Object System.Drawing.Font('Segoe UI', 10, [System.Drawing.FontStyle]::Regular)
    $dataGridView.DefaultCellStyle.Font = New-Object System.Drawing.Font('Segoe UI', 10, [System.Drawing.FontStyle]::Regular)
    # Adjust the row height based on font size
    $rowHeight = [System.Math]::Ceiling($dataGridView.Font.Height * 1.5)  # Factor of 1.5 to ensure enough space
    $dataGridView.RowTemplate.Height = $rowHeight
    $dataGridView.ColumnHeadersDefaultCellStyle.Font = New-Object System.Drawing.Font('Segoe UI', 12, [System.Drawing.FontStyle]::Regular)
    $dataGridView.ColumnHeadersHeight = 30  # Set a custom height for the header row

   # Initialize button click event
    $buttonInitialize.Add_Click({
        Manage-SLHandle -Release | Out-null
        $dataGridView.Rows.Clear()
        $WMI_QUERY = Get-SLIDList -eQueryIdType SL_ID_PRODUCT_SKU -eReturnIdType SL_ID_PRODUCT_SKU
        $WMI_SQL = $Global:PKeyDatabase | Where-Object { $WMI_QUERY -contains $_.ActConfigId } | Select-Object ActConfigId, EditionId, ProductDescription
        foreach ($entry in $WMI_SQL) {
            $dataGridView.Rows.Add($entry.ActConfigId, $entry.EditionId, $entry.ProductDescription)
        }
    })

    $buttonRemove.Add_Click({
        # Ensure we have selected rows
        if ($dataGridView.SelectedRows.Count -gt 0) {
            
            # Initialize an empty list
            $idList = @()

            # Loop through selected rows and add ID to $idList, casting as [Guid]
            $dataGridView.SelectedRows | % {
                [string]$id = $_.Cells["ID"].Value
                $idList += [GUID]($id.Substring(1,36))
            }

            Manage-SLHandle -Release | Out-null
            if ($idList.Count -gt 0) {
                SL-UninstallLicense -ProductSKUs $idList
            }
            $dataGridView.Rows.Clear()
            $WMI_QUERY = Get-SLIDList -eQueryIdType SL_ID_PRODUCT_SKU -eReturnIdType SL_ID_PRODUCT_SKU
            $WMI_SQL = $Global:PKeyDatabase | Where-Object { $WMI_QUERY -contains $_.ActConfigId } | Select-Object ActConfigId, EditionId, ProductDescription
            foreach ($entry in $WMI_SQL) {
                $dataGridView.Rows.Add($entry.ActConfigId, $entry.EditionId, $entry.ProductDescription)
            }
        }
    })

    # Show the form
    $form.ShowDialog()
}
Function WMI_Form {
    # Create the form with basic styling
    $form = New-Object System.Windows.Forms.Form
    $form.Text = "License Viewer"
    $form.Size = New-Object System.Drawing.Size(1200, 500)
    $form.StartPosition = "CenterScreen"
    $form.FormBorderStyle = [System.Windows.Forms.FormBorderStyle]::FixedDialog
    $form.MaximizeBox = $false
    $form.MinimizeBox = $false
    $form.BackColor = [System.Drawing.Color]::LightSteelBlue
    $font = New-Object System.Drawing.Font('Segoe UI', 10)

    # Add Refresh button (with logic to load data into ComboBox)
    $buttonRefresh = New-Object System.Windows.Forms.Button
    $buttonRefresh.Text = "Refresh"
    $buttonRefresh.Location = New-Object System.Drawing.Point(12, 10)
    $buttonRefresh.Size = New-Object System.Drawing.Size(160, 40)
    $buttonRefresh.Font = New-Object System.Drawing.Font('Segoe UI', 10, [System.Drawing.FontStyle]::Bold)
    $buttonRefresh.BackColor = [System.Drawing.Color]::CadetBlue
    $buttonRefresh.ForeColor = [System.Drawing.Color]::White
    $buttonRefresh.FlatStyle = 'Standard'
    $form.Controls.Add($buttonRefresh)

    # Add Refresh button (with logic to load data into ComboBox)
    $buttonInitilize = New-Object System.Windows.Forms.Button
    $buttonInitilize.Text = "Initilize"
    $buttonInitilize.Location = New-Object System.Drawing.Point(180, 10)
    $buttonInitilize.Size = New-Object System.Drawing.Size(160, 40)
    $buttonInitilize.Font = New-Object System.Drawing.Font('Segoe UI', 10, [System.Drawing.FontStyle]::Bold)
    $buttonInitilize.BackColor = [System.Drawing.Color]::CadetBlue
    $buttonInitilize.ForeColor = [System.Drawing.Color]::White
    $buttonInitilize.FlatStyle = 'Standard'
    $form.Controls.Add($buttonInitilize)

    # Add ComboBox for product selection (empty initially)
    $comboProducts = New-Object System.Windows.Forms.ComboBox
    $comboProducts.Location = New-Object System.Drawing.Point(360, 15)
    $comboProducts.Size = New-Object System.Drawing.Size(810, 30)
    $comboProducts.Font = $font
    $comboProducts.DropDownStyle = [System.Windows.Forms.ComboBoxStyle]::DropDownList
    $form.Controls.Add($comboProducts)

    $dataGridView = New-Object System.Windows.Forms.DataGridView
    $dataGridView.Location = New-Object System.Drawing.Point(12, 60)
    $dataGridView.Size = New-Object System.Drawing.Size(1160, 390)
    $dataGridView.AutoSizeColumnsMode = [System.Windows.Forms.DataGridViewAutoSizeColumnsMode]::Fill
    $dataGridView.AllowUserToAddRows = $false
    $dataGridView.AllowUserToDeleteRows = $false
    $dataGridView.ReadOnly = $true

    # === Lines to make text bigger for both cells and headers ===
    $newGeneralFont = New-Object System.Drawing.Font("Microsoft Sans Serif", 10) # Base font size for cells
    $dataGridView.Font = $newGeneralFont

    # === Line to specifically make header text bigger and potentially bold ===
    $newHeaderFont = New-Object System.Drawing.Font("Microsoft Sans Serif", 11, [System.Drawing.FontStyle]::Bold) # Adjust '12' for header size, and added Bold style
    $dataGridView.ColumnHeadersDefaultCellStyle.Font = $newHeaderFont

    # === Line to make the header row taller ===
    $dataGridView.ColumnHeadersHeight = 40 # Adjust this value (e.g., 30, 50, etc.) to your desired height

    # If you also want to prevent users from resizing the header height:
    $dataGridView.AllowUserToResizeColumns = $false # To prevent horizontal resizing by user
    $dataGridView.ColumnHeadersHeightSizeMode = [System.Windows.Forms.DataGridViewColumnHeadersHeightSizeMode]::DisableResizing # To prevent vertical resizing of headers by user

    # === Line to make the data rows taller ===
    $dataGridView.RowTemplate.Height = 30 # Adjust this value (e.g., 25, 35, etc.) to your desired height for data rows

    # === THESE ARE THE LINES THAT DEFINE THE COLUMNS ===
    $dataGridView.ColumnCount = 2 # Tell the DataGridView it will have 2 columns

    $dataGridView.Columns[0].Name = "Property"
    $dataGridView.Columns[0].HeaderText = "Name" # This text will appear in the header
    $dataGridView.Columns[0].Width = 260 # Give it a fixed width

    $dataGridView.Columns[1].Name = "Value"
    $dataGridView.Columns[1].HeaderText = "Value" # This text will appear in the header

    $form.Controls.Add($dataGridView) # Add the DataGridView to the form

    # Global variable to hold licensing products
    $global:LicensingProducts = @()

    # Function to load licensing data from Get-SLIDList
    function Load-LicenseData {
        $form.Refresh()

        # Example call to Get-SLIDList and retrieve product details
        $global:LicensingProducts = Get-SLIDList -eQueryIdType SL_ID_PRODUCT_SKU -eReturnIdType SL_ID_PRODUCT_SKU |
        ForEach-Object {
            [PSCustomObject]@{
                SKU_ID    = $_
                Name      = $Global:PKeyDatabase | ? ActConfigId  -eq "{$_}" | select -ExpandProperty ProductDescription
            }
        }

        # Clear the ComboBox and populate with new items
        $comboProducts.Items.Clear()
        foreach ($product in $global:LicensingProducts) {
            $comboProducts.Items.Add(
                "$($product.SKU_ID) - $($product.Name)")
        }

        if ($comboProducts.Items.Count -gt 0) {
            $comboProducts.SelectedIndex = 0
        }
    }
    # Function to update DataGrid based on ComboBox selection change
    function Test-ValidString([string]$str) {
        return -not(
            ([string]::IsNullOrWhiteSpace($str)) -or 
                ($str -and $str.Length -le 1)
            )
    }
    function Update-DataGrid {
        param (
            [Parameter(Mandatory=$true)]
            [string] $selectedSKU
        )

        if ([string]::IsNullOrWhiteSpace($selectedSKU)) {
            # Clear DataGrid if no SKU selected (using the correct variable name)
            $dataGridView.Rows.Clear()
            return
        }

        try { 
            $licenseInfo = Get-LicenseInfo -ActConfigId $selectedSKU
            $dataGridView.Rows.Clear()
            $dataGridView.ReadOnly = $false
            $iid = $licenseInfo.OfflineInstallationId
            if ($iid) {
                $iid = ($licenseInfo.OfflineInstallationId -replace '(.{7})', '$1-').TrimEnd('-')
            }

            $fields = @{
                'Installation Id'                 = $iid
                'ActConfigId'                     = $licenseInfo.ActConfigId
                'RefGroupId'                      = $licenseInfo.RefGroupId
                'EditionId'                       = $licenseInfo.EditionId
                'ProductKeyType'                  = $licenseInfo.ProductKeyType
                'IsRandomized'                    = $licenseInfo.IsRandomized
                'Description'                     = $licenseInfo.Description
                'Name'                            = $licenseInfo.Name
                'Author'                          = $licenseInfo.Author
                'License Type'                    = $licenseInfo.licenseType
                'License Version'                 = $licenseInfo.licenseVersion
                'Licensor URL'                    = $licenseInfo.licensorUrl
                'License Category'                = $licenseInfo.licenseCategory
                'Product SKU ID'                  = $licenseInfo.ID
                'Private Certificate ID'          = $licenseInfo.privateCertificateId
                'Application ID'                  = $licenseInfo.applicationId
                'Product Name'                    = $licenseInfo.productName
                'Family'                          = $licenseInfo.Family
                'Product Author'                  = $licenseInfo.productAuthor
                'Product Description'             = $licenseInfo.productDescription
                'HWID OOT Grace'                  = $licenseInfo.hwidootGrace
                'Trusted Time'                    = $licenseInfo.TrustedTime
                'License Is Addon'                = $licenseInfo.LicenseIsAddon
                'Product Uniqueness Group ID'     = $licenseInfo.ProductUniquenessGroupId
                'Issuance Certificate ID'         = $licenseInfo.issuanceCertificateId
                'PKey Config License ID'          = $licenseInfo.pkeyConfigLicenseId
                'Val URL'                         = $licenseInfo.ValidationURL
                'Build Version'                   = $licenseInfo.BuildVersion
                'Activation Sequence'             = $licenseInfo.ActivationSequence
                'Enable Activation Validation'    = $licenseInfo.EnableActivationValidation
                'Validity Timer Uniqueness'       = $licenseInfo.ValidityTimerUniqueness
                'Application Bitmap'              = $licenseInfo.ApplicationBitmap
                'PA URL'                          = $licenseInfo.UseLicenseURL
                'Windows Sku Category'            = $licenseInfo.UXDifferentiator
                'Product Key Group Uniqueness'    = $licenseInfo.ProductKeyGroupUniqueness
                'Migratable'                      = $licenseInfo.migratable
                'License Depends On'              = $licenseInfo.LicenseDependsOn
                'Enable Notification Mode'        = $licenseInfo.EnableNotificationMode
                'Grace Timer Uniqueness'          = $licenseInfo.GraceTimerUniqueness
                'VL Activation Interval'          = $licenseInfo.VLActivationInterval
                'Validation Template ID'          = $licenseInfo.ValidationTemplateId
                'Token Activation Grant Number'   = $licenseInfo.TokenActivationGrantNumber
                'Licensor Key Index'              = $licenseInfo.licensorKeyIndex
                'Token Activation ILV ID'         = $licenseInfo.TokenActivationILVID
                'Key Management Service Port'     = $licenseInfo.KeyManagementServicePort
                'Product Key Channel'             = $licenseInfo.ProductKeyChannel
                'Digital PID'                     = $licenseInfo.ProductKeyID
                'Digital PID 2'                   = $licenseInfo.ProductKeyID2
                'Partial Product Key'             = $licenseInfo.PartialProductKey
            }

            # Enumerate the hashtable and add valid items to the DataGrid
            $fields.GetEnumerator() | ForEach-Object {
                if (Test-ValidString($_.Value)) {
                    $dataGridView.Rows.Add($_.Key, $_.Value.ToString())
                }
            }
            
            # Add a check to display a message if no data was added (e.g., $licenseInfo was empty)
            if ($dataGridView.Rows.Count -eq 0) {
                $dataGridView.Rows.Add("No details available", "for selected SKU.")
            }
        }
        catch {
            # Provide user feedback on the UI
            $dataGridView.Rows.Clear() # Clear any existing data
            $dataGridView.Rows.Add("Error loading data", $_.Exception.Message)
            [System.Windows.Forms.MessageBox]::Show("Error updating DataGrid: $($_.Exception.Message)", "Data Update Error", [System.Windows.Forms.MessageBoxButtons]::OK, [System.Windows.Forms.MessageBoxIcon]::Error)
        }
    }

    # Event handler for the Refresh button
    $buttonRefresh.Add_Click({
        Load-LicenseData
    })

    $comboProducts.Add_SelectedIndexChanged({
        $selectedGuid = [GUID]::Empty
        try {
            [GUID]::TryParse(
                ($comboProducts.SelectedItem).Substring(0,36),
                [ref]$selectedGuid)
        }
        catch {
        }
        if ($selectedGuid -eq [GUID]::Empty) {
            Write-Warning "Fail to get GUID, $comboProducts.SelectedItem"
            return
        }
        Update-DataGrid -selectedSKU $selectedGuid
    })

    $buttonInitilize.Add_Click({
        try {
            $selected = ($comboProducts.SelectedItem).Substring(0,36)
            Update-DataGrid -selectedSKU $selected
        }
        catch {
        }
    })

    # load Data
    Load-LicenseData

    # Show the form modally
    [void]$form.ShowDialog()
}
Function About_Form {
    # Create the form with styling from SL_Remove_License_Form
    $form = New-Object System.Windows.Forms.Form
    $form.Text = "License Viewer"
    $form.Size = New-Object System.Drawing.Size(1200, 530)
    $form.StartPosition = "CenterScreen"
    $form.FormBorderStyle = [System.Windows.Forms.FormBorderStyle]::FixedDialog
    $form.MaximizeBox = $false
    $form.MinimizeBox = $false
    $form.BackColor = [System.Drawing.Color]::LightSteelBlue
    $font = New-Object System.Drawing.Font('Segoe UI', 10)

    # Add Refresh button (styling from SL_Remove_License_Form)
    $buttonRefresh = New-Object System.Windows.Forms.Button
    $buttonRefresh.Text = "Refresh"
    $buttonRefresh.Location = New-Object System.Drawing.Point(12, 10)
    $buttonRefresh.Size = New-Object System.Drawing.Size(160, 40)
    $buttonRefresh.Font = New-Object System.Drawing.Font('Segoe UI', 10, [System.Drawing.FontStyle]::Bold)
    $buttonRefresh.BackColor = [System.Drawing.Color]::CadetBlue
    $buttonRefresh.ForeColor = [System.Drawing.Color]::White
    $buttonRefresh.FlatStyle = 'Standard'
    $form.Controls.Add($buttonRefresh)

    # Add ComboBox for product selection
    $comboProducts = New-Object System.Windows.Forms.ComboBox
    $comboProducts.Location = New-Object System.Drawing.Point(180, 15)
    $comboProducts.Size = New-Object System.Drawing.Size(990, 30)
    $comboProducts.Font = $font
    $comboProducts.DropDownStyle = [System.Windows.Forms.ComboBoxStyle]::DropDownList
    $form.Controls.Add($comboProducts)

    # Tab Control (fill form client area below buttons)
    $tabs = New-Object System.Windows.Forms.TabControl
    $tabs.Location = New-Object System.Drawing.Point(12, 60)
    $tabs.Size = New-Object System.Drawing.Size(1160, 420)
    $form.Controls.Add($tabs)

    # Create tabs
    $tabNames = @("Config Info", "Product Key Info", "License Info", "Genuine Info", "Application Info")
    $tabPages = @{}
    foreach ($name in $tabNames) {
        $tab = New-Object System.Windows.Forms.TabPage
        $tab.Text = $name
        $tabs.TabPages.Add($tab)
        $tabPages[$name] = $tab
    }

    # Helper function to add hashtable fields to tab page
    function Add-HashTableFieldsToTab {
        param (
            [hashtable]$hash,
            [System.Windows.Forms.TabPage]$tabPage
        )
        $y = 20
        foreach ($key in $hash.Keys) {
            if ($key -eq 'Keys') { continue }
            $label = New-Object System.Windows.Forms.Label
            $label.Text = "$($key):"
            $label.Location = New-Object System.Drawing.Point(20, $y)
            $label.Size = New-Object System.Drawing.Size(350, 20)
            $label.Font = $font

            $text = New-Object System.Windows.Forms.TextBox
            $text.ReadOnly = $true
            $text.Text = $hash[$key]
            $text.Location = New-Object System.Drawing.Point(370, $y)
            $text.Size = New-Object System.Drawing.Size(750, 20)
            $text.Font = $font

            $tabPage.Controls.AddRange(@($label, $text))
            $y += 30
        }
    }

    # Global variable to hold licensing products
    $global:LicensingProducts = @()

    function Get-LicensingProductsByAppId() {
        Manage-SLHandle -release | Out-Null
        Get-SLIDList -eQueryIdType SL_ID_PRODUCT_SKU -eReturnIdType SL_ID_PRODUCT_SKU |
        Where-Object { Retrieve-SKUInfo -SkuId $_ -eReturnIdType SL_ID_PKEY } |
        ForEach-Object {
            [PSCustomObject]@{
                SKU_ID    = $_
                PKEY_ID   = Retrieve-SKUInfo -SkuId $_ -eReturnIdType SL_ID_PKEY
                APP_ID    = Retrieve-SKUInfo -SkuId $_ -eReturnIdType SL_ID_APPLICATION
                Name      = $Global:PKeyDatabase | ? ActConfigId  -eq "{$_}" | select -ExpandProperty ProductDescription
            }
        }
    }

    # Load license data and populate product ComboBox
    function Load-LicenseData {
        $form.Refresh()
        Manage-SLHandle -Release | Out-null
        $global:LicensingProducts = Get-LicensingProductsByAppId

        # Fill ComboBox with product names and descriptions
        $comboProducts.Items.Clear()
        foreach ($p in $global:LicensingProducts) {
            if ($p.SKU_ID) {
                $comboProducts.Items.Add(
                    "$($p.SKU_ID) - $($p.Name)")
            }
        }

        if ($comboProducts.Items.Count -gt 0) {
            $comboProducts.SelectedIndex = 0
        }
    }

    # Load selected product details into tabs
    function Load-SelectedProductData {
        if ($comboProducts.SelectedIndex -lt 0) {
            return }

        try {
            $sku = $comboProducts.SelectedItem.Substring(0,36)
            $selectedProduct = $global:LicensingProducts | ? SKU_ID -Match $sku
        }
        catch {
            return
        }
        Manage-SLHandle -Release | Out-null
        $Status  = Get-SLLicensingStatus -ApplicationID $selectedProduct.APP_ID -SkuID $selectedProduct.SKU_ID
        $keyInfo = Get-SLCPKeyInfo -PKEY $selectedProduct.PKEY_ID -loopAllValues
        $genuine = Get-GenuineInformation -QueryId $selectedProduct.SKU_ID -loopAllValues
        $appInfo = Get-ApplicationInformation -ApplicationId $selectedProduct.APP_ID -loopAllValues
        $config  = $Global:PKeyDatabase | ? ActConfigId -EQ "{$($selectedProduct.SKU_ID)}"
        Manage-SLHandle -Release | Out-null

        # Clear previous controls from tabs
        foreach ($tab in $tabPages.Values) {
            $tab.Controls.Clear()
        }

        # License Info tab explicit fields
        $configFields = @(
            "ActConfigId", "RefGroupId", "EditionId",
            "ProductDescription", "ProductKeyType",
            "IsRandomized"
        )
        $y = 20
        foreach ($field in $configFields) {
            $label = New-Object System.Windows.Forms.Label
            $label.Text = "$($field):"
            $label.Location = New-Object System.Drawing.Point(20, $y)
            $label.Size = New-Object System.Drawing.Size(350, 20)
            $label.Font = $font

            $text = New-Object System.Windows.Forms.TextBox
            $text.ReadOnly = $true
            $text.Text = $config.$field
            $text.Location = New-Object System.Drawing.Point(370, $y)
            $text.Size = New-Object System.Drawing.Size(750, 20)
            $text.Font = $font

            $tabPages["Config Info"].Controls.AddRange(@($label, $text))
            $y += 30
        }

        # License Info tab explicit fields
        $licenseFields = @(
            "LicenseStatus","ID","GracePeriodRemaining","TotalGraceDays",
            "EvaluationEndDate","LicenseStatusReason","LicenseChannel",
            "LicenseTier","ApiCallHResult","ErrorMessage"
        )
        $y = 20
        foreach ($field in $licenseFields) {
            $label = New-Object System.Windows.Forms.Label
            $label.Text = "$($field):"
            $label.Location = New-Object System.Drawing.Point(20, $y)
            $label.Size = New-Object System.Drawing.Size(350, 20)
            $label.Font = $font

            $text = New-Object System.Windows.Forms.TextBox
            $text.ReadOnly = $true
            $text.Text = $Status.$field
            $text.Location = New-Object System.Drawing.Point(370, $y)
            $text.Size = New-Object System.Drawing.Size(750, 20)
            $text.Font = $font

            $tabPages["License Info"].Controls.AddRange(@($label, $text))
            $y += 30
        }

        Add-HashTableFieldsToTab -hash $keyInfo -tabPage $tabPages["Product Key Info"]
        Add-HashTableFieldsToTab -hash $genuine -tabPage $tabPages["Genuine Info"]
        Add-HashTableFieldsToTab -hash $appInfo -tabPage $tabPages["Application Info"]
    }

    # Event handlers
    $buttonRefresh.Add_Click({
        Load-LicenseData
    })

    $comboProducts.Add_SelectedIndexChanged({
        Load-SelectedProductData
    })

    # Initial load
    Load-LicenseData
    if ($comboProducts.Items.Count -gt 0) {
        Load-SelectedProductData
    }

    # Show the form modally
    [void]$form.ShowDialog()
}
function Main-Form {
    $form = New-Object Form
    $form.Text = 'Select Location or Add File'
    $form.Size = New-Object Size(1190, 600)
    $form.StartPosition = 'CenterScreen'
    $form.FormBorderStyle = [FormBorderStyle]::None
    $form.BackColor = [Color]::LightSteelBlue

    $radius = 20
    $region = Create-RoundedRectangleRegion $form.ClientRectangle $radius
    $form.Region = New-Object Region($region)

    $fileDialog = New-Object OpenFileDialog
    $fileDialog.Filter = "xrm-ms files (*.xrm-ms)|*.xrm-ms"
    $fileDialog.Title = "Select a .xrm-ms file"

    $addFileButton = New-Object Button
    $addFileButton.Text = 'Add Files'
    $addFileButton.Location = New-Object Point(20, 20)
    $addFileButton.Size = New-Object Size(110, 35)
    $addFileButton.Font = New-Object Font('Segoe UI', 10, [FontStyle]::Bold)
    $addFileButton.BackColor = [Color]::CadetBlue
    $addFileButton.ForeColor = [Color]::White
    $addFileButton.FlatStyle = 'Flat'

    $selectButton = New-Object Button
    $selectButton.Text = 'Select Files'
    $selectButton.Location = New-Object Point(140, 20)
    $selectButton.Size = New-Object Size(110, 35)
    $selectButton.Font = New-Object Font('Segoe UI', 10, [FontStyle]::Bold)
    $selectButton.BackColor = [Color]::CadetBlue
    $selectButton.ForeColor = [Color]::White
    $selectButton.FlatStyle = 'Flat'

    # Encode Button
    $encodeKeyButton = New-Object Button
    $encodeKeyButton.Text = 'Encode'
    $encodeKeyButton.Location = New-Object Point(260, 20)
    $encodeKeyButton.Size = New-Object Size(100, 35)
    $encodeKeyButton.Font = New-Object Font('Segoe UI', 10, [FontStyle]::Bold)
    $encodeKeyButton.BackColor = [Color]::CadetBlue
    $encodeKeyButton.ForeColor = [Color]::White
    $encodeKeyButton.FlatStyle = 'Flat'

    # Decode Button
    $decodeKeyButton = New-Object Button
    $decodeKeyButton.Text = 'Decode'
    $decodeKeyButton.Location = New-Object Point(370, 20)
    $decodeKeyButton.Size = New-Object Size(100, 35)
    $decodeKeyButton.Font = New-Object Font('Segoe UI', 10, [FontStyle]::Bold)
    $decodeKeyButton.BackColor = [Color]::CadetBlue
    $decodeKeyButton.ForeColor = [Color]::White
    $decodeKeyButton.FlatStyle = 'Flat'

    # Extract Button
    $ExtracKeyButton = New-Object Button
    $ExtracKeyButton.Text = 'Extract'
    $ExtracKeyButton.Location = New-Object Point(480, 20)
    $ExtracKeyButton.Size = New-Object Size(100, 35)
    $ExtracKeyButton.Font = New-Object Font('Segoe UI', 10, [FontStyle]::Bold)
    $ExtracKeyButton.BackColor = [Color]::CadetBlue
    $ExtracKeyButton.ForeColor = [Color]::White
    $ExtracKeyButton.FlatStyle = 'Flat'

    $ActivateButton = New-Object Button
    $ActivateButton.Text = 'Activate / Upgrade'
    $ActivateButton.Location = New-Object Point(590, 20)
    $ActivateButton.Size = New-Object Size(165, 35)
    $ActivateButton.Font = New-Object Font('Segoe UI', 10, [FontStyle]::Bold)
    $ActivateButton.BackColor = [Color]::CadetBlue
    $ActivateButton.ForeColor = [Color]::White
    $ActivateButton.FlatStyle = 'Flat'

    $AddLIcenseBtn = New-Object Button
    $AddLIcenseBtn.Text = 'Add License'
    $AddLIcenseBtn.Location = New-Object Point(765, 20)
    $AddLIcenseBtn.Size = New-Object Size(110, 35)
    $AddLIcenseBtn.Font = New-Object Font('Segoe UI', 10, [FontStyle]::Bold)
    $AddLIcenseBtn.BackColor = [Color]::CadetBlue
    $AddLIcenseBtn.ForeColor = [Color]::White
    $AddLIcenseBtn.FlatStyle = 'Flat'

    $RemoveLIcenseBtn = New-Object Button
    $RemoveLIcenseBtn.Text = 'Remove License'
    $RemoveLIcenseBtn.Location = New-Object Point(885, 20)
    $RemoveLIcenseBtn.Size = New-Object Size(140, 35)
    $RemoveLIcenseBtn.Font = New-Object Font('Segoe UI', 10, [FontStyle]::Bold)
    $RemoveLIcenseBtn.BackColor = [Color]::CadetBlue
    $RemoveLIcenseBtn.ForeColor = [Color]::White
    $RemoveLIcenseBtn.FlatStyle = 'Flat'

    $ValidateLIcenseBtn = New-Object Button
    $ValidateLIcenseBtn.Text = 'Validate Keys'
    $ValidateLIcenseBtn.Location = New-Object Point(1035, 20)
    $ValidateLIcenseBtn.Size = New-Object Size(115, 35)
    $ValidateLIcenseBtn.Font = New-Object Font('Segoe UI', 10, [FontStyle]::Bold)
    $ValidateLIcenseBtn.BackColor = [Color]::CadetBlue
    $ValidateLIcenseBtn.ForeColor = [Color]::White
    $ValidateLIcenseBtn.FlatStyle = 'Flat'

    # Create RichTextBox for status display
    $statusBox = New-Object Windows.Forms.RichTextBox
    $statusBox.ReadOnly = $true
    $statusBox.Font = New-Object Drawing.Font('Segoe UI', 10)
    $statusBox.Location = New-Object Drawing.Point(20, 500)
    $statusBox.Size = New-Object Drawing.Size(760, 40) 
    $statusBox.BackColor = [System.Drawing.Color]::White
    $statusBox.BorderStyle = 'FixedSingle'

    # Set the text in the statusBox
    #$statusBox.Text = "Ready."  # Initial text
    $ProductDescription = $null
    try {
        # Will fail on TSFORGE & MAK License's only.
        # Will work even if all license are removed from local computer
		$DigitalKey = Parse-DigitalProductId4 | select -ExpandProperty DigitalKey
		$RefGroupId = Retrieve-ProductKeyInfo -CdKey $DigitalKey | Select -ExpandProperty RefGroupId
		$ProductDescription = $Global:PKeyDatabase | ? RefGroupId -EQ $RefGroupId | Select -ExpandProperty ProductDescription
	}
	catch { }
    if (-not $ProductDescription) {
	    try {
            # Interface check, will work most time, even on Country specific
            $SkuId = Get-LicensingInfo | select -ExpandProperty SkuId

            # Kernel Policies check, will fail when use choice Country specific
            if (-not $skuId) {
                $skuId = ($((Get-ProductPolicy -Filter 'Security-SPP-Action-StateData' -UseApi).Value -split ';' | Where-Object { $_ -match 'SkuId' }) -split '=')[1]
            }
            # fail safe, find Any skuId, with SL_ID_PKEY guid, and not ESU
            # will fail only if user removed all licenses from local computer
            if (-not $skuId) {
                Manage-SLHandle -Release | Out-null
                $skuId = Get-SLIDList -eQueryIdType SL_ID_APPLICATION -eReturnIdType SL_ID_PRODUCT_SKU -pQueryId $windowsAppID | ? { Retrieve-SKUInfo -SkuId $_ -eReturnIdType SL_ID_PKEY } | ? {
                    (Get-LicenseDetails -ActConfigId $_ -pwszValueName 'Description') -notmatch 'ESU'} | select -First 1 -ExpandProperty Guid
            }
            if ($skuId) {
                $ProductDescription = $Global:PKeyDatabase | ? ActConfigId -EQ "{$skuId}" | select -ExpandProperty ProductDescription
            }
        }
        catch { }
    }
    if (-not $ProductDescription) {
        try {
            # last resort, Using Edition Type + License Type,
            # And, find best match, usually work.
            $EditionType = Parse-DigitalProductId4 | select -ExpandProperty EditionType
            $KeyType = Parse-DigitalProductId4 | select -ExpandProperty KeyType
            $ProductDescription = $Global:PKeyDatabase | ? EditionId -eq $EditionType | ? ProductDescription -match $KeyType | Select -First 1 -ExpandProperty ProductDescription
        }
        catch { }
    }
    $OperatingSystem = Get-WmiObject Win32_OperatingSystem
    $Global:arch = $OperatingSystem.OSArchitecture
    $Global:edition = Get-ProductID
    $Global:memory = [math]::round((Get-WmiObject Win32_ComputerSystem).TotalPhysicalMemory / 1GB, 2)
    $Global:version = "$($Global:osVersion.Version -join '.').$($Global:osVersion.UBR)"  
    $statusBox.Text = "System Info: $ProductDescription ($Global:arch) | $($Global:version) | $([math]::Round($Global:memory)) GB"

    # Create Status Info button (fixed position near statusBox)
    $AboutButton = New-Object Windows.Forms.Button
    $AboutButton.Text = 'Status Info'
    $AboutButton.Location = New-Object Point(790, 500)  # Fixed position near statusBox
    $AboutButton.Size = New-Object Size(110, 40)  # Button size (120px wide)
    $AboutButton.Font = New-Object Font('Segoe UI', 10, [FontStyle]::Bold)
    $AboutButton.BackColor = [Color]::SlateGray
    $AboutButton.ForeColor = [Color]::White
    $AboutButton.FlatStyle = 'Flat'

    # Create Wmi Info button (fixed position near Status button, calculated to fit before Close button)
    $WmiButton = New-Object Windows.Forms.Button
    $WmiButton.Text = 'Wmi Info'
    $WmiButton.Location = New-Object Point(910, 500)  # Position adjusted to fit space before Close button
    $WmiButton.Size = New-Object Size(110, 40)  # Wmi button size (120px wide, same as Status button)
    $WmiButton.Font = New-Object Font('Segoe UI', 10, [FontStyle]::Bold)
    $WmiButton.BackColor = [Color]::SlateGray
    $WmiButton.ForeColor = [Color]::White
    $WmiButton.FlatStyle = 'Flat'

    # Create Close button (wider and repositioned)
    $closeButton = New-Object Windows.Forms.Button
    $closeButton.Text = 'Close'
    $closeButton.Location = New-Object Point(1030, 500)  # Adjusted to the right of the status box
    $closeButton.Size = New-Object Size(120, 40)  # Button wider
    $closeButton.Font = New-Object Font('Segoe UI', 10, [FontStyle]::Bold)
    $closeButton.BackColor = [Color]::SlateGray
    $closeButton.ForeColor = [Color]::White
    $closeButton.FlatStyle = 'Flat'

    # Create and configure DataGridView
    $dataGridView = New-Object DataGridView
    $dataGridView.Location = New-Object Point(20, 70)
    $dataGridView.Size = New-Object Size(1130, 420)
    $dataGridView.AutoSizeColumnsMode = 'Fill'
    $dataGridView.ColumnCount = 1
    $dataGridView.Columns[0].Name = 'Locations'
    $dataGridView.RowTemplate.Height = 35
    $dataGridView.ColumnHeadersHeight = 45
    $dataGridView.SelectionMode = 'FullRowSelect'  # Keep this for full row selection
    $dataGridView.MultiSelect = $true  # Allow multiple selections
    $dataGridView.AllowUserToAddRows = $false
    $dataGridView.AllowUserToDeleteRows = $false
    $dataGridView.BorderStyle = [BorderStyle]::None
    $dataGridView.BackgroundColor = [Color]::LightGray
    $dataGridView.CellBorderStyle = 'Single'
    $dataGridView.DefaultCellStyle.BackColor = [Color]::Gainsboro
    $dataGridView.DefaultCellStyle.ForeColor = [Color]::Black
    $dataGridView.DefaultCellStyle.SelectionBackColor = [Color]::LightSlateGray
    $dataGridView.DefaultCellStyle.SelectionForeColor = [Color]::White
    $dataGridView.ColumnHeadersDefaultCellStyle.BackColor = [Color]::CadetBlue
    $dataGridView.ColumnHeadersDefaultCellStyle.ForeColor = [Color]::White
    $dataGridView.ColumnHeadersDefaultCellStyle.Font = New-Object Font('Segoe UI', 11, [FontStyle]::Bold)

    foreach ($location in $predefinedLocations) {
        $dataGridView.Rows.Add($location)
    }

    # Handle Enter key press on the form
    $form.KeyPreview = $true

    $closeButton.Add_Click({
        $form.Close()
    })
    $AddLIcenseBtn.Add_Click({
        SL_Add_License_Form
    })
    $RemoveLIcenseBtn.Add_Click({
        SL_Remove_License_Form
    })
    $ValidateLIcenseBtn.Add_Click({
        ValidateForm
    })
    $AboutButton.Add_Click({
        About_Form
    })
    $WmiButton.Add_Click({
        WMI_Form
    })
    $form.Add_KeyDown({
        if ($_.KeyCode -eq [Keys]::Enter) {
            $selectedRows = $dataGridView.SelectedRows  # Get all selected rows
            if ($selectedRows.Count -gt 0) {
                $selectedFiles = @()  # Initialize an array to hold file paths

                foreach ($row in $selectedRows) {
                    $filePath = $row.Cells[0].Value
                    if ($filePath -and [IO.FILE]::Exists($filePath)) {
                        $selectedFiles += $filePath  # Add to the array if the file exists
                    }
                }

                if ($selectedFiles.Count -gt 0) {
                    foreach ($last in $selectedFiles) {
                        # Call GenerateConfigList for each selected file
                        GenerateConfigList -pkeyconfig $last | Out-HtmlView
                    }
                } else {
                    [MessageBox]::Show("No valid files selected.", "Warning", [MessageBoxButtons]::OK, [MessageBoxIcon]::Warning)
                }
            }
        }
    })
    $dataGridView.Add_CellDoubleClick({
        $selectedRow = $dataGridView.CurrentRow
        if ($selectedRow -ne $null) {
            $selectedFile = $selectedRow.Cells[0].Value -split '`n'
            $last = $selectedFile[$selectedFile.Length-1]
            if ($last -and [IO.FILE]::Exists($last)) {
               GenerateConfigList -pkeyconfig $last | Out-HtmlView }
        }
    })
    $addFileButton.Add_Click({
        # Set up the FileDialog for multiple selection with filter for .xrm-ms files
        $fileDialog = New-Object OpenFileDialog
        $fileDialog.Title = 'Select Files'
        $fileDialog.Multiselect = $true  # Enable multiple file selection
        $fileDialog.Filter = 'XRM Files (*.xrm-ms)|*.xrm-ms'  # Restrict to .xrm-ms files

        if ($fileDialog.ShowDialog() -eq 'OK') {
            foreach ($filePath in $fileDialog.FileNames) {
                $dataGridView.Rows.Add($filePath)  # Add each selected file path to the DataGridView
            }
        }
    })
    $selectButton.Add_Click({
        $selectedRows = $dataGridView.SelectedRows  # Get all selected rows
        if ($selectedRows.Count -gt 0) {
            $selectedFiles = @()  # Initialize an array to hold file paths

            foreach ($row in $selectedRows) {
                $filePath = $row.Cells[0].Value
                if ($filePath -and [IO.FILE]::Exists($filePath)) {
                    $selectedFiles += $filePath  # Add to the array if the file exists
                }
            }

            if ($selectedFiles.Count -gt 0) {
                # Loop through each valid selected file
                foreach ($last in $selectedFiles) {
                    # Call GenerateConfigList for each selected file
                    $result = GenerateConfigList -pkeyconfig $last
                    $result | Out-HtmlView  # Output results for the current file

                    # Optionally pause for user input before continuing to the next file
                    #[MessageBox]::Show("Results displayed for: $last", "Information", [MessageBoxButtons]::OK)
                }
            } else {
                #[MessageBox]::Show("No valid files selected.", "Warning", [MessageBoxButtons]::OK, [MessageBoxIcon]::Warning)
            }
        } else {
            #[MessageBox]::Show('Please select a location from the list.', 'Selection Required', [MessageBoxButtons]::OK, [MessageBoxIcon]::Warning)
        }
    })
    $encodeKeyButton.Add_Click({
        EncodeForm
    })
    $decodeKeyButton.Add_Click({
        DecodeForm
    })
    $ExtracKeyButton.Add_Click({
        ExtractForm
    })
    $ActivateButton.Add_Click({
        GetWmiProductsForm
    })

    # Add controls to the form
    $form.Controls.Add($addFileButton)
    $form.Controls.Add($selectButton)
    $form.Controls.Add($encodeKeyButton)
    $form.Controls.Add($decodeKeyButton)
    $form.Controls.Add($ExtracKeyButton)
    $form.Controls.Add($ActivateButton)
    $form.Controls.Add($AddLIcenseBtn)
    $form.Controls.Add($RemoveLIcenseBtn)
    $form.Controls.Add($ValidateLIcenseBtn)
    $form.Controls.Add($closeButton)
    $form.Controls.Add($AboutButton)
    $form.Controls.Add($dataGridView)
    $form.Controls.Add($statusBox)
    $form.Controls.Add($statusLabel)
    $form.Controls.Add($WmiButton)

    # Add mouse event handlers to make the form movable
    $form.Add_MouseDown({
        $form.Tag = @{
            MouseDown = $true
            StartX = $args.X
            StartY = $args.Y
        }
    })
    $form.Add_MouseMove({
        if ($form.Tag -and $form.Tag.MouseDown) {
            $start = $form.Tag
            $newX = $form.Left + ($args.X - $start.StartX)
            $newY = $form.Top + ($args.Y - $start.StartY)
            $form.Location = New-Object Point($newX, $newY)
        }
    })
    $form.Add_MouseUp({
        if ($form.Tag) {
            $form.Tag.MouseDown = $false
        }
    })

    # Initial values
    $Global:previousEdition = $null

    # Timer to check every 5 seconds
    $timer = New-Object System.Windows.Forms.Timer
    $timer.Interval = 10000
    $timer.Add_Tick({
        $ProductDescription = $null
        try {
            # Will fail on TSFORGE & MAK License's only.
            # Will work even if all license are removed from local computer
		    $DigitalKey = Parse-DigitalProductId4 | select -ExpandProperty DigitalKey
		    $RefGroupId = Retrieve-ProductKeyInfo -CdKey $DigitalKey | Select -ExpandProperty RefGroupId
		    $ProductDescription = $Global:PKeyDatabase | ? RefGroupId -EQ $RefGroupId | Select -ExpandProperty ProductDescription
	    }
	    catch { }
        if (-not $ProductDescription) {
	        try {
                # Interface check, will work most time, even on Country specific
                $SkuId = Get-LicensingInfo | select -ExpandProperty SkuId

                # Kernel Policies check, will fail when use choice Country specific
                if (-not $skuId) {
                    $skuId = ($((Get-ProductPolicy -Filter 'Security-SPP-Action-StateData' -UseApi).Value -split ';' | Where-Object { $_ -match 'SkuId' }) -split '=')[1]
                }
                # fail safe, find Any skuId, with SL_ID_PKEY guid, and not ESU
                # will fail only if user removed all licenses from local computer
                if (-not $skuId) {
                    Manage-SLHandle -Release | Out-null
                    $skuId = Get-SLIDList -eQueryIdType SL_ID_APPLICATION -eReturnIdType SL_ID_PRODUCT_SKU -pQueryId $windowsAppID | ? { Retrieve-SKUInfo -SkuId $_ -eReturnIdType SL_ID_PKEY } | ? {
                        (Get-LicenseDetails -ActConfigId $_ -pwszValueName 'Description') -notmatch 'ESU'} | select -First 1 -ExpandProperty Guid
                }
                if ($skuId) {
                    $ProductDescription = $Global:PKeyDatabase | ? ActConfigId -EQ "{$skuId}" | select -ExpandProperty ProductDescription
                }
            }
            catch { }
        }
        if (-not $ProductDescription) {
            try {
                # last resort, Using Edition Type + License Type,
                # And, find best match, usually work.
                $EditionType = Parse-DigitalProductId4 | select -ExpandProperty EditionType
                $KeyType = Parse-DigitalProductId4 | select -ExpandProperty KeyType
                $ProductDescription = $Global:PKeyDatabase | ? EditionId -eq $EditionType | ? ProductDescription -match $KeyType | Select -First 1 -ExpandProperty ProductDescription
            }
            catch { }
        }
            
        # Update the label text
        $statusBox.Text = "System Info: $ProductDescription ($Global:arch) | $($Global:version) | $([math]::Round($Global:memory)) GB"

    })
    $timer.Start()
    try {
        $form.ShowDialog()
    } catch [PipelineStoppedException] {
        Write-Host "Pipeline was stopped."
    }
    return $form.Tag
}

# Start #
# Main Script. Here.
# Begin #

if (-not (Get-Module PSWriteHTML -ListAvailable)) {
  Install-Module PSWriteHTML -Force }
if (-not (Get-Module PSWriteHTML -ListAvailable)) {
  throw "ERROR: Missing libary - PSWriteHTML"
  return
}

$tempPath = "$env:windir\Temp" #[Path]::GetTempPath()
$currentScriptLocation = $PSScriptRoot
$jsonFilePath = Join-Path $currentScriptLocation 'pkeyconfigs.json'
$outPath = Join-Path $tempPath 'pkeyconfigs'
if ([IO.FILE]::Exists($jsonFilePath)) {
  Restore-DirectoryStructureFromData -inputFilePath $jsonFilePath -outPath $outPath
}

Main-Form | Out-Null
if ([IO.FILE]::Exists($jsonFilePath)) {
  Remove-Item -LiteralPath $outPath -Recurse -Force -EA 0 | Out-Null
}
